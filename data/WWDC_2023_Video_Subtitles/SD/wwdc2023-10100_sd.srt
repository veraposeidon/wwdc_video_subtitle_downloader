2
00:00:00,033 --> 00:00:03,670 line:-1
♪ Mellow instrumental hip-hop ♪


3
00:00:03,670 --> 00:00:10,043 size:2% position:90% line:0
♪


4
00:00:10,043 --> 00:00:11,778 line:-1
Hi, my name's Roy,


5
00:00:11.778 --> 00:00:14.147 line:-1 position:50%
and I'm an engineer
on the Performance team.


6
00:00:14,147 --> 00:00:16,516 line:-1
Today, we'll learn
how you can optimize


7
00:00:16,516 --> 00:00:19,253 line:-1
your app for spatial computing.


8
00:00:19,253 --> 00:00:21,455 line:-1
We'll first look at
the unique aspects


9
00:00:21.455 --> 00:00:25.092 line:-1 position:50%
of this new platform
for performance and power.


10
00:00:25,092 --> 00:00:28,228 line:-1
We'll then go over building
a performance plan,


11
00:00:28,228 --> 00:00:31,298 line:-1
starting with
profiling your app.


12
00:00:31,298 --> 00:00:34,701 line:-1
And finally, we'll take a tour
of the best ways


13
00:00:34,701 --> 00:00:39,373 line:-1
to optimize performance issues
for this platform.


14
00:00:39.373 --> 00:00:42.142 line:-1 position:50%
So what makes
spatial computing different


15
00:00:42,142 --> 00:00:44,745 line:-1
for power and performance?


16
00:00:44,745 --> 00:00:47,247 line:-1
For one,
the content on the display


17
00:00:47,247 --> 00:00:51,351 line:-1
is always being updated,
regardless of app updates.


18
00:00:51.351 --> 00:00:55.422 line:-1 position:50%
Whenever people move
their body, hands, or eyes,


19
00:00:55.422 --> 00:00:57.991 line:-1 position:50%
content needs to be updated.


20
00:00:57,991 --> 00:01:01,328 line:-1
This means the system
is always rendering


21
00:01:01.328 --> 00:01:04.131 line:-1 position:50%
every frame at all times.


22
00:01:04,131 --> 00:01:07,935 line:-1
The platform is also always
running spatial algorithms


23
00:01:07,935 --> 00:01:12,539 line:-1
to create visuals and
interactions across every app,


24
00:01:12,539 --> 00:01:17,210 line:-1
and can run multiple apps
at the same time.


25
00:01:17,210 --> 00:01:20,747 line:-1
People will use your app
with other apps.


26
00:01:20,747 --> 00:01:24,651 line:-1
To handle multitasking
and the additional system work,


27
00:01:24.651 --> 00:01:28.989 line:-1 position:50%
optimize your own app's resource
usage as much as you can.


28
00:01:28.989 --> 00:01:31.391 line:-1 position:50%
To deliver a great
user experience,


29
00:01:31.391 --> 00:01:35.062 line:-1 position:50%
performance in your app
is essential.


30
00:01:35,062 --> 00:01:38,832 line:-1
People want apps to be
immediately responsive to input


31
00:01:38,832 --> 00:01:41,501 line:-1
and to provide
smooth visual updates


32
00:01:41.501 --> 00:01:45.605 line:-1 position:50%
for a sense of immersion
and comfort.


33
00:01:45,605 --> 00:01:49,676 line:-1
Let's talk about how to
profile and analyze your app


34
00:01:49,676 --> 00:01:52,412 line:-1
for performance issues.


35
00:01:52.412 --> 00:01:55.849 line:-1 position:50%
You may already be familiar
with performance metrics


36
00:01:55.849 --> 00:01:58.218 line:-1 position:50%
from other Apple platforms.


37
00:01:58,218 --> 00:02:02,589 line:0
On any platform, people want
apps that launch quickly,


38
00:02:02,589 --> 00:02:06,493 line:0
avoid disk wear,
and don't use too much battery.


39
00:02:06,493 --> 00:02:09,496 line:0
They also want apps
that avoid terminations


40
00:02:09,496 --> 00:02:11,932 line:0
from inefficient memory use.


41
00:02:11,932 --> 00:02:14,901 line:0
With spatial computing,
some of these metrics


42
00:02:14,901 --> 00:02:17,304 position:50%
take on new meaning.


43
00:02:17,304 --> 00:02:18,805 line:-1
Take power.


44
00:02:18.805 --> 00:02:21.541 line:-1 position:50%
Users want apps
optimized for power,


45
00:02:21,541 --> 00:02:25,212 line:-1
not for battery life,
but because of thermal pressure.


46
00:02:25,212 --> 00:02:27,414 line:-1
To sustain great performance,


47
00:02:27.414 --> 00:02:30.917 line:-1 position:50%
apps need to be optimized
for system power use,


48
00:02:30,917 --> 00:02:36,089 line:-1
to reduce the likelihood of
encountering thermal pressure.


49
00:02:36.089 --> 00:02:38.692 line:-1 position:50%
Hangs are another example.


50
00:02:38,692 --> 00:02:41,428 line:-1
They occur when an app's
main thread is stalled


51
00:02:41,428 --> 00:02:44,131 line:-1
on doing work
for a period of time.


52
00:02:44,131 --> 00:02:48,435 line:-1
But on this platform,
even small, momentary stalls


53
00:02:48,435 --> 00:02:51,838 line:-1
are disruptive
to responsiveness.


54
00:02:51.838 --> 00:02:54.007 line:-1 position:50%
Now consider rendering.


55
00:02:54,007 --> 00:02:56,643 line:-1
On other platforms,
you may be optimizing


56
00:02:56,643 --> 00:02:59,479 line:-1
for render performance
primarily to provide


57
00:02:59,479 --> 00:03:02,949 line:-1
smooth UI and 3D animations.


58
00:03:02,949 --> 00:03:05,886 line:-1
But here,
render performance is essential


59
00:03:05,886 --> 00:03:12,659 line:-1
for static content as well, since
the system is always rendering.


60
00:03:12.659 --> 00:03:17.297 line:-1 position:50%
All Apple platforms provide
tools to profile these metrics.


61
00:03:17,297 --> 00:03:20,667 line:-1
Today, we'll cover finding
performance issues


62
00:03:20,667 --> 00:03:23,703 line:-1
specifically for
spatial computing apps.


63
00:03:23,703 --> 00:03:27,007 position:50%
But to learn more about
optimizing for these metrics


64
00:03:27,007 --> 00:03:31,144 line:0
on any Apple platform, check out
the "Ultimate Application


65
00:03:31,144 --> 00:03:34,915 line:0
Performance Survival Guide"
session.


66
00:03:34,915 --> 00:03:38,351 line:-1
To optimize your app,
profile during development


67
00:03:38,351 --> 00:03:42,122 line:-1
using tools like Instruments
and Xcode Gauges.


68
00:03:42,122 --> 00:03:46,293 line:-1
Once your app is released,
gather more data from the field


69
00:03:46.293 --> 00:03:49.396 line:-1 position:50%
to help you further optimize
your app.


70
00:03:49,396 --> 00:03:54,101 line:-1
Let's talk more about
profiling during development.


71
00:03:54,101 --> 00:03:58,105 line:-1
RealityKit Trace is a brand-new
template in Instruments


72
00:03:58,105 --> 00:04:01,208 line:-1
to help profile any
spatial computing app


73
00:04:01,208 --> 00:04:03,710 line:-1
for performance and power.


74
00:04:03.710 --> 00:04:06.980 line:-1 position:50%
It is an incredible tool
that can help identify


75
00:04:06.980 --> 00:04:10.117 line:-1 position:50%
when your app has
poor rendering performance


76
00:04:10.117 --> 00:04:14.421 line:-1 position:50%
or when it is causing
high system power use.


77
00:04:14,421 --> 00:04:18,558 line:-1
There are many more instrument
templates you can use as well.


78
00:04:18,558 --> 00:04:22,095 line:0
To learn more and explore
this new template in action,


79
00:04:22,095 --> 00:04:26,199 line:0
watch the session
"Meet RealityKit Trace."


80
00:04:26,199 --> 00:04:29,136 line:-1
Your app's performance
and power depends on


81
00:04:29,136 --> 00:04:31,805 line:-1
how someone interacts with it.


82
00:04:31.805 --> 00:04:35.976 line:-1 position:50%
The simulator doesn't perform
the same work as a real device,


83
00:04:35.976 --> 00:04:39.179 line:-1 position:50%
so its performance data
might not be accurate.


84
00:04:39.179 --> 00:04:41.381 line:-1 position:50%
Profile in the device.


85
00:04:41,381 --> 00:04:44,651 line:-1
Profile using various
interactions in your app


86
00:04:44.651 --> 00:04:46.953 line:-1 position:50%
when playing audio or video,


87
00:04:46.953 --> 00:04:50.991 line:-1 position:50%
or when using technologies
like FaceTime and Personas.


88
00:04:50,991 --> 00:04:55,662 line:-1
Make sure to check for good
performance and low system power


89
00:04:55,662 --> 00:04:57,697 line:-1
over minutes of use.


90
00:04:57,697 --> 00:05:01,868 line:-1
Lastly, try profiling while
other apps are also running


91
00:05:01,868 --> 00:05:04,204 line:-1
and using resources.


92
00:05:04,204 --> 00:05:08,208 line:-1
If you are bringing over
compatible iPad and iPhone apps,


93
00:05:08,208 --> 00:05:10,977 line:-1
make sure to profile them
on device


94
00:05:10,977 --> 00:05:14,014 line:-1
to identify further
optimizations needed.


95
00:05:14.981 --> 00:05:17.984 line:-1 position:50%
After development,
people may run your app


96
00:05:17.984 --> 00:05:20.687 line:-1 position:50%
in a wide variety of conditions.


97
00:05:20,687 --> 00:05:24,558 line:-1
Data from the field
is a great way to find issues


98
00:05:24,558 --> 00:05:27,961 line:-1
that people are actually
running into.


99
00:05:27,961 --> 00:05:31,431 line:-1
When your app is in beta
or publicly released,


100
00:05:31,431 --> 00:05:35,535 line:-1
use MetricKit to get
diagnostic reports from users.


101
00:05:35.535 --> 00:05:39.639 line:-1 position:50%
Xcode Organizer provides
aggregated performance data


102
00:05:39,639 --> 00:05:42,175 line:-1
from consenting users' devices,


103
00:05:42,175 --> 00:05:47,814 line:-1
including energy diagnostics
to help find any power issues.


104
00:05:47.814 --> 00:05:51.685 line:-1 position:50%
All of this data you collect
helps you find bottlenecks


105
00:05:51.685 --> 00:05:55.422 line:-1 position:50%
and prioritize
performance work for your app.


106
00:05:55,422 --> 00:06:00,727 line:-1
Now, let's talk about optimizing
your spatial computing app.


107
00:06:00,727 --> 00:06:04,431 line:-1
Performance issues can arise
from many areas.


108
00:06:04.431 --> 00:06:07.701 line:-1 position:50%
Today, we'll cover strategies
for optimizing


109
00:06:07,701 --> 00:06:13,607 line:-1
several core areas:
rendering, user input, ARKit,


110
00:06:13,607 --> 00:06:16,343 line:-1
audio and video playback,
SharePlay,


111
00:06:16.343 --> 00:06:19.946 line:-1 position:50%
and app terminations
from system pressure.


112
00:06:19,946 --> 00:06:24,117 line:-1
Great rendering performance
is one of the top priorities


113
00:06:24.117 --> 00:06:26.219 line:-1 position:50%
for a great user experience.


114
00:06:26.219 --> 00:06:28.688 line:-1 position:50%
Let's dive in.


115
00:06:28.688 --> 00:06:33.827 line:-1 position:50%
In this platform, the rendering
pipeline starts with your app,


116
00:06:33,827 --> 00:06:37,564 line:-1
which is responsible for
updating your app's content.


117
00:06:37,564 --> 00:06:41,601 line:-1
Like all Apple platforms,
your app's interface is updated


118
00:06:41.601 --> 00:06:45.939 line:-1 position:50%
on the main thread and
must provide updates promptly.


119
00:06:45,939 --> 00:06:50,977 line:-1
Since your app is rendered in
a 3D space alongside other apps,


120
00:06:50.977 --> 00:06:55.181 line:-1 position:50%
its updates get sent
to the system render server.


121
00:06:55.181 --> 00:06:58.451 line:-1 position:50%
The render server
is continuously running


122
00:06:58.451 --> 00:07:02.422 line:-1 position:50%
to process updates from apps,
users' inputs,


123
00:07:02.422 --> 00:07:05.558 line:-1 position:50%
and from their space
and surroundings.


124
00:07:05,558 --> 00:07:09,162 line:-1
It renders a new frame
with all these updates


125
00:07:09.162 --> 00:07:12.065 line:-1 position:50%
and sends it
to the compositor.


126
00:07:12.065 --> 00:07:15.168 line:-1 position:50%
The compositor
is always rendering.


127
00:07:15.168 --> 00:07:17.871 line:-1 position:50%
It supplies new frames
to the display


128
00:07:17,871 --> 00:07:21,341 line:-1
at a rate matching
the display's refresh rate.


129
00:07:21.341 --> 00:07:24.744 line:-1 position:50%
This helps provide
a comfortable experience.


130
00:07:24,744 --> 00:07:31,351 line:-1
This rate is usually 90 frames
a second, but can be higher.


131
00:07:31.351 --> 00:07:35.155 line:-1 position:50%
While the compositor updates
the display consistently,


132
00:07:35.155 --> 00:07:38.725 line:-1 position:50%
a great user experience
still needs fast visual updates


133
00:07:38.725 --> 00:07:40.560 line:-1 position:50%
from your app.


134
00:07:40.560 --> 00:07:43.430 line:-1 position:50%
If your app has content
or updates that take


135
00:07:43,430 --> 00:07:46,833 line:-1
too long to render,
the render server can miss


136
00:07:46,833 --> 00:07:50,937 line:-1
its rendering deadline
for optimal rendering latency.


137
00:07:50.937 --> 00:07:53.840 line:-1 position:50%
This means the app visuals
could have made it


138
00:07:53,840 --> 00:07:56,343 line:-1
to the compositor
on frame Y,


139
00:07:56.343 --> 00:07:59.779 line:-1 position:50%
but made it on
frame Y+1 instead.


140
00:07:59.779 --> 00:08:03.616 line:-1 position:50%
This delays the visual updates
the people see on display


141
00:08:03,616 --> 00:08:07,187 line:-1
and makes your app
feel less responsive.


142
00:08:07,187 --> 00:08:10,724 line:-1
Especially severe rendering
stalls can even cause


143
00:08:10,724 --> 00:08:14,294 line:-1
your app to be terminated.


144
00:08:14,294 --> 00:08:18,264 line:-1
Whether your app
is built on SwiftUI, UIKit,


145
00:08:18.264 --> 00:08:22.335 line:-1 position:50%
RealityKit, or Metal,
you want to optimize its content


146
00:08:22,335 --> 00:08:24,904 line:-1
and updates
to reduce frame drops


147
00:08:24,904 --> 00:08:28,508 line:-1
and work done
in the render server.


148
00:08:28,508 --> 00:08:33,179 line:-1
Let's start with optimizing
SwiftUI and UIKit usage.


149
00:08:33.179 --> 00:08:36.282 line:-1 position:50%
On this platform,
the system does render work


150
00:08:36,282 --> 00:08:40,620 line:-1
for static UI content,
even with no app updates.


151
00:08:40.620 --> 00:08:44.324 line:-1 position:50%
This rendering work can increase
from overdraw.


152
00:08:44,324 --> 00:08:47,961 line:-1
Overdraw occurs when
you have translucent content


153
00:08:47,961 --> 00:08:50,830 line:-1
in front of other
virtual content.


154
00:08:50.830 --> 00:08:54.801 line:-1 position:50%
The GPU has to do work
to render both content,


155
00:08:54.801 --> 00:08:59.305 line:-1 position:50%
but if that translucent content
was fully opaque,


156
00:08:59.305 --> 00:09:04.110 line:-1 position:50%
the GPU wouldn't need to render
any UI behind it.


157
00:09:04.110 --> 00:09:08.348 line:-1 position:50%
If you have any overlapping
UI views with Z offsets,


158
00:09:08,348 --> 00:09:11,751 line:-1
avoid adding translucency
to them.


159
00:09:11,751 --> 00:09:14,487 line:-1
Also, the more pixels
on the display


160
00:09:14.487 --> 00:09:16.689 line:-1 position:50%
that your app's UI takes up,


161
00:09:16,689 --> 00:09:20,093 line:-1
the more work is done
to render the window.


162
00:09:20,093 --> 00:09:24,798 line:-1
Consider reducing
their default sizes.


163
00:09:24.798 --> 00:09:28.401 line:-1 position:50%
UI redraws in the render server
are usually triggered


164
00:09:28.401 --> 00:09:31.571 line:-1 position:50%
by app updates,
but on this platform,


165
00:09:31.571 --> 00:09:34.674 line:-1 position:50%
they are also triggered
by dynamic content scaling


166
00:09:34.674 --> 00:09:37.110 line:-1 position:50%
of core animation layers.


167
00:09:37,110 --> 00:09:40,447 line:-1
With this behavior,
the resolution of text,


168
00:09:40.447 --> 00:09:44.417 line:-1 position:50%
or vector-based UI content
changes based on


169
00:09:44,417 --> 00:09:49,589 line:-1
where the user is looking
to allow for sharper visuals.


170
00:09:49,589 --> 00:09:53,860 line:-1
This can also lead to more
frequent redrawing of UI content


171
00:09:53.860 --> 00:09:59.532 line:-1 position:50%
at potentially higher scales,
even with no app updates.


172
00:09:59,532 --> 00:10:03,470 line:-1
SwiftUI and UIKit
enable this behavior by default,


173
00:10:03.470 --> 00:10:06.005 line:-1 position:50%
but apps doing
custom Core Animation


174
00:10:06,005 --> 00:10:10,810 line:-1
or Core Graphics rendering
can opt in to this behavior.


175
00:10:10,810 --> 00:10:13,813 line:0
To learn more about its visual
benefits and trade-offs,


176
00:10:13,813 --> 00:10:15,281 position:50%
watch the session


177
00:10:15,281 --> 00:10:19,285 position:50%
"Explore rendering
for spatial computing."


178
00:10:19.285 --> 00:10:22.121 line:-1 position:50%
The cost of these redraws
is heavily impacted


179
00:10:22.121 --> 00:10:23.923 line:-1 position:50%
by offscreen render passes.


180
00:10:23.923 --> 00:10:25.992 line:-1 position:50%
This can be caused
by visual effects


181
00:10:25.992 --> 00:10:29.062 line:-1 position:50%
like shadows, blur, and masking.


182
00:10:29.062 --> 00:10:31.631 line:-1 position:50%
Reduce these effects
to make your app


183
00:10:31.631 --> 00:10:34.601 line:-1 position:50%
easier for the system to render.


184
00:10:34,601 --> 00:10:36,636 line:-1
To minimize re-draws in your app,


185
00:10:36,636 --> 00:10:40,540 line:-1
avoid unnecessary view updates
whenever possible.


186
00:10:40,540 --> 00:10:44,611 line:-1
For example, with SwiftUI,
use @Observable.


187
00:10:44,611 --> 00:10:47,847 line:-1
@Observable provides
more granular change tracking


188
00:10:47.847 --> 00:10:51.484 line:-1 position:50%
and reduces unneeded
layout updates.


189
00:10:51,484 --> 00:10:55,822 line:-1
Next, let's talk about
optimizing 3D rendering


190
00:10:55.822 --> 00:10:58.358 line:-1 position:50%
with RealityKit.


191
00:10:58,358 --> 00:11:01,327 line:-1
SwiftUI has added
RealityView this year


192
00:11:01,327 --> 00:11:03,396 line:-1
for spatial computing.


193
00:11:03.396 --> 00:11:06.866 line:-1 position:50%
It can natively display
RealityKit 3D scenes


194
00:11:06.866 --> 00:11:10.136 line:-1 position:50%
within a SwiftUI hierarchy.


195
00:11:10,136 --> 00:11:13,339 line:-1
Your app should be
a good citizen on the platform


196
00:11:13.339 --> 00:11:15.241 line:-1 position:50%
by optimizing your 3D scenes


197
00:11:15.241 --> 00:11:18.144 line:-1 position:50%
for all of these
RealityKit features.


198
00:11:18,144 --> 00:11:19,946 line:-1
In these 3D scenes,


199
00:11:19,946 --> 00:11:22,982 line:-1
the complexity
of the assets they contain


200
00:11:22.982 --> 00:11:24.817 line:-1 position:50%
can greatly increase the amount


201
00:11:24,817 --> 00:11:27,687 line:-1
of render server work
done each frame.


202
00:11:27.687 --> 00:11:31.558 line:-1 position:50%
So let's start
by optimizing these assets.


203
00:11:31,558 --> 00:11:34,160 line:-1
Reality Composer Pro
helps you create


204
00:11:34.160 --> 00:11:37.297 line:-1 position:50%
RealityKit scenes from assets.


205
00:11:37.297 --> 00:11:40.767 line:-1 position:50%
From mesh rendering,
particles, animations,


206
00:11:40,767 --> 00:11:44,504 line:-1
physics, and audio work,
this tool provides statistics


207
00:11:44.504 --> 00:11:47.640 line:-1 position:50%
about the entire scene
that can help you


208
00:11:47,640 --> 00:11:50,543 line:-1
understand
its performance impact.


209
00:11:50,543 --> 00:11:55,214 line:-1
When examining these statistics,
lower numbers usually mean


210
00:11:55.214 --> 00:11:58.985 line:-1 position:50%
less work, which can improve
render performance.


211
00:11:58,985 --> 00:12:00,253 line:0
Watch the session


212
00:12:00,253 --> 00:12:03,856 position:50%
"Create 3D models for Quick Look
spatial experiences"


213
00:12:03,856 --> 00:12:06,059 position:50%
to learn more around
best practices


214
00:12:06,059 --> 00:12:10,730 position:50%
for visuals and power use
of 3D assets.


215
00:12:10,730 --> 00:12:15,668 line:-1
Mesh rendering in particular
is a core part of 3D rendering.


216
00:12:15,668 --> 00:12:19,305 line:-1
Complex meshes and materials
can quickly become


217
00:12:19.305 --> 00:12:21.708 line:-1 position:50%
performance bottlenecks.


218
00:12:21,708 --> 00:12:24,877 line:-1
Optimize the geometry
of your mesh assets.


219
00:12:24.877 --> 00:12:26.946 line:-1 position:50%
Reduce the amount
of separate mesh parts


220
00:12:26.946 --> 00:12:30.316 line:-1 position:50%
by combining parts
that share a material.


221
00:12:30,316 --> 00:12:33,586 line:-1
Mesh geometries with
high triangle and vertex counts


222
00:12:33.586 --> 00:12:36.089 line:-1 position:50%
can also be costly.


223
00:12:36,089 --> 00:12:39,926 line:-1
Use assets with smaller counts
as needed.


224
00:12:39.926 --> 00:12:43.997 line:-1 position:50%
Minimize the impact of overdraw
with your 3D meshes.


225
00:12:43,997 --> 00:12:46,766 line:-1
To do this,
use transparency sparingly


226
00:12:46.766 --> 00:12:49.669 line:-1 position:50%
just like with UI content.


227
00:12:49,669 --> 00:12:53,206 line:-1
The “Physically Based” material
in Reality Composer Pro


228
00:12:53,206 --> 00:12:56,009 line:-1
has environment lighting,
is well optimized,


229
00:12:56.009 --> 00:13:00.313 line:-1 position:50%
and works best for meshes
with minimal transparency.


230
00:13:00.313 --> 00:13:04.083 line:-1 position:50%
But for translucent
or very large content,


231
00:13:04.083 --> 00:13:08.354 line:-1 position:50%
consider using a Custom
material with an unlit surface,


232
00:13:08,354 --> 00:13:12,558 line:-1
Use baked lighting textures
or other cheaper visuals.


233
00:13:12,558 --> 00:13:14,694 line:-1
This helps avoid
potential bottlenecks


234
00:13:14.694 --> 00:13:18.364 line:-1 position:50%
with more expensive
lighting calculations.


235
00:13:18,364 --> 00:13:21,601 position:50%
For further guidance on
building and using materials


236
00:13:21,601 --> 00:13:26,439 line:0
in RealityKit,
watch these two sessions.


237
00:13:26,439 --> 00:13:29,108 line:-1
Having optimized content
for runtime rendering


238
00:13:29.108 --> 00:13:30.977 line:-1 position:50%
is a great start.


239
00:13:30,977 --> 00:13:33,146 line:-1
But there's even more
you can do


240
00:13:33,146 --> 00:13:37,617 line:-1
to optimize your app
with RealityKit.


241
00:13:37,617 --> 00:13:40,987 line:-1
When your app updates
its RealityKit content,


242
00:13:40.987 --> 00:13:43.556 line:-1 position:50%
updates get sent
to the render server,


243
00:13:43,556 --> 00:13:46,025 line:-1
which applies and renders them.


244
00:13:46,025 --> 00:13:49,295 line:-1
But too many updates
in a short period of time


245
00:13:49,295 --> 00:13:52,865 line:-1
can become a bottleneck
for the render server.


246
00:13:52,865 --> 00:13:57,904 line:-1
For example, your app may be
rapidly creating and destroying


247
00:13:57,904 --> 00:13:59,739 line:-1
RealityKit entities.


248
00:13:59.739 --> 00:14:02.875 line:-1 position:50%
It may have too many
complex animations,


249
00:14:02,875 --> 00:14:05,945 line:-1
be updating too many
SwiftUI views,


250
00:14:05.945 --> 00:14:10.550 line:-1 position:50%
or it may be loading
many assets in a single frame.


251
00:14:10.550 --> 00:14:15.188 line:-1 position:50%
Create entities in advance,
and hide or show them as needed.


252
00:14:15,188 --> 00:14:18,558 line:-1
You could remove and add them
to the scene hierarchy,


253
00:14:18,558 --> 00:14:21,260 line:-1
or use the isEnabled flag.


254
00:14:21,260 --> 00:14:24,497 line:-1
Minimize the amount of entities
that are updated


255
00:14:24.497 --> 00:14:28.000 line:-1 position:50%
by flattening your mesh
entity hierarchies.


256
00:14:28.000 --> 00:14:32.472 line:-1 position:50%
For code-based animations,
consider lower update rates


257
00:14:32.472 --> 00:14:37.110 line:-1 position:50%
or reducing the number of
entities the animations update.


258
00:14:37,110 --> 00:14:39,846 line:-1
And when updating
RealityKit entities,


259
00:14:39.846 --> 00:14:44.751 line:-1 position:50%
avoid triggering excessive
SwiftUI redrawing accidentally.


260
00:14:44.751 --> 00:14:47.920 line:-1 position:50%
When using attachments,
make sure to optimize


261
00:14:47,920 --> 00:14:49,655 line:-1
their rendering
in the same way


262
00:14:49.655 --> 00:14:54.026 line:-1 position:50%
you optimize
for all SwiftUI content.


263
00:14:54,026 --> 00:14:56,963 line:-1
Loading complex assets
can also trigger


264
00:14:56.963 --> 00:14:59.298 line:-1 position:50%
expensive render updates.


265
00:14:59.298 --> 00:15:01.834 line:-1 position:50%
Complex assets
can also contribute


266
00:15:01.834 --> 00:15:05.571 line:-1 position:50%
to high app launch
and content loading times.


267
00:15:05.571 --> 00:15:08.741 line:-1 position:50%
Use asynchronous
loading APIs at runtime


268
00:15:08,741 --> 00:15:11,110 line:-1
to avoid blocking
the main thread


269
00:15:11.110 --> 00:15:15.448 line:-1 position:50%
and load assets well before
they are needed.


270
00:15:15,448 --> 00:15:17,583 line:-1
Entities that use
the same assets


271
00:15:17.583 --> 00:15:22.121 line:-1 position:50%
can also share that asset
and only load it once.


272
00:15:22,121 --> 00:15:25,725 line:-1
Use exported files
from Reality Composer Pro


273
00:15:25,725 --> 00:15:28,628 line:-1
as these files are optimized
for loading times


274
00:15:28.628 --> 00:15:30.830 line:-1 position:50%
and memory costs.


275
00:15:30,830 --> 00:15:34,267 line:-1
You also get texture
compression for free.


276
00:15:34.267 --> 00:15:38.037 line:-1 position:50%
Reducing asset sizes
usually speeds up loading,


277
00:15:38.037 --> 00:15:41.374 line:-1 position:50%
but remember that texture
compression already happens


278
00:15:41.374 --> 00:15:43.743 line:-1 position:50%
with Reality Composer Pro files,


279
00:15:43.743 --> 00:15:47.480 line:-1 position:50%
so you may not
need to do it yourself.


280
00:15:47,480 --> 00:15:50,716 line:-1
Finally, let's talk about
immersive experiences


281
00:15:50,716 --> 00:15:52,485 line:-1
with RealityKit.


282
00:15:52,485 --> 00:15:56,455 line:-1
When your app requests to move
to a dedicated full space,


283
00:15:56,455 --> 00:16:00,126 line:-1
it becomes the only
foreground experience running.


284
00:16:00.126 --> 00:16:04.564 line:-1 position:50%
When using a portal or moving
to a fully immersive experience,


285
00:16:04,564 --> 00:16:06,065 line:-1
the system also hides


286
00:16:06,065 --> 00:16:10,136 line:-1
part or all of the person's
surroundings.


287
00:16:10,136 --> 00:16:12,805 line:-1
Your app can create
an environment


288
00:16:12.805 --> 00:16:17.076 line:-1 position:50%
with RealityKit content
to fill their space.


289
00:16:17,076 --> 00:16:19,979 line:-1
Your fully immersive content
needs to be rendered


290
00:16:19.979 --> 00:16:22.615 line:-1 position:50%
to a lot more pixels
on the display


291
00:16:22,615 --> 00:16:25,818 line:-1
than scenes in a shared space
or a full space.


292
00:16:25.818 --> 00:16:29.188 line:-1 position:50%
This means that more work
can be done on the GPU


293
00:16:29,188 --> 00:16:31,257 line:-1
to render that content.


294
00:16:31,257 --> 00:16:35,161 line:-1
Optimize this type of content
for GPU power use.


295
00:16:35,161 --> 00:16:38,464 line:-1
Start with a “Custom” material
with an unlit surface


296
00:16:38,464 --> 00:16:42,335 line:-1
in Reality Composer Pro
for optimal power use.


297
00:16:42.335 --> 00:16:45.238 line:-1 position:50%
Consider adding
baked lighting textures


298
00:16:45,238 --> 00:16:47,306 line:-1
or using time-based animations


299
00:16:47.306 --> 00:16:50.543 line:-1 position:50%
to get a feel
of dynamic lighting instead.


300
00:16:50,543 --> 00:16:56,782 line:-1
Profile your material for system
power and render performance.


301
00:16:56,782 --> 00:16:59,819 line:-1
You can also create
fully immersive experiences


302
00:16:59.819 --> 00:17:01.454 line:-1 position:50%
with Metal.


303
00:17:01,454 --> 00:17:04,757 line:-1
For those of you building
3D engines or experiences


304
00:17:04.757 --> 00:17:09.495 line:-1 position:50%
using Metal, let's talk about
some things to optimize.


305
00:17:09.495 --> 00:17:13.399 line:-1 position:50%
You can use Metal with the
CompositorServices framework


306
00:17:13.399 --> 00:17:17.069 line:-1 position:50%
to bypass the render server
and send a rendered surface


307
00:17:17.069 --> 00:17:19.872 line:-1 position:50%
directly to the compositor.


308
00:17:19,872 --> 00:17:23,342 line:0
Watch the session "Discover
Metal for immersive apps"


309
00:17:23,342 --> 00:17:26,312 position:50%
to learn how
to do this properly.


310
00:17:26,312 --> 00:17:29,081 line:-1
When using CompositorServices,


311
00:17:29,081 --> 00:17:32,585 line:-1
pace your Metal frame
submissions so the compositor


312
00:17:32.585 --> 00:17:36.122 line:-1 position:50%
receives a new frame
on each of its updates.


313
00:17:36.122 --> 00:17:38.991 line:-1 position:50%
Make sure to query
a new foviation map


314
00:17:38,991 --> 00:17:41,494 line:-1
and post prediction each frame.


315
00:17:41,494 --> 00:17:44,563 line:-1
And query this input data
at the last moment


316
00:17:44.563 --> 00:17:48.467 line:-1 position:50%
before you start using it
to encode GPU work.


317
00:17:48,467 --> 00:17:51,671 line:-1
Doing all three of these things
helps ensure


318
00:17:51,671 --> 00:17:53,839 line:-1
responsive virtual content


319
00:17:53,839 --> 00:17:57,576 line:-1
relative to user motion
and input.


320
00:17:57,576 --> 00:18:01,213 line:-1
If the app takes too long
to submit a new frame,


321
00:18:01.213 --> 00:18:03.182 line:-1 position:50%
the system terminates it.


322
00:18:03,182 --> 00:18:06,686 line:-1
Avoid any long frame stalls.


323
00:18:06,686 --> 00:18:09,555 line:-1
Make sure to profile
GPU performance


324
00:18:09,555 --> 00:18:12,591 line:-1
using the Metal System Trace
Instruments template


325
00:18:12,591 --> 00:18:14,794 line:-1
while running your app.


326
00:18:14.794 --> 00:18:17.964 line:-1 position:50%
Long-running fragment
and vertex shader executions


327
00:18:17.964 --> 00:18:20.900 line:-1 position:50%
from your Metal app
or from custom materials


328
00:18:20.900 --> 00:18:23.502 line:-1 position:50%
with Reality Composer Pro


329
00:18:23,502 --> 00:18:27,206 line:-1
can impact
system rendering times heavily.


330
00:18:27,206 --> 00:18:30,076 line:-1
To reduce fragment
and vertex times,


331
00:18:30.076 --> 00:18:33.045 line:-1 position:50%
start by reducing
ALU instructions


332
00:18:33,045 --> 00:18:36,515 line:-1
and texture accesses by shaders.


333
00:18:36,515 --> 00:18:41,721 line:-1
For Metal, use compute shaders
instead wherever possible.


334
00:18:41,721 --> 00:18:44,090 line:0
Review these talks
to learn more


335
00:18:44,090 --> 00:18:47,860 line:0
about optimizing
your GPU performance.


336
00:18:47,860 --> 00:18:52,164 line:-1
Remember, optimizing your app
for UI and 3D rendering


337
00:18:52,164 --> 00:18:57,236 line:-1
performance benefits
the overall user experience.


338
00:18:57,236 --> 00:19:00,840 line:-1
Let's now move on
to input performance.


339
00:19:00,840 --> 00:19:04,910 line:-1
People can use their eyes,
hands, voice,


340
00:19:04.910 --> 00:19:08.080 line:-1 position:50%
and hardware inputs
on this platform.


341
00:19:08,080 --> 00:19:12,318 line:-1
App updates to inputs are
processed on the main thread.


342
00:19:12,318 --> 00:19:14,253 line:-1
If these take too long,


343
00:19:14.253 --> 00:19:19.025 line:-1 position:50%
it makes your app
feel slow and unresponsive.


344
00:19:19,025 --> 00:19:22,328 line:-1
Input updates on the main
thread need to complete


345
00:19:22.328 --> 00:19:26.766 line:-1 position:50%
within certain deadlines based
on the display refresh rate.


346
00:19:26.766 --> 00:19:28.801 line:-1 position:50%
Hardware for this platform


347
00:19:28.801 --> 00:19:32.405 line:-1 position:50%
usually has a refresh rate
of 90 hertz or higher.


348
00:19:32,405 --> 00:19:35,708 line:-1
For 90 hertz refresh
rates, keep input updates


349
00:19:35.708 --> 00:19:39.845 line:-1 position:50%
below eight milliseconds
for optimal latency.


350
00:19:39,845 --> 00:19:42,415 line:-1
When interacting
with spatial content,


351
00:19:42.415 --> 00:19:45.484 line:-1 position:50%
the system does hit testing
work to check


352
00:19:45,484 --> 00:19:50,656 line:-1
which UI or 3D objects the user
is trying to interact with.


353
00:19:50.656 --> 00:19:54.760 line:-1 position:50%
For RealityKit content,
you will add physics colliders


354
00:19:54,760 --> 00:19:56,695 line:-1
to interact with them.


355
00:19:56,695 --> 00:20:00,332 line:-1
When adding these colliders,
use static colliders


356
00:20:00,332 --> 00:20:03,536 line:-1
over dynamic colliders
whenever possible,


357
00:20:03,536 --> 00:20:06,205 line:-1
as static ones are cheaper.


358
00:20:06,205 --> 00:20:09,375 line:-1
To reduce redundant hit
testing work in your app,


359
00:20:09,375 --> 00:20:13,979 line:-1
minimize overlapping
any interactive content.


360
00:20:13,979 --> 00:20:17,950 line:-1
Now, let's move on to ARKit.


361
00:20:17.950 --> 00:20:20.786 line:-1 position:50%
On this platform,
ARKit algorithms


362
00:20:20,786 --> 00:20:24,390 line:-1
are always running to create
visuals and interactions


363
00:20:24,390 --> 00:20:26,225 line:-1
across every app.


364
00:20:26,225 --> 00:20:30,563 line:-1
Your app can impact system
power and visual smoothness


365
00:20:30,563 --> 00:20:36,302 line:-1
based on how it uses ARKit data
and anchors virtual content.


366
00:20:36,302 --> 00:20:40,506 line:-1
For example, your app
can use ARKit or RealityKit


367
00:20:40,506 --> 00:20:44,143 line:-1
to place an anchor content
in the user's surroundings,


368
00:20:44,143 --> 00:20:46,312 line:-1
head, or hands.


369
00:20:46.312 --> 00:20:50.116 line:-1 position:50%
Every anchor adds additional
work for the system.


370
00:20:50.116 --> 00:20:53.619 line:-1 position:50%
When anchoring content,
consider whether the anchors


371
00:20:53,619 --> 00:20:57,590 line:-1
need to be tracked
continuously in a user's space.


372
00:20:57,590 --> 00:21:00,593 line:-1
When using AnchorComponent
in RealityKit,


373
00:21:00.593 --> 00:21:05.998 line:-1 position:50%
use the “once” tracking mode to
avoid continuous tracking costs.


374
00:21:05,998 --> 00:21:08,934 line:-1
Minimize the total amount
of persistent


375
00:21:08,934 --> 00:21:12,138 line:-1
and transient anchors
from your app.


376
00:21:12.138 --> 00:21:14.673 line:-1 position:50%
For persistent anchors
especially,


377
00:21:14,673 --> 00:21:16,642 line:-1
every app can add them,


378
00:21:16.642 --> 00:21:20.913 line:-1 position:50%
so try not to add too many
from your own app.


379
00:21:20.913 --> 00:21:23.916 line:-1 position:50%
There's even more
optimizations you can do


380
00:21:23.916 --> 00:21:26.318 line:-1 position:50%
while using ARKit data.


381
00:21:26,318 --> 00:21:31,457 line:-1
If you apply ARKit data
that is too old to app content,


382
00:21:31.457 --> 00:21:35.194 line:-1 position:50%
app visuals can look
out of sync with input.


383
00:21:35,194 --> 00:21:39,265 line:-1
Query ARKit data right before
it needs to be used


384
00:21:39.265 --> 00:21:42.668 line:-1 position:50%
and apply it
to updates promptly.


385
00:21:42,668 --> 00:21:46,005 line:-1
Post predictions
are expensive to compute.


386
00:21:46,005 --> 00:21:49,275 line:-1
Generally, only custom
Metal rendering engines


387
00:21:49,275 --> 00:21:51,143 line:-1
need this data.


388
00:21:51.143 --> 00:21:54.380 line:-1 position:50%
If you just want to place
app content in the scene,


389
00:21:54.380 --> 00:21:57.716 line:-1 position:50%
RealityKit is
a great choice instead.


390
00:21:57.716 --> 00:22:00.819 line:-1 position:50%
Generating collision data
for scene understanding meshes


391
00:22:00,819 --> 00:22:03,455 line:-1
is also expensive.


392
00:22:03.455 --> 00:22:06.392 line:-1 position:50%
If you do use this data,
turn it off


393
00:22:06,392 --> 00:22:09,495 line:-1
when your app doesn't
need it anymore.


394
00:22:09,495 --> 00:22:13,632 line:-1
Now, let's talk about optimizing
audio and video playback


395
00:22:13.632 --> 00:22:16.068 line:-1 position:50%
for spatial computing.


396
00:22:16,068 --> 00:22:20,339 line:-1
Spatial audio is used by default
on this platform.


397
00:22:20.339 --> 00:22:24.009 line:-1 position:50%
The system processes
information in real time


398
00:22:24,009 --> 00:22:26,979 line:-1
about the user's position,
their surroundings,


399
00:22:26.979 --> 00:22:30.416 line:-1 position:50%
and audio sources
to output audio.


400
00:22:30.416 --> 00:22:34.320 line:-1 position:50%
If your app causes too much
spatial audio work,


401
00:22:34.320 --> 00:22:37.389 line:-1 position:50%
it can cause problems
with system power use


402
00:22:37.389 --> 00:22:40.793 line:-1 position:50%
or lead to delays
in audio output.


403
00:22:40.793 --> 00:22:42.895 line:-1 position:50%
If you see these issues,


404
00:22:42,895 --> 00:22:45,164 line:-1
there are three main things
to look at


405
00:22:45,164 --> 00:22:48,033 line:-1
for reducing spatial audio work:


406
00:22:48.033 --> 00:22:50.536 line:-1 position:50%
concurrently playing
audio sources,


407
00:22:50.536 --> 00:22:52.938 line:-1 position:50%
the number of moving
audio sources,


408
00:22:52,938 --> 00:22:55,307 line:-1
and the size of the soundstage.


409
00:22:55.307 --> 00:22:58.177 line:-1 position:50%
All of these are variables
that can increase


410
00:22:58,177 --> 00:23:01,046 line:-1
the computational work.


411
00:23:01.046 --> 00:23:03.882 line:-1 position:50%
Now, let's consider video.


412
00:23:03,882 --> 00:23:08,721 line:-1
In a shared space, people can
play multiple videos at once.


413
00:23:08,721 --> 00:23:12,524 line:0
For each video,
the system needs to decode it


414
00:23:12,524 --> 00:23:15,661 position:50%
and render it
in the render server.


415
00:23:15,661 --> 00:23:17,963 line:0
Each new rendered video frame


416
00:23:17,963 --> 00:23:21,834 line:0
needs to make it to the display
at consistent intervals


417
00:23:21,834 --> 00:23:25,671 line:0
for a great video
watching experience.


418
00:23:25.671 --> 00:23:28.707 line:-1 position:50%
To give the render server
as much power and time


419
00:23:28.707 --> 00:23:30.909 line:-1 position:50%
to meet its rendering deadlines,


420
00:23:30,909 --> 00:23:35,281 line:-1
your app should minimize
updates to UI or 3D content


421
00:23:35.281 --> 00:23:37.283 line:-1 position:50%
during video playback.


422
00:23:37.283 --> 00:23:41.553 line:-1 position:50%
The video frame rate
also impacts the work done.


423
00:23:41,553 --> 00:23:44,523 line:-1
Consider using 24 or 30 hertz
videos


424
00:23:44,523 --> 00:23:47,192 line:-1
for optimal performance
and power.


425
00:23:47.192 --> 00:23:50.796 line:-1 position:50%
Finally, reduce the number
of concurrent videos


426
00:23:50.796 --> 00:23:54.366 line:-1 position:50%
that need to be played
and rendered on the device


427
00:23:54,366 --> 00:23:58,037 line:-1
from your app at any given time.


428
00:23:58.037 --> 00:24:01.040 line:-1 position:50%
When choosing between
video presentation methods,


429
00:24:01.040 --> 00:24:03.575 line:-1 position:50%
consider how you would
like to optimize


430
00:24:03.575 --> 00:24:06.412 line:-1 position:50%
for different features
and performance.


431
00:24:06,412 --> 00:24:08,113 line:0
Watch the session


432
00:24:08,113 --> 00:24:12,985 position:50%
"Create a great spatial playback
experience" to learn more.


433
00:24:12.985 --> 00:24:16.055 line:-1 position:50%
Now, let's talk about SharePlay.


434
00:24:16,055 --> 00:24:20,059 line:-1
This platform opens up
a whole new set of experiences


435
00:24:20.059 --> 00:24:23.962 line:-1 position:50%
to collaborate
and connect with people.


436
00:24:23.962 --> 00:24:27.433 line:-1 position:50%
To create a truly great
SharePlay group experience,


437
00:24:27,433 --> 00:24:31,170 line:-1
you'll want to ensure your app
can sustain great performance


438
00:24:31,170 --> 00:24:34,473 line:-1
over long periods of time.


439
00:24:34,473 --> 00:24:38,043 line:-1
And great spatial computing
performance with SharePlay


440
00:24:38.043 --> 00:24:40.346 line:-1 position:50%
starts with the basics.


441
00:24:40,346 --> 00:24:44,817 line:-1
Profile and optimize your app
for local performance first.


442
00:24:44.817 --> 00:24:49.355 line:-1 position:50%
Then examine your app's
performance during SharePlay


443
00:24:49,355 --> 00:24:51,523 line:-1
to avoid expensive
render updates


444
00:24:51,523 --> 00:24:54,760 line:-1
being synced across devices.


445
00:24:54,760 --> 00:24:59,365 line:-1
Profile your app for power
to ensure system power needs


446
00:24:59.365 --> 00:25:01.600 line:-1 position:50%
doesn't create
thermal pressure,


447
00:25:01,600 --> 00:25:04,370 line:-1
which can prevent your app
from sustaining


448
00:25:04,370 --> 00:25:06,472 line:-1
its great performance.


449
00:25:06.472 --> 00:25:09.641 line:-1 position:50%
To help with this,
carefully consider


450
00:25:09,641 --> 00:25:12,177 line:-1
what work and
features in your app


451
00:25:12,177 --> 00:25:15,481 line:-1
are essential for your app's
SharePlay experience,


452
00:25:15,481 --> 00:25:19,685 line:-1
and turn off anything
it doesn't need.


453
00:25:19.685 --> 00:25:22.354 line:-1 position:50%
Lastly,
let's look at app terminations


454
00:25:22,354 --> 00:25:25,858 line:-1
from thermal or memory pressure.


455
00:25:25.858 --> 00:25:29.661 line:-1 position:50%
People may use this device
in a warm place.


456
00:25:29,661 --> 00:25:33,265 line:-1
Like all Apple platforms,
the system manages


457
00:25:33,265 --> 00:25:37,569 line:-1
computational resources
available under thermal pressure


458
00:25:37.569 --> 00:25:42.141 line:-1 position:50%
in order to keep the device cool
and comfortable when in use.


459
00:25:42.141 --> 00:25:44.943 line:-1 position:50%
Having lower
computational resources


460
00:25:44,943 --> 00:25:48,614 line:-1
can impact
your app's performance.


461
00:25:48,614 --> 00:25:52,084 line:-1
The system may even
terminate your app


462
00:25:52.084 --> 00:25:54.420 line:-1 position:50%
due to critical
thermal pressure,


463
00:25:54,420 --> 00:25:59,658 line:-1
or because render deadlines
were no longer being met.


464
00:25:59,658 --> 00:26:03,529 line:-1
When under thermal pressure,
do less work in your app


465
00:26:03,529 --> 00:26:07,232 line:-1
to maintain good performance
and to keep thermal pressure


466
00:26:07,232 --> 00:26:09,601 line:-1
from increasing further.


467
00:26:09.601 --> 00:26:11.837 line:-1 position:50%
Do this by subscribing to the


468
00:26:11,837 --> 00:26:15,107 line:-1
thermalStateDidChange
Notification.


469
00:26:15,107 --> 00:26:17,075 line:-1
When the pressure gets higher,


470
00:26:17.075 --> 00:26:22.281 line:-1 position:50%
adapt your app's content
and updates in response to it.


471
00:26:22,281 --> 00:26:25,651 line:-1
To see how your app performs
under a thermal pressure,


472
00:26:25.651 --> 00:26:28.954 line:-1 position:50%
use thermal inducers
in Xcode to simulate


473
00:26:28,954 --> 00:26:32,558 line:-1
higher thermal states
for your device.


474
00:26:32,558 --> 00:26:35,427 position:50%
To learn even more
about thermal pressure,


475
00:26:35,427 --> 00:26:37,062 line:0
check out the session


476
00:26:37,062 --> 00:26:41,333 line:0
"Designing for Adverse Network
and Temperature Conditions."


477
00:26:41,333 --> 00:26:44,870 line:0
Next, let's talk about
memory pressure.


478
00:26:44,870 --> 00:26:47,773 position:50%
Devices have a limited
amount of memory


479
00:26:47,773 --> 00:26:52,644 line:0
that is shared between
the system and all apps running.


480
00:26:52,644 --> 00:26:55,414 line:0
When the device gets
close to this limit,


481
00:26:55,414 --> 00:26:58,450 line:0
the system begins
to terminate apps,


482
00:26:58,450 --> 00:27:02,654 line:0
starting with apps that are
not being actively used.


483
00:27:02,654 --> 00:27:05,290 line:0
A single app using
too much memory


484
00:27:05,290 --> 00:27:09,761 position:50%
can also get terminated,
even if it is being used.


485
00:27:09,761 --> 00:27:13,765 position:50%
You don't want this
to happen for your app.


486
00:27:13.765 --> 00:27:17.269 line:-1 position:50%
You can avoid this by reducing
your app's memory usage


487
00:27:17.269 --> 00:27:19.838 line:-1 position:50%
as much as possible.


488
00:27:19,838 --> 00:27:22,608 line:-1
On this platform,
apps are more likely


489
00:27:22.608 --> 00:27:25.143 line:-1 position:50%
to have large amounts
of memory allocated


490
00:27:25,143 --> 00:27:29,815 line:-1
for UI and 3D rendering,
and audio and video playback.


491
00:27:29.815 --> 00:27:33.085 line:-1 position:50%
If your app has UI content,
reduce rendering


492
00:27:33.085 --> 00:27:37.956 line:-1 position:50%
memory allocations by minimizing
offscreen render passes,


493
00:27:37,956 --> 00:27:41,960 line:-1
the total amount of windows,
and media content.


494
00:27:41,960 --> 00:27:45,597 line:-1
For 3D memory with RealityKit,
the resolution


495
00:27:45,597 --> 00:27:50,135 line:-1
of your textures and geometry
sizers for meshes and particles


496
00:27:50,135 --> 00:27:53,605 line:-1
can contribute
significantly to memory use.


497
00:27:53,605 --> 00:27:57,175 line:-1
Reduce them wherever you can.


498
00:27:57,175 --> 00:28:01,780 line:-1
When playing audio and video,
evaluate the total memory load


499
00:28:01,780 --> 00:28:05,083 line:-1
from all audio
and video files in your app.


500
00:28:05,083 --> 00:28:08,854 line:-1
When changing resolutions,
bitrates, file formats,


501
00:28:08.854 --> 00:28:11.757 line:-1 position:50%
and durations,
consider the trade-offs


502
00:28:11,757 --> 00:28:14,760 line:-1
for the user experience
and performance


503
00:28:14,760 --> 00:28:17,896 line:-1
against any memory savings.


504
00:28:17,896 --> 00:28:21,366 line:0
Review these talks to learn
more tips for reducing


505
00:28:21,366 --> 00:28:26,071 line:0
your memory footprint
across all Apple platforms.


506
00:28:26.071 --> 00:28:29.207 line:-1 position:50%
Remember,
performance is essential


507
00:28:29,207 --> 00:28:33,645 line:-1
for a great user experience
on this platform.


508
00:28:33.645 --> 00:28:36.048 line:-1 position:50%
To get started,
profile your apps


509
00:28:36,048 --> 00:28:38,317 line:-1
actively during development


510
00:28:38.317 --> 00:28:41.787 line:-1 position:50%
to find performance
and power issues.


511
00:28:41.787 --> 00:28:45.123 line:-1 position:50%
Build a performance plan
around important metrics


512
00:28:45,123 --> 00:28:46,992 line:-1
for spatial computing.


513
00:28:46,992 --> 00:28:50,362 line:-1
And optimize your app
for rendering, power,


514
00:28:50.362 --> 00:28:53.799 line:-1 position:50%
and all of the other areas
we covered today.


515
00:28:53,799 --> 00:28:57,069 line:-1
And finally,
collect performance field data


516
00:28:57,069 --> 00:29:01,640 line:-1
with tools like MetricKit
and Xcode Organizer.


517
00:29:01.640 --> 00:29:05.277 line:-1 position:50%
I can't wait to see all
the great apps and experiences


518
00:29:05.277 --> 00:29:07.312 line:-1 position:50%
you come up with
on this platform.


519
00:29:07,312 --> 00:29:08,747 line:-1
Thanks for watching.


520
00:29:08,747 --> 00:29:12,751 line:0 size:2% position:90%
♪

