2
00:00:00,501 --> 00:00:08,509 line:-1
♪ ♪


3
00:00:10.010 --> 00:00:13.580 line:-2 align:center
Alex Hoppen: Who likes writing repetitive
boilerplate code?


4
00:00:13.614 --> 00:00:15.249 line:-1 align:center
Nobody does!


5
00:00:15,282 --> 00:00:20,687 line:-2
And that's why in Swift 5.9
we are introducing Swift macros.


6
00:00:20.721 --> 00:00:24.892 line:-2 align:center
Swift macros allow you to generate
that repetitive code at compile time,


7
00:00:24,925 --> 00:00:29,930 line:-2
making your app's codebases
more expressive and easier to read.


8
00:00:29.963 --> 00:00:33.600 line:-2 align:center
My name is Alex Hoppen,
and today I am going to show you


9
00:00:33,634 --> 00:00:35,969 line:-1
how you can write your own macros.


10
00:00:36,003 --> 00:00:40,874 line:-2
I will start off by giving you
a short overview of how macros work.


11
00:00:42,376 --> 00:00:45,846 line:-2
Afterwards,
we will jump straight into Xcode


12
00:00:45,879 --> 00:00:49,483 line:-2
and see how
you can create your first macro.


13
00:00:50.817 --> 00:00:53.320 line:-1 align:center
Having seen our first macro in Xcode,


14
00:00:53,353 --> 00:00:56,957 line:-2
we will explore more roles
in which you can use macros


15
00:00:56,990 --> 00:00:59,493 line:-1
and I will show you how I used macros


16
00:00:59,526 --> 00:01:02,829 line:-2
to simplify the codebase of an app
I am currently working on.


17
00:01:05.199 --> 00:01:09.770 line:-2 align:center
Finally, I will show you how macros
can communicate errors or warnings


18
00:01:09,803 --> 00:01:13,941 line:-2
back to the compiler if they are not
applicable in a certain context.


19
00:01:15.275 --> 00:01:17.344 line:-1 align:center
So let's get started.


20
00:01:17.377 --> 00:01:21.048 line:-2 align:center
Here we have a list of calculations
that first-year students can use


21
00:01:21.081 --> 00:01:23.817 line:-1 align:center
to practice their arithmetic skills.


22
00:01:23.851 --> 00:01:27.321 line:-2 align:center
We have the result
as an integer on the left


23
00:01:27,354 --> 00:01:31,792 line:-2
and the calculation as a string literal
on the right side of the tuple.


24
00:01:31,825 --> 00:01:36,463 line:-2
Notice how this is repetitive,
redundant, and even error prone


25
00:01:36.496 --> 00:01:41.902 line:-2 align:center
because nobody can guarantee that the
result actually matches the calculation.


26
00:01:41,935 --> 00:01:47,641 line:-2
Luckily, with Swift 5.9 we can define
a stringify macro to simplify this.


27
00:01:48.675 --> 00:01:50.811 line:-1 align:center
This macro also happens to be the one


28
00:01:50,844 --> 00:01:53,814 line:-1
that is included in Xcode's template.


29
00:01:53.847 --> 00:01:58.785 line:-2 align:center
The stringify macro only takes
the calculation as a single parameter.


30
00:01:58,819 --> 00:02:02,656 line:-2
At compile time it expands to the tuple
that we saw before,


31
00:02:02,689 --> 00:02:07,294 line:-2
guaranteeing that the calculation
and the result match.


32
00:02:07.327 --> 00:02:09.363 line:-1 align:center
So how does this work?


33
00:02:09.396 --> 00:02:12.165 line:-2 align:center
Let's take a look at the definition
of the macro itself.


34
00:02:13.500 --> 00:02:16.937 line:-2 align:center
Notice that it looks a lot
like a function.


35
00:02:16,970 --> 00:02:21,108 line:-2
The stringify macro takes an integer
as the input parameter


36
00:02:21,141 --> 00:02:24,077 line:-2
and outputs a tuple
containing an the result,


37
00:02:24,111 --> 00:02:28,749 line:-2
an integer, and the calculation--
a string.


38
00:02:28.782 --> 00:02:33.053 line:-2 align:center
If the arguments of the macro expression
don't match the macro's parameters,


39
00:02:33,086 --> 00:02:35,355 line:-1
or don't type check by themselves,


40
00:02:35.389 --> 00:02:39.193 line:-2 align:center
the compiler will emit an error
without applying the macro expansion.


41
00:02:40.394 --> 00:02:43.897 line:-2 align:center
For example,
if I pass a string literal to this macro,


42
00:02:43,931 --> 00:02:47,868 line:-2
the compiler complains
that 'String' is not convertible


43
00:02:47.901 --> 00:02:51.538 line:-1 align:center
to expected argument type 'Int'.


44
00:02:51.572 --> 00:02:54.441 line:-2 align:center
This is different to, for example,
C macros,


45
00:02:54.474 --> 00:02:59.179 line:-2 align:center
which are evaluated at the pre-processor
stage before type-checking.


46
00:02:59,213 --> 00:03:01,348 line:-1
But it allows us to use all the powers


47
00:03:01,381 --> 00:03:04,218 line:-2
that you know and love
from Swift functions,


48
00:03:04,251 --> 00:03:06,620 line:-2
like being able
to make your macro generic.


49
00:03:08.188 --> 00:03:14.161 line:-2 align:center
Also note that this macro is declared with
the freestanding expression macro role.


50
00:03:14.194 --> 00:03:18.465 line:-2 align:center
This means that you can use the macro
wherever you can use an expression,


51
00:03:18.498 --> 00:03:24.538 line:-2 align:center
and that it will be indicated by the hash
character, like we see with #stringify.


52
00:03:24.571 --> 00:03:30.143 line:-2 align:center
Other kinds of macros are attached macros
that can augment declarations.


53
00:03:30,177 --> 00:03:31,979 line:-1
I will cover those later.


54
00:03:32,012 --> 00:03:36,550 line:-2
After checking that all the arguments
match the macro's parameters,


55
00:03:36.583 --> 00:03:39.987 line:-1 align:center
the compiler performs the macro expansion.


56
00:03:40,020 --> 00:03:44,525 line:-2
To see how that works,
let's focus on a single macro expression.


57
00:03:47,227 --> 00:03:49,329 line:-1
To perform the expansion,


58
00:03:49.363 --> 00:03:53.734 line:-2 align:center
each macro defines its implementation
in a compiler plug-in.


59
00:03:53,767 --> 00:03:57,204 line:-2
The compiler will send the source code
of the entire macro expression


60
00:03:57,237 --> 00:03:59,806 line:-1
to that plug-in.


61
00:03:59.840 --> 00:04:02.442 line:-2 align:center
The first thing
that the macro plug-in does,


62
00:04:02.476 --> 00:04:08.048 line:-2 align:center
is to parse the source code of the macro
into a SwiftSyntax tree.


63
00:04:08,081 --> 00:04:13,320 line:-2
This tree is a source-accurate, structural
representation of the macro,


64
00:04:13.353 --> 00:04:16.723 line:-2 align:center
and it will be the basis
on which the macro operates.


65
00:04:17,791 --> 00:04:22,196 line:-2
For example, our 'stringify' macro
is represented in the tree


66
00:04:22,229 --> 00:04:26,366 line:-1
as a macro expansion expression node.


67
00:04:26,400 --> 00:04:31,004 line:-2
That expression
has the macro name 'stringify'.


68
00:04:31.038 --> 00:04:33.073 line:-1 align:center
And it takes a single argument,


69
00:04:33,106 --> 00:04:38,812 line:-2
which is the infix operator plus
applied to 2 and 3.


70
00:04:38,846 --> 00:04:41,748 line:-1
What's really powerful about Swift macros


71
00:04:41,782 --> 00:04:46,220 line:-2
is that that the macro's implementation
is itself a program written in Swift


72
00:04:46,253 --> 00:04:49,923 line:-2
and can perform any transformation
to the syntax tree it wants.


73
00:04:51,191 --> 00:04:56,463 line:-2
In our case,
it generates a tuple like we saw before.


74
00:04:56,496 --> 00:05:01,401 line:-2
It will then serialize the generated
syntax tree into source code again


75
00:05:01.435 --> 00:05:04.605 line:-2 align:center
and send it to the compiler,
which will replace the macro expression


76
00:05:04.638 --> 00:05:06.373 line:-1 align:center
by the expanded code.


77
00:05:09.309 --> 00:05:10.944 line:-1 align:center
That's really cool,


78
00:05:10,978 --> 00:05:16,483 line:-2
but now I want to understand how
all of this actually looks like in code.


79
00:05:16.517 --> 00:05:18.485 line:-1 align:center
The new macro template in Xcode


80
00:05:18.519 --> 00:05:22.623 line:-2 align:center
defines the stringify macro
that we have just seen.


81
00:05:22.656 --> 00:05:26.827 line:-2 align:center
Let us walk through that template
and explore the macro's definition,


82
00:05:26,860 --> 00:05:31,431 line:-2
how the expansion works,
and how the macro can be tested.


83
00:05:31.465 --> 00:05:37.638 line:-2 align:center
To create the template,
I click File, New, Package,


84
00:05:37.671 --> 00:05:41.074 line:-1 align:center
and now I select the Swift Macro template.


85
00:05:43.977 --> 00:05:47.614 line:-1 align:center
Let's call our first macro "WWDC".


86
00:05:55,656 --> 00:05:58,959 line:-1
So what do we get with the template?


87
00:05:58,992 --> 00:06:02,529 line:-2
Here we have an invocation
of the #stringify macro,


88
00:06:02.563 --> 00:06:05.098 line:-1 align:center
similar to what we have seen before.


89
00:06:05,132 --> 00:06:08,168 line:-1
It takes a parameter "a + b"


90
00:06:08.202 --> 00:06:09.970 line:-1 align:center
and returns the result,


91
00:06:10.003 --> 00:06:12.339 line:-1 align:center
as well as the code that produced it.


92
00:06:12,372 --> 00:06:15,142 line:-2
If I want to know
what the macro expands to,


93
00:06:15.175 --> 00:06:18.779 line:-2 align:center
I can right-click on it
and select Expand Macro.


94
00:06:20.848 --> 00:06:23.617 line:-1 align:center
That's exactly what we saw before.


95
00:06:23,650 --> 00:06:26,119 line:-1
But how is the macro defined?


96
00:06:26,153 --> 00:06:27,821 line:-1
Let's jump to its definition.


97
00:06:32,092 --> 00:06:34,494 line:-2
Here we have
a slightly generalized version


98
00:06:34,528 --> 00:06:37,998 line:-1
of our previous 'stringify' macro.


99
00:06:38,031 --> 00:06:39,933 line:-1
Instead of taking an integer,


100
00:06:39.967 --> 00:06:43.570 line:-2 align:center
this macro is generic
and can receive any type T.


101
00:06:47.241 --> 00:06:50.143 line:-2 align:center
The macro is declared
as an external macro.


102
00:06:52,045 --> 00:06:55,449 line:-2
This tells the compiler
that to perform the expansion,


103
00:06:55.482 --> 00:07:00.053 line:-2 align:center
it needs to look at
the StringifyMacro type


104
00:07:00.087 --> 00:07:02.422 line:-1 align:center
in the WWDCMacros module.


105
00:07:04,124 --> 00:07:06,026 line:-1
How is that type defined?


106
00:07:07,361 --> 00:07:10,330 line:-1
Let's take a closer look at it.


107
00:07:10.364 --> 00:07:14.468 line:-2 align:center
Because stringify is declared
as a freestanding expression macro,


108
00:07:14,501 --> 00:07:19,239 line:-2
the StringifyMacro type needs to conform
to the ExpressionMacro protocol.


109
00:07:20,741 --> 00:07:24,077 line:-1
This protocol has a single requirement:


110
00:07:24,111 --> 00:07:26,713 line:-1
The expansion function.


111
00:07:26,747 --> 00:07:30,617 line:-2
It takes the syntax tree
of the macro expression itself,


112
00:07:30.651 --> 00:07:34.788 line:-2 align:center
as well as a context that can be used
to communicate with the compiler.


113
00:07:36.823 --> 00:07:41.161 line:-2 align:center
The expansion function then returns
the rewritten expression syntax.


114
00:07:42,896 --> 00:07:45,966 line:-1
What does it do in the implementation?


115
00:07:45,999 --> 00:07:52,339 line:-2
At first, it retrieves the single argument
to the macro expression.


116
00:07:52,372 --> 00:07:56,443 line:-2
It knows that this argument exists
because stringify is declared


117
00:07:56,476 --> 00:07:58,979 line:-1
as taking a single parameter


118
00:07:59.012 --> 00:08:01.248 line:-1 align:center
and all arguments need to type-check


119
00:08:01,281 --> 00:08:05,352 line:-1
before the macro expansion can be applied.


120
00:08:05,385 --> 00:08:10,324 line:-2
It then uses string interpolation
to create the syntax tree of a tuple.


121
00:08:10,357 --> 00:08:14,161 line:-1
The first element is the argument itself


122
00:08:14,194 --> 00:08:16,330 line:-1
and the second is a string literal


123
00:08:16,363 --> 00:08:18,465 line:-2
containing the source code
of the argument.


124
00:08:20.567 --> 00:08:23.971 line:-2 align:center
Notice that the function
is not returning a string here.


125
00:08:24,004 --> 00:08:27,608 line:-1
It is returning an expression syntax.


126
00:08:27.641 --> 00:08:30.611 line:-2 align:center
The macro will automatically invoke
the Swift parser


127
00:08:30,644 --> 00:08:34,715 line:-2
to transform this literal
into a syntax tree.


128
00:08:34,748 --> 00:08:37,150 line:-2
And because it is using
the literal interpolation style


129
00:08:37,184 --> 00:08:39,052 line:-1
for the second argument,


130
00:08:39,086 --> 00:08:44,424 line:-2
it will make sure that the literal's
contents are properly escaped.


131
00:08:44.458 --> 00:08:46.193 line:-1 align:center
Nobody likes bugs.


132
00:08:46,226 --> 00:08:50,197 line:-2
But what I like even less
are bugs in code that I don't see


133
00:08:50.230 --> 00:08:54.568 line:-2 align:center
unless I explicitly ask for it
by expanding the macro.


134
00:08:54,601 --> 00:08:58,338 line:-2
That is why you want to make sure
that your macro is well-tested.


135
00:08:58.372 --> 00:09:01.041 line:-1 align:center
Because macros don't have side effects


136
00:09:01,074 --> 00:09:04,711 line:-2
and the source code of syntax trees
is easy to compare,


137
00:09:04.745 --> 00:09:08.649 line:-2 align:center
a great way to test them
is to write unit tests.


138
00:09:08.682 --> 00:09:11.185 line:-1 align:center
The macro template already comes with one.


139
00:09:12,920 --> 00:09:16,390 line:-2
This test case uses
the 'assertMacroExpansion' function


140
00:09:16,423 --> 00:09:18,358 line:-1
from the SwiftSyntax package


141
00:09:18.392 --> 00:09:21.895 line:-2 align:center
to verify that the 'stringify' macro
expands correctly.


142
00:09:23,764 --> 00:09:26,767 line:-2
It takes the '#stringify(a + b)'
expression,


143
00:09:26.800 --> 00:09:29.937 line:-1 align:center
that we saw before, as input.


144
00:09:29.970 --> 00:09:33.173 line:-2 align:center
and asserts
that after the macro is expanded,


145
00:09:33.207 --> 00:09:37.044 line:-1 align:center
it produces a tuple containing 'a + b'


146
00:09:37,077 --> 00:09:40,314 line:-1
and the string literal 'a + b'.


147
00:09:42.516 --> 00:09:45.285 line:-2 align:center
To tell the test case
how to expand the macros,


148
00:09:45,319 --> 00:09:48,355 line:-1
it passes the 'testMacros' parameter,


149
00:09:48,388 --> 00:09:51,692 line:-1
which specifies that the macro ‘#stringify'


150
00:09:51,725 --> 00:09:55,429 line:-2
should be expanded
using the 'StringifyMacro' type.


151
00:09:55.462 --> 00:09:57.998 line:-1 align:center
Let's run the tests in the same way


152
00:09:58,031 --> 00:10:00,367 line:-2
that you might already run the tests
of your app,


153
00:10:00,400 --> 00:10:02,836 line:-1
to see if they indeed pass.


154
00:10:09,877 --> 00:10:11,512 line:-1
The tests pass,


155
00:10:11.545 --> 00:10:15.082 line:-2 align:center
and with that,
we already have our first macro.


156
00:10:16.517 --> 00:10:20.487 line:-1 align:center
In it, we saw its basic building blocks.


157
00:10:20,521 --> 00:10:24,258 line:-2
The macro declaration
defines the macro's signature.


158
00:10:24,291 --> 00:10:28,095 line:-1
It also declares the macros roles.


159
00:10:28,128 --> 00:10:31,798 line:-2
The compiler plug-in
performs the expansion.


160
00:10:31,832 --> 00:10:35,235 line:-2
It is a program
that is itself written in Swift


161
00:10:35.269 --> 00:10:37.604 line:-1 align:center
and operates on SwiftSyntax trees.


162
00:10:39.540 --> 00:10:42.809 line:-1 align:center
We also saw that macros are very testable


163
00:10:42.843 --> 00:10:46.713 line:-2 align:center
because they are deterministic
transformations of syntax trees


164
00:10:46,747 --> 00:10:51,051 line:-2
and the source code of syntax trees
is easy to compare.


165
00:10:51,084 --> 00:10:56,056 line:-2
So you might wonder, "In which other
situations can we use macros?"


166
00:10:56,089 --> 00:11:00,060 line:-2
We have already seen
a freestanding expression macro.


167
00:11:00,093 --> 00:11:03,564 line:-2
Just to recap,
this macro is spelled with a hash


168
00:11:03,597 --> 00:11:07,467 line:-2
and allows you to rewrite
the entire macro expression.


169
00:11:07,501 --> 00:11:10,103 line:-2
There's also
a freestanding declaration role


170
00:11:10,137 --> 00:11:14,208 line:-2
that expands to a declaration
instead of an expression.


171
00:11:14.241 --> 00:11:18.011 line:-2 align:center
The other kinds of macros
are attached macros.


172
00:11:18.045 --> 00:11:21.415 line:-2 align:center
These are spelled with an @,
just like attributes,


173
00:11:21,448 --> 00:11:25,786 line:-2
and allow the macro to augment
the declaration they are attached to.


174
00:11:25,819 --> 00:11:28,789 line:-1
For example, an attached member macro


175
00:11:28.822 --> 00:11:32.059 line:-2 align:center
adds new members of the type
it is attached to.


176
00:11:32,092 --> 00:11:35,162 align:center
To learn more about these other roles,
I highly recommend watching


177
00:11:35,195 --> 00:11:37,064 align:center
"Expand on Swift macros"


178
00:11:37,097 --> 00:11:40,400 line:0
where Becca goes over them
in great detail.


179
00:11:40,434 --> 00:11:43,637 line:-2
But I want to focus
on the attached member role


180
00:11:43,670 --> 00:11:46,507 line:-2
because it helped me
improve the codebase of an app


181
00:11:46.540 --> 00:11:48.642 line:-1 align:center
I am currently working on.


182
00:11:48.675 --> 00:11:50.777 line:-1 align:center
I am also a ski instructor,


183
00:11:50,811 --> 00:11:53,213 line:-1
and recently I have been working on an app


184
00:11:53,247 --> 00:11:56,517 line:-2
that allows me to plan the tours
I want to take my students on.


185
00:11:57,818 --> 00:12:01,154 line:-2
One thing you absolutely want to avoid
as a ski instructor


186
00:12:01.188 --> 00:12:04.525 line:-2 align:center
is to take beginners on slopes
that are too hard for them.


187
00:12:04,558 --> 00:12:08,395 line:-2
I want to use the Swift type system
to enforce that.


188
00:12:08,428 --> 00:12:11,131 line:-2
That's why,
in addition to the Slope enum


189
00:12:11.164 --> 00:12:14.835 line:-2 align:center
that contains all the slopes
in my favorite ski resort,


190
00:12:14.868 --> 00:12:20.941 line:-2 align:center
I also have an EasySlope type that only
contains slopes suitable for beginners.


191
00:12:20.974 --> 00:12:24.711 line:-2 align:center
It has an initializer
to convert a slope to an easy slope,


192
00:12:24.745 --> 00:12:28.081 line:-1 align:center
if the slope is indeed easy,


193
00:12:28.115 --> 00:12:33.120 line:-2 align:center
and a computed property to convert
an easy slope back to a general slope.


194
00:12:34.988 --> 00:12:38.792 line:-2 align:center
While this provides great type safety,
it is really repetitive.


195
00:12:38.825 --> 00:12:43.530 line:-2 align:center
If I want to add an easy slope,
I need to add it to Slope...


196
00:12:45.766 --> 00:12:48.468 line:-1 align:center
EasySlope,


197
00:12:48,502 --> 00:12:50,537 line:-1
the initializer,


198
00:12:50,571 --> 00:12:53,540 line:-1
and the computed property.


199
00:12:53,574 --> 00:12:56,610 line:-2
Let's see if we can improve things
using a macro.


200
00:12:56,643 --> 00:13:00,881 line:-2
What we want to do is to
automatically generate the initializer


201
00:13:00,914 --> 00:13:03,517 line:-1
and the computed property.


202
00:13:03.550 --> 00:13:06.320 line:-1 align:center
How can we do this?


203
00:13:06,353 --> 00:13:09,356 line:-2
Both the initializer
and the computed property


204
00:13:09,389 --> 00:13:12,392 line:-1
are members of the EasySlope type,


205
00:13:12.426 --> 00:13:15.162 line:-2 align:center
so we need to declare
an attached member macro.


206
00:13:16,697 --> 00:13:21,768 line:-2
Next, we will create the compiler plug-in
that contains the macro's implementation.


207
00:13:23.103 --> 00:13:26.106 line:-2 align:center
To make sure
that our macro behaves as expected,


208
00:13:26,139 --> 00:13:29,643 line:-2
we want to develop it
in a test-driven way.


209
00:13:29,676 --> 00:13:32,179 line:-2
Thus,
we will leave its implementation empty


210
00:13:32,212 --> 00:13:34,414 line:-1
until we write a test case for it.


211
00:13:36,049 --> 00:13:39,152 line:-2
After we defined the macro's behavior
in a test case,


212
00:13:39,186 --> 00:13:42,890 line:-2
we will write the implementation
to match that test case.


213
00:13:45.359 --> 00:13:50.464 line:-2 align:center
And finally, we will integrate
the new macro into my app.


214
00:13:50,497 --> 00:13:54,334 line:-2
If all goes well,
we will be able to remove the initializer


215
00:13:54.368 --> 00:13:56.803 line:-1 align:center
and have the macro generate it for us.


216
00:13:58.972 --> 00:14:04.011 line:-2 align:center
To develop the macro, we work with
the template that we created earlier.


217
00:14:04.044 --> 00:14:07.314 line:-2 align:center
And since I don't really need
the ‘#stringify' macro in my app,


218
00:14:07,347 --> 00:14:09,783 line:-1
I have already removed it.


219
00:14:09,816 --> 00:14:13,153 line:-2
I start by declaring
a new attached member macro


220
00:14:13.187 --> 00:14:15.722 line:-2 align:center
by using the '@attached(member)'
attribute.


221
00:14:18,125 --> 00:14:22,796 line:-2
I call it SlopeSubset because
EasySlope is a subset of Slope.


222
00:14:24,331 --> 00:14:28,435 line:-2
The macro also defines the names
of the members it introduces.


223
00:14:30.270 --> 00:14:34.441 line:-2 align:center
In this demo, I will just be showing you
how to generate the initializer.


224
00:14:34,474 --> 00:14:37,311 line:-2
Generating the computed property
is very similar,


225
00:14:37,344 --> 00:14:39,379 line:-1
because it's also just a switch statement


226
00:14:39,413 --> 00:14:42,316 line:-1
that switches over all the cases.


227
00:14:42.349 --> 00:14:46.053 line:-2 align:center
With this declaration,
we have defined the macro,


228
00:14:46.086 --> 00:14:49.656 line:-2 align:center
but we have not implemented
the expansion that it actually performs.


229
00:14:50,724 --> 00:14:54,461 line:-2
For this, our macro references
the SlopeSubsetMacro type


230
00:14:54.494 --> 00:14:58.031 line:-1 align:center
in the WWDCMacros module .


231
00:14:58,065 --> 00:14:59,800 line:-1
Let us go and create that type


232
00:14:59,833 --> 00:15:02,402 line:-2
so we can continue
to the really exciting part:


233
00:15:02,436 --> 00:15:05,205 line:-1
The actual macro implementation.


234
00:15:06,273 --> 00:15:10,377 line:-2
Since we declared SlopeSubset
as an attached member macro,


235
00:15:10.410 --> 00:15:14.448 line:-2 align:center
the corresponding implementation needs
to conform to the MemberMacro protocol.


236
00:15:15.849 --> 00:15:18.352 line:-1 align:center
This protocol has a single requirement:


237
00:15:18,385 --> 00:15:20,153 line:-1
The 'expansion' function,


238
00:15:20.187 --> 00:15:22.723 line:-1 align:center
similar to ExpressionMacro.


239
00:15:24,892 --> 00:15:27,594 line:-2
The 'expansion' function
takes the attribute


240
00:15:27.628 --> 00:15:32.065 line:-2 align:center
with which we apply the macro
to a declaration,


241
00:15:32.099 --> 00:15:36.537 line:-2 align:center
as well as the declaration that the macro
is being applied to.


242
00:15:36.570 --> 00:15:41.041 line:-2 align:center
In our case, this will be
the EasySlope enum declaration.


243
00:15:42,809 --> 00:15:45,746 line:-2
The macro then returns the list
of all the new members


244
00:15:45.779 --> 00:15:48.215 line:-1 align:center
it wants to add to that declaration.


245
00:15:50,117 --> 00:15:52,052 line:-1
I know that it's very tempting


246
00:15:52,085 --> 00:15:55,055 line:-2
to start implementing this transformation
straight away,


247
00:15:55,088 --> 00:15:59,059 line:-2
but we agreed that we wanted to start
by writing a test case for it.


248
00:16:00,394 --> 00:16:04,164 line:-2
So for now,
let us just return an empty array,


249
00:16:04,198 --> 00:16:06,433 line:-2
indicating that no new members
should be added.


250
00:16:12.105 --> 00:16:17.778 line:-2 align:center
Finally, we need to make SlopeSubset
visible to the compiler.


251
00:16:17.811 --> 00:16:21.215 line:-2 align:center
For this, I add it
to the 'providingMacros' property


252
00:16:21,248 --> 00:16:22,850 line:-1
down here.


253
00:16:26,386 --> 00:16:27,721 line:-1
Before diving any deeper,


254
00:16:27,754 --> 00:16:32,092 line:-2
I want to make sure
that what we have so far works.


255
00:16:32.125 --> 00:16:34.895 line:-2 align:center
While I could try
applying the macro in Xcode


256
00:16:34.928 --> 00:16:36.897 line:-1 align:center
and looking at the expanded code,


257
00:16:36.930 --> 00:16:39.566 line:-1 align:center
I much prefer to write a test case for it


258
00:16:39,600 --> 00:16:43,070 line:-2
that I can rerun
whenever I'm making changes to the macro,


259
00:16:43.103 --> 00:16:46.240 line:-2 align:center
to make sure
I'm not introducing regressions.


260
00:16:51,278 --> 00:16:53,947 line:-2
Just like in the test case
in the template,


261
00:16:53,981 --> 00:16:59,853 line:-2
we use the 'assertMacroExpansion' function
to verify our macro's behavior.


262
00:17:03,423 --> 00:17:06,693 line:-2
What we want to test
is what the macro generates


263
00:17:06.727 --> 00:17:09.563 line:-1 align:center
when applied to the EasySlope type,


264
00:17:09.596 --> 00:17:12.866 line:-1 align:center
so we use that as our test case's input.


265
00:17:16.103 --> 00:17:19.039 line:-2 align:center
And since the macro's
not doing anything yet,


266
00:17:19,072 --> 00:17:21,909 line:-1
we just expect it to remove the attribute


267
00:17:21.942 --> 00:17:24.611 line:-1 align:center
and not add any new members,


268
00:17:24,645 --> 00:17:28,515 line:-2
so the expected expanded code
is the same as the input,


269
00:17:28,549 --> 00:17:31,418 line:-1
just without '@SlopeSubset'.


270
00:17:36.657 --> 00:17:39.359 line:-1 align:center
Finally, we need to let the test case know


271
00:17:39,393 --> 00:17:42,229 line:-2
that it should expand the macro
SlopeSubset


272
00:17:42.262 --> 00:17:46.300 line:-1 align:center
using the SlopeSubsetMacro implementation.


273
00:17:46.333 --> 00:17:50.804 line:-2 align:center
For that, we need to map the macro name
to its implementing type


274
00:17:50,838 --> 00:17:53,106 line:-1
in the 'testMacros' dictionary


275
00:17:53.140 --> 00:17:56.643 line:-2 align:center
and pass that dictionary
to the assertion function.


276
00:18:04,084 --> 00:18:05,886 line:-1
Let's run our tests now


277
00:18:05,919 --> 00:18:09,523 line:-2
to check that what
we have written so far actually works.


278
00:18:18,365 --> 00:18:19,399 line:-1
It does.


279
00:18:19.433 --> 00:18:20.868 line:-1 align:center
Great.


280
00:18:20.901 --> 00:18:24.104 line:-2 align:center
But we want really wanted
is to check that our macro


281
00:18:24.137 --> 00:18:26.273 line:-1 align:center
actually generates the initializer,


282
00:18:26,306 --> 00:18:29,142 line:-1
not just remove the attribute.


283
00:18:29.176 --> 00:18:33.480 line:-2 align:center
So I'll copy the code that I previously
wrote by hand into the test case


284
00:18:33.514 --> 00:18:37.918 line:-2 align:center
because really, that's what we want
the plug-in to generate.


285
00:18:42,990 --> 00:18:45,692 line:-1
If we run the test again…


286
00:18:47,861 --> 00:18:49,162 line:-1
...it fails


287
00:18:49.196 --> 00:18:52.566 line:-2 align:center
because our macro doesn't actually
generate the initializer yet.


288
00:18:53,867 --> 00:18:56,870 line:-1
Let's change that now.


289
00:19:01,508 --> 00:19:07,447 line:-2
The initializer switches over all the enum
elements declared in the EasySlopes enum.


290
00:19:07,481 --> 00:19:09,883 line:-1
So the first thing that we need to do


291
00:19:09.917 --> 00:19:15.122 line:-2 align:center
is to retrieve these enum elements
from the declaration.


292
00:19:15,155 --> 00:19:19,426 line:-2
Since enum elements can only be declared
inside enum declarations,


293
00:19:19.459 --> 00:19:23.630 line:-2 align:center
we start by casting 'declaration'
to an enum declaration.


294
00:19:27.601 --> 00:19:30.938 line:-2 align:center
If the macro is attached to a type
that is not an enum,


295
00:19:30.971 --> 00:19:33.006 line:-1 align:center
we should be emitting an error.


296
00:19:33.040 --> 00:19:36.610 line:-2 align:center
I added a TODO
so that we don’t forget to do it later,


297
00:19:36,643 --> 00:19:39,546 line:-1
and return an empty array for now.


298
00:19:39.580 --> 00:19:44.384 line:-2 align:center
Next, we need to get all the elements
that the enum declares.


299
00:19:44,418 --> 00:19:46,553 line:-1
To figure out how to do that,


300
00:19:46.587 --> 00:19:50.858 line:-2 align:center
I want to inspect the syntactic structure
of our enum in the SwiftSyntax tree.


301
00:19:52.492 --> 00:19:56.496 line:-2 align:center
Since the macro's implementation
is just an ordinary Swift program,


302
00:19:56,530 --> 00:20:01,969 line:-2
I can use all the tools that you know
from Xcode to debug your programs.


303
00:20:02.002 --> 00:20:06.139 line:-2 align:center
For example, I can set a breakpoint inside
the expansion function


304
00:20:06,173 --> 00:20:09,743 line:-2
and run the test cases
to hit that breakpoint.


305
00:20:17.851 --> 00:20:22.422 line:-2 align:center
We now have the debugger paused
inside the macro’s implementation


306
00:20:22.456 --> 00:20:25.859 line:-1 align:center
and 'enumDecl' is the EasySlopes enum.


307
00:20:25.893 --> 00:20:31.431 line:-2 align:center
We can print it in the debugger
by typing 'po enumDecl'.


308
00:20:34,434 --> 00:20:36,904 line:-1
Let's inspect the output.


309
00:20:38,138 --> 00:20:42,442 line:-2
The innermost nodes of the syntax tree
represent the enum elements,


310
00:20:42.476 --> 00:20:46.780 line:-2 align:center
the 'beginnersParadise',
and 'practiceRun' slopes.


311
00:20:46.813 --> 00:20:49.750 line:-2 align:center
To retrieve them,
we need to follow the structure


312
00:20:49,783 --> 00:20:52,719 line:-1
that is outlined to us in the syntax tree.


313
00:20:52.753 --> 00:20:56.023 line:-2 align:center
Let us walk through that structure
step-by-step


314
00:20:56.056 --> 00:20:58.458 line:-1 align:center
and write the access code as we go.


315
00:20:59.760 --> 00:21:04.464 line:-2 align:center
The enum declaration
has a child called 'memberBlock'.


316
00:21:04,498 --> 00:21:08,235 line:-1
This member block contains both the braces


317
00:21:08.268 --> 00:21:09.736 line:-1 align:center
and the actual members.


318
00:21:09,770 --> 00:21:12,039 line:-1
So to access the members,


319
00:21:12,072 --> 00:21:17,010 line:-2
we start with
'enumDecl.memberBlock.members'.


320
00:21:18,545 --> 00:21:21,715 line:-2
These members contain
the actual declaration,


321
00:21:21,748 --> 00:21:23,851 line:-1
as well as an optional semicolon.


322
00:21:23,884 --> 00:21:27,187 line:-1
We are interested in the declarations,


323
00:21:27.221 --> 00:21:31.758 line:-2 align:center
in particular those declarations
that actually declare enum cases.


324
00:21:31.792 --> 00:21:36.063 line:-2 align:center
I'm using compact map to get a list
of all the member declarations


325
00:21:36.096 --> 00:21:38.832 line:-1 align:center
that are enum cases.


326
00:21:38,866 --> 00:21:42,536 line:-2
Each case declaration
can declare multiple elements.


327
00:21:42.569 --> 00:21:46.440 line:-2 align:center
This is because instead of declaring
each slope on a new line


328
00:21:46.473 --> 00:21:49.076 line:-1 align:center
after a separate case keyword,


329
00:21:49.109 --> 00:21:51.178 line:-1 align:center
I could have written them on the same line


330
00:21:51.211 --> 00:21:55.682 line:-1 align:center
as 'case beginnersParadise, practiceRun'.


331
00:21:57,718 --> 00:22:00,921 line:-2
To retrieve all of them,
we can use 'flatMap'.


332
00:22:03.090 --> 00:22:06.260 line:-2 align:center
And now that we have retrieved
all the elements,


333
00:22:06.293 --> 00:22:08.762 line:-1 align:center
we can start constructing the initializer


334
00:22:08.795 --> 00:22:12.432 line:-1 align:center
that we actually want to add to EasySlope.


335
00:22:14,735 --> 00:22:18,272 line:-2
The initializer declaration
has a single item:


336
00:22:18.305 --> 00:22:20.040 line:-1 align:center
A switch expression.


337
00:22:22,109 --> 00:22:26,980 line:-2
This switch expression contains a case
for each element in the enum,


338
00:22:27.014 --> 00:22:31.151 line:-2 align:center
as well as a default case
that returns nil.


339
00:22:31,185 --> 00:22:33,987 line:-2
We need to create syntax nodes
for all of these.


340
00:22:36,423 --> 00:22:39,760 line:-2
Two great ways of finding
the syntax nodes to create, are


341
00:22:39,793 --> 00:22:43,463 line:-2
either by printing the syntax tree
like we did before,


342
00:22:43,497 --> 00:22:47,000 line:-1
or by reading SwiftSyntax's documentation.


343
00:22:48.402 --> 00:22:52.072 line:-2 align:center
We start by constructing
an InitializerDeclSyntax.


344
00:22:56,443 --> 00:22:58,312 line:-1
This type can be constructed


345
00:22:58,345 --> 00:23:01,114 line:-2
by building the body
using a result builder


346
00:23:01.148 --> 00:23:02.883 line:-1 align:center
and specifying the header--


347
00:23:02,916 --> 00:23:07,387 line:-2
that is the 'init' keyword
and all the parameters.


348
00:23:07,421 --> 00:23:10,858 line:-2
This will allow us to use a for loop
inside the result builder


349
00:23:10,891 --> 00:23:13,193 line:-1
to iterate over all the elements,


350
00:23:13,227 --> 00:23:15,128 line:-1
exactly what we need.


351
00:23:17.097 --> 00:23:20.234 line:-2 align:center
I just copy the init header
from our test case.


352
00:23:24,104 --> 00:23:27,941 line:-2
Inside the body,
we need a switch expression.


353
00:23:33,480 --> 00:23:35,916 line:-1
This type also has an initializer


354
00:23:35,949 --> 00:23:39,286 line:-1
that takes a header and a result builder.


355
00:23:39.319 --> 00:23:40.888 line:-1 align:center
Let's use it again.


356
00:23:44.925 --> 00:23:48.295 line:-2 align:center
Now we can use the power
of result builders


357
00:23:48,328 --> 00:23:51,899 line:-2
by iterating over all elements
that we gathered earlier.


358
00:23:54,835 --> 00:23:58,739 line:-2
For each element,
we want to create a new case item,


359
00:23:58.772 --> 00:24:01.742 line:-2 align:center
which we can construct
using string interpolation


360
00:24:01,775 --> 00:24:04,211 line:-1
just like we saw for ‘#stringify'.


361
00:24:06,880 --> 00:24:10,984 line:-2
We also need to add a default case
that returns nil.


362
00:24:14,454 --> 00:24:18,425 line:-2
And finally,
we can return the initializer.


363
00:24:22.329 --> 00:24:27.467 line:-2 align:center
Let's run the tests to see if we are
indeed generating the correct initializer.


364
00:24:32,773 --> 00:24:33,941 line:-1
We are.


365
00:24:33,974 --> 00:24:36,210 line:-1
So we know that our macro works


366
00:24:36.243 --> 00:24:39.847 line:-1 align:center
and we can start using it in my app.


367
00:24:42.816 --> 00:24:45.953 line:-2 align:center
To add our macro package
to my Xcode project,


368
00:24:45,986 --> 00:24:50,490 line:-2
I can right-click on it
and select "Add Package Dependencies".


369
00:24:50,524 --> 00:24:54,628 line:-2
I can now select the local package
that we just created.


370
00:25:00,634 --> 00:25:03,103 line:-1
To be able to use the macro,


371
00:25:03.136 --> 00:25:07.508 line:-2 align:center
I add the WWDC target
as a dependency of my app.


372
00:25:12,279 --> 00:25:16,483 line:-2
We can now import the WWDC module
from the package


373
00:25:16,517 --> 00:25:20,187 line:-2
and apply the SlopeSubset macro
to the EasySlope type.


374
00:25:23.924 --> 00:25:28.929 line:-1 align:center
…


375
00:25:31,865 --> 00:25:35,369 line:-1
If we build...


376
00:25:35,402 --> 00:25:39,206 line:-2
...the compiler complains
that the hand-written initializer


377
00:25:39,239 --> 00:25:41,875 line:-1
is an invalid redeclaration.


378
00:25:41.909 --> 00:25:45.979 line:-2 align:center
And that's because
the macro now generates it for us.


379
00:25:46,013 --> 00:25:47,714 line:-1
So we can just delete it.


380
00:25:53.153 --> 00:25:56.089 line:-1 align:center
It's always fun to delete code. Right?


381
00:25:56,123 --> 00:25:59,927 line:-2
So if we want to see
what the macro actually generated,


382
00:25:59,960 --> 00:26:04,097 line:-2
we can right-click on SlopeSubset
and click Expand Macro.


383
00:26:06,066 --> 00:26:08,836 line:-1
And if I forgot what the macro does,


384
00:26:08,869 --> 00:26:12,506 line:-2
I can also Option-click on it
to read its documentation.


385
00:26:16,810 --> 00:26:20,647 line:-2
The next step would be
to also generate the computed property,


386
00:26:20,681 --> 00:26:23,817 line:-1
but I'll do that later today.


387
00:26:23,851 --> 00:26:28,488 line:-2
By using macros, we were able to get
the type safety of EasySlopes


388
00:26:28,522 --> 00:26:32,259 line:-1
without the need to write repetitive code.


389
00:26:32.292 --> 00:26:35.295 line:-1 align:center
How did we do that?


390
00:26:35,329 --> 00:26:39,800 line:-2
We started with
the Swift macro package template.


391
00:26:39.833 --> 00:26:42.503 line:-1 align:center
To explore the syntax tree's structure,


392
00:26:42.536 --> 00:26:44.505 line:-1 align:center
we stopped the macro's execution


393
00:26:44.538 --> 00:26:48.609 line:-2 align:center
and printed the syntax node
inside the debugger.


394
00:26:48.642 --> 00:26:51.912 line:-2 align:center
This allowed us to see
which properties we needed to access


395
00:26:51.945 --> 00:26:54.248 line:-1 align:center
to get all the enum elements.


396
00:26:56,016 --> 00:27:00,888 line:-2
And it was really easy to develop
the macro on its own using a test case.


397
00:27:00.921 --> 00:27:05.726 line:-2 align:center
After we added it to my app,
it worked straight away.


398
00:27:05.759 --> 00:27:11.131 line:-2 align:center
But what happens if your macro is used
in situations that it doesn't support?


399
00:27:11.164 --> 00:27:15.502 line:-2 align:center
Just like you never want to take
a beginner skier onto a difficult slope,


400
00:27:15.536 --> 00:27:19.606 line:-2 align:center
you never want to let you macro
perform unexpected expansions,


401
00:27:19.640 --> 00:27:23.544 line:-1 align:center
or generate code that does not compile.


402
00:27:23,577 --> 00:27:26,613 line:-2
If your macro is used in ways
that it doesn't support,


403
00:27:26,647 --> 00:27:31,385 line:-2
always emit error messages that inform
your adopters about what's going wrong,


404
00:27:31.418 --> 00:27:35.789 line:-2 align:center
instead of having them read
the generated code to debug your macro.


405
00:27:37.224 --> 00:27:42.062 line:-2 align:center
In that spirit, let's go and fix
the TODO we left in our codebase.


406
00:27:42,095 --> 00:27:45,933 line:-2
When SlopeSubset is applied
to a type that is not an enum,


407
00:27:45.966 --> 00:27:48.135 line:-1 align:center
the macro should emit an error,


408
00:27:48,168 --> 00:27:51,672 line:-2
saying that it is only applicable
to enums.


409
00:27:51,705 --> 00:27:55,876 line:-2
Just like before,
let's start by adding a test case.


410
00:28:01.682 --> 00:28:05.986 line:-2 align:center
This time, we are applying
the SlopeSubset macro to a struct.


411
00:28:08,488 --> 00:28:11,191 line:-2
Since there are no enum elements
in the struct,


412
00:28:11,225 --> 00:28:15,662 line:-2
we don't expect the macro
to generate an initializer.


413
00:28:15,696 --> 00:28:20,000 line:-2
Instead, it should emit a diagnostic,
that is an error,


414
00:28:20.033 --> 00:28:24.905 line:-2 align:center
informing us that SlopeSubset
can only be applied to an enum.


415
00:28:24.938 --> 00:28:30.043 line:-1 align:center
If we run this test...


416
00:28:30,077 --> 00:28:31,612 line:-1
...it fails


417
00:28:31.645 --> 00:28:34.581 line:-2 align:center
because we are not outputting
the error message yet.


418
00:28:34,615 --> 00:28:38,252 line:-2
Let's go to the compiler plug-in
to do so now.


419
00:28:41,922 --> 00:28:44,925 line:-2
Macro errors can be represented
by any type


420
00:28:44.958 --> 00:28:48.795 line:-1 align:center
that conforms to the Swift Error protocol.


421
00:28:48,829 --> 00:28:52,666 line:-2
I use an enum with a single case
to describe the error message


422
00:28:52.699 --> 00:28:56.837 line:-2 align:center
if SlopeSubset is applied
to a type that's not an enum.


423
00:29:01.441 --> 00:29:04.611 line:-2 align:center
If we throw the error
from the expansion function,


424
00:29:04.645 --> 00:29:08.649 line:-2 align:center
it will be shown at the attribute
that calls the macro expansion.


425
00:29:12,452 --> 00:29:16,957 line:-2
If you want to show the error message at
a different location than the attribute,


426
00:29:16.990 --> 00:29:21.128 line:-2 align:center
generate warnings,
or even show Fix-Its in Xcode,


427
00:29:21,161 --> 00:29:24,731 line:-2
there's an 'addDiagnostic' method
on the context parameter


428
00:29:24.765 --> 00:29:27.334 line:-2 align:center
that allows you
to generate rich diagnostics.


429
00:29:27.367 --> 00:29:31.138 line:-2 align:center
But I think in this case, it's efficient
to just show a simple error message


430
00:29:31,171 --> 00:29:33,841 line:-1
at the attribute.


431
00:29:33.874 --> 00:29:38.579 line:-2 align:center
Now, let's see if we did everything right
and if our tests pass.


432
00:29:43,817 --> 00:29:45,652 line:-1
Great, they do.


433
00:29:45.686 --> 00:29:51.291 line:-2 align:center
So how does it look like in Xcode
if I apply SlopeSubset to a struct?


434
00:29:51.325 --> 00:29:55.229 line:-2 align:center
For this,
let me copy the test case into a file.


435
00:30:02.569 --> 00:30:05.038 line:-1 align:center
Xcode shows the custom error message


436
00:30:05.072 --> 00:30:07.407 line:-1 align:center
inline with all other compilation errors.


437
00:30:07,441 --> 00:30:11,612 line:-2
That makes it easy for adopters of
my macro to see what they are doing wrong.


438
00:30:13,447 --> 00:30:15,182 line:-1
And you know what?


439
00:30:15.215 --> 00:30:17.484 line:-1 align:center
Now that we have good error handling,


440
00:30:17.518 --> 00:30:20.454 line:-2 align:center
I think this macro might also be useful
for other developers


441
00:30:20,487 --> 00:30:24,591 line:-2
specifying enum subsets,
not just for slopes.


442
00:30:24.625 --> 00:30:26.426 line:-1 align:center
Let's go and generalize it.


443
00:30:29,997 --> 00:30:32,065 line:-1
To specify the superset of the enum,


444
00:30:32.099 --> 00:30:34.501 line:-1 align:center
that we have so far hard-coded as Slope,


445
00:30:34.535 --> 00:30:38.071 line:-2 align:center
we add a generic parameter
to the macro declaration.


446
00:30:44,378 --> 00:30:47,915 line:-2
And since the macro is now
no longer specific to slopes,


447
00:30:47,948 --> 00:30:50,918 line:-1
let's rename it to EnumSubset


448
00:30:50,951 --> 00:30:56,390 line:-2
by right clicking on SlopeSubset
and selecting Refactor, Rename.


449
00:31:03.764 --> 00:31:08.435 line:-2 align:center
I can also choose to rename all occurences
inside string literals and comments


450
00:31:08,468 --> 00:31:10,270 line:-1
by Command-clicking them.


451
00:31:14,775 --> 00:31:17,444 line:-2
We now need to adjust
our macro implementation


452
00:31:17,477 --> 00:31:19,413 line:-1
to use the generic parameter,


453
00:31:19.446 --> 00:31:22.416 line:-1 align:center
instead of the hard-coded Slopes type.


454
00:31:22,449 --> 00:31:25,185 line:-2
If we print the attribute
inside the debugger


455
00:31:25.219 --> 00:31:29.256 line:-2 align:center
and inspect its layout,
just like we did for 'enumDecl',


456
00:31:29.289 --> 00:31:32.826 line:-2 align:center
we can see that we can retrieve
the generic parameter


457
00:31:32.860 --> 00:31:36.230 line:-1 align:center
by accessing the 'argumentType'


458
00:31:36.263 --> 00:31:38.732 line:-1 align:center
of the first argument


459
00:31:38.765 --> 00:31:43.837 line:-2 align:center
in the 'genericArgumentClause'
of the attribute's name.


460
00:31:43.871 --> 00:31:47.574 line:-2 align:center
So now that we've retrieved
the generic parameter,


461
00:31:47,608 --> 00:31:50,711 line:-2
we can replace
the so-far hardcoded Slope type


462
00:31:50,744 --> 00:31:53,046 line:-1
by the variable 'supersetType'.


463
00:32:00.754 --> 00:32:03.490 line:-2 align:center
I still need to make
a couple more changes,


464
00:32:03,524 --> 00:32:06,326 line:-1
like renaming the initializer's parameter,


465
00:32:06,360 --> 00:32:09,196 line:-2
changing the macro implementation's
type name,


466
00:32:09.229 --> 00:32:11.198 line:-1 align:center
and updating the documentation.


467
00:32:11.231 --> 00:32:13.467 line:-1 align:center
I'll do that later.


468
00:32:13.500 --> 00:32:17.538 line:-2 align:center
Instead, for now, let's make sure
that our tests are still passing.


469
00:32:22.676 --> 00:32:25.179 line:-1 align:center
Since we made EnumSubset generic,


470
00:32:25,212 --> 00:32:29,917 line:-2
we need to explicitly specify
that EasySlope is a subset of Slope


471
00:32:29.950 --> 00:32:36.023 line:-2 align:center
by passing slope as a generic parameter
to the EnumSubset macro.


472
00:32:43.030 --> 00:32:45.566 line:-1 align:center
Let's see if the tests are now passing.


473
00:32:50.070 --> 00:32:52.673 line:-1 align:center
They are.


474
00:32:52.706 --> 00:32:57.477 line:-2 align:center
I should really consider publishing this
macro to others as a Swift package.


475
00:32:57.511 --> 00:33:00.214 line:-2 align:center
So that's a lot of ground
we covered today.


476
00:33:00,247 --> 00:33:02,983 line:-1
Let's recap what we went through.


477
00:33:03,016 --> 00:33:07,721 line:-2
To create a macro, you can start
with the macro package template,


478
00:33:07.754 --> 00:33:11.892 line:-2 align:center
which includes the stringify macro
as a great starting point.


479
00:33:11,925 --> 00:33:13,961 line:-1
While developing your macro,


480
00:33:13,994 --> 00:33:17,197 line:-2
we highly encourage you
to write test cases


481
00:33:17,231 --> 00:33:21,835 line:-2
to make sure that the code
your macro generates is indeed valid.


482
00:33:21,869 --> 00:33:25,873 line:-2
And if you're doing this, you can inspect
the layout of the syntax tree


483
00:33:25,906 --> 00:33:28,942 line:-2
by setting a breakpoint
in the expansion function,


484
00:33:28.976 --> 00:33:33.547 line:-2 align:center
running a test, and printing
the syntax tree in the debugger.


485
00:33:33,580 --> 00:33:38,051 line:0
And finally, if your macro is not
applicable in certain circumstances,


486
00:33:41,288 --> 00:33:45,893 align:center
so that even if things go wrong,
your macro will shine.


487
00:33:45.926 --> 00:33:50.430 line:-2 align:center
Thanks for watching, and I'm thrilled to
see what kind of macros you will create.

