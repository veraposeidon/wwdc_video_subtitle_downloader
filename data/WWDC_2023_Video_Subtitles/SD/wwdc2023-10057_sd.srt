2
00:00:00,334 --> 00:00:07,341 line:-1
♪ ♪


3
00:00:10,978 --> 00:00:13,947 line:-2
Tyler: Welcome
to "Unleash the UIKit Trait System."


4
00:00:13,981 --> 00:00:16,450 line:-1
I’m Tyler Fox, a UI frameworks engineer,


5
00:00:16,483 --> 00:00:20,320 line:-2
and I’m excited to tell you
about some incredible new UIKit features


6
00:00:20,354 --> 00:00:23,123 line:-1
that you can take advantage of in iOS 17.


7
00:00:23,156 --> 00:00:28,328 line:-2
To start, I’ll review fundamentals
about the trait system in UIKit.


8
00:00:28,362 --> 00:00:31,765 line:-2
Then I’ll guide you
through the new features and capabilities,


9
00:00:31,798 --> 00:00:35,169 line:-2
which include the ability
to define custom traits


10
00:00:35,202 --> 00:00:38,071 line:-1
to add your own data to UITraitCollection,


11
00:00:38,105 --> 00:00:42,109 line:-2
easier ways to apply trait overrides
in your app’s hierarchy,


12
00:00:42,142 --> 00:00:46,313 line:-2
and more flexible ways
to handle when traits change.


13
00:00:46,346 --> 00:00:51,285 line:-2
Finally, I’ll explain how you can bridge
UIKit traits with SwiftUI environment keys


14
00:00:51,318 --> 00:00:57,324 line:-2
to seamlessly pass data between UIKit
and SwiftUI components in your app.


15
00:00:57,357 --> 00:01:00,027 line:-1
It's time to review some fundamentals.


16
00:01:00,060 --> 00:01:05,098 line:-2
Traits are independent pieces of data
that the system automatically propagates


17
00:01:05,132 --> 00:01:08,669 line:-2
to every view controller and view
in your app.


18
00:01:08,702 --> 00:01:11,538 line:-2
UIKit provides
many built-in system traits,


19
00:01:11,572 --> 00:01:15,108 line:-2
such as user interface style,
horizontal size class,


20
00:01:15,142 --> 00:01:18,512 line:-1
and preferred content size category.


21
00:01:18,545 --> 00:01:23,250 line:0
In iOS 17, you can define
your own custom traits as well.


22
00:01:23,283 --> 00:01:26,854 line:0
This unlocks a powerful new way
for you to provide data


23
00:01:26,887 --> 00:01:30,090 line:0
to your app's view controllers and views.


24
00:01:30,123 --> 00:01:34,761 line:0
I'll tell you all about custom traits
a little bit later.


25
00:01:34,795 --> 00:01:39,433 line:-2
The main way that you work with traits
in UIKit is using trait collections.


26
00:01:39,466 --> 00:01:44,304 line:-2
A trait collection contains traits
and their associated values.


27
00:01:44,338 --> 00:01:47,074 line:-1
There are some new APIs in iOS 17


28
00:01:47,107 --> 00:01:50,277 line:-2
that make it easier
to work with trait collections.


29
00:01:50,310 --> 00:01:54,948 line:-2
First, there is a new initializer
that takes a closure.


30
00:01:54,982 --> 00:01:59,319 line:-2
Inside that closure,
you receive a mutable traits container


31
00:01:59,353 --> 00:02:01,822 line:-1
that you can set values to.


32
00:02:01,855 --> 00:02:08,629 line:-2
This mutable container conforms
to a new protocol named UIMutableTraits.


33
00:02:08,662 --> 00:02:12,366 line:-2
Inside the closure,
I set the user interface idiom to phone


34
00:02:12,399 --> 00:02:15,636 line:-1
and the horizontal size class to regular.


35
00:02:15,669 --> 00:02:17,671 line:-1
When the closure finishes executing,


36
00:02:17,704 --> 00:02:22,075 line:-2
the initializer returns
an immutable UITraitCollection instance


37
00:02:22,109 --> 00:02:26,847 line:-2
that contains all of the trait values
I set inside the closure.


38
00:02:26,880 --> 00:02:32,252 line:-2
There’s also a new modifyingTraits method
that allows you to create a new instance


39
00:02:32,286 --> 00:02:37,824 line:-2
by modifying values from the original
trait collection inside the closure.


40
00:02:37,858 --> 00:02:41,895 line:0
Here I’ve changed
the horizontal size class to compact,


41
00:02:41,929 --> 00:02:46,834 line:0
and I've populated a dark value
for the user interface style.


42
00:02:46,867 --> 00:02:49,570 line:0
Since I haven't changed
the user interface idiom,


43
00:02:49,603 --> 00:02:55,242 line:0
it remains equal to phone
from my original trait collection.


44
00:02:55,275 --> 00:02:58,178 line:0
While you can create
your own trait collections like this,


45
00:02:58,212 --> 00:03:03,217 line:0
most of the time you obtain
trait collections from trait environments.


46
00:03:03,250 --> 00:03:06,653 line:0
Trait environments
in your app are window scenes,


47
00:03:06,687 --> 00:03:11,925 line:0
windows, presentation controllers,
view controllers, and views.


48
00:03:11,959 --> 00:03:15,929 line:0
Every one of these trait environments has
its own trait collection,


49
00:03:15,963 --> 00:03:20,567 line:0
and each trait collection may contain
different values.


50
00:03:20,601 --> 00:03:24,204 line:0
Trait environments are connected
in the trait hierarchy,


51
00:03:24,238 --> 00:03:27,307 line:0
which is how traits flow through your app.


52
00:03:27,341 --> 00:03:30,511 line:0
Here's an example
of the trait hierarchy’s tree structure,


53
00:03:30,544 --> 00:03:32,913 line:0
from each window scene all the way down


54
00:03:32,946 --> 00:03:36,316 line:0
to the individual view controllers
and views.


55
00:03:36,350 --> 00:03:41,421 line:0
Each trait environment inherits
trait values from its parent environment.


56
00:03:41,455 --> 00:03:43,123 line:0
Always use the trait collection


57
00:03:43,156 --> 00:03:47,794 line:0
of the most specific
trait environment possible.


58
00:03:47,828 --> 00:03:53,700 line:-2
I'll dive deeper into the way that traits
flow through view controllers and views.


59
00:03:55,002 --> 00:03:57,538 line:-2
Here is an example
of a parent view controller,


60
00:03:57,571 --> 00:04:00,274 line:-1
which contains a child view controller.


61
00:04:00,307 --> 00:04:04,711 line:-2
The dashed line represents
the view controller hierarchy.


62
00:04:04,745 --> 00:04:06,980 line:-1
The parent controller owns a view,


63
00:04:07,014 --> 00:04:11,785 line:-2
and the solid line connecting them
represents their relationship.


64
00:04:11,818 --> 00:04:14,388 line:-1
The parent view has one subview,


65
00:04:14,421 --> 00:04:19,493 line:-2
and the dashed line through the views
represents the view hierarchy.


66
00:04:19,526 --> 00:04:25,532 line:0
Finally, the view of the child controller
is a subview of that middle view.


67
00:04:25,566 --> 00:04:29,403 line:0
First I’ll explain how traits flowed
through view controllers and views


68
00:04:29,436 --> 00:04:33,073 line:0
prior to iOS 17.


69
00:04:33,106 --> 00:04:38,512 line:0
View controllers inherited traits directly
from their parent view controller.


70
00:04:38,545 --> 00:04:41,982 line:0
And views owned by a view controller
inherited their traits


71
00:04:42,015 --> 00:04:45,052 line:0
directly from their view controller.


72
00:04:45,085 --> 00:04:48,989 line:0
Finally, views without a view controller
inherited traits


73
00:04:49,022 --> 00:04:52,025 line:0
directly from their superview.


74
00:04:52,059 --> 00:04:56,163 line:0
This behavior meant that the flow
of traits in the view hierarchy stopped


75
00:04:56,196 --> 00:04:59,066 line:0
at each view owned by a view controller.


76
00:04:59,099 --> 00:05:03,337 line:0
For example, a trait value from the view
of the parent controller


77
00:05:03,370 --> 00:05:07,341 line:0
would only be inherited
by its direct subview.


78
00:05:07,374 --> 00:05:10,878 line:0
The view of the child controller wouldn’t
receive that value,


79
00:05:10,911 --> 00:05:15,883 line:0
even though it is a subview
in the view hierarchy below those views.


80
00:05:15,916 --> 00:05:18,619 line:0
This behavior could be surprising.


81
00:05:18,652 --> 00:05:21,788 line:0
In iOS 17, we’ve eliminated this issue


82
00:05:21,822 --> 00:05:27,694 line:0
by unifying the trait hierarchy
for view controllers and views.


83
00:05:27,728 --> 00:05:32,399 line:0
View controllers now inherit their trait
collection from their view’s superview,


84
00:05:32,432 --> 00:05:35,903 line:0
instead of directly
from their parent view controller.


85
00:05:35,936 --> 00:05:39,072 line:0
This creates a simple linear flow
of traits


86
00:05:39,106 --> 00:05:42,142 line:0
through view controllers and views.


87
00:05:42,176 --> 00:05:46,413 line:0
Note how view controllers still inherit
traits from their parent view controller,


88
00:05:46,446 --> 00:05:50,784 line:0
it just happens indirectly
via the views in between them.


89
00:05:50,817 --> 00:05:55,556 line:-2
Because view controllers now inherit
their traits from the view hierarchy,


90
00:05:55,589 --> 00:05:58,692 line:-2
a view controller’s view must be
in the hierarchy


91
00:05:58,725 --> 00:06:02,262 line:-2
for the view controller
to receive updated traits.


92
00:06:02,296 --> 00:06:05,866 line:-2
As a result, if you access
a view controller’s trait collection


93
00:06:05,899 --> 00:06:08,702 line:-2
before its view has been added
to the hierarchy,


94
00:06:08,735 --> 00:06:12,873 line:-2
the view controller won’t have
up-to-date values for its traits.


95
00:06:12,906 --> 00:06:18,879 line:-2
The most common place you might find code
that is affected is inside viewWillAppear,


96
00:06:18,912 --> 00:06:23,750 line:-2
as that is always called before
the view has been added to the hierarchy.


97
00:06:23,784 --> 00:06:29,156 line:-2
There's a new callback named
viewIsAppearing that you can use instead.


98
00:06:29,189 --> 00:06:32,693 line:-2
viewIsAppearing is called
after viewWillAppear


99
00:06:32,726 --> 00:06:35,362 line:-2
once the view has been added
to the hierarchy


100
00:06:35,395 --> 00:06:40,100 line:-2
and both the view controller and view have
up-to-date trait collections.


101
00:06:40,133 --> 00:06:42,970 line:-1
viewIsAppearing is a drop-in replacement


102
00:06:43,003 --> 00:06:47,641 line:-2
for nearly all cases
where you’re using viewWillAppear today.


103
00:06:47,674 --> 00:06:54,448 line:-2
And the best part is that this new method
back-deploys all the way to iOS 13.


104
00:06:54,481 --> 00:06:58,552 line:0
Watch "What’s New In UIKit"
to learn more about this new callback


105
00:06:58,585 --> 00:07:03,123 line:0
and how it fits
into the view controller life cycle.


106
00:07:03,156 --> 00:07:09,062 line:-2
iOS 17 also improves the consistency
and performance for view trait updates.


107
00:07:09,096 --> 00:07:13,066 line:-2
Views only update their trait collection
when they are in the hierarchy.


108
00:07:13,100 --> 00:07:17,004 line:-2
And once in the hierarchy, each view only
updates its trait collection


109
00:07:17,037 --> 00:07:20,874 line:-1
immediately before it performs layout.


110
00:07:20,908 --> 00:07:24,444 line:-2
The best practice is to use traits
during layout.


111
00:07:24,478 --> 00:07:27,080 line:-2
For views,
that means using the traitCollection


112
00:07:27,114 --> 00:07:31,451 line:-1
from inside the layoutSubviews method.


113
00:07:31,485 --> 00:07:34,054 line:-1
Remember that layoutSubviews runs again


114
00:07:34,087 --> 00:07:37,491 line:-2
any time setNeedsLayout is called
on the view,


115
00:07:37,524 --> 00:07:43,230 line:-2
so your implementation should avoid
duplicating work if called multiple times.


116
00:07:43,263 --> 00:07:48,101 line:-2
Custom traits are a powerful new feature
in iOS 17.


117
00:07:48,135 --> 00:07:51,438 line:-2
They open up an entirely new way
for you to provide data


118
00:07:51,471 --> 00:07:54,474 line:-1
to your view controllers and views.


119
00:07:54,508 --> 00:07:57,878 line:-2
As you work with data in your app,
consider the following things


120
00:07:57,911 --> 00:08:02,382 line:-2
to help you decide
when to define a new custom trait.


121
00:08:02,416 --> 00:08:06,587 line:-2
Traits are a great choice when you need
to propagate data to many children,


122
00:08:06,620 --> 00:08:10,257 line:-2
such as from a parent view controller
to multiple child view controllers


123
00:08:10,290 --> 00:08:13,794 line:-2
or from a superview
to all of its subviews.


124
00:08:13,827 --> 00:08:16,964 line:-2
You can also use traits to pass data
to other components


125
00:08:16,997 --> 00:08:19,299 line:-1
that may be nested many layers deep,


126
00:08:19,333 --> 00:08:22,703 line:-2
where you don’t have
a direct connection to them.


127
00:08:22,736 --> 00:08:25,506 line:-2
Because traits are inherited
through the hierarchy,


128
00:08:25,539 --> 00:08:28,675 line:-2
they can provide context
to your views and view controllers


129
00:08:28,709 --> 00:08:30,210 line:-1
about their environment,


130
00:08:30,244 --> 00:08:34,982 line:-2
such as providing information
about a containing view controller.


131
00:08:35,015 --> 00:08:40,420 line:-2
While the trait system is powerful,
using it to propagate data is not free.


132
00:08:40,454 --> 00:08:43,891 line:-2
For best performance,
use traits when they add value,


133
00:08:43,924 --> 00:08:48,595 line:-2
but avoid using traits
when you can easily pass data directly.


134
00:08:48,629 --> 00:08:51,999 line:-2
Now you're ready to define
your first custom trait.


135
00:08:52,032 --> 00:08:55,402 line:-2
Imagine that I have a Settings screen
in my app,


136
00:08:55,435 --> 00:08:59,173 line:-2
and I want to implement a trait
that indicates whether a view is contained


137
00:08:59,206 --> 00:09:02,075 line:-1
inside my Settings view controller.


138
00:09:02,109 --> 00:09:05,479 line:-2
I can define a custom trait
with just a few lines of code.


139
00:09:06,613 --> 00:09:08,749 line:-1
To start, I declare a new struct


140
00:09:08,782 --> 00:09:12,386 line:-2
and conform
to the UITraitDefinition protocol.


141
00:09:12,419 --> 00:09:17,157 line:-2
I implement the one required
static property, defaultValue.


142
00:09:17,191 --> 00:09:21,962 line:-2
This is the default value for the trait
when no value has been set.


143
00:09:21,995 --> 00:09:25,432 line:-2
Each trait definition has
an associated value type,


144
00:09:25,465 --> 00:09:28,635 line:-1
which is inferred from the defaultValue.


145
00:09:28,669 --> 00:09:32,673 line:-2
In this case, since I am assigning
a defaultValue of false,


146
00:09:32,706 --> 00:09:37,144 line:-2
the type of this trait's values
is inferred to be Bool.


147
00:09:37,177 --> 00:09:41,248 line:-2
If you’ve ever defined a custom
environment key in SwiftUI before,


148
00:09:41,281 --> 00:09:44,985 line:-1
this should feel very familiar.


149
00:09:45,018 --> 00:09:49,056 line:-2
Once you’ve defined a trait,
you can immediately use it with new APIs


150
00:09:49,089 --> 00:09:52,893 line:-1
on UITraitCollection and UIMutableTraits.


151
00:09:52,926 --> 00:09:58,599 line:-2
You can think of the trait as a key
that you use to get and set values.


152
00:09:58,632 --> 00:10:01,802 line:-2
Inside the new
UITraitCollection initializer,


153
00:10:01,835 --> 00:10:08,242 line:-2
I can set a value for my trait by using
the subscript operator on UIMutableTraits.


154
00:10:08,275 --> 00:10:10,911 line:-2
And then I can read back
the value for the trait


155
00:10:10,944 --> 00:10:15,682 line:-2
by using the subscript operator
on UITraitCollection.


156
00:10:15,716 --> 00:10:19,119 line:-2
Adding two simple extensions will
let me access this trait


157
00:10:19,152 --> 00:10:24,024 line:-2
using standard property syntax,
just like all of the system traits.


158
00:10:24,057 --> 00:10:26,693 line:-1
Here I’ve declared a read-only property


159
00:10:26,727 --> 00:10:31,064 line:-2
in an extension
of the immutable UITraitCollection class.


160
00:10:31,098 --> 00:10:33,600 line:-2
And then I’ve declared
a read-write property


161
00:10:33,634 --> 00:10:37,971 line:-2
in an extension
of the UIMutableTraits protocol.


162
00:10:38,005 --> 00:10:40,674 line:0
Now that I’ve added
these very simple extensions,


163
00:10:40,707 --> 00:10:46,180 line:0
I can use standard property syntax
to access my trait everywhere.


164
00:10:46,213 --> 00:10:52,052 line:0
Always write these extensions
when you define your own custom traits.


165
00:10:52,085 --> 00:10:55,689 line:-1
I have an idea for another custom trait.


166
00:10:55,722 --> 00:10:59,960 line:-2
Imagine I'm building support
for custom color themes in my app.


167
00:10:59,993 --> 00:11:02,996 line:-1
I have an enum named MyAppTheme


168
00:11:03,030 --> 00:11:08,001 line:-2
that represents the four different
color themes my app supports.


169
00:11:08,035 --> 00:11:11,071 line:-2
The first thing I’ll do is declare
a new struct


170
00:11:11,104 --> 00:11:15,442 line:-2
which conforms
to the UITraitDefinition protocol.


171
00:11:15,475 --> 00:11:20,814 line:-2
I’ll use the standard theme
as the default value for this trait.


172
00:11:20,848 --> 00:11:25,752 line:-2
Since I plan to use this new theme trait
in my app’s custom dynamic colors,


173
00:11:25,786 --> 00:11:28,689 line:-2
I indicate that this trait affects
color appearance,


174
00:11:28,722 --> 00:11:34,528 line:-2
and the system will automatically
redraw views when this trait changes.


175
00:11:34,561 --> 00:11:37,531 line:-2
Traits that affect color appearance
are much more expensive,


176
00:11:37,564 --> 00:11:43,003 line:-2
so use this sparingly and only for traits
that change infrequently.


177
00:11:43,036 --> 00:11:45,572 line:-2
Traits also have a name,
which is used for things


178
00:11:45,606 --> 00:11:48,709 line:-1
like printing the trait in the debugger.


179
00:11:48,742 --> 00:11:52,045 line:-2
By default, it will use the name
of the trait type itself,


180
00:11:52,079 --> 00:11:55,516 line:-2
but I can give it a shorter name,
like “Theme.”


181
00:11:55,549 --> 00:11:59,186 line:-2
And finally,
I can provide an identifier string.


182
00:11:59,219 --> 00:12:04,458 line:-2
The identifier makes the trait eligible
for additional features such as encoding.


183
00:12:04,491 --> 00:12:06,493 line:-1
Use reverse-DNS format


184
00:12:06,527 --> 00:12:10,964 line:-2
to ensure each trait's identifier
is globally unique in your app.


185
00:12:12,966 --> 00:12:17,671 line:0
I want to be able to use regular
property syntax to set and get this trait,


186
00:12:17,704 --> 00:12:22,242 line:0
so I’ll extend UITraitCollection
and UIMutableTraits to declare a property,


187
00:12:22,276 --> 00:12:25,712 line:0
just as I did before
in the previous example.


188
00:12:25,746 --> 00:12:29,650 line:-2
And that’s all I need to do
to implement a custom theme trait.


189
00:12:29,683 --> 00:12:32,152 line:-1
Now I can start using this new trait.


190
00:12:32,186 --> 00:12:36,356 line:-2
For example, here is how to define
a custom dynamic color


191
00:12:36,390 --> 00:12:40,327 line:-2
that changes its appearance
based on the theme.


192
00:12:40,360 --> 00:12:45,799 line:-2
I create a new UIColor
using the dynamic provider initializer.


193
00:12:45,832 --> 00:12:48,902 line:-2
Inside the closure,
I use the theme of the trait collection


194
00:12:48,936 --> 00:12:54,241 line:-2
that gets passed in
to determine which color to return.


195
00:12:54,274 --> 00:12:58,078 line:-2
Now I can set this custom background color
to a view.


196
00:12:58,111 --> 00:13:00,981 line:-2
Because I indicated
that this trait affects color appearance


197
00:13:01,014 --> 00:13:04,985 line:-2
when I defined it, any views using
this custom background color


198
00:13:05,018 --> 00:13:08,522 line:-2
will automatically update
when the theme changes.


199
00:13:08,555 --> 00:13:12,426 line:-2
When defining a trait,
the most important thing to consider


200
00:13:12,459 --> 00:13:16,196 line:-2
is the associated data type
of the trait’s values.


201
00:13:16,230 --> 00:13:18,665 line:-2
The best traits are built
around value types,


202
00:13:18,699 --> 00:13:21,935 line:-1
including simple structs and enums.


203
00:13:21,969 --> 00:13:26,206 line:-2
Avoid traits that are based
around classes in Swift.


204
00:13:26,240 --> 00:13:31,478 line:-2
The most efficient data types
for traits are Bool, Int, and Double,


205
00:13:31,512 --> 00:13:35,782 line:-1
or an enum that uses an Int raw value.


206
00:13:35,816 --> 00:13:38,952 line:-2
Enums are one of the most useful
data types for traits.


207
00:13:38,986 --> 00:13:43,724 line:-2
Just make sure to explicitly specify Int
as the enum's raw data type


208
00:13:43,757 --> 00:13:47,060 line:-1
for maximum efficiency.


209
00:13:47,094 --> 00:13:50,964 line:0
Any custom struct data types
that you use as trait values should have


210
00:13:50,998 --> 00:13:54,935 line:0
an efficient implementation
of the Equatable protocol.


211
00:13:54,968 --> 00:13:57,571 line:0
The system will compare trait values
frequently


212
00:13:57,604 --> 00:13:59,873 line:0
to determine when traits have changed,


213
00:13:59,907 --> 00:14:03,510 line:0
so your equal-to function should be
as fast as possible.


214
00:14:05,512 --> 00:14:08,382 line:-2
For those of you with apps
that use Objective-C,


215
00:14:08,415 --> 00:14:12,052 line:-2
the new trait system functionality
is available there as well.


216
00:14:12,085 --> 00:14:17,157 line:-2
The API for custom traits is different
in Swift and Objective-C.


217
00:14:17,191 --> 00:14:22,362 line:-2
However, you can define one custom trait
in Swift and one in Objective-C,


218
00:14:22,396 --> 00:14:26,466 line:-2
and have both point
to the same underlying data.


219
00:14:26,500 --> 00:14:31,205 line:-2
Refer to the documentation for more
details and special considerations.


220
00:14:32,172 --> 00:14:34,007 line:-1
Once you’ve defined a custom trait,


221
00:14:34,041 --> 00:14:38,212 line:-2
the next step is to populate some data
for it in your app's trait hierarchy.


222
00:14:39,379 --> 00:14:45,385 line:-2
Trait overrides are the mechanism you use
to modify data within the trait hierarchy.


223
00:14:45,419 --> 00:14:50,290 line:-2
In iOS 17, it’s easier than ever
to apply trait overrides.


224
00:14:50,324 --> 00:14:54,995 line:-2
There’s a new traitOverrides property
on each of the trait environment classes,


225
00:14:55,028 --> 00:14:58,498 line:-1
including window scenes, windows, views,


226
00:14:58,532 --> 00:15:01,869 line:-2
view controllers,
and presentation controllers.


227
00:15:01,902 --> 00:15:05,038 line:-2
Going back to the illustration
of the trait hierarchy,


228
00:15:05,072 --> 00:15:10,577 line:-2
trait overrides change the value
for traits at any location in this tree.


229
00:15:10,611 --> 00:15:14,748 line:-2
When you apply a trait override to one of
the trait environments in this hierarchy,


230
00:15:14,781 --> 00:15:19,453 line:-2
it modifies the value for that trait
in the trait collection of that object


231
00:15:19,486 --> 00:15:21,455 line:-1
and all of its descendants.


232
00:15:21,488 --> 00:15:26,193 line:0
Taking a parent and child trait
environment from the trait hierarchy,


233
00:15:26,226 --> 00:15:29,596 line:0
here’s how trait overrides affect both.


234
00:15:29,630 --> 00:15:34,535 line:0
Trait overrides applied to the parent
affect the parent’s own trait collection.


235
00:15:34,568 --> 00:15:37,237 line:0
And then the values
from the parent’s trait collection


236
00:15:37,271 --> 00:15:40,073 line:0
are inherited to the child.


237
00:15:40,107 --> 00:15:45,245 line:0
Finally, the child's trait overrides
are applied to the values it inherited


238
00:15:45,279 --> 00:15:48,916 line:0
to produce its own trait collection.


239
00:15:48,949 --> 00:15:52,119 line:-2
Think of trait overrides
as optional inputs,


240
00:15:52,152 --> 00:15:54,688 line:-1
and the trait collection as the output.


241
00:15:54,721 --> 00:15:58,959 line:-2
Any traits without overrides will inherit
from the parent.


242
00:15:58,992 --> 00:16:01,328 line:-2
I’ll go through an example
of using trait overrides


243
00:16:01,361 --> 00:16:04,798 line:-2
to change the color theme
for specific parts of my app.


244
00:16:04,831 --> 00:16:09,670 line:-2
On the right, I have an illustration
of my app’s trait hierarchy.


245
00:16:09,703 --> 00:16:14,942 line:-2
Initially, I haven’t applied any overrides
to populate the value for my theme trait,


246
00:16:14,975 --> 00:16:18,145 line:-2
so all of these trait collections have
the default value,


247
00:16:18,178 --> 00:16:20,614 line:-1
which is the standard theme.


248
00:16:20,647 --> 00:16:23,951 line:-2
I’ll start by applying a trait override
to the root of this hierarchy


249
00:16:23,984 --> 00:16:27,054 line:-1
on the window scene.


250
00:16:27,087 --> 00:16:31,358 line:-2
The traitOverrides property leverages
the UIMutableTraits protocol


251
00:16:31,391 --> 00:16:34,494 line:-1
to allow you to easily set trait values.


252
00:16:34,528 --> 00:16:38,198 line:-2
Therefore, you can set override values
for custom traits


253
00:16:38,232 --> 00:16:40,067 line:-1
with standard property syntax


254
00:16:40,100 --> 00:16:44,838 line:-2
using the extension to UIMutableTraits
I explained earlier.


255
00:16:44,872 --> 00:16:49,376 line:-2
By setting the theme to pastel on
the trait overrides of the window scene,


256
00:16:49,409 --> 00:16:53,914 line:-2
all of the windows, view controllers,
and views inside of that window scene


257
00:16:53,947 --> 00:16:57,751 line:-2
now inherit the pastel value
in their trait collections.


258
00:16:57,784 --> 00:17:01,455 line:-2
So by setting the theme in one place
at the root of the hierarchy,


259
00:17:01,488 --> 00:17:03,824 line:-2
I’ve changed the base value
that gets propagated


260
00:17:03,857 --> 00:17:06,493 line:-1
to everything in that hierarchy.


261
00:17:06,527 --> 00:17:09,463 line:-2
For example, I can read the theme
from the trait collection


262
00:17:09,496 --> 00:17:12,399 line:-2
of any view controller
inside that window scene


263
00:17:12,432 --> 00:17:15,936 line:-1
and get back pastel.


264
00:17:15,969 --> 00:17:21,108 line:-2
Then I can use the traitOverrides property
on a view deeper in the hierarchy


265
00:17:21,141 --> 00:17:25,479 line:-2
to modify the theme for that view
and anything below it.


266
00:17:25,512 --> 00:17:30,417 line:-2
Here I’m setting a monochrome theme
trait override for this view.


267
00:17:30,450 --> 00:17:34,354 line:0
So this monochrome value is what
is inherited by its subview,


268
00:17:34,388 --> 00:17:38,825 line:0
overriding the pastel value
from higher up in the hierarchy.


269
00:17:38,859 --> 00:17:42,296 line:-2
You may not see changes
to trait overrides reflected immediately


270
00:17:42,329 --> 00:17:43,897 line:-1
in the trait collection.


271
00:17:43,931 --> 00:17:48,435 line:-2
For example, because views update their
trait collection right before layout,


272
00:17:48,468 --> 00:17:53,407 line:-2
modifications to a view’s trait overrides
aren't reflected in its trait collection


273
00:17:53,440 --> 00:17:57,711 line:-1
until just before it runs layoutSubviews.


274
00:17:57,744 --> 00:18:00,414 line:-2
The traitOverrides property
also allows you to check


275
00:18:00,447 --> 00:18:04,184 line:-2
whether overrides are applied
and remove overrides altogether.


276
00:18:04,218 --> 00:18:07,588 line:-1
Here is an example of toggling an override


277
00:18:07,621 --> 00:18:11,792 line:-2
by using the contains method
to check if an override exists,


278
00:18:11,825 --> 00:18:15,762 line:-2
and the remove method
to remove the override entirely.


279
00:18:15,796 --> 00:18:17,631 line:-1
Each time this method is called,


280
00:18:17,664 --> 00:18:20,567 line:-2
it will either remove
the existing override


281
00:18:20,601 --> 00:18:25,939 line:-2
or apply a new theme override
when there wasn't one already.


282
00:18:25,973 --> 00:18:29,710 line:-2
Trait overrides are an input mechanism
to set values.


283
00:18:29,743 --> 00:18:34,014 line:-2
To read trait values,
always use the traitCollection property.


284
00:18:34,047 --> 00:18:37,684 line:-2
Reading from traitOverrides
when no override has been set


285
00:18:37,718 --> 00:18:39,353 line:-1
will raise an exception.


286
00:18:41,355 --> 00:18:43,023 line:-1
Here are some performance considerations


287
00:18:43,056 --> 00:18:45,926 line:-2
to keep in mind
as you use trait overrides.


288
00:18:45,959 --> 00:18:49,363 line:-2
First, each trait override
has a small cost,


289
00:18:49,396 --> 00:18:52,466 line:-2
so only set trait overrides
on the places you need them


290
00:18:52,499 --> 00:18:55,836 line:-2
and avoid setting trait overrides
that aren’t used.


291
00:18:55,869 --> 00:18:58,172 line:-2
And every time you change
a trait override,


292
00:18:58,205 --> 00:19:00,641 line:-2
the system needs
to update the trait collection


293
00:19:00,674 --> 00:19:03,510 line:-1
of any descendants in the hierarchy.


294
00:19:03,544 --> 00:19:08,582 line:-2
Therefore, minimize the number of times
that you change trait overrides.


295
00:19:08,615 --> 00:19:12,452 line:-2
Finally, trait overrides applied
near the root of the hierarchy,


296
00:19:12,486 --> 00:19:17,257 line:-2
such as on the window scene or window,
affect everything beneath them.


297
00:19:17,291 --> 00:19:20,093 line:-2
This is very useful,
and there are many great use cases


298
00:19:20,127 --> 00:19:24,097 line:-2
for applying trait overrides
to the window scene or window.


299
00:19:24,131 --> 00:19:29,536 line:-2
However, when a trait only affects
a few views deep in the hierarchy,


300
00:19:29,570 --> 00:19:32,573 line:-2
then apply the trait override
to the nearest common ancestor


301
00:19:32,606 --> 00:19:37,644 line:-2
of those views instead, such as
a common superview or a view controller.


302
00:19:37,678 --> 00:19:39,546 line:-1
That way, you aren’t paying the cost


303
00:19:39,580 --> 00:19:42,583 line:-2
of propagating the trait
to your entire hierarchy


304
00:19:42,616 --> 00:19:47,421 line:-2
when only a small portion
of the hierarchy uses that data.


305
00:19:47,454 --> 00:19:49,423 line:-1
Now that you know how to define traits


306
00:19:49,456 --> 00:19:51,859 line:-2
and populate data for them
in the hierarchy,


307
00:19:51,892 --> 00:19:54,728 line:-1
you need to handle when they change value.


308
00:19:56,029 --> 00:20:00,234 line:-2
traitCollectionDidChange is deprecated
in iOS 17.


309
00:20:00,267 --> 00:20:02,636 line:-2
When you implement
traitCollectionDidChange,


310
00:20:02,669 --> 00:20:06,006 line:-2
the system doesn’t know
which traits you actually care about,


311
00:20:06,039 --> 00:20:11,478 line:-2
so it has to call that method
every time that any trait changes value.


312
00:20:11,512 --> 00:20:15,449 line:-2
However, most classes only use
a handful of traits


313
00:20:15,482 --> 00:20:18,385 line:-2
and don’t care about changes
to any others.


314
00:20:18,418 --> 00:20:21,822 line:-2
This is why
traitCollectionDidChange doesn’t scale


315
00:20:21,855 --> 00:20:25,893 line:-1
as you add more and more custom traits.


316
00:20:25,926 --> 00:20:29,630 line:-2
In its place,
there are new trait registration APIs


317
00:20:29,663 --> 00:20:32,966 line:-2
that are more flexible
and improve performance.


318
00:20:33,000 --> 00:20:35,903 line:-2
By registering for changes
to specific traits,


319
00:20:35,936 --> 00:20:40,073 line:-2
the system knows exactly
which traits you depend on.


320
00:20:40,107 --> 00:20:42,776 line:-2
The new APIs allow you
to receive callbacks


321
00:20:42,809 --> 00:20:46,513 line:-2
using the target-action pattern
or a closure.


322
00:20:46,547 --> 00:20:50,217 line:-2
And because you no longer need
to override a method in your subclass,


323
00:20:50,250 --> 00:20:54,688 line:-2
it’s now easy to observe trait changes
from anywhere.


324
00:20:54,721 --> 00:20:56,924 line:-1
I'll start by explaining how to update


325
00:20:56,957 --> 00:21:00,060 line:-2
an existing implementation
of traitCollectionDidChange.


326
00:21:00,093 --> 00:21:02,729 line:-1
Here’s my existing implementation.


327
00:21:02,763 --> 00:21:06,033 line:-2
Note how I check whether
the horizontalSizeClass trait changed


328
00:21:06,066 --> 00:21:08,302 line:-1
before calling updateViews,


329
00:21:08,335 --> 00:21:12,005 line:-2
as that method only relies
on this one trait.


330
00:21:12,039 --> 00:21:15,142 line:-2
If you need to keep using
traitCollectionDidChange


331
00:21:15,175 --> 00:21:18,579 line:-2
because you are deploying your app
to older iOS versions,


332
00:21:18,612 --> 00:21:20,447 line:-1
make sure that your implementation checks


333
00:21:20,480 --> 00:21:24,718 line:-2
whether the specific traits
that you care about have changed.


334
00:21:24,751 --> 00:21:26,753 line:-1
Now I'll replace this implementation


335
00:21:26,787 --> 00:21:31,692 line:-2
with the new trait registration methods
in iOS 17.


336
00:21:31,725 --> 00:21:33,961 line:-1
I'll start with the closure-based method.


337
00:21:33,994 --> 00:21:39,233 line:-2
I call registerForTraitChanges and pass
an array of traits to register for.


338
00:21:39,266 --> 00:21:43,303 line:-2
There are new UITrait symbols
for all of the system traits,


339
00:21:43,337 --> 00:21:46,907 line:-2
such as this one
for horizontal size class.


340
00:21:46,940 --> 00:21:52,012 line:-2
Then I pass a closure that is called
when those specific traits change.


341
00:21:52,045 --> 00:21:55,749 line:-2
The closure is not called
for changes to any other traits,


342
00:21:55,782 --> 00:22:00,687 line:-2
so there's no need to compare old
and new trait values here.


343
00:22:00,721 --> 00:22:02,823 line:-2
The object whose traits have changed
is passed


344
00:22:02,856 --> 00:22:05,759 line:-1
as the first parameter to the closure.


345
00:22:05,792 --> 00:22:08,295 line:-2
Use this parameter
so you don’t have to capture


346
00:22:08,328 --> 00:22:11,565 line:-1
a weak reference to that object.


347
00:22:11,598 --> 00:22:14,468 line:-2
When you're registering
for trait changes on self,


348
00:22:14,501 --> 00:22:19,473 line:-1
always write "self: Self" here.


349
00:22:19,506 --> 00:22:24,244 line:-2
You can also observe trait changes
for a different trait environment.


350
00:22:24,278 --> 00:22:27,281 line:-2
Here I'm registering for changes
to two traits,


351
00:22:27,314 --> 00:22:28,916 line:-1
the horizontal size class


352
00:22:28,949 --> 00:22:33,921 line:-2
and the ContainedInSettings custom trait
I defined earlier.


353
00:22:33,954 --> 00:22:39,726 line:-2
The closure executes when either
of these traits change on this other view.


354
00:22:39,760 --> 00:22:42,262 line:-2
I write the type of the view
I'm registering on


355
00:22:42,296 --> 00:22:45,265 line:-1
as the first parameter of the closure.


356
00:22:47,267 --> 00:22:51,138 line:-2
Here's an example of the new
target-action-based method.


357
00:22:51,171 --> 00:22:55,843 line:-2
Call registerForTraitChanges and pass
an array of traits to register for


358
00:22:55,876 --> 00:23:00,013 line:-2
as well as the target and action method
to call on changes.


359
00:23:00,047 --> 00:23:02,249 line:-1
The target parameter is optional.


360
00:23:02,282 --> 00:23:05,419 line:-2
If you omit it,
the target will be the same object


361
00:23:05,452 --> 00:23:08,355 line:-1
that registerForTraitChanges is called on.


362
00:23:08,388 --> 00:23:11,692 line:-1
In this case, that's self.


363
00:23:11,725 --> 00:23:15,162 line:-2
As with the closure method,
you can also register for changes


364
00:23:15,195 --> 00:23:17,731 line:-1
on other trait environments.


365
00:23:17,764 --> 00:23:21,034 line:-2
Here I’m registering for trait changes
on another view,


366
00:23:21,068 --> 00:23:26,807 line:-2
but setting up a call to a method on self
named handleTraitChange.


367
00:23:26,840 --> 00:23:30,377 line:0
When registering for trait changes
using a target-action,


368
00:23:30,410 --> 00:23:36,216 line:0
your action method can have zero,
one, or two parameters.


369
00:23:36,250 --> 00:23:40,387 line:0
The first parameter is always the object
whose traits are changing.


370
00:23:40,420 --> 00:23:44,892 line:0
Use this parameter
to get the new traitCollection.


371
00:23:44,925 --> 00:23:48,395 line:0
The second parameter will always be
the previous trait collection


372
00:23:48,428 --> 00:23:52,366 line:0
for that object before the change.


373
00:23:52,399 --> 00:23:55,702 line:-2
In addition to registering
for individual traits,


374
00:23:55,736 --> 00:24:00,040 line:-2
you can also register
using new semantic sets of system traits.


375
00:24:00,073 --> 00:24:04,211 line:-2
For example, there is
systemTraitsAffectingColorAppearance,


376
00:24:04,244 --> 00:24:06,880 line:-2
which returns any system traits
that may affect


377
00:24:06,914 --> 00:24:10,517 line:-1
the way system dynamic colors resolve.


378
00:24:10,551 --> 00:24:13,654 line:-2
There’s also
systemTraitsAffectingImageLookup,


379
00:24:13,687 --> 00:24:16,790 line:-2
which returns the subset of system traits
that are considered


380
00:24:16,823 --> 00:24:20,827 line:-2
when you load an image using
UIImage(named:).


381
00:24:20,861 --> 00:24:24,431 line:-2
Pass either of these sets directly
to registerForTraitChanges


382
00:24:24,464 --> 00:24:26,733 line:-1
to perform custom invalidation.


383
00:24:28,735 --> 00:24:30,671 line:-1
Registrations are cleaned up automatically


384
00:24:30,704 --> 00:24:34,708 line:-2
when you use the new methods
to register for trait changes.


385
00:24:34,741 --> 00:24:38,612 line:0
If you have an advanced use case,
you can manually unregister


386
00:24:38,645 --> 00:24:42,983 line:0
using a token that is returned
by each of the registration methods.


387
00:24:43,016 --> 00:24:44,818 line:0
But these cases are very rare,


388
00:24:44,852 --> 00:24:47,621 line:0
so generally you should just ignore
the return value


389
00:24:47,654 --> 00:24:51,024 line:0
when you call registerForTraitChanges.


390
00:24:51,058 --> 00:24:53,994 line:-2
As you adopt the new
trait registration APIs,


391
00:24:54,027 --> 00:24:56,763 line:-2
there are two best practices
to keep in mind.


392
00:24:56,797 --> 00:25:00,534 line:-2
First, register only for the traits
that you actually depend on


393
00:25:00,567 --> 00:25:04,838 line:-2
so you don't perform work
when unrelated traits change value.


394
00:25:04,872 --> 00:25:08,475 line:-2
Finally, try to invalidate
in response to trait changes


395
00:25:08,509 --> 00:25:10,644 line:-1
without updating immediately.


396
00:25:10,677 --> 00:25:14,348 line:-2
For example, if you use traits
inside of the layoutSubviews method


397
00:25:14,381 --> 00:25:19,853 line:-2
of a view subclass, call setNeedsLayout
to invalidate for a trait change.


398
00:25:19,887 --> 00:25:22,523 line:-2
This schedules the view
to receive layoutSubviews,


399
00:25:22,556 --> 00:25:25,058 line:-2
but doesn’t perform the update
immediately.


400
00:25:25,092 --> 00:25:29,396 line:-2
Now that you can propagate your own data
using the trait system in UIKit,


401
00:25:29,429 --> 00:25:33,534 line:-2
it unlocks an entirely new way
for you to seamlessly pass data


402
00:25:33,567 --> 00:25:37,204 line:-2
between UIKit and SwiftUI components
in your app.


403
00:25:37,237 --> 00:25:43,310 line:-2
Custom traits in UIKit are very similar
to custom environment keys in SwiftUI.


404
00:25:43,343 --> 00:25:48,949 line:-2
You can bridge them to access
the same data from both UIKit and SwiftUI.


405
00:25:48,982 --> 00:25:52,553 line:-2
Whether you’re embedding
SwiftUI components inside of UIKit,


406
00:25:52,586 --> 00:25:55,322 line:-1
or UIKit components inside of SwiftUI,


407
00:25:55,355 --> 00:25:58,992 line:-2
bridged data passes seamlessly
between them.


408
00:25:59,026 --> 00:26:02,262 line:-2
You can read and write
to the same underlying data


409
00:26:02,296 --> 00:26:04,865 line:-1
using the trait APIs in your UIKit code


410
00:26:04,898 --> 00:26:08,869 line:-2
and the environment APIs
in your SwiftUI code.


411
00:26:08,902 --> 00:26:12,639 line:-2
It’s incredibly easy to take
the new color theme trait


412
00:26:12,673 --> 00:26:14,975 line:-1
I defined for my app’s UIKit code


413
00:26:15,008 --> 00:26:18,545 line:-2
and bridge it to a corresponding
environment key in SwiftUI.


414
00:26:19,646 --> 00:26:24,418 line:-2
Assuming I have a custom trait in UIKit
and a custom environment key in SwiftUI


415
00:26:24,451 --> 00:26:26,787 line:-1
that represent the same data,


416
00:26:26,820 --> 00:26:29,623 line:-2
all I need to do to bridge them
is add a conformance


417
00:26:29,656 --> 00:26:33,493 line:-2
to the UITraitBridgedEnvironmentKey
protocol.


418
00:26:33,527 --> 00:26:35,929 line:0
To do this, I implement one method


419
00:26:35,963 --> 00:26:40,167 line:0
to read the trait from UIKit
and return the value to SwiftUI,


420
00:26:40,200 --> 00:26:46,206 line:0
and one method to write the SwiftUI
environment value to the UIKit trait.


421
00:26:46,240 --> 00:26:52,346 line:0
And now both the UIKit trait and SwiftUI
environment key access unified storage,


422
00:26:52,379 --> 00:26:55,282 line:0
so I can read or write to the same data


423
00:26:55,315 --> 00:26:59,820 line:0
from components written
using either framework.


424
00:26:59,853 --> 00:27:04,691 line:-2
Here is an example of how I can use
the bridged trait and environment key.


425
00:27:04,725 --> 00:27:08,996 line:-2
At the root of my app, I apply
a trait override for the theme trait


426
00:27:09,029 --> 00:27:12,032 line:-1
onto the UIKit window scene.


427
00:27:12,065 --> 00:27:14,701 line:-1
This propagates the monochrome theme value


428
00:27:14,735 --> 00:27:18,572 line:-2
to everything contained
inside that window scene.


429
00:27:18,605 --> 00:27:22,176 line:-2
Then, deeper down inside of a window
in that window scene,


430
00:27:22,209 --> 00:27:24,778 line:-1
I have a UIKit collection view.


431
00:27:24,811 --> 00:27:26,947 line:-1
This collection view contains cells,


432
00:27:26,980 --> 00:27:30,217 line:-2
which are configured
using UIHostingConfiguration,


433
00:27:30,250 --> 00:27:34,188 line:-1
to display a SwiftUI view in each cell.


434
00:27:34,221 --> 00:27:38,325 line:0
Inside the SwiftUI CellView,
I have a property named "theme,"


435
00:27:38,358 --> 00:27:40,961 line:0
which uses
the Environment property wrapper


436
00:27:40,994 --> 00:27:44,598 line:0
to read the value
from the SwiftUI environment.


437
00:27:44,631 --> 00:27:48,202 line:0
The value in the environment corresponds
to the same value


438
00:27:48,235 --> 00:27:51,638 line:0
for the bridged trait in UIKit.


439
00:27:51,672 --> 00:27:55,275 line:0
And finally, I use the theme property
to control the color of text


440
00:27:55,309 --> 00:27:58,078 line:0
inside this SwiftUI view.


441
00:27:58,111 --> 00:28:01,882 line:-2
Because SwiftUI automatically tracks
data dependencies,


442
00:28:01,915 --> 00:28:06,386 line:-2
if the theme trait override all the way up
on the UIKit window scene changes


443
00:28:06,420 --> 00:28:11,358 line:-2
to a different value, my SwiftUI cell view
will automatically update


444
00:28:11,391 --> 00:28:14,528 line:-1
to reflect the new theme.


445
00:28:14,561 --> 00:28:17,397 line:-2
The bridging also works
in the other direction.


446
00:28:17,431 --> 00:28:22,469 line:-2
Here I have a SwiftUI view
that displays my app’s settings.


447
00:28:22,503 --> 00:28:25,973 line:-2
I use the environment modifier
to set the standard theme,


448
00:28:26,006 --> 00:28:30,244 line:-2
which will apply to everything
in the settings controller.


449
00:28:30,277 --> 00:28:35,749 line:-2
This is conceptually equivalent
to applying a trait override in UIKit.


450
00:28:35,782 --> 00:28:38,852 line:-2
Then, in the UIKit-based
Settings view controller


451
00:28:38,886 --> 00:28:42,656 line:-2
contained inside
the UIViewControllerRepresentable,


452
00:28:42,689 --> 00:28:45,859 line:-2
I read the theme value
from the bridged trait


453
00:28:45,893 --> 00:28:50,230 line:-2
and use it to update the title displayed
for this view controller.


454
00:28:50,264 --> 00:28:53,333 line:-2
This is how easy it is
to seamlessly access data


455
00:28:53,367 --> 00:28:57,971 line:-2
using bridged UIKit traits
and SwiftUI environment keys.


456
00:28:58,005 --> 00:29:01,375 line:-2
Now that you've learned
about these powerful new features,


457
00:29:01,408 --> 00:29:04,945 line:-2
go and find places in your app
where you can leverage the trait system


458
00:29:04,978 --> 00:29:10,918 line:-2
to automatically propagate data
by defining your own custom traits.


459
00:29:10,951 --> 00:29:14,087 line:-2
Next, adopt the new
traitOverrides property


460
00:29:14,121 --> 00:29:17,257 line:-2
to easily modify data
in the trait hierarchy.


461
00:29:17,291 --> 00:29:21,094 line:-2
And then use the more flexible
trait registration APIs


462
00:29:21,128 --> 00:29:25,732 line:-2
to create precise dependencies
on the exact traits you use.


463
00:29:25,766 --> 00:29:30,771 line:-2
Finally, bridge your custom UIKit traits
with custom SwiftUI environment keys


464
00:29:30,804 --> 00:29:36,476 line:-2
so that your data flows seamlessly between
UIKit and SwiftUI components in your app.


465
00:29:36,510 --> 00:29:41,048 line:-2
Now it’s up to you
to unleash the power of traits.


466
00:29:41,081 --> 00:29:42,983 line:-1
Thanks for watching.


467
00:29:43,016 --> 00:29:45,152 line:-1
♪ ♪

