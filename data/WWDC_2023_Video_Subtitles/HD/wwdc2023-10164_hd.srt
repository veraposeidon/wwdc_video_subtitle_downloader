2
00:00:00.334 --> 00:00:06.340 line:-1 align:center
♪ ♪


3
00:00:10,511 --> 00:00:14,014 line:-2
Ben: Hi, and welcome
to "What's New in Swift 5.9."


4
00:00:14.047 --> 00:00:16.049 line:-2 align:center
I'm Ben,
and together with my colleague Doug,


5
00:00:16.083 --> 00:00:17.651 line:-2 align:center
we'll take you through some
of the improvements


6
00:00:17,684 --> 00:00:19,286 line:-1
to the Swift language this year.


7
00:00:19.319 --> 00:00:23.223 line:-2 align:center
We'll talk about some ways
it's easier to express what you mean


8
00:00:23,257 --> 00:00:27,394 line:-2
using Swift's clean syntax,
some powerful new features


9
00:00:27,427 --> 00:00:32,299 line:-2
that help framework authors
make their new APIs more natural to use,


10
00:00:32.332 --> 00:00:36.570 line:-2 align:center
and we'll look at some new ways
to get more control over performance


11
00:00:36,603 --> 00:00:39,306 line:-1
and safety in low-level code.


12
00:00:40,274 --> 00:00:44,578 line:-2
But let's start by talking
about the Swift open source project.


13
00:00:44,611 --> 00:00:47,881 line:-2
This is a great update for Swift,
and it couldn't have happened


14
00:00:47.915 --> 00:00:49.683 line:-1 align:center
without the Swift community,


15
00:00:49.716 --> 00:00:52.219 line:-2 align:center
the contributors
and users of the language


16
00:00:52.252 --> 00:00:56.356 line:-2 align:center
who gather at swift.org,
working together to evolve the language


17
00:00:56,390 --> 00:00:59,092 line:-1
and support new initiatives.


18
00:00:59.126 --> 00:01:02.896 line:-2 align:center
Swift follows an open process
for language evolution.


19
00:01:02,930 --> 00:01:06,033 line:-2
New features or significant
behavior changes are proposed


20
00:01:06,066 --> 00:01:09,403 line:-2
and reviewed
in the open on the Swift forums.


21
00:01:09.436 --> 00:01:12.105 line:-2 align:center
If you want to follow along,
you can find a dashboard


22
00:01:12,139 --> 00:01:15,409 line:-2
of all the language proposals
on the Swift website.


23
00:01:16.276 --> 00:01:18.645 line:-2 align:center
A year ago,
we saw a significant restructuring


24
00:01:18,679 --> 00:01:20,747 line:-1
of the Swift Project governance.


25
00:01:20,781 --> 00:01:24,184 line:-2
The core team announced the formation
of the Language Steering Group,


26
00:01:24,218 --> 00:01:28,021 line:-2
which took on primary responsibility
for oversight of the Swift language


27
00:01:28,055 --> 00:01:30,591 line:-1
and standard library evolution.


28
00:01:30,624 --> 00:01:32,860 line:-2
Since then,
the language group has overseen


29
00:01:32,893 --> 00:01:34,761 line:-1
40 new language proposals,


30
00:01:34.795 --> 00:01:37.464 line:-2 align:center
and we're going to talk
about several of them today.


31
00:01:38.532 --> 00:01:41.101 line:-2 align:center
But sometimes,
individual language proposals


32
00:01:41,134 --> 00:01:43,871 line:-1
come together as part of a wider theme,


33
00:01:43,904 --> 00:01:46,039 line:-1
like the addition of Swift concurrency,


34
00:01:46.073 --> 00:01:49.376 line:-2 align:center
which was introduced
through ten separate proposals.


35
00:01:50.177 --> 00:01:52.746 line:-2 align:center
For cases like this,
the language steering group


36
00:01:52,779 --> 00:01:55,649 line:-2
has introduced a new way
of tying together these proposals,


37
00:01:55.682 --> 00:01:57.918 line:-1 align:center
through vision documents.


38
00:01:57,951 --> 00:02:02,222 line:-2
These documents lay out a proposal
for larger changes to the language.


39
00:02:02.256 --> 00:02:05.359 line:-2 align:center
The first one to be accepted
by the language steering group


40
00:02:05,392 --> 00:02:09,763 line:-2
was a vision of Swift macros,
a new feature in Swift 5.9


41
00:02:09,796 --> 00:02:12,299 line:-1
that we'll be covering later in this talk.


42
00:02:13.233 --> 00:02:15.936 line:-2 align:center
Of course,
evolution of the language is only part


43
00:02:15.969 --> 00:02:17.838 line:-1 align:center
of the work of the Swift community.


44
00:02:17.871 --> 00:02:20.874 line:-2 align:center
A successful language
needs much more than this.


45
00:02:20.908 --> 00:02:24.845 line:-2 align:center
It needs great tooling,
robust support for multiple platforms,


46
00:02:24,878 --> 00:02:27,014 line:-1
and rich documentation.


47
00:02:27.047 --> 00:02:30.651 line:-2 align:center
To oversee progress in this area,
the core team is creating


48
00:02:30.684 --> 00:02:35.022 line:-2 align:center
an ecosystem steering group
parallel to the language steering group.


49
00:02:35,055 --> 00:02:39,660 line:-2
This new structure was recently laid out
in a blog post on Swift.org,


50
00:02:39,693 --> 00:02:41,795 line:-1
a look out for further announcements


51
00:02:41,828 --> 00:02:44,865 line:-2
about the formation
of this new group soon.


52
00:02:44.898 --> 00:02:48.235 line:-2 align:center
Now let's talk about changes
to the Swift language this year,


53
00:02:48,268 --> 00:02:52,573 line:-2
starting with better ways
to express yourself in your code.


54
00:02:52,606 --> 00:02:54,441 line:-1
Swift 5.9 includes what


55
00:02:54.474 --> 00:02:58.078 line:-2 align:center
is probably our most commonly
requested language enhancement,


56
00:02:58,111 --> 00:03:02,916 line:-2
allowing if/else and switch statements
to be used as expressions,


57
00:03:02.950 --> 00:03:05.986 line:-2 align:center
providing a nice way
to clean up your code.


58
00:03:07.554 --> 00:03:11.091 line:-2 align:center
For example,
if you wanted to initialize a let variable


59
00:03:11,124 --> 00:03:14,862 line:-2
based on some complex condition,
you had to resort to tricks,


60
00:03:14,895 --> 00:03:18,398 line:-2
like this hard-to-read
compound ternary expression.


61
00:03:19,566 --> 00:03:23,036 line:-2
If expressions let you
instead use a much more familiar


62
00:03:23.070 --> 00:03:25.772 line:-1 align:center
and readable chain of if statements.


63
00:03:27,274 --> 00:03:28,842 line:-1
Another place where this helps


64
00:03:28.876 --> 00:03:33.180 line:-2 align:center
is if you're initializing
a global variable or a stored property.


65
00:03:33.213 --> 00:03:37.551 line:-2 align:center
Single expressions work fine here,
but if you wanted a condition,


66
00:03:37,584 --> 00:03:40,153 line:-2
you had to use the trick
of wrapping it in a closure


67
00:03:40.187 --> 00:03:42.489 line:-1 align:center
that you then immediately executed.


68
00:03:43.957 --> 00:03:46.693 line:-2 align:center
Now that an if statement
can be an expression,


69
00:03:46,727 --> 00:03:50,998 line:-2
you can just drop that clutter,
leaving you with neater code.


70
00:03:51,765 --> 00:03:56,803 line:-2
Result builders, the declarative syntax
that drives features like SwiftUI,


71
00:03:56.837 --> 00:03:59.540 line:-2 align:center
have seen
significant improvements this year,


72
00:03:59,573 --> 00:04:02,309 line:-2
including optimized
type checking performance,


73
00:04:02,342 --> 00:04:05,846 line:-2
code completion,
and improved error messages.


74
00:04:06,914 --> 00:04:11,318 line:-2
This improvement
was particularly focused on invalid code.


75
00:04:11,351 --> 00:04:16,456 line:-2
Previously, result builder code with
errors would take a long time to fail,


76
00:04:16.490 --> 00:04:20.661 line:-2 align:center
as the type checker explored
the many possible invalid paths.


77
00:04:21.762 --> 00:04:26.166 line:-2 align:center
As of Swift 5.8,
invalid code type checks much faster,


78
00:04:26.200 --> 00:04:31.238 line:-3 align:center
and error messages on invalid code
are now more precise.


79
00:04:31.271 --> 00:04:34.708 line:-2 align:center
For example, previously,
some invalid code could lead


80
00:04:34.741 --> 00:04:39.046 line:-2 align:center
to misleading errors in a completely
different part of the result builder.


81
00:04:39,079 --> 00:04:42,149 line:-2
In Swift 5.7,
you'd receive an error like this,


82
00:04:42,182 --> 00:04:45,085 line:-1
when the mistake actually lies up here.


83
00:04:46,286 --> 00:04:48,722 line:-1
In the latest release, you now receive


84
00:04:48,755 --> 00:04:52,926 line:-2
a more accurate compiler diagnostic
identifying the real issue.


85
00:04:53.894 --> 00:04:57.064 line:-2 align:center
Next, let's talk about how
an addition to the generics system


86
00:04:57,097 --> 00:05:01,301 line:-2
will allow for some great improvements
to frameworks you use every day.


87
00:05:02.469 --> 00:05:06.540 line:-2 align:center
Almost all the Swift you write
is using generics in some way.


88
00:05:06,573 --> 00:05:10,077 line:-2
Type inference enables
using these types without needing


89
00:05:10.110 --> 00:05:13.747 line:-2 align:center
to understand the advanced capabilities
they're built with.


90
00:05:13,780 --> 00:05:17,484 line:-2
For example, the standard library
Array type uses generics


91
00:05:17.518 --> 00:05:20.654 line:-2 align:center
to provide an array
that works with any type of data


92
00:05:20,687 --> 00:05:22,923 line:-1
that you might want to store.


93
00:05:22.956 --> 00:05:27.261 line:-2 align:center
When you use an array, all you need
to do is provide the elements.


94
00:05:27.294 --> 00:05:31.331 line:-2 align:center
There's no need to specify
an explicit argument for the element type


95
00:05:31,365 --> 00:05:34,668 line:-2
because it can be inferred
from the element values.


96
00:05:36,003 --> 00:05:39,439 line:-2
Swift's generics system
enables natural APIs


97
00:05:39.473 --> 00:05:41.875 line:-1 align:center
that preserve type information


98
00:05:41,909 --> 00:05:46,680 line:-2
so that your code operates seamlessly
on the concrete types that you provide.


99
00:05:47.648 --> 00:05:51.351 line:-2 align:center
Here's an example inspired
by the Swift compiler's own codebase:


100
00:05:51,385 --> 00:05:53,654 line:-1
An API that takes a request type


101
00:05:53.687 --> 00:05:57.024 line:-2 align:center
and evaluates it
to produce a strongly typed value.


102
00:05:57,057 --> 00:05:59,560 line:-2
So you can make a request
for a Boolean value


103
00:05:59,593 --> 00:06:01,929 line:-1
and get back a Boolean result.


104
00:06:03,330 --> 00:06:08,435 line:-2
Now, some APIs want to abstract
not only over concrete types,


105
00:06:08,468 --> 00:06:12,739 line:-2
but also the number
of arguments that you pass in.


106
00:06:12,773 --> 00:06:17,044 line:-2
So a function might take one request
and return one result


107
00:06:17.077 --> 00:06:21.815 line:-2 align:center
or two requests and return two results,
or three and return three results.


108
00:06:22.883 --> 00:06:25.419 line:-2 align:center
To support this,
the generics system has to be used


109
00:06:25.452 --> 00:06:29.022 line:-2 align:center
together with a mechanism
to handle multiple argument lengths


110
00:06:29.056 --> 00:06:34.127 line:-2 align:center
so that all of the types that you pass in
are linked to the types that you get out.


111
00:06:34.895 --> 00:06:38.365 line:-2 align:center
Before Swift 5.9,
the only way to accomplish this pattern


112
00:06:38.398 --> 00:06:41.969 line:-2 align:center
was by adding an overload
for each specific argument length


113
00:06:42,002 --> 00:06:44,238 line:-1
the API supported.


114
00:06:44,271 --> 00:06:47,007 line:-1
But this approach has limitations.


115
00:06:47,040 --> 00:06:49,543 line:-1
It forces an artificial upper bound


116
00:06:49,576 --> 00:06:51,712 line:-1
on the number of arguments you can pass,


117
00:06:51.745 --> 00:06:53.413 line:-1 align:center
resulting in compiler errors


118
00:06:53.447 --> 00:06:55.282 line:-1 align:center
if you pass too many.


119
00:06:56,149 --> 00:06:58,552 line:0
In this case,
there isn't an overload that can handle


120
00:06:58,585 --> 00:07:01,855 line:0
more than six arguments,
but we've passed seven.


121
00:07:02,789 --> 00:07:06,660 line:0
This overloading pattern
and its limitations are pervasive


122
00:07:06,693 --> 00:07:11,198 line:0
across APIs that conceptually handle
arbitrary argument length.


123
00:07:12,900 --> 00:07:17,371 line:-2
In Swift 5.9, the generics system
is gaining first-class support


124
00:07:17.404 --> 00:07:23.110 line:-2 align:center
for this API pattern by enabling
generic abstraction over argument length.


125
00:07:23,143 --> 00:07:25,712 line:-1
This is done with a new language concept


126
00:07:25,746 --> 00:07:28,582 line:-2
that can represent multiple
individual type parameters


127
00:07:28,615 --> 00:07:30,617 line:-1
that are "packed" together.


128
00:07:30,651 --> 00:07:34,421 line:-2
This new concept is called
a type parameter pack.


129
00:07:35,389 --> 00:07:37,090 line:-1
Using parameter packs,


130
00:07:37,124 --> 00:07:40,093 line:-2
APIs that currently
have individual overloads


131
00:07:40,127 --> 00:07:42,196 line:-1
for each fixed argument length


132
00:07:42.229 --> 00:07:45.699 line:-2 align:center
can be collapsed down
into a single function.


133
00:07:49.837 --> 00:07:53.473 line:-2 align:center
Instead of accepting
a single type parameter, Result,


134
00:07:53,507 --> 00:07:56,677 line:-2
representing the result type
of a single request,


135
00:07:56,710 --> 00:08:02,182 line:-2
the evaluate function now accepts
a separate request over each Result type.


136
00:08:03.083 --> 00:08:06.787 line:-2 align:center
The function returns each
result instance in parenthesis,


137
00:08:06,820 --> 00:08:12,559 line:-2
which will either be a single value
or a tuple containing each value.


138
00:08:13.527 --> 00:08:19.266 line:-2 align:center
The evaluate function now handles all
argument lengths with no artificial limit.


139
00:08:21,235 --> 00:08:25,439 line:-2
Type inference makes APIs
using parameter packs natural to use


140
00:08:25,472 --> 00:08:29,510 line:-2
without needing to know
that the API is using them.


141
00:08:31,011 --> 00:08:33,180 line:-1
Calling our new evaluate function


142
00:08:33.213 --> 00:08:35.682 line:-2 align:center
that can now
handle any number of arguments,


143
00:08:35.716 --> 00:08:39.953 line:-2 align:center
looks just like calling
the fixed-length overloads.


144
00:08:39.987 --> 00:08:44.291 line:-2 align:center
Swift infers the type of each argument
along with the total number


145
00:08:44,324 --> 00:08:47,027 line:0
based on how you're calling the function.


146
00:08:47,060 --> 00:08:50,631 align:center
To learn about how to write
generic library APIs like these,


147
00:08:50,664 --> 00:08:54,701 line:0
check out Generalize APIs
using parameter packs.


148
00:08:55,636 --> 00:08:59,673 line:-2
Calling generic APIs
in a natural way demonstrates one


149
00:08:59,706 --> 00:09:05,479 line:-2
of Swift's fundamental design goals,
clear expression through concise code.


150
00:09:06.480 --> 00:09:10.584 line:-2 align:center
Swift's advanced language features
enable beautiful APIs


151
00:09:10.617 --> 00:09:13.320 line:-1 align:center
that make it easier to say what you mean.


152
00:09:14.321 --> 00:09:16.790 line:-2 align:center
You benefit
from these advanced language features


153
00:09:16,823 --> 00:09:19,626 line:-2
from the very first lines
of Swift that you ever write,


154
00:09:19.660 --> 00:09:23.096 line:-2 align:center
whether it's using generics
through arrays or dictionaries


155
00:09:23.130 --> 00:09:26.133 line:-1 align:center
or designing a UI in SwiftUI.


156
00:09:26,166 --> 00:09:30,304 line:-2
Swift's embrace of progressive
disclosure means that you can learn


157
00:09:30.337 --> 00:09:33.707 line:-2 align:center
about the more advanced features
when you're ready to.


158
00:09:35,042 --> 00:09:39,713 line:-2
Swift 5.9 takes this design approach
to the next level


159
00:09:39,746 --> 00:09:43,116 line:-2
by providing library authors
with a new toolbox


160
00:09:43.150 --> 00:09:47.888 line:-2 align:center
for expressive API design
using a new macro system.


161
00:09:47.921 --> 00:09:50.524 line:-1 align:center
Here's Doug to tell you more.


162
00:09:50,557 --> 00:09:54,795 line:-2
Doug: With macros, you can extend
the capabilities of the language itself,


163
00:09:54.828 --> 00:09:59.766 line:-2 align:center
eliminating boilerplate and unlocking more
of Swift's expressive power.


164
00:09:59,800 --> 00:10:02,402 line:-2
Let's consider
the ever-present assert function,


165
00:10:02.436 --> 00:10:05.005 line:-1 align:center
which checks whether a condition is true.


166
00:10:05.038 --> 00:10:07.908 line:-2 align:center
Assert will stop the program
if the condition is false,


167
00:10:07,941 --> 00:10:10,444 line:-2
but when that happens,
you get very little information


168
00:10:10,477 --> 00:10:14,147 line:-2
about what went wrong,
just the file and line number.


169
00:10:14.181 --> 00:10:18.952 line:-2 align:center
You'll need to add some logging or trap
the program in the debugger to learn more.


170
00:10:18,986 --> 00:10:21,154 line:-2
There have been attempts
to improve on this.


171
00:10:21,188 --> 00:10:26,093 line:-2
XCTest provides an assert-equal operation
that takes the two values separately,


172
00:10:26,126 --> 00:10:29,930 line:-2
so when things fail, you can at least see
the two values that aren't equal.


173
00:10:29.963 --> 00:10:32.666 line:-2 align:center
But we still don't know
which value is wrong here.


174
00:10:32,699 --> 00:10:35,769 line:-1
Was it a, b, or the result of max?


175
00:10:35,802 --> 00:10:38,705 line:-2
And this approach really doesn't scale
for all of the kinds of checks


176
00:10:38,739 --> 00:10:40,541 line:-1
we perform in asserts.


177
00:10:40,574 --> 00:10:44,745 line:-2
If we go back to the original assertion,
there is so much information here


178
00:10:44,778 --> 00:10:48,949 line:-2
in the source code that we'd like to see
in the log when our assertion fails.


179
00:10:48.982 --> 00:10:50.384 line:-1 align:center
What was the code?


180
00:10:50.417 --> 00:10:53.120 line:-1 align:center
What are the values of a, and b, and c?


181
00:10:53,153 --> 00:10:55,088 line:-1
What did max produce?


182
00:10:55.122 --> 00:10:59.159 line:-2 align:center
We couldn't improve this in Swift before
without some custom feature,


183
00:10:59,193 --> 00:11:01,161 line:-1
but macros make it possible.


184
00:11:02,396 --> 00:11:08,135 line:-2
In this example, the "hash-assert" syntax
is expanding the macro called "assert."


185
00:11:08,168 --> 00:11:10,337 line:-1
The hash syntax might look familiar


186
00:11:10.370 --> 00:11:13.707 line:-2 align:center
because Swift already has a few things
with this same spelling,


187
00:11:13,740 --> 00:11:17,611 line:-2
like hash-file,
hash-selector, and hash-warning.


188
00:11:17,644 --> 00:11:21,181 line:-2
The assert macro looks and feels
like the function version,


189
00:11:21,215 --> 00:11:24,651 line:-2
but because it's a macro,
it can provide a richer experience


190
00:11:24,685 --> 00:11:26,587 line:-1
when the assertion fails.


191
00:11:27.421 --> 00:11:30.557 line:-2 align:center
Now the program is showing the code
for the failing assertion,


192
00:11:30.591 --> 00:11:34.461 line:-2 align:center
along with each of the values
that contributed to the result.


193
00:11:35.662 --> 00:11:40.334 line:-2 align:center
In Swift, macros are APIs,
just like types or functions,


194
00:11:40,367 --> 00:11:44,738 line:-2
so you access them by importing
the module that defines them.


195
00:11:44,771 --> 00:11:49,176 line:-2
Like many other APIs,
macros are distributed as packages.


196
00:11:49.209 --> 00:11:53.347 line:-2 align:center
The assert macro here comes
from the power asserts library,


197
00:11:53,380 --> 00:11:56,617 line:-2
an open-source Swift package
available on GitHub.


198
00:11:58.118 --> 00:12:01.121 line:-2 align:center
If you were to look
into the macro package,


199
00:12:01,154 --> 00:12:04,958 line:-2
you would find
a macro declaration for assert.


200
00:12:04,992 --> 00:12:07,594 line:-1
It is introduced with the "macro" keyword,


201
00:12:07,628 --> 00:12:10,297 line:-2
but otherwise,
it looks a lot like a function.


202
00:12:10,330 --> 00:12:12,966 line:-1
There's a single unlabeled Bool parameter


203
00:12:13,000 --> 00:12:14,768 line:-1
for the condition to be checked.


204
00:12:14,801 --> 00:12:16,803 line:-1
If this macro produced a value,


205
00:12:16.837 --> 00:12:18.405 line:-1 align:center
that result type would be written


206
00:12:18.438 --> 00:12:21.575 line:-1 align:center
with the usual arrow syntax.


207
00:12:21,608 --> 00:12:24,044 line:-1
Uses of the macro will be type checked


208
00:12:24,077 --> 00:12:25,946 line:-1
against the parameters.


209
00:12:25,979 --> 00:12:27,948 line:-1
That means, if you were to make a mistake


210
00:12:27.981 --> 00:12:29.416 line:-1 align:center
in using the macro,


211
00:12:29,449 --> 00:12:31,118 line:-1
such as forgetting to compare


212
00:12:31.151 --> 00:12:33.587 line:-1 align:center
the maximum value against something,


213
00:12:33,620 --> 00:12:35,589 line:-1
you'll get a useful error message


214
00:12:35.622 --> 00:12:36.723 line:-1 align:center
immediately,


215
00:12:36,757 --> 00:12:39,326 line:-1
before the macro is ever expanded.


216
00:12:39,359 --> 00:12:41,094 line:-1
This allows Swift to provide


217
00:12:41,128 --> 00:12:42,796 line:-1
a great development experience


218
00:12:42.829 --> 00:12:45.499 line:-1 align:center
when using macros because macros operate


219
00:12:45,532 --> 00:12:47,868 line:-1
on well-typed inputs and produce code


220
00:12:47.901 --> 00:12:49.336 line:-1 align:center
that augments your program


221
00:12:49,369 --> 00:12:51,505 line:-1
in predictable ways.


222
00:12:51.538 --> 00:12:53.207 line:-1 align:center
Most macros are defined


223
00:12:53.240 --> 00:12:55.309 line:-1 align:center
as "external macros,"


224
00:12:55,342 --> 00:13:01,215 line:-2
specifying the module and type
for a macro implementation via strings.


225
00:13:01.248 --> 00:13:04.918 line:-2 align:center
The external macro types
are defined in separate programs


226
00:13:04,952 --> 00:13:08,088 line:-1
that act as compiler plugins.


227
00:13:08.121 --> 00:13:10.390 line:-1 align:center
The Swift compiler passes the source code


228
00:13:10,424 --> 00:13:13,460 align:center
for the use of the macro to the plugin.


229
00:13:13,493 --> 00:13:15,696 align:center
The plugin produces new source code,


230
00:13:15,729 --> 00:13:19,099 line:0
which is then integrated back
into the Swift program.


231
00:13:19,132 --> 00:13:22,202 align:center
Here, the macro is expanding the assertion
into code


232
00:13:22,236 --> 00:13:24,538 align:center
that captures the individual values


233
00:13:24,571 --> 00:13:27,674 line:0
and where they should be displayed
in the source code.


234
00:13:27,708 --> 00:13:30,143 line:0
You wouldn't want
to write the boilerplate yourself,


235
00:13:30,177 --> 00:13:32,613 line:0
but the macro does it for you.


236
00:13:32,646 --> 00:13:37,384 align:center
Macro declarations have one additional
piece of information, their role.


237
00:13:37.417 --> 00:13:41.522 line:-2 align:center
The assert macro here
is a freestanding expression macro.


238
00:13:41.555 --> 00:13:45.092 line:-2 align:center
It is called freestanding
because it uses the "hash" syntax


239
00:13:45.125 --> 00:13:48.362 line:-2 align:center
and operates directly
on that syntax to produce new code.


240
00:13:48,395 --> 00:13:51,465 line:-2
It is an expression macro
because it can be used anywhere


241
00:13:51.498 --> 00:13:53.800 line:-1 align:center
that one can produce a value.


242
00:13:53,834 --> 00:13:59,106 align:center
The new Foundation Predicate APIs provide
a great example of an expression macro.


243
00:13:59,139 --> 00:14:01,575 align:center
The predicate macro allows one
to write predicates


244
00:14:01,608 --> 00:14:04,411 line:1
in a type-safe manner using closures.


245
00:14:04,444 --> 00:14:08,916 align:center
The resulting predicate values can then
be used with a number of other APIs,


246
00:14:08,949 --> 00:14:13,320 align:center
including the Swift collection operations
SwiftUI and SwiftData.


247
00:14:14,254 --> 00:14:16,423 line:-1
The macro itself is generic


248
00:14:16,456 --> 00:14:19,026 line:-1
over the set of input types.


249
00:14:19,059 --> 00:14:21,094 line:-1
It accepts a closure argument


250
00:14:21.128 --> 00:14:22.829 line:-1 align:center
that's a function operating on values


251
00:14:22,863 --> 00:14:24,698 line:-1
of those input types and produces


252
00:14:24,731 --> 00:14:26,099 line:-1
a Boolean result,


253
00:14:26.133 --> 00:14:28.702 line:-1 align:center
does the set of inputs match or not?


254
00:14:29,670 --> 00:14:31,572 line:-1
And the macro returns an instance


255
00:14:31.605 --> 00:14:33.140 line:-1 align:center
of the new Predicate type,


256
00:14:33,173 --> 00:14:34,508 line:-1
which can be used elsewhere


257
00:14:34.541 --> 00:14:35.843 line:-1 align:center
in the program.


258
00:14:36.844 --> 00:14:39.646 line:-2 align:center
But there is more to macros
because a lot of the boilerplate


259
00:14:39,680 --> 00:14:42,683 line:-2
we end up writing
is because we need to augment code


260
00:14:42.716 --> 00:14:46.086 line:-2 align:center
we have written
with something else derived from it.


261
00:14:46.119 --> 00:14:47.688 line:-1 align:center
Let's take an example.


262
00:14:47,721 --> 00:14:50,691 line:-2
I find that I use enums a lot
in my own code,


263
00:14:50.724 --> 00:14:55.062 line:-2 align:center
like this Path enum that captures
either relative or absolute paths.


264
00:14:55,095 --> 00:14:58,665 line:-2
But I'll often find myself needing
to check for a specific case,


265
00:14:58.699 --> 00:15:02.135 line:-2 align:center
say, by filtering all absolute paths
from a collection.


266
00:15:02.169 --> 00:15:06.540 line:-2 align:center
I can write this isAbsolute check
as a computed property, of course.


267
00:15:06,573 --> 00:15:10,477 align:center
But sooner or later,
I'm going to have to write another one.


268
00:15:10,511 --> 00:15:13,080 align:center
This is getting a bit tedious.


269
00:15:14,214 --> 00:15:18,285 line:0
Macros can help here
by generating the boilerplate for us.


270
00:15:19,186 --> 00:15:22,256 line:-1
Case detection is an attached macro,


271
00:15:22.289 --> 00:15:26.827 line:-2 align:center
written using the same custom-attribute
syntax as property wrappers.


272
00:15:26,860 --> 00:15:31,198 line:-2
Attached macros take as input the syntax
of the declaration they apply to--


273
00:15:31.231 --> 00:15:35.536 line:-2 align:center
here it's the enum declaration itself--
and will generate new code.


274
00:15:38,672 --> 00:15:41,742 line:-2
This macro-expanded code
is normal Swift code,


275
00:15:41,775 --> 00:15:44,711 line:-2
which the compiler integrates
into your program.


276
00:15:44.745 --> 00:15:48.815 line:-2 align:center
You can inspect the macro-generated
code in your editor, debug into it,


277
00:15:48.849 --> 00:15:52.686 line:-2 align:center
copy it out if you want
to customize it further, and so on.


278
00:15:53,887 --> 00:15:57,524 line:1
Attached macros are classified
into five different roles


279
00:15:57,558 --> 00:16:01,828 align:center
based on how they augment
the declaration they are attached to.


280
00:16:01,862 --> 00:16:06,767 line:1
The case detection macro we just discussed
is a "member" attached macro,


281
00:16:06,800 --> 00:16:10,838 line:1
meaning that it creates new members
in a type or extension.


282
00:16:11,805 --> 00:16:16,910 align:center
Peer macros add new declarations alongside
the declaration they're attached to,


283
00:16:16,944 --> 00:16:19,546 line:1
for example,
to create a completion-handler version


284
00:16:19,580 --> 00:16:22,216 line:2
of an async method or vice-versa.


285
00:16:23,884 --> 00:16:28,355 line:1
Accessor macros can turn a stored property
into a computed property,


286
00:16:28,388 --> 00:16:32,125 align:center
which can be used to perform
specific actions on property access


287
00:16:32,159 --> 00:16:35,929 align:center
or abstract the actual storage
in a manner similar to,


288
00:16:35,963 --> 00:16:38,532 line:2
but more flexible than property wrappers.


289
00:16:38,565 --> 00:16:41,168 line:1
And attached macros
can introduce attributes


290
00:16:41,201 --> 00:16:46,273 align:center
onto specific members of a type,
as well as add new protocol conformances.


291
00:16:47.074 --> 00:16:50.410 line:-2 align:center
Several attached macro roles
can be composed together


292
00:16:50,444 --> 00:16:52,412 line:-1
to achieve useful effects.


293
00:16:52,446 --> 00:16:56,116 line:-2
One important example
of this is with observation.


294
00:16:57,017 --> 00:17:00,220 line:-2
Observation has
always been a part of SwiftUI.


295
00:17:00.254 --> 00:17:03.757 line:-2 align:center
To be able to observe changes
to the properties of a class,


296
00:17:03.790 --> 00:17:08.629 line:-2 align:center
one need only make the type
conform to ObservableObject,


297
00:17:08,662 --> 00:17:12,299 line:-1
and mark every property at-Published,


298
00:17:12.332 --> 00:17:15.736 line:-2 align:center
and use the ObservedObject
property wrapper in your view.


299
00:17:16.637 --> 00:17:19.706 line:-2 align:center
That's a bunch of steps,
and missing a step can mean


300
00:17:19.740 --> 00:17:22.309 line:-1 align:center
that the UI doesn't update as expected.


301
00:17:22,342 --> 00:17:25,779 line:-2
We can do better
with macro-based observation.


302
00:17:27.047 --> 00:17:31.084 line:-2 align:center
Attaching the Observable macro
to a class provides observation


303
00:17:31.118 --> 00:17:33.353 line:-1 align:center
for all of its stored properties.


304
00:17:33,387 --> 00:17:36,390 line:-2
There is no need
to annotate each stored property


305
00:17:36,423 --> 00:17:38,458 line:-1
or worry about what happens if you don't


306
00:17:38.492 --> 00:17:41.862 line:-2 align:center
because the Observable macro
handles it all.


307
00:17:42.930 --> 00:17:47.968 line:-2 align:center
The Observable macro works
through composition of three macro roles.


308
00:17:48.001 --> 00:17:51.572 line:-2 align:center
Let's dive
into how these roles work together.


309
00:17:52.506 --> 00:17:55.809 line:-2 align:center
Each macro role corresponds
to a specific way


310
00:17:55,843 --> 00:18:00,347 line:-2
in which the Person class
is augmented by the Observable macro.


311
00:18:00.380 --> 00:18:04.284 line:-2 align:center
The member role introduces
new properties and methods.


312
00:18:05,686 --> 00:18:10,123 line:0
The member attribute role
will add the @ObservationTracked macro


313
00:18:10,157 --> 00:18:13,894 align:center
to the stored properties
of the observed class,


314
00:18:13,927 --> 00:18:18,866 line:0
which in turn expands to getters
and setters to trigger observation events.


315
00:18:18,899 --> 00:18:21,969 line:0
Finally, the conformance role
introduces the conformance


316
00:18:22,002 --> 00:18:24,137 line:0
to the Observable protocol.


317
00:18:25,239 --> 00:18:29,676 line:0
This may look like a lot of code,
but it's all just normal Swift code,


318
00:18:29,710 --> 00:18:33,680 line:0
and it's neatly folded away
behind the Observable macro.


319
00:18:34.848 --> 00:18:37.951 line:-2 align:center
Whenever you need
to see how any macro expands


320
00:18:37.985 --> 00:18:41.121 line:-2 align:center
to better understand
its effect on your program,


321
00:18:41,154 --> 00:18:44,157 line:-2
it's right there
at your fingertips in Xcode.


322
00:18:45.392 --> 00:18:47.628 line:-1 align:center
Use the "Expand Macro" action


323
00:18:47,661 --> 00:18:51,098 line:-2
to see the macro-expanded source code
in your editor.


324
00:18:51,131 --> 00:18:53,901 line:-2
Any error messages
within macro-generated code


325
00:18:53.934 --> 00:18:56.336 line:-1 align:center
will automatically show the expanded code,


326
00:18:56,370 --> 00:18:59,706 line:-2
and you can step into and out of it
with your debugger.


327
00:19:00.908 --> 00:19:05.846 line:-2 align:center
Swift macros provide a new tool
for enabling more expressive APIs


328
00:19:05,879 --> 00:19:08,415 line:-2
and eliminating boilerplate
from your Swift code,


329
00:19:08,448 --> 00:19:11,752 line:-1
helping unlock Swift's expressive power.


330
00:19:11,785 --> 00:19:15,355 line:-2
Macros type-check their inputs,
produce normal Swift code,


331
00:19:15.389 --> 00:19:18.058 line:-2 align:center
and integrate
at defined points in your program,


332
00:19:18,091 --> 00:19:20,794 line:-1
so their effects are easy to reason about.


333
00:19:20.827 --> 00:19:24.064 line:-2 align:center
And any time you need
to understand what a macro did,


334
00:19:24.097 --> 00:19:27.701 line:-2 align:center
its expanded source code
is right there in your editor.


335
00:19:27.734 --> 00:19:30.370 line:-2 align:center
We've just scratched
the surface of macros.


336
00:19:30,404 --> 00:19:34,341 line:-5
"Expand on Swift macros" will go deep
into the design of Swift macros


337
00:19:34,374 --> 00:19:37,077 line:-5
to answer all of those questions
you must have.


338
00:19:37,110 --> 00:19:40,347 line:-5
And you can get hands-on
implementing your own macros


339
00:19:40,380 --> 00:19:42,482 line:-4
with "Write Swift macros."


340
00:19:42.516 --> 00:19:45.919 line:-2 align:center
I can't wait to see what new macros
the Swift community will build.


341
00:19:46,920 --> 00:19:51,525 line:-2
Ben: From the start, Swift was designed
to be a scalable language.


342
00:19:52.492 --> 00:19:57.865 line:-2 align:center
Swift's design emphasizes expressivity
with clear and concise code


343
00:19:57,898 --> 00:20:02,202 line:-2
that is low on ceremony
and easy to read and write.


344
00:20:02.236 --> 00:20:04.705 line:-1 align:center
By leveraging Swift's powerful features,


345
00:20:04,738 --> 00:20:07,708 line:-2
like generics
and native concurrency support,


346
00:20:07.741 --> 00:20:10.611 line:-1 align:center
frameworks like SwiftUI or SwiftData


347
00:20:10.644 --> 00:20:13.180 line:-2 align:center
let you quickly achieve
the results you want,


348
00:20:13,213 --> 00:20:16,750 line:-2
leaving you more time
to focus on what matters.


349
00:20:17.951 --> 00:20:20.554 line:-2 align:center
Despite these high-level
capabilities though,


350
00:20:20.587 --> 00:20:23.223 line:-1 align:center
Swift is also efficient.


351
00:20:23.257 --> 00:20:27.027 line:-2 align:center
It compiles natively,
and its use of value types


352
00:20:27,060 --> 00:20:29,963 line:-2
and of reference counting
instead of garbage collection means


353
00:20:29.997 --> 00:20:33.033 line:-2 align:center
it's able to achieve
a low memory footprint.


354
00:20:34,101 --> 00:20:38,505 line:-2
This scalability means we're able
to push Swift to more places


355
00:20:38,539 --> 00:20:41,408 line:-2
than was previously possible
with Objective-C,


356
00:20:41,441 --> 00:20:45,512 line:-2
to low-level systems,
where previously you might expect


357
00:20:45.546 --> 00:20:49.249 line:-1 align:center
to have to use C or C++.


358
00:20:49.283 --> 00:20:54.087 line:-2 align:center
This means bringing Swift's clearer code
and critical safety guarantees


359
00:20:54.121 --> 00:20:56.423 line:-1 align:center
to more places.


360
00:20:56,456 --> 00:20:59,326 line:-2
We recently open sourced
the start of a rewrite


361
00:20:59.359 --> 00:21:02.262 line:-1 align:center
of the Foundation framework in Swift.


362
00:21:02,296 --> 00:21:05,566 line:-2
This initiative will lead
to a single shared implementation


363
00:21:05.599 --> 00:21:10.103 line:-2 align:center
of Foundation on both Apple
and non-Apple platforms.


364
00:21:10,137 --> 00:21:15,943 line:-2
But it also meant rewriting large amounts
of Objective-C and C code in Swift.


365
00:21:16.710 --> 00:21:22.049 line:-2 align:center
As of MacOS Sonoma and iOS 17,
there are new Swift-backed implementations


366
00:21:22,082 --> 00:21:25,085 line:-1
of essential types like Date and Calendar,


367
00:21:25,118 --> 00:21:27,654 line:-2
of formatting
and internationalization essentials


368
00:21:27,688 --> 00:21:30,090 line:-1
like Locale and AttributedString,


369
00:21:30,123 --> 00:21:34,995 line:-2
and a new Swift implementation
of JSON encoding and decoding.


370
00:21:35,028 --> 00:21:38,498 line:-2
And the performance wins
have been significant.


371
00:21:39.566 --> 00:21:43.971 line:-2 align:center
Calendar's ability to calculate
important dates can take better advantage


372
00:21:44,004 --> 00:21:48,275 line:-2
of Swift's value semantics
to avoid intermediate allocations,


373
00:21:48,308 --> 00:21:52,579 line:-2
resulting in over a 20% improvement
in some benchmarks.


374
00:21:53.447 --> 00:21:56.517 line:-2 align:center
Date formatting
using FormatStyle also gained


375
00:21:56.550 --> 00:22:00.654 line:-2 align:center
some major performance upgrades,
showing a massive 150% improvement


376
00:22:00,687 --> 00:22:04,625 line:-2
in a benchmark of formatting
with a standard date and time template.


377
00:22:05,559 --> 00:22:10,998 line:-2
Even more exciting are the improvements
to JSON decoding in the new package.


378
00:22:11,031 --> 00:22:13,700 line:-2
Foundation has
a brand-new Swift implementation


379
00:22:13,734 --> 00:22:18,272 line:-2
for JSONDecoder and JSONEncoder,
eliminating costly roundtrips


380
00:22:18,305 --> 00:22:21,875 line:-2
to and from the Objective-C
collection types.


381
00:22:21,909 --> 00:22:26,880 line:-2
The tight integration of parsing JSON
in Swift for initializing Codable types


382
00:22:26,914 --> 00:22:29,616 line:-1
improves performance too.


383
00:22:29,650 --> 00:22:33,053 line:-2
In benchmarks parsing test data,
the new implementation


384
00:22:33,086 --> 00:22:36,623 line:-1
is between two and five times faster.


385
00:22:36,657 --> 00:22:40,027 line:-2
These improvements came from both
reducing the bridging cost


386
00:22:40.060 --> 00:22:43.030 line:-2 align:center
from the old Objective-C
implementation to Swift,


387
00:22:43.063 --> 00:22:47.067 line:-2 align:center
but also by the new Swift-based
implementations being faster.


388
00:22:48.068 --> 00:22:51.071 line:-1 align:center
Let's look at one benchmark as an example.


389
00:22:51.104 --> 00:22:55.943 line:-2 align:center
In Ventura, calling enumerateDates
from Objective-C was slightly faster


390
00:22:55.976 --> 00:22:59.413 line:-2 align:center
than calling it from Swift
because of bridging costs.


391
00:22:59,446 --> 00:23:01,348 line:-1
In MacOS Sonoma,


392
00:23:01,381 --> 00:23:05,786 line:-2
calling that same functionality
from Swift is 20% faster.


393
00:23:05,819 --> 00:23:08,822 line:-2
Some of that speed up comes
from eliminating bridging costs,


394
00:23:08,856 --> 00:23:12,993 line:-2
but the new function implementation itself
is also faster,


395
00:23:13.026 --> 00:23:16.563 line:-1 align:center
as seen when calling it from Objective-C.


396
00:23:16.597 --> 00:23:19.466 line:-2 align:center
This particular date calculation
is not overly complex,


397
00:23:19.499 --> 00:23:21.802 line:-2 align:center
so this is a great way
of seeing the reduction


398
00:23:21,835 --> 00:23:25,072 line:-1
in overhead between the two languages.


399
00:23:25.105 --> 00:23:28.108 line:-2 align:center
Now, sometimes,
when you're operating at lower levels


400
00:23:28,141 --> 00:23:31,645 line:-2
of the system,
you need more fine-grained control


401
00:23:31,678 --> 00:23:35,015 line:-2
to achieve a necessary level
of performance.


402
00:23:35,048 --> 00:23:39,686 line:-2
Swift 5.9 introduces
some new opt-in capabilities


403
00:23:39.720 --> 00:23:43.156 line:-2 align:center
that help you
achieve this level of control.


404
00:23:43,190 --> 00:23:47,928 line:-2
These capabilities focus
on the concept of ownership, that is,


405
00:23:47.961 --> 00:23:52.799 line:-2 align:center
what part of the code "owns" a value
as it passes around your application.


406
00:23:53,867 --> 00:23:56,303 line:-2
To see when you might want
to use these features,


407
00:23:56.336 --> 00:23:59.106 line:-1 align:center
let's first look at some example code.


408
00:23:59.773 --> 00:24:03.010 line:-2 align:center
Here we have a very simple wrapper
for a file descriptor


409
00:24:03,043 --> 00:24:08,015 line:-2
that would allow us to give low-level
system calls a nicer Swift interface.


410
00:24:08,048 --> 00:24:12,886 line:-2
But there’s still some easy ways
to make mistakes with this API.


411
00:24:12.920 --> 00:24:17.724 line:-2 align:center
For example, you might try to write
to the file after you’ve called close.


412
00:24:17,758 --> 00:24:20,928 line:-2
And you have to be careful
to always close it manually


413
00:24:20.961 --> 00:24:24.097 line:-2 align:center
by calling the close method
before the type goes out of scope.


414
00:24:24.131 --> 00:24:26.533 line:-1 align:center
Otherwise, you would get a resource leak.


415
00:24:27,201 --> 00:24:29,937 line:-1
One solution would be to make it a class


416
00:24:29,970 --> 00:24:34,174 line:0
with a deinit that closes it automatically
when the type goes out of scope.


417
00:24:35,209 --> 00:24:37,644 line:0
But that has different downsides,


418
00:24:37,678 --> 00:24:40,447 line:0
like making an additional
memory allocation,


419
00:24:40,480 --> 00:24:42,983 line:0
which is usually not a big problem,


420
00:24:43,016 --> 00:24:46,687 line:0
except in some very constrained
systems contexts.


421
00:24:48,155 --> 00:24:51,391 line:-1
Classes also have reference semantics.


422
00:24:51.425 --> 00:24:55.495 line:-2 align:center
You might unintentionally end up sharing
a file descriptor type across threads,


423
00:24:55.529 --> 00:24:59.066 line:-2 align:center
leading to race conditions,
or store it unintentionally.


424
00:25:00,234 --> 00:25:02,970 line:-2
But let's go back
and look at the struct version.


425
00:25:04.571 --> 00:25:09.076 line:-2 align:center
Really, this struct also behaves
like a reference type.


426
00:25:09.109 --> 00:25:12.346 line:-2 align:center
It holds an integer
that references the true value,


427
00:25:12.379 --> 00:25:14.982 line:-1 align:center
which is an open file.


428
00:25:15,015 --> 00:25:18,752 line:-2
Making a copy of this type could
also lead to unintentional sharing


429
00:25:18,785 --> 00:25:22,956 line:-2
of mutable state across your app
in ways that could lead to bugs.


430
00:25:22,990 --> 00:25:27,694 line:-2
What you want is to suppress
the ability to make a copy of this struct.


431
00:25:29.096 --> 00:25:34.168 line:-2 align:center
Swift types, whether structs or classes,
are copyable by default.


432
00:25:34,201 --> 00:25:37,337 line:-1
This is the right choice most of the time.


433
00:25:37,371 --> 00:25:41,975 line:-2
While excessive unnecessary copies can
sometimes be a bottleneck in your code,


434
00:25:42,009 --> 00:25:44,745 line:-2
it's better to spend the time
finding those bottlenecks


435
00:25:44.778 --> 00:25:47.447 line:-2 align:center
in instruments occasionally
than to be constantly bothered


436
00:25:47,481 --> 00:25:50,851 line:-2
by the compiler requiring you
to be explicit about those copies.


437
00:25:51.785 --> 00:25:56.790 line:-2 align:center
But sometimes that implicit copy
isn't what you want--in particular,


438
00:25:56,823 --> 00:26:00,594 line:-2
when making copies of a value
might lead to correctness issues,


439
00:26:00,627 --> 00:26:03,497 line:-1
like with our file descriptor wrapper.


440
00:26:03,530 --> 00:26:09,136 line:-2
In Swift 5.9, you can do that
with this new syntax that can be applied


441
00:26:09,169 --> 00:26:11,104 line:-1
to struct and enum declarations


442
00:26:11.138 --> 00:26:15.375 line:-2 align:center
and that suppresses the implicit ability
to copy a type.


443
00:26:15,409 --> 00:26:19,613 line:-2
Once a type is non-copyable,
you can give it a deinit,


444
00:26:19.646 --> 00:26:21.281 line:-1 align:center
like you can a class,


445
00:26:21.315 --> 00:26:24.852 line:-2 align:center
that will run when a value
of the type goes out of scope.


446
00:26:26.687 --> 00:26:31.692 line:-2 align:center
Non-copyable types can also be used
to solve the problem of calling close,


447
00:26:31.725 --> 00:26:34.361 line:-1 align:center
and then using other methods.


448
00:26:35,362 --> 00:26:39,333 line:-2
The close operation
can be marked as consuming.


449
00:26:39.366 --> 00:26:43.270 line:-2 align:center
Calling a consuming method
or argument gives up ownership


450
00:26:43.303 --> 00:26:46.139 line:-1 align:center
of a value to the method you called.


451
00:26:46.173 --> 00:26:48.041 line:-1 align:center
Since our type is not copyable,


452
00:26:48,075 --> 00:26:52,145 line:-2
giving up ownership means
you can no longer use the value.


453
00:26:53,380 --> 00:26:59,353 line:-2
By default, methods in Swift
borrow their arguments, including self.


454
00:26:59.386 --> 00:27:03.257 line:-2 align:center
So you can call the write method,
which borrows the file descriptor,


455
00:27:03,290 --> 00:27:06,260 line:-2
uses it to write out to the buffer,
and after that,


456
00:27:06,293 --> 00:27:08,862 line:-2
ownership
of the value returns to the caller,


457
00:27:08,896 --> 00:27:11,665 line:-2
and you can call another method,
like close.


458
00:27:12,699 --> 00:27:15,736 line:-2
But since close
has been marked as consuming,


459
00:27:15,769 --> 00:27:20,407 line:-2
not the default of borrowing,
it must be its final use.


460
00:27:21,608 --> 00:27:26,280 line:-2
This means, if you close the file first
and then attempt to call another method,


461
00:27:26,313 --> 00:27:30,184 line:-2
like write, you'll get an error message
at compile time,


462
00:27:30,217 --> 00:27:32,753 line:-1
rather than a runtime failure.


463
00:27:32,786 --> 00:27:36,690 line:-2
The compiler will also indicate
where the consuming use occurred.


464
00:27:37.724 --> 00:27:40.861 line:-2 align:center
Non-copyable types
are a powerful new feature


465
00:27:40,894 --> 00:27:43,897 line:-1
for systems level programming in Swift.


466
00:27:43.931 --> 00:27:46.834 line:-2 align:center
They're still
at an early point in their evolution.


467
00:27:46,867 --> 00:27:51,638 line:-2
Later versions of Swift will expand
on non-copyable types in generic code.


468
00:27:52,472 --> 00:27:54,741 line:-2
If you're interested
in following along with this work,


469
00:27:54,775 --> 00:27:58,879 line:-2
it's being actively discussed
on the Swift forums.


470
00:27:58,912 --> 00:28:03,750 line:-2
Doug: A key to Swift's success has been
its interoperability with Objective-C.


471
00:28:03.784 --> 00:28:05.919 line:-1 align:center
From the start, developers have been able


472
00:28:05.953 --> 00:28:10.090 line:-2 align:center
to take incremental steps towards Swift
adoption in their existing code bases,


473
00:28:10,123 --> 00:28:14,161 line:-2
mixing in Swift a single file
or module at a time.


474
00:28:14,194 --> 00:28:17,998 line:-2
But we know a lot of you don't
just have code written in Objective-C.


475
00:28:18,031 --> 00:28:21,902 line:-2
Many apps also have
core business logic implemented in C++,


476
00:28:21.935 --> 00:28:25.105 line:-2 align:center
and interfacing
to that has not been so easy.


477
00:28:25,138 --> 00:28:29,576 line:-2
Often it meant adding an extra
manual bridging layer, going from Swift,


478
00:28:29,610 --> 00:28:34,281 line:-2
through Objective-C,
and then into C++, and all the way back.


479
00:28:34,314 --> 00:28:38,118 line:-2
Swift 5.9 introduces the ability
to interact with C++ types


480
00:28:38.151 --> 00:28:40.654 line:-1 align:center
and functions directly from Swift.


481
00:28:40,687 --> 00:28:46,326 line:-2
C++ interoperability works just like
Objective-C interoperability always has,


482
00:28:46,360 --> 00:28:49,596 line:-2
mapping C++ APIs
into their Swift equivalents


483
00:28:49,630 --> 00:28:52,232 line:-1
that you can use directly from Swift code.


484
00:28:53,166 --> 00:28:57,304 line:-2
C++ is a large language
with its own notions of ideas


485
00:28:57.337 --> 00:29:01.041 line:-2 align:center
like classes,
methods, containers, and so on.


486
00:29:01,074 --> 00:29:04,845 line:-2
The Swift compiler
understands common C++ idioms,


487
00:29:04.878 --> 00:29:07.548 line:-1 align:center
so many types can be used directly.


488
00:29:07,581 --> 00:29:12,252 line:-2
For example, this Person type
defines the five special member functions


489
00:29:12,286 --> 00:29:16,423 line:-2
expected of a C++ value type:
Copy and move constructors,


490
00:29:16,456 --> 00:29:19,493 line:-1
assignment operators, and a destructor.


491
00:29:19.526 --> 00:29:22.362 line:-2 align:center
The Swift compiler
treats this as a value type


492
00:29:22,396 --> 00:29:26,867 line:-2
and will automatically call the right
special member function at the right time.


493
00:29:26,900 --> 00:29:31,338 line:-2
Additionally,
C++ containers like vectors and maps


494
00:29:31.371 --> 00:29:33.540 line:-1 align:center
are accessible as Swift collections.


495
00:29:34,842 --> 00:29:38,579 align:center
The result of all of this is that we
can write straightforward Swift code


496
00:29:38,612 --> 00:29:42,316 line:0
that makes direct use
of C++ functions and types.


497
00:29:42,349 --> 00:29:45,285 line:0
We can filter over the vector
of Person instances,


498
00:29:45,319 --> 00:29:49,890 line:0
calling C++ member functions
and accessing data members directly.


499
00:29:51.758 --> 00:29:55.762 line:-2 align:center
In the other direction,
using Swift code from C++


500
00:29:55.796 --> 00:29:59.233 line:-2 align:center
is based on the same mechanism
as with Objective-C.


501
00:29:59.266 --> 00:30:02.503 line:-2 align:center
The Swift compiler
will produce a "generated header"


502
00:30:02,536 --> 00:30:06,907 line:-2
that contains a C++ view
on the Swift APIs.


503
00:30:06,940 --> 00:30:11,311 line:-2
However, unlike with Objective-C,
you don't need to restrict yourself


504
00:30:11,345 --> 00:30:15,816 line:-2
to only using Swift classes
annotated with the objc attribute.


505
00:30:15,849 --> 00:30:20,287 line:-2
C++ can directly use most Swift types
and their full APIs,


506
00:30:20,320 --> 00:30:23,223 line:-2
including properties,
methods, and initializers,


507
00:30:23.257 --> 00:30:25.459 line:-1 align:center
without any bridging overhead.


508
00:30:26,360 --> 00:30:30,597 align:center
Here we can see how C++
can make use of our Point struct.


509
00:30:30,631 --> 00:30:32,566 line:0
After including the generated header,


510
00:30:32,599 --> 00:30:36,603 line:0
C++ can call Swift initializers
to create Point instances,


511
00:30:36,637 --> 00:30:38,472 line:0
invoke mutating methods,


512
00:30:38,505 --> 00:30:41,308 align:center
and access both stored
and computed properties,


513
00:30:41,341 --> 00:30:44,244 line:0
all without any change
to the Swift code itself.


514
00:30:45,913 --> 00:30:49,917 line:-2
Swift's C++ interoperability
makes it easier than ever


515
00:30:49,950 --> 00:30:53,420 line:-2
to integrate Swift
with existing C++ code bases.


516
00:30:53,453 --> 00:30:57,391 line:-2
Many C++ idioms can be
directly expressed in Swift,


517
00:30:57,424 --> 00:31:01,495 line:-2
often automatically, but occasionally
requiring some annotations


518
00:31:01.528 --> 00:31:03.931 line:-1 align:center
to indicate the desired semantics.


519
00:31:03.964 --> 00:31:07.534 line:-2 align:center
And Swift APIs
can be directly accessed from C++,


520
00:31:07.568 --> 00:31:10.237 line:-1 align:center
no annotation or code changes required,


521
00:31:10,270 --> 00:31:13,774 line:-2
making it possible to incrementally adopt
Swift throughout a code base


522
00:31:13,807 --> 00:31:18,011 line:-1
using any mix of C, C++, and Objective-C.


523
00:31:19,379 --> 00:31:23,016 line:-1
C++ interoperability is an evolving story,


524
00:31:23,050 --> 00:31:26,286 line:-2
guided by the C++
interoperability workgroup.


525
00:31:26,320 --> 00:31:30,324 line:-3
For more information,
please see the "Mix Swift and C++" talk,


526
00:31:30,357 --> 00:31:33,293 line:-3
or join us in the discussion
on the Swift forums.


527
00:31:34.862 --> 00:31:38.432 line:-2 align:center
Interoperability
at the language level is really important,


528
00:31:38,465 --> 00:31:41,535 line:-2
but you also have
to be able to build your code.


529
00:31:41,568 --> 00:31:45,272 line:-2
And having to replace your existing
build system with Xcode


530
00:31:45.305 --> 00:31:48.542 line:-2 align:center
or the Swift Package Manager
to even get started with Swift


531
00:31:48,575 --> 00:31:52,279 line:-2
can be just as big a barrier
as rewriting a large amount of code.


532
00:31:53,247 --> 00:31:55,749 line:-2
That's why we worked
with the CMake community


533
00:31:55.782 --> 00:31:57.918 line:-1 align:center
to improve Swift support in CMake.


534
00:31:57.951 --> 00:32:01.755 line:-2 align:center
You can integrate Swift code
into your CMake build by declaring Swift


535
00:32:01,788 --> 00:32:05,893 line:-2
as one of the languages for the project
and putting Swift files into a target.


536
00:32:06.960 --> 00:32:12.065 line:-2 align:center
More importantly, you can mix C++
and Swift within a single target,


537
00:32:12,099 --> 00:32:14,701 line:-2
and CMake will be sure
to compile each separately


538
00:32:14,735 --> 00:32:17,871 line:-2
and link all of the appropriate
supporting libraries and runtimes


539
00:32:17.905 --> 00:32:19.773 line:-1 align:center
for both languages.


540
00:32:19.806 --> 00:32:24.811 line:-2 align:center
This means you can start adopting Swift
in your cross-platform C++ projects today,


541
00:32:24,845 --> 00:32:27,614 line:-1
file by file or target by target.


542
00:32:27,648 --> 00:32:30,083 line:-1
We're also providing a sample repository


543
00:32:30,117 --> 00:32:34,454 line:-2
with CMake projects containing Swift
and mixed C++/Swift targets,


544
00:32:34,488 --> 00:32:37,057 line:-2
including using
the bridging and generated headers,


545
00:32:37.090 --> 00:32:38.892 line:-1 align:center
to help you get started.


546
00:32:40.594 --> 00:32:43.830 line:-2 align:center
A few years ago,
we introduced a new concurrency model


547
00:32:43.864 --> 00:32:47.935 line:-2 align:center
into Swift based
on the building blocks of async/await,


548
00:32:47.968 --> 00:32:50.871 line:-1 align:center
structured concurrency, and actors.


549
00:32:50.904 --> 00:32:53.740 line:-2 align:center
Swift's concurrency model
is an abstract model,


550
00:32:53,774 --> 00:32:57,878 line:-2
which can be adapted
to different environments and libraries.


551
00:32:57,911 --> 00:33:03,517 line:-2
The abstract model has two main pieces:
Tasks and actors.


552
00:33:03.550 --> 00:33:09.256 line:-2 align:center
Tasks represent a sequential unit of work
that can conceptually run anywhere.


553
00:33:09,289 --> 00:33:12,926 line:-2
Tasks can be suspended whenever
there's an "await" in the program,


554
00:33:12,960 --> 00:33:15,662 line:-2
and then resume
once the task can continue.


555
00:33:16,763 --> 00:33:19,299 line:-1
Actors are a synchronization mechanism


556
00:33:19.333 --> 00:33:23.470 line:-2 align:center
that provide mutually-exclusive access
to isolated state.


557
00:33:23,504 --> 00:33:26,306 line:-2
Entering an actor
from the outside requires an "await"


558
00:33:26.340 --> 00:33:28.208 line:-1 align:center
because it may suspend the task.


559
00:33:29.977 --> 00:33:34.214 line:-2 align:center
Tasks and actors are integrated
into the abstract language model,


560
00:33:34.248 --> 00:33:37.584 line:-2 align:center
but within that model,
they can be implemented in different ways


561
00:33:37,618 --> 00:33:39,887 line:-1
to fit different environments.


562
00:33:39.920 --> 00:33:43.824 line:-2 align:center
Tasks are executed
on the global concurrent pool.


563
00:33:43.857 --> 00:33:48.829 line:-2 align:center
How that global concurrent pool decides
to schedule work is up to the environment.


564
00:33:48.862 --> 00:33:52.032 line:-2 align:center
For Apple's platforms,
the Dispatch library provides


565
00:33:52.065 --> 00:33:55.068 line:-2 align:center
optimized scheduling
for the whole operating system,


566
00:33:55.102 --> 00:33:58.372 line:-2 align:center
and has been extensively tuned
for each platform.


567
00:33:58.405 --> 00:34:00.507 line:-1 align:center
In more restrictive environments,


568
00:34:00.541 --> 00:34:04.745 line:-2 align:center
the overhead of a multithreaded
scheduler may not be acceptable.


569
00:34:04,778 --> 00:34:07,347 line:-2
There Swift's concurrency model
is implemented


570
00:34:07,381 --> 00:34:10,284 line:-1
with a single-threaded cooperative queue.


571
00:34:10,317 --> 00:34:13,287 line:-2
The same Swift code works
in both environments


572
00:34:13,320 --> 00:34:16,390 line:-2
because the abstract model
is flexible enough to map


573
00:34:16,423 --> 00:34:18,592 line:-1
to diverse runtime environments.


574
00:34:19,660 --> 00:34:23,897 align:center
Additionally, interoperability
with callback-based libraries


575
00:34:23,931 --> 00:34:28,001 line:0
was built into Swift's async/await support
from the beginning.


576
00:34:28,035 --> 00:34:31,738 line:0
The withCheckedContinuation operations
allow one to suspend a task,


577
00:34:31,772 --> 00:34:34,975 line:0
and then resume it later
in response to a callback.


578
00:34:35,008 --> 00:34:37,644 line:0
This enables integration
with existing libraries


579
00:34:37,678 --> 00:34:40,280 align:center
that manage tasks themselves.


580
00:34:41.448 --> 00:34:45.052 line:-2 align:center
The standard implementation of actors
in the Swift concurrency runtime


581
00:34:45.085 --> 00:34:48.455 line:-2 align:center
is a lock-free queue of tasks
to execute on the actor,


582
00:34:48.488 --> 00:34:51.792 line:-2 align:center
but it's not the only possible
implementation.


583
00:34:51.825 --> 00:34:55.796 line:-2 align:center
In a more restricted environment,
one might not have atomics,


584
00:34:55,829 --> 00:35:00,534 line:-2
and instead could use another
concurrency primitive such as spinlocks.


585
00:35:00,567 --> 00:35:04,404 line:-2
If that environment were single-threaded,
no synchronization is needed,


586
00:35:04,438 --> 00:35:07,808 line:-2
but the actor model maintains
the abstract concurrency model


587
00:35:07,841 --> 00:35:09,743 line:-1
for the program regardless.


588
00:35:09.776 --> 00:35:12.546 line:-2 align:center
You could still take that same code
to another environment


589
00:35:12.579 --> 00:35:15.015 line:-1 align:center
that is multi-threaded.


590
00:35:15.048 --> 00:35:18.252 line:-2 align:center
With Swift 5.9,
custom actor executors allow


591
00:35:18.285 --> 00:35:22.890 line:-2 align:center
a particular actor to implement
its own synchronization mechanism.


592
00:35:22.923 --> 00:35:27.494 line:-2 align:center
This makes actors more flexible
and adaptable to existing environments.


593
00:35:27.528 --> 00:35:29.062 line:-1 align:center
Let's take an example.


594
00:35:30,030 --> 00:35:34,168 line:-2
Here we consider an actor
that manages a database connection.


595
00:35:34,201 --> 00:35:38,238 line:-2
Swift ensures mutually-exclusive access
to the storage of this actor,


596
00:35:38.272 --> 00:35:42.042 line:-2 align:center
so there won't be any concurrent access
to the database.


597
00:35:42,075 --> 00:35:45,946 line:-2
However, what if you need more control
over the specific way


598
00:35:45,979 --> 00:35:48,315 line:-1
in which synchronization is done?


599
00:35:48.348 --> 00:35:51.418 line:-2 align:center
For example, what if you want
to use a specific dispatch queue


600
00:35:51,451 --> 00:35:54,154 line:-2
for your database connection,
perhaps because that queue is shared


601
00:35:54.188 --> 00:35:57.224 line:-2 position:49% align:center
with other code
that hasn't adopted actors?


602
00:35:57,257 --> 00:36:00,060 line:-1 align:center
With custom actor executors, you can.


603
00:36:01,662 --> 00:36:05,399 line:-2
Here we've added
a serial dispatch queue to our actor


604
00:36:05,432 --> 00:36:08,802 line:-2
and an implementation
of the unowned executor property


605
00:36:08.836 --> 00:36:13.407 line:-2 align:center
that produces the executor
corresponding to that dispatch queue.


606
00:36:13.440 --> 00:36:15.876 line:-2 align:center
With this change,
all of the synchronization


607
00:36:15.909 --> 00:36:19.479 line:-2 align:center
for our actor instances
will happen through that queue.


608
00:36:20,547 --> 00:36:25,052 line:-2
When you "await" on the call
to pruneOldEntries from outside the actor,


609
00:36:25,085 --> 00:36:29,523 line:-2
this will now perform a dispatch-async
on the corresponding queue.


610
00:36:29,556 --> 00:36:32,526 line:-2
This gives you more control
over how individual actors


611
00:36:32,559 --> 00:36:35,495 line:-2
provide synchronization,
and even lets you synchronize an actor


612
00:36:35.529 --> 00:36:37.965 line:-2 align:center
with other code
that isn't using actors yet,


613
00:36:37.998 --> 00:36:41.168 line:-2 align:center
perhaps because it's written
in Objective-C or C++.


614
00:36:43.203 --> 00:36:46.707 line:-2 align:center
The synchronization of actors
via dispatch queues is made possible


615
00:36:46.740 --> 00:36:51.845 line:-2 align:center
because dispatch queue conforms
to the new SerialExecutor protocol.


616
00:36:51,879 --> 00:36:56,149 line:-2
You can provide your own synchronization
mechanism to use with actors


617
00:36:56.183 --> 00:36:59.319 line:-2 align:center
by defining a new type
that conforms to this protocol


618
00:36:59,353 --> 00:37:02,823 line:-1
which has only few core operations:


619
00:37:02,856 --> 00:37:07,561 line:-2
Checking whether the code is already
executing in the context of the executor.


620
00:37:07,594 --> 00:37:10,531 line:-2
For example,
are we running on the main thread?


621
00:37:11.598 --> 00:37:15.169 line:-2 align:center
Extracting an unowned reference
to the executor to allow access to it


622
00:37:15,202 --> 00:37:18,105 line:-1
without excess reference-counting traffic.


623
00:37:18,138 --> 00:37:21,041 line:-1
And the most core operation, enqueue,


624
00:37:21,074 --> 00:37:24,144 line:-2
which takes ownership
of an executor "job."


625
00:37:24.178 --> 00:37:26.847 line:-2 align:center
A job is part
of an asynchronous task that needs


626
00:37:26,880 --> 00:37:29,383 line:-1
to run synchronously on the executor.


627
00:37:29,416 --> 00:37:32,452 line:-2
At the point where enqueue is called,
it's the responsibility


628
00:37:32,486 --> 00:37:35,422 line:-2
of the executor
to run that job at some point


629
00:37:35,455 --> 00:37:38,725 line:-2
when there's no other code running
on the serial executor.


630
00:37:38.759 --> 00:37:44.064 line:-2 align:center
For example, enqueue for a dispatch queue
would call dispatch async on that queue.


631
00:37:45,299 --> 00:37:48,468 line:-2
Swift Concurrency has been in use
for a few years now,


632
00:37:48.502 --> 00:37:51.972 line:-2 align:center
and its abstract model
consisting of tasks and actors


633
00:37:52.005 --> 00:37:55.676 line:-2 align:center
covers a large range
of concurrent programming tasks.


634
00:37:55,709 --> 00:37:58,846 line:-2
The abstract model itself
is quite flexible,


635
00:37:58,879 --> 00:38:02,082 line:-2
making it adaptable
to different execution environments,


636
00:38:02,115 --> 00:38:05,352 line:-2
from iPhones to Apple Watches,
to servers and beyond.


637
00:38:05,385 --> 00:38:09,790 line:-2
It also allowed customization
at key points to enable it to interoperate


638
00:38:09.823 --> 00:38:13.360 line:-2 align:center
with code that hasn't fully adopted
Swift Concurrency yet.


639
00:38:13,393 --> 00:38:17,030 line:-5
For more information,
please see our "Behind the Scenes" talk,


640
00:38:17,064 --> 00:38:20,467 line:-5
as well as "Beyond the basics
of Structured Concurrency."


641
00:38:20,501 --> 00:38:24,204 line:-2
I want to wrap up with a bit
of a case study of Swift operating


642
00:38:24.238 --> 00:38:28.008 line:-2 align:center
in an environment very different
from the iOS or MacOS apps


643
00:38:28,041 --> 00:38:29,943 line:-1
where we are used to seeing it.


644
00:38:29.977 --> 00:38:35.182 line:-2 align:center
FoundationDB is a distributed database,
providing a scalable solution


645
00:38:35.215 --> 00:38:39.019 line:-2 align:center
for very large key-value stores
running on commodity hardware


646
00:38:39.052 --> 00:38:43.991 line:-2 align:center
and supporting a variety of platforms,
including MacOS, Linux, and Windows.


647
00:38:44,825 --> 00:38:50,497 line:-2
FoundationDB is an open-source project
with a large code base written in C++.


648
00:38:50,531 --> 00:38:52,533 line:-1
The code is heavily asynchronous,


649
00:38:52,566 --> 00:38:55,936 line:-2
with its own form
of distributed actors and runtime


650
00:38:55,969 --> 00:38:59,573 line:-2
that provides a critically important
deterministic simulation environment


651
00:38:59,606 --> 00:39:01,608 line:-1
for testing purposes.


652
00:39:01,642 --> 00:39:04,878 line:-2
FoundationDB was looking
to modernize their code base


653
00:39:04,912 --> 00:39:08,115 line:-2
and found Swift to be a good match
for its performance,


654
00:39:08,148 --> 00:39:10,984 line:-1
safety, and code clarity.


655
00:39:11.018 --> 00:39:14.855 line:-2 align:center
A complete rewrite would be a big,
risky endeavor.


656
00:39:14,888 --> 00:39:18,158 line:-2
Instead,
we leveraged Swift's interoperability


657
00:39:18.192 --> 00:39:21.061 line:-1 align:center
to integrate into the existing code base.


658
00:39:21,094 --> 00:39:24,331 line:-2
For example,
here's a part of the C++ implementation


659
00:39:24.364 --> 00:39:27.734 line:-1 align:center
of FoundationDB's "master data" actor.


660
00:39:29.203 --> 00:39:30.871 line:-1 align:center
There's a lot going on here,


661
00:39:30,904 --> 00:39:33,707 line:-2
and you don't need
to understand all of this C++.


662
00:39:33.740 --> 00:39:38.579 line:-2 align:center
However, I'd like to point out
a few key aspects of the code.


663
00:39:38.612 --> 00:39:41.882 line:-1 align:center
First, C++ doesn't have async/await,


664
00:39:41.915 --> 00:39:45.519 line:-2 align:center
so FoundationDB has
their own preprocessor-like approach


665
00:39:45,552 --> 00:39:47,087 line:-1
to emulate it.


666
00:39:48,288 --> 00:39:50,390 line:-1
Like many C++ code bases,


667
00:39:50,424 --> 00:39:53,093 line:-2
they've implemented
their own C++ Future type


668
00:39:53.126 --> 00:39:55.529 line:-1 align:center
to manage asynchronous tasks.


669
00:39:56,496 --> 00:39:59,099 line:-1
These pair with explicit messaging


670
00:39:59.132 --> 00:40:01.768 line:-1 align:center
to send responses to the requests.


671
00:40:01,802 --> 00:40:03,837 line:-1
Note the careful pairing of sending


672
00:40:03.871 --> 00:40:07.074 line:-1 align:center
a reply with returning from the function.


673
00:40:07,107 --> 00:40:09,109 line:-1
Finally, FoundationDB has


674
00:40:09.142 --> 00:40:10.978 line:-1 align:center
its own reference-counted smart pointers


675
00:40:11,011 --> 00:40:13,580 line:-1
to help manage memory automatically.


676
00:40:13.614 --> 00:40:15.582 line:-1 align:center
We can implement this whole thing


677
00:40:15,616 --> 00:40:17,985 line:-1
much more cleanly in Swift.


678
00:40:20,087 --> 00:40:22,389 line:-1
[breathes deeply]


679
00:40:22,422 --> 00:40:24,491 line:-1
That's better.


680
00:40:24,525 --> 00:40:28,862 line:-2
This function can be directly implemented
as an async function in Swift.


681
00:40:28,896 --> 00:40:32,132 line:-2
We have a normal return type
and normal return statements


682
00:40:32,165 --> 00:40:36,770 line:-2
to provide the response to this request,
so you can't ever be out of sync.


683
00:40:36,803 --> 00:40:39,573 line:-2
We have an "await"
to indicate the suspension point


684
00:40:39,606 --> 00:40:43,510 line:-2
in the same manner
as all other Swift async code.


685
00:40:43,544 --> 00:40:47,314 line:-2
And this Swift code ties in
with the C++ Future type


686
00:40:47.347 --> 00:40:50.117 line:-1 align:center
adapted using continuations.


687
00:40:51,251 --> 00:40:54,121 line:-1
We're using a number of C++ types here.


688
00:40:54,154 --> 00:40:58,992 line:-2
The MasterData type in C++ was
using a reference-counted smart pointer.


689
00:40:59.026 --> 00:41:02.596 line:-2 align:center
By annotating the type in C++,
the Swift compiler can use


690
00:41:02.629 --> 00:41:04.765 line:-1 align:center
this type like any other class,


691
00:41:04,798 --> 00:41:07,835 line:-2
automatically managing
reference counts for us.


692
00:41:09,002 --> 00:41:12,272 line:-2
Other types,
such as the request and reply types,


693
00:41:12.306 --> 00:41:16.443 line:-2 align:center
are C++ value types
being used directly in Swift.


694
00:41:16,476 --> 00:41:19,279 line:-1
And the interoperability goes both ways.


695
00:41:19,313 --> 00:41:20,814 line:-1
This asynchronous function,


696
00:41:20,848 --> 00:41:24,084 line:-2
and indeed, all the work introduced
by the Swift concurrency model,


697
00:41:24.117 --> 00:41:28.555 line:-2 align:center
run on FoundationDB's
existing deterministic runtime.


698
00:41:28,589 --> 00:41:31,592 line:-2
So we can get the benefits
of Swift where we want it,


699
00:41:31.625 --> 00:41:36.797 line:-2 align:center
interfacing with the existing C++
to enable gradual adoption throughout.


700
00:41:38,532 --> 00:41:41,635 line:-2
In this session,
we've covered a lot of ground.


701
00:41:41,668 --> 00:41:44,938 line:-1
We described features like parameter packs


702
00:41:44,972 --> 00:41:47,174 line:-2
and macros
that enable more expressive APIs


703
00:41:47,207 --> 00:41:51,144 line:-1
and can help you write better code faster.


704
00:41:51.178 --> 00:41:54.781 line:-2 align:center
We talked about the use of Swift
in performance-sensitive code


705
00:41:54,815 --> 00:41:57,150 line:-1
and the introduction of non-copyable types


706
00:41:57.184 --> 00:42:00.821 line:-2 align:center
to provide resource management
without reference-counting overhead.


707
00:42:01,755 --> 00:42:04,725 line:-1
Then we dove into C++ interoperability,


708
00:42:04.758 --> 00:42:10.097 line:-2 align:center
which provides support for using C++ APIs
in Swift and vice-versa,


709
00:42:10,130 --> 00:42:14,568 line:-2
making it easier to bring the benefits
of Swift to more of your code.


710
00:42:15,636 --> 00:42:19,339 line:-2
Finally, we talked about how
Swift's flexible concurrency model


711
00:42:19.373 --> 00:42:21.408 line:-1 align:center
can adapt to myriad environments


712
00:42:21,441 --> 00:42:26,146 line:-2
across devices and languages
to make concurrency easier and safer.


713
00:42:26.180 --> 00:42:29.850 line:-2 align:center
Parameter packs,
macros, non-copyable types,


714
00:42:29.883 --> 00:42:33.987 line:-2 align:center
and all of the other language enhancements
in Swift 5.9 were designed


715
00:42:34,021 --> 00:42:37,591 line:-2
and developed openly
through the Swift Evolution process,


716
00:42:37,624 --> 00:42:41,828 line:-2
and community feedback
was crucial in shaping these features.


717
00:42:41.862 --> 00:42:45.299 line:-2 align:center
Swift 5.9 is the culmination
of countless contributions


718
00:42:45,332 --> 00:42:49,937 line:-2
from members across the Swift community,
including active design discussions,


719
00:42:49,970 --> 00:42:54,608 line:-2
bug reports, pull requests,
educational content, and more.


720
00:42:54,641 --> 00:42:59,046 line:-2
Thank you for making Swift 5.9
the great release it is.


721
00:42:59,079 --> 00:43:03,317 align:center
♪ ♪

