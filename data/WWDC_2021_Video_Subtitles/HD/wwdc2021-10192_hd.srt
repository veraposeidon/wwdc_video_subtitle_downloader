2
00:00:00.334 --> 00:00:03.337 line:-1
[upbeat music]


3
00:00:03.370 --> 00:00:08.976 line:-1
♪ ♪


4
00:00:09.009 --> 00:00:09.910 line:-1
[Nicole] Hi!


5
00:00:09.943 --> 00:00:14.414 line:-2
I'm Nicole, and welcome
to "What's new in Swift."


6
00:00:14.448 --> 00:00:17.918 line:-2
Swift 5.5 is
our best release yet!


7
00:00:17.951 --> 00:00:21.221 line:-2
The Swift language continues
to evolve at a rapid pace,


8
00:00:21.255 --> 00:00:24.625 line:-2
with many new features,
including Swift Concurrency,


9
00:00:24.658 --> 00:00:27.761 line:-2
a new model for asynchronous
and concurrent programming


10
00:00:27.794 --> 00:00:29.763 line:-2
designed to make
concurrent programming in Swift


11
00:00:29.796 --> 00:00:33.400 line:-1
convenient, efficient, and safe.


12
00:00:33.433 --> 00:00:36.069 line:-2
In addition,
we've made it easier than ever


13
00:00:36.103 --> 00:00:38.472 line:-2
to develop in Swift,
thanks to advances


14
00:00:38.505 --> 00:00:42.042 line:-2
in the package experience,
new standard library packages,


15
00:00:42.075 --> 00:00:44.811 line:-2
and features enhancing
the developer experience.


16
00:00:46.180 --> 00:00:48.582 line:-2
As important
as these advances are,


17
00:00:48.615 --> 00:00:51.852 line:-2
the heart of the Swift project
is not code,


18
00:00:51.885 --> 00:00:53.453 line:-1
but a community of people


19
00:00:53.487 --> 00:00:56.323 line:-2
working towards the goals
of the Swift project.


20
00:00:56.356 --> 00:00:57.991 line:-2
This is why
it is important that we invest


21
00:00:58.025 --> 00:01:01.528 line:-2
in our community,
as well as our software.


22
00:01:01.562 --> 00:01:03.530 line:-2
I'd like to start things off
by talking about


23
00:01:03.564 --> 00:01:06.567 line:-2
an important Swift
community initiative.


24
00:01:06.600 --> 00:01:10.070 line:-2
Diversity is a core value
of the Swift community.


25
00:01:10.103 --> 00:01:13.006 line:-2
Research shows that diverse
open source projects


26
00:01:13.040 --> 00:01:16.310 line:-2
are more productive
and make better decisions.


27
00:01:16.343 --> 00:01:18.579 line:-2
Including people
from all backgrounds


28
00:01:18.612 --> 00:01:23.083 line:-2
and with diverse perspectives
helps a community thrive.


29
00:01:23.116 --> 00:01:25.953 line:-2
We, and other members
of the Swift community,


30
00:01:25.986 --> 00:01:28.722 line:-2
saw the opportunity
to encourage active engagement


31
00:01:28.755 --> 00:01:32.159 line:-2
in the Swift ecosystem
and community from a wider range


32
00:01:32.192 --> 00:01:35.963 line:-2
of developers with our
Diversity in Swift initiative.


33
00:01:35.996 --> 00:01:38.932 line:-2
The mission of Diversity
in Swift is to foster


34
00:01:38.966 --> 00:01:40.934 line:-1
an inclusive Swift community


35
00:01:40.968 --> 00:01:43.770 line:-2
by elevating
a wide variety of voices


36
00:01:43.804 --> 00:01:46.740 line:-2
and making it easier
for developers to start learning


37
00:01:46.773 --> 00:01:50.611 line:-2
or contributing to Swift,
regardless of their background.


38
00:01:50.644 --> 00:01:52.446 line:-1
As part of this initiative,


39
00:01:52.479 --> 00:01:54.715 line:-2
we have expanded
the swift.org blog


40
00:01:54.748 --> 00:01:57.818 line:-2
to include posts that recognize
and highlight the contributions


41
00:01:57.851 --> 00:02:01.255 line:-2
from a wide range of developers
within our community.


42
00:02:01.288 --> 00:02:03.290 line:-2
We have also created
community groups


43
00:02:03.323 --> 00:02:05.726 line:-2
in the Swift forums
for developers to connect


44
00:02:05.759 --> 00:02:08.462 line:-2
with others who may have had
similar experiences


45
00:02:08.495 --> 00:02:10.330 line:-1
or faced similar barriers.


46
00:02:10.364 --> 00:02:12.599 line:-2
To get involved
with Diversity in Swift,


47
00:02:12.633 --> 00:02:14.168 line:-1
or find out more,


48
00:02:14.201 --> 00:02:18.472 line:-2
please visit
swift.org/diversity.


49
00:02:18.505 --> 00:02:21.608 line:-2
We also want to help developers
already in the community


50
00:02:21.642 --> 00:02:24.478 line:-2
grow and reach their goals
with Swift.


51
00:02:24.511 --> 00:02:26.880 line:-2
To make contributing
to Swift open source projects


52
00:02:26.914 --> 00:02:29.216 line:-2
more approachable,
we recently announced


53
00:02:29.249 --> 00:02:31.785 line:-2
the Swift mentorship program
to help newcomers get


54
00:02:31.818 --> 00:02:35.656 line:-2
direct support and guidance
from regular contributors.


55
00:02:35.689 --> 00:02:38.525 line:-2
This program isn't limited
to Apple's projects.


56
00:02:38.559 --> 00:02:41.061 line:-2
It also encompasses
the entire ecosystem


57
00:02:41.094 --> 00:02:44.431 line:-2
of Swift packages
and open source tools.


58
00:02:44.464 --> 00:02:48.602 line:-2
Next, I'd like to talk
about packages.


59
00:02:48.635 --> 00:02:50.671 line:-2
Packages are
a fundamental building block


60
00:02:50.704 --> 00:02:52.372 line:-2
for building software,
allowing you


61
00:02:52.406 --> 00:02:54.975 line:-2
to conveniently take advantage
of an ever-growing array


62
00:02:55.008 --> 00:02:56.777 line:-1
of open source code.


63
00:02:56.810 --> 00:02:58.579 line:-1
Members of the Swift community


64
00:02:58.612 --> 00:03:00.514 line:-2
have come up
with some great solutions


65
00:03:00.547 --> 00:03:02.516 line:-2
to help developers
find packages,


66
00:03:02.549 --> 00:03:04.751 line:-1
like the Swift Package Index.


67
00:03:04.785 --> 00:03:06.720 line:-2
The Swift Package Index
is a page


68
00:03:06.753 --> 00:03:08.989 line:-2
created by the community
that helps you find


69
00:03:09.022 --> 00:03:12.326 line:-2
packages which support
the Swift Package Manager.


70
00:03:12.359 --> 00:03:16.496 line:-2
Now, in Swift 5.5 and Xcode 13,
we are providing


71
00:03:16.530 --> 00:03:19.967 line:-2
additional ways for you to find
and access packages,


72
00:03:20.000 --> 00:03:22.569 line:-2
by providing integrated
Xcode tooling support


73
00:03:22.603 --> 00:03:26.206 line:-2
to make it even faster
and easier to use packages


74
00:03:26.240 --> 00:03:28.976 line:-2
in your project as part
of your development workflow.


75
00:03:32.112 --> 00:03:36.316 line:-2
This year, we are introducing
Swift Package Collections,


76
00:03:36.350 --> 00:03:39.086 line:-2
curated lists of Swift packages
you can use


77
00:03:39.119 --> 00:03:42.856 line:-2
both from the command line
and from Xcode 13.


78
00:03:42.890 --> 00:03:45.726 line:-2
With package collections,
you no longer need to search


79
00:03:45.759 --> 00:03:47.394 line:-1
for packages on the Internet,


80
00:03:47.427 --> 00:03:50.063 line:-2
or copy and paste URLs
to add them.


81
00:03:50.097 --> 00:03:53.000 line:-2
You can now simply browse
a collection and add packages


82
00:03:53.033 --> 00:03:55.903 line:-2
from a new package
search screen in Xcode.


83
00:03:55.936 --> 00:03:58.772 line:-2
Package collections
are simple JSON files


84
00:03:58.805 --> 00:04:00.607 line:-1
you can publish anywhere.


85
00:04:00.641 --> 00:04:03.644 line:-2
Package collections are meant
to allow anyone to build


86
00:04:03.677 --> 00:04:06.647 line:-2
curated lists of packages
for different use cases.


87
00:04:06.680 --> 00:04:10.117 line:-2
For example, an instructor
for a computer science class


88
00:04:10.150 --> 00:04:11.952 line:-2
can put together
a set of packages


89
00:04:11.985 --> 00:04:14.521 line:-2
that helps teach
the concepts of that class,


90
00:04:14.555 --> 00:04:17.891 line:-2
or someone can put together
a collection of packages


91
00:04:17.925 --> 00:04:20.394 line:-2
that are good
for a particular domain or task,


92
00:04:20.427 --> 00:04:22.863 line:-2
or that are used
by their organization.


93
00:04:22.896 --> 00:04:24.965 line:-2
We're excited to see
all the different ways


94
00:04:24.998 --> 00:04:27.768 line:-2
in which people will
use collections.


95
00:04:27,801 --> 00:04:30,437
We have a great presentation
on package collections


96
00:04:30,470 --> 00:04:33,407
that I recommend
you check out to learn more.


97
00:04:33.440 --> 00:04:34.641 line:-1
Package collections include


98
00:04:34.675 --> 00:04:37.177 line:-2
some powerful tooling support
in Xcode.


99
00:04:37.211 --> 00:04:41.715 line:-2
You are now just an import away
from using your favorite APIs.


100
00:04:41.748 --> 00:04:44.852 line:-2
When you try to import
a module that cannot be found,


101
00:04:44.885 --> 00:04:46.920 line:-2
Xcode will check
if any of the packages


102
00:04:46.954 --> 00:04:49.223 line:-2
in the package collections
that you have configured


103
00:04:49.256 --> 00:04:51.758 line:-2
provide that module
and provide you the opportunity


104
00:04:51.792 --> 00:04:54.795 line:-2
to automatically start using
that package.


105
00:04:54.828 --> 00:04:56.897 line:-2
Once you choose to use
a package,


106
00:04:56.930 --> 00:04:59.032 line:-2
all configuration
is handled for you


107
00:04:59.066 --> 00:05:01.635 line:-2
based on the information
in the package collection.


108
00:05:01.668 --> 00:05:04.538 line:-2
Package collections
are also searchable,


109
00:05:04.571 --> 00:05:08.442 line:-2
making it easy to find packages
to meet your use case.


110
00:05:08.475 --> 00:05:11.712 line:-2
If you are interested in trying
out package collections today,


111
00:05:11.745 --> 00:05:13.480 line:-2
there are some
already available,


112
00:05:13.514 --> 00:05:15.916 line:-2
including a package collection
of the Swift Packages


113
00:05:15.949 --> 00:05:18.385 line:-1
that Apple publishes on GitHub.


114
00:05:18.418 --> 00:05:21.889 line:-2
Xcode comes pre-wired
to use the Apple collection.


115
00:05:23.757 --> 00:05:25.292 line:-2
If you are interested
in learning more


116
00:05:25.325 --> 00:05:27.861 line:-2
about package collections,
including collections


117
00:05:27.895 --> 00:05:29.863 line:-2
already available
from the community,


118
00:05:29.897 --> 00:05:31.999 line:-2
check out the new swift.org
blog post


119
00:05:32.032 --> 00:05:34.835 line:-1
on package collections.


120
00:05:34.868 --> 00:05:38.071 line:-2
Speaking of your favorite APIs,
Apple publishes


121
00:05:38.105 --> 00:05:42.242 line:-2
a growing family
of open source Swift packages.


122
00:05:42.276 --> 00:05:44.077 line:-2
In addition
to some big enhancements


123
00:05:44.111 --> 00:05:46.580 line:-2
to your favorite packages,
this year,


124
00:05:46.613 --> 00:05:48.849 line:-2
we launched
four more new packages.


125
00:05:48.882 --> 00:05:52.386 line:-2
First, I'd like to tell you
about Swift Collections.


126
00:05:55.656 --> 00:05:59.193 line:-2
Swift Collections is a new
open source package


127
00:05:59.226 --> 00:06:01.695 line:-2
of data structures
that complements those available


128
00:06:01.728 --> 00:06:04.531 line:-1
in the Swift Standard Library.


129
00:06:04.565 --> 00:06:06.867 line:-2
The initial version
of Swift Collections


130
00:06:06.900 --> 00:06:08.702 line:-2
comes with implementations
for three


131
00:06:08.735 --> 00:06:11.305 line:-2
of the most frequently requested
data structures:


132
00:06:11.338 --> 00:06:15.075 line:-2
Deque, OrderedSet,
and OrderedDictionary.


133
00:06:16.777 --> 00:06:19.746 line:-2
Deque is like an Array,
except that it supports


134
00:06:19.780 --> 00:06:24.484 line:-2
efficient insertion
and removal at both ends.


135
00:06:24.518 --> 00:06:29.189 line:-2
OrderedSet is a powerful hybrid
of an Array and a Set.


136
00:06:29.223 --> 00:06:33.026 line:-2
Like Array, OrderedSet
maintains its elements in order


137
00:06:33.060 --> 00:06:34.928 line:-1
and supports random access.


138
00:06:34.962 --> 00:06:37.931 line:-2
Like a Set,
OrderedSet ensures each element


139
00:06:37.965 --> 00:06:41.568 line:-2
appears only once and provides
efficient membership testing.


140
00:06:43.270 --> 00:06:46.707 line:-2
And last is OrderedDictionary,
which is a useful alternative


141
00:06:46.740 --> 00:06:49.343 line:-2
to Dictionary
when order is important,


142
00:06:49.376 --> 00:06:52.679 line:-2
or we need
random access to elements.


143
00:06:52.713 --> 00:06:56.850 line:-2
Next, let's talk
about Swift Algorithms.


144
00:06:56.884 --> 00:06:59.686 line:-2
Swift Algorithms is
a new open source package


145
00:06:59.720 --> 00:07:01.955 line:-2
of Sequence
and Collection algorithms.


146
00:07:03.524 --> 00:07:08.028 line:-2
We've already added over 40
algorithms to Swift Algorithms


147
00:07:08.061 --> 00:07:12.299 line:-2
for things like generating all
the combinations or permutations


148
00:07:12.332 --> 00:07:15.302 line:-2
of a collection of elements,
or iterating the elements


149
00:07:15.335 --> 00:07:18.272 line:-2
of a sequence by two
or three or in groups


150
00:07:18.305 --> 00:07:20.807 line:-1
determined by a predicate,


151
00:07:20.841 --> 00:07:24.711 line:-2
or selecting the five smallest
elements in a collection,


152
00:07:24.745 --> 00:07:28.048 line:-2
the five largest,
or just any five at random.


153
00:07:29.283 --> 00:07:32.119 line:-2
It takes a little investment
to learn the vocabulary,


154
00:07:32.152 --> 00:07:34.721 line:-2
but once you do,
it can be striking to discover


155
00:07:34.755 --> 00:07:37.558 line:-2
just how many algorithms
are hiding in plain sight.


156
00:07:38.559 --> 00:07:40.794 line:-3
If you want to learn more,
we have a session


157
00:07:40.827 --> 00:07:43.430 line:-3
which describes
how the new Swift Algorithms


158
00:07:43.463 --> 00:07:46.133 line:-3
and Collections packages
can help you make your code


159
00:07:46.166 --> 00:07:49.303 line:-3
clearer, faster,
and more correct.


160
00:07:49.336 --> 00:07:51.772 line:-2
Now, let's talk
about Swift System.


161
00:07:51.805 --> 00:07:55.108 line:-2
Last fall,
we open-sourced Swift System,


162
00:07:55.142 --> 00:07:56.977 line:-1
a library providing idiomatic,


163
00:07:57.010 --> 00:08:00.180 line:-2
low-level interfaces
to system calls.


164
00:08:00.214 --> 00:08:02.950 line:-2
System is available
on Apple platforms,


165
00:08:02.983 --> 00:08:05.319 line:-1
Linux, and even Windows.


166
00:08:05.352 --> 00:08:07.754 line:-2
We recently added
powerful new APIs


167
00:08:07.788 --> 00:08:09.456 line:-1
to System's FilePath type


168
00:08:09.489 --> 00:08:12.726 line:-2
for performing common path
manipulation operations.


169
00:08:12.759 --> 00:08:16.763 line:-2
These include the ability
to query or set extensions,


170
00:08:16.797 --> 00:08:21.368 line:-2
add and remove components,
and perform path normalization.


171
00:08:21.401 --> 00:08:25.138 line:-2
A path can be decomposed
into its root


172
00:08:25.172 --> 00:08:27.608 line:-1
and its relative components.


173
00:08:27.641 --> 00:08:30.310 line:-2
FilePath's ComponentView
is a collection


174
00:08:30.344 --> 00:08:33.347 line:-2
of structured path components,
meaning it comes with support


175
00:08:33.380 --> 00:08:36.517 line:-2
for many of Swift's generic
algorithms right out of the box.


176
00:08:38.018 --> 00:08:40.888 line:-2
And when targeting Windows,
Windows paths,


177
00:08:40.921 --> 00:08:42.990 line:-2
with their complex
root components,


178
00:08:43.023 --> 00:08:47.127 line:-2
are fully supported
by all the new FilePath APIs.


179
00:08:47.160 --> 00:08:51.431 line:-2
Next, let's talk
about Swift Numerics.


180
00:08:51.465 --> 00:08:55.369 line:-2
Swift Numerics received a number
of big additions this year.


181
00:08:55.402 --> 00:09:00.807 line:-2
We brought Float16 to iOS,
tvOS, and watchOS last year.


182
00:09:00.841 --> 00:09:05.245 line:-2
This year, we added Float16
support to Apple Silicon Macs


183
00:09:05.279 --> 00:09:09.516 line:-2
and the ability to make
Float16-based complex numbers.


184
00:09:09.550 --> 00:09:13.020 line:-2
Another addition this year
is complex number support


185
00:09:13.053 --> 00:09:14.621 line:-2
for all
the elementary functions,


186
00:09:14.655 --> 00:09:18.192 line:-1
like log, sine, and cosine.


187
00:09:18.225 --> 00:09:20.861 line:-2
Because these implementations
are written in Swift,


188
00:09:20.894 --> 00:09:22.362 line:-2
they are frequently
more efficient


189
00:09:22.396 --> 00:09:25.499 line:-2
than a traditional C library
and allow for optimizations


190
00:09:25.532 --> 00:09:28.135 line:-2
that would otherwise
not be possible.


191
00:09:28.168 --> 00:09:32.139 line:-2
Finally, let's talk
about Swift ArgumentParser.


192
00:09:32.172 --> 00:09:35.275 line:-2
We've continued to refine
Swift ArgumentParser this year,


193
00:09:35.309 --> 00:09:38.145 line:-2
with enhancements like
the ability to generate


194
00:09:38.178 --> 00:09:40.547 line:-2
code-completion scripts
for the Fish shell,


195
00:09:40.581 --> 00:09:44.585 line:-2
joined short options,
and improved error messages.


196
00:09:44.618 --> 00:09:46.820 line:-2
We also passed
an important milestone


197
00:09:46.854 --> 00:09:49.356 line:-2
this spring when
ArgumentParser was adopted


198
00:09:49.389 --> 00:09:53.060 line:-2
by the Swift Package Manager
in Xcode 12.5.


199
00:09:53.093 --> 00:09:54.461 line:-1
That's right!


200
00:09:54.494 --> 00:09:56.296 line:-2
If you've used
the Swift Package Manager


201
00:09:56.330 --> 00:09:58.031 line:-1
command-line tool recently,


202
00:09:58.065 --> 00:10:01.101 line:-2
you've used
Swift ArgumentParser.


203
00:10:01.134 --> 00:10:04.171 line:-2
Next, I'd like to talk
about some work we've done


204
00:10:04.204 --> 00:10:07.374 line:-2
to support Swift
on server development.


205
00:10:07.407 --> 00:10:10.811 line:-2
Last year, we added support
for a number of platforms,


206
00:10:10.844 --> 00:10:12.946 line:-1
including Amazon Linux.


207
00:10:12.980 --> 00:10:16.250 line:-2
This year, we've followed up
on that work by investing


208
00:10:16.283 --> 00:10:19.953 line:-2
in performance and functionality
for Swift server applications.


209
00:10:21.121 --> 00:10:24.057 line:-2
We started by enabling
static linking on Linux,


210
00:10:24.091 --> 00:10:26.393 line:-2
which improves
application startup time,


211
00:10:26.426 --> 00:10:28.128 line:-2
as well as simplifies
the deployment


212
00:10:28.161 --> 00:10:29.763 line:-1
of server applications,


213
00:10:29.796 --> 00:10:32.699 line:-2
which can now be deployed
as a single file.


214
00:10:32.733 --> 00:10:36.904 line:-2
Also, in Swift 5.5,
the JSON encoding and decoding


215
00:10:36.937 --> 00:10:40.007 line:-2
used on Linux were
reimplemented from scratch,


216
00:10:40.040 --> 00:10:44.378 line:-2
resulting in performance gains
for most common use cases.


217
00:10:44.411 --> 00:10:47.648 line:-2
Finally, we've enhanced
and optimized the performance


218
00:10:47.681 --> 00:10:51.685 line:-2
of the AWS Lambda
runtime library itself.


219
00:10:51.718 --> 00:10:56.023 line:-2
All this work made Swift
programs running on AWS Lambda


220
00:10:56.056 --> 00:10:59.293 line:-1
start 33% faster,


221
00:10:59.326 --> 00:11:02.796 line:-2
as well as 40% faster
invocation time


222
00:11:02.829 --> 00:11:06.533 line:-2
for a lambda routed
via AWS API Gateway.


223
00:11:06.567 --> 00:11:07.901 line:-1
In addition to optimizing


224
00:11:07.935 --> 00:11:10.537 line:-2
the AWS runtime
library performance,


225
00:11:10.571 --> 00:11:13.774 line:-2
we refactored it to use
our new async/await model


226
00:11:13.807 --> 00:11:16.376 line:-1
instead of closures.


227
00:11:16.410 --> 00:11:18.478 line:-2
Improving the Swift
developer experience


228
00:11:18.512 --> 00:11:21.682 line:-2
is another key focus
in Swift 5.5.


229
00:11:21.715 --> 00:11:25.252 line:-2
I'd like to start by talking
about documentation.


230
00:11:25.285 --> 00:11:29.389 line:-2
Providing great documentation
is key for creating a smooth


231
00:11:29.423 --> 00:11:33.227 line:-2
and enjoyable experience
for users of a framework.


232
00:11:33.260 --> 00:11:36.296 line:-2
This year,
we are introducing DocC,


233
00:11:36.330 --> 00:11:39.266 line:-2
a documentation compiler
that's deeply integrated


234
00:11:39.299 --> 00:11:42.302 line:-2
inside Xcode 13,
to help you teach developers


235
00:11:42.336 --> 00:11:45.205 line:-2
how to use your Swift framework
or package.


236
00:11:45.239 --> 00:11:48.175 line:-2
It's now easier than ever
to write and share


237
00:11:48.208 --> 00:11:50.110 line:-1
great documentation.


238
00:11:51.378 --> 00:11:53.881 line:-2
DocC is built
from the ground up,


239
00:11:53.914 --> 00:11:56.817 line:-2
using tools and technologies
that you already know and love,


240
00:11:56.850 --> 00:11:59.820 line:-2
such as markdown comments
in your Swift source code,


241
00:11:59.853 --> 00:12:02.756 line:-2
so that you can easily write
and diff your documentation.


242
00:12:04,591 --> 00:12:07,127
We have four fantastic sessions
to show you


243
00:12:07,160 --> 00:12:10,631
every aspect of DocC
documentation in Xcode.


244
00:12:10,664 --> 00:12:13,433
I highly recommend
you check them out.


245
00:12:13.467 --> 00:12:16.737 line:-2
And now,
I'm thrilled to announce


246
00:12:16.770 --> 00:12:20.073 line:-2
that Swift DocC will be
open-sourced later this year.


247
00:12:20.107 --> 00:12:23.043 line:-2
Open-sourcing Swift DocC
will allow developers


248
00:12:23.076 --> 00:12:25.646 line:-2
to more easily generate
great documentation


249
00:12:25.679 --> 00:12:28.682 line:-2
on all of Swift's
supported platforms.


250
00:12:30.450 --> 00:12:33.353 line:-2
In Swift 5.5,
we invested in quality


251
00:12:33.387 --> 00:12:36.023 line:-2
and performance improvements
in the type checker.


252
00:12:36.056 --> 00:12:38.792 line:-2
One result of this is
you will see fewer


253
00:12:38.825 --> 00:12:43.297 line:-2
"expression too complex" errors
when compiling your code.


254
00:12:43.330 --> 00:12:45.065 line:-1
We also sped up the performance


255
00:12:45.098 --> 00:12:47.134 line:-2
for type checking
of array literals.


256
00:12:48.769 --> 00:12:52.406 line:-2
In this release, we're also
enhancing developer productivity


257
00:12:52.439 --> 00:12:56.677 line:-2
with three major improvements
to speed up incremental builds.


258
00:12:56.710 --> 00:13:00.280 line:-2
First of all, we now support
incremental imports,


259
00:13:00.314 --> 00:13:03.083 line:-2
meaning we now no longer rebuild
every source file


260
00:13:03.116 --> 00:13:06.687 line:-2
that imports a module
when that module changes.


261
00:13:06.720 --> 00:13:08.622 line:-1
In addition, we now compute


262
00:13:08.655 --> 00:13:11.024 line:-2
the module dependency graph
up front


263
00:13:11.058 --> 00:13:12.993 line:-2
so that we can quickly start
incremental builds


264
00:13:13.026 --> 00:13:15.329 line:-1
of only what has changed.


265
00:13:15.362 --> 00:13:18.298 line:-2
Finally, we've extended
selective recompilation


266
00:13:18.332 --> 00:13:21.435 line:-2
to work with extensions,
meaning fewer recompilations


267
00:13:21.468 --> 00:13:25.105 line:-2
when you change the body
of an extension.


268
00:13:25.138 --> 00:13:28.709 line:-3
Using the SwiftDriver open
source project as an example,


269
00:13:28.742 --> 00:13:30.811 line:-3
on the average,
with incremental imports


270
00:13:30.844 --> 00:13:33.514 line:-3
in Swift 5.5, we now recompile


271
00:13:33.547 --> 00:13:38.418 line:-3
less than a tenth as many files
when imported modules change,


272
00:13:38.452 --> 00:13:43.190 line:-3
and the build time
is decreased by about a third.


273
00:13:43.223 --> 00:13:45.959 line:-3
The performance improvements
from incremental imports


274
00:13:45.993 --> 00:13:48.462 line:-4
means that you can now
modularize your project


275
00:13:48.495 --> 00:13:49.997 line:-3
and change an imported module


276
00:13:50.030 --> 00:13:52.900 line:-3
without a large penalty
in build performance.


277
00:13:52.933 --> 00:13:56.637 line:-2
And by the way, some of these
performance improvements


278
00:13:56.670 --> 00:13:59.206 line:-2
were made possible
by an important milestone


279
00:13:59.239 --> 00:14:00.707 line:-1
for the Swift project,


280
00:14:00.741 --> 00:14:04.511 line:-2
the first part of the compiler
to be written in Swift.


281
00:14:04.545 --> 00:14:07.781 line:-2
This is the Swift Driver,
the program that coordinates


282
00:14:07.814 --> 00:14:10.184 line:-2
the compilation
of Swift source code.


283
00:14:10.217 --> 00:14:14.655 line:-2
This project began in late 2019
and, as of Xcode 13,


284
00:14:14.688 --> 00:14:17.824 line:-2
is now the default
for Swift compilation.


285
00:14:17.858 --> 00:14:20.460 line:-2
Finally, let's talk about
improvements we've made


286
00:14:20.494 --> 00:14:23.830 line:-2
to make memory management
in Swift more efficient,


287
00:14:23.864 --> 00:14:27.501 line:-2
so Swift programs reclaim
memory more quickly.


288
00:14:27.534 --> 00:14:29.436 line:-1
Swift class instances use


289
00:14:29.469 --> 00:14:32.105 line:-2
Automatic Reference Counting,
ARC,


290
00:14:32.139 --> 00:14:33.841 line:-2
to track how many
references there are


291
00:14:33.874 --> 00:14:37.110 line:-2
to a particular object
at any given time.


292
00:14:37.144 --> 00:14:40.581 line:-2
In most cases, this means
that memory management


293
00:14:40.614 --> 00:14:43.217 line:-2
just works in Swift,
and you don't need


294
00:14:43.250 --> 00:14:46.086 line:-2
to think about
memory management yourself.


295
00:14:46.119 --> 00:14:48.088 line:-1
ARC automatically frees up


296
00:14:48.121 --> 00:14:50.123 line:-2
the memory used
by class instances


297
00:14:50.157 --> 00:14:52.960 line:-2
when those instances
are no longer needed.


298
00:14:52.993 --> 00:14:57.064 line:-2
To do this, the Swift compiler
inserts a retain operation


299
00:14:57.097 --> 00:14:59.566 line:-2
any time a new reference
is created


300
00:14:59.600 --> 00:15:01.068 line:-1
and a release operation


301
00:15:01.101 --> 00:15:04.238 line:-2
whenever a new reference
stops being used.


302
00:15:04.271 --> 00:15:06.573 line:-2
This year,
we introduced a new way


303
00:15:06.607 --> 00:15:08.909 line:-2
to track references
inside the compiler


304
00:15:08.942 --> 00:15:11.578 line:-2
that allows the compiler
to significantly reduce


305
00:15:11.612 --> 00:15:14.648 line:-2
the number of retain
and release operations.


306
00:15:14.681 --> 00:15:17.084 line:-2
We've seen measurable
performance and code size


307
00:15:17.117 --> 00:15:20.020 line:-1
improvements from this change.


308
00:15:20.053 --> 00:15:24.191 line:-2
We've added an Xcode setting,
Optimize Object Lifetimes,


309
00:15:24.224 --> 00:15:26.527 line:-2
that will allow you to see
the effect of this new,


310
00:15:26.560 --> 00:15:30.030 line:-2
more aggressive ARC
optimization on your code.


311
00:15:30,063 --> 00:15:32,032
For more information on ARC,


312
00:15:32,065 --> 00:15:34,501
please check out
the "ARC in Swift" session.


313
00:15:36.470 --> 00:15:38.071 line:-2
These are just some
of the improvements


314
00:15:38.105 --> 00:15:40.374 line:-1
brought to you by Swift 5.5.


315
00:15:40.407 --> 00:15:43.443 line:-2
Next, Tim will talk to you
about Swift Concurrency


316
00:15:43.477 --> 00:15:46.713 line:-2
and other evolutions
in the Swift language.


317
00:15:46.747 --> 00:15:48.348 line:-1
[Tim] Thanks, Nicole.


318
00:15:48.382 --> 00:15:50.250 line:-2
We're all very excited
about Swift Concurrency,


319
00:15:50.284 --> 00:15:53.320 line:-2
but before I get to that,
I want to discuss a number


320
00:15:53.353 --> 00:15:54.988 line:-2
of other changes
we've made to Swift


321
00:15:55.022 --> 00:15:58.192 line:-2
to simplify and improve
everyday programming.


322
00:15:59.526 --> 00:16:01.228 line:-2
Here's a list
of the ergonomic improvements


323
00:16:01.261 --> 00:16:02.663 line:-1
we've made this year.


324
00:16:02.696 --> 00:16:06.900 line:-2
The SE numbers identify
Swift Evolution proposals.


325
00:16:06.934 --> 00:16:09.169 line:-2
Each of these proposals
was written by a member


326
00:16:09.203 --> 00:16:12.439 line:-2
of the community, discussed
on the Swift Evolution forum,


327
00:16:12.472 --> 00:16:14.608 line:-2
and approved
by the Swift Core Team


328
00:16:14.641 --> 00:16:16.910 line:-2
before being accepted
into the language.


329
00:16:16.944 --> 00:16:19.980 line:-2
All SE proposals,
whether accepted, rejected,


330
00:16:20.013 --> 00:16:22.282 line:-2
or still in discussion,
can be found


331
00:16:22.316 --> 00:16:24.985 line:-2
in the Swift Evolution
repository on GitHub.


332
00:16:25.018 --> 00:16:27.921 line:-2
Let's look
at a few of these changes.


333
00:16:27.955 --> 00:16:30.858 line:-1
First, Result Builders.


334
00:16:30.891 --> 00:16:33.026 line:-2
When SwiftUI
was first announced,


335
00:16:33.060 --> 00:16:35.629 line:-2
it introduced a new syntax
that could be used


336
00:16:35.662 --> 00:16:39.900 line:-2
to quickly and easily describe
complex object hierarchies.


337
00:16:39.933 --> 00:16:43.570 line:-2
This past year, that syntax
was standardized and refined


338
00:16:43.604 --> 00:16:46.139 line:-2
through the Swift Evolution
process so that it could be


339
00:16:46.173 --> 00:16:49.910 line:-2
more easily used
in a wide variety of contexts.


340
00:16:49,943 --> 00:16:52,813
If you'd like to take advantage
of this powerful technology,


341
00:16:52,846 --> 00:16:54,815
we have a session
specifically devoted


342
00:16:54,848 --> 00:16:57,551
to using Result Builders.


343
00:16:57.584 --> 00:16:59.086 line:-1
The Codable protocol


344
00:16:59.119 --> 00:17:01.388 line:-2
is a convenient way
to serialize your data,


345
00:17:01.421 --> 00:17:04.725 line:-2
but it's long suffered
from a notable omission.


346
00:17:04.758 --> 00:17:07.895 line:-1
Consider this two-case Enum.


347
00:17:07.928 --> 00:17:11.331 line:-2
In order to make it conform
to Codable, you used to have


348
00:17:11.365 --> 00:17:15.235 line:-2
to manually implement
all of this boilerplate.


349
00:17:15.269 --> 00:17:18.305 line:-2
Now, you just need to declare
the Codable conformance,


350
00:17:18.338 --> 00:17:20.574 line:-2
and the compiler will do
all of that work for you.


351
00:17:22.342 --> 00:17:24.178 line:-2
We also made
some key improvements


352
00:17:24.211 --> 00:17:26.113 line:-1
to Swift's type checker.


353
00:17:26.146 --> 00:17:29.016 line:-2
As you know,
type inference in Swift


354
00:17:29.049 --> 00:17:31.818 line:-2
means you can omit
redundant type information.


355
00:17:31.852 --> 00:17:34.421 line:-2
Here, it lets you shorten
Coffee.regular


356
00:17:34.454 --> 00:17:37.524 line:-1
down to just .regular.


357
00:17:37,558 --> 00:17:40,527
But Enum-like structures are
also represented in other ways.


358
00:17:40,561 --> 00:17:43,897
For example, you might have
a collection of types


359
00:17:43,931 --> 00:17:45,465
that conform to a protocol


360
00:17:45,499 --> 00:17:50,037
and want to use instances
of those types in your API.


361
00:17:50,070 --> 00:17:52,739
You can now refer to instances
of those types


362
00:17:52,773 --> 00:17:56,643
using the same dot-notation
that you use for Enums,


363
00:17:56,677 --> 00:18:00,714
by declaring a few static
properties on your protocol.


364
00:18:00,747 --> 00:18:03,450
This is enabled by improvements
to Swift's type checker


365
00:18:03,483 --> 00:18:05,619
that allows it to reason
more generally


366
00:18:05,652 --> 00:18:08,255
about static properties
in generic contexts,


367
00:18:08,288 --> 00:18:10,657
including chained
property references


368
00:18:10,691 --> 00:18:12,793
such as the .large here.


369
00:18:12,826 --> 00:18:16,663
This allows library authors
to build sophisticated generic


370
00:18:16,697 --> 00:18:21,635
data models with natural
and easy-to-use Enum-like APIs.


371
00:18:23.270 --> 00:18:25.672 line:-2
Property wrappers were
also improved this year.


372
00:18:27,074 --> 00:18:29,109
Property wrappers
are a convenient tool


373
00:18:29,142 --> 00:18:31,745
for applying common
semantics to properties.


374
00:18:31,778 --> 00:18:34,014
Many of you have implemented
your own property wrappers


375
00:18:34,047 --> 00:18:37,484
using the @propertyWrapper
annotation on a struct.


376
00:18:37,518 --> 00:18:39,686
Here's an example
that adds the requirement


377
00:18:39,720 --> 00:18:42,789
that the property not be empty.


378
00:18:42,823 --> 00:18:46,026
With the implementation
of SE-0293,


379
00:18:46,059 --> 00:18:48,495
those same property wrappers
can now be used


380
00:18:48,529 --> 00:18:50,697
on function
and closure parameters.


381
00:18:52,432 --> 00:18:55,002
Cumulatively,
these and other changes


382
00:18:55,035 --> 00:18:58,338
to the language can simplify
a lot of common coding problems.


383
00:18:58.372 --> 00:19:00.307 line:-2
Let's look at them together
in the context


384
00:19:00.340 --> 00:19:02.976 line:-1
of a simple SwiftUI code sample.


385
00:19:03.010 --> 00:19:07.047 line:-2
Here's a SwiftUI View
that has a single property,


386
00:19:07.080 --> 00:19:11.652 line:-2
holding an array of settings,
and a body that presents


387
00:19:11.685 --> 00:19:16.356 line:-2
a list of those settings,
with a toggle next to each one.


388
00:19:16.390 --> 00:19:18.859 line:-2
Let's review this code
and see how


389
00:19:18.892 --> 00:19:22.029 line:-2
the new Swift 5.5 features
can simplify it.


390
00:19:22.062 --> 00:19:26.733 line:-2
First, that Toggle() initializer
is obviously duplicated.


391
00:19:26,767 --> 00:19:29,603
This duplication
used to be necessary,


392
00:19:29,636 --> 00:19:32,639
but we've relaxed the use
of #if to allow it to surround


393
00:19:32,673 --> 00:19:34,975
postfix expressions,
such as the toggleStyle


394
00:19:35,008 --> 00:19:37,411
modifiers here, which allows us


395
00:19:37,444 --> 00:19:40,447
to factor out that redundancy.


396
00:19:40.480 --> 00:19:43.917 line:-2
SwiftUI has also been updated
to take advantage of the new


397
00:19:43.951 --> 00:19:46.220 line:-2
type checker improvements
I mentioned earlier.


398
00:19:46.253 --> 00:19:48.689 line:-2
So you can use
natural dot-notation


399
00:19:48.722 --> 00:19:51.391 line:-1
in many more places.


400
00:19:51.425 --> 00:19:53.760 line:-1
It's--it's a little awkward


401
00:19:53.794 --> 00:19:55.863 line:-2
to specify indexes
for the settings array


402
00:19:55.896 --> 00:19:58.498 line:-2
and then index the array
within the closure.


403
00:19:58.532 --> 00:20:01.134 line:-2
We'd rather just step
through the values.


404
00:20:01.168 --> 00:20:03.437 line:-2
Now you can pass
the projected binding


405
00:20:03.470 --> 00:20:05.205 line:-2
directly into
the List constructor,


406
00:20:05.239 --> 00:20:08.442 line:-2
which can then iterate
over the array values.


407
00:20:08.475 --> 00:20:10.744 line:-2
The new support
for property wrapper arguments


408
00:20:10.777 --> 00:20:13.780 line:-2
lets us write the closure
argument with a dollar sign,


409
00:20:13.814 --> 00:20:16.116 line:-2
which will give us
a bound setting in our closure.


410
00:20:16.149 --> 00:20:18.452 line:-2
That, in turn,
allows us to access


411
00:20:18.485 --> 00:20:21.321 line:-2
both the wrapped value
and the binding.


412
00:20:21,355 --> 00:20:25,125
And finally, the Swift compiler
now transparently converts


413
00:20:25,158 --> 00:20:27,027
between CGFloat and Double,


414
00:20:27,060 --> 00:20:29,396
which allows you to eliminate
many redundant numeric


415
00:20:29,429 --> 00:20:33,000
conversions when working
with Apple platform APIs.


416
00:20:33.033 --> 00:20:35.269 line:-2
As you see,
our continuing effort


417
00:20:35.302 --> 00:20:38.305 line:-2
to refine the core language
is making the code you write


418
00:20:38.338 --> 00:20:42.142 line:-2
every day simpler than ever
and creating more opportunities


419
00:20:42.176 --> 00:20:46.446 line:-2
for library authors to build
rich and easy-to-use APIs.


420
00:20:46,480 --> 00:20:48,549
For more information
about some of the many ways


421
00:20:48,582 --> 00:20:50,817
that SwiftUI programming
has been improved this year,


422
00:20:50,851 --> 00:20:54,388
please watch the "What's new
in SwiftUI" session.


423
00:20:54.421 --> 00:20:57.824 line:-2
Of course,
the highlight of Swift 5.5


424
00:20:57.858 --> 00:21:00.093 line:-2
is a set
of interlocking features


425
00:21:00.127 --> 00:21:03.130 line:-2
to support asynchronous
and concurrent programming.


426
00:21:03.163 --> 00:21:05.332 line:-2
I'll introduce these
in a moment, but first,


427
00:21:05.365 --> 00:21:08.402 line:-2
let me briefly explain
what I mean by "asynchronous"


428
00:21:08.435 --> 00:21:10.370 line:-1
and "concurrent."


429
00:21:10.404 --> 00:21:12.339 line:-1
Software projects are composed


430
00:21:12.372 --> 00:21:15.943 line:-2
out of blocks of code
that execute in some order.


431
00:21:15.976 --> 00:21:18.111 line:-2
In the simplest case,
those blocks execute,


432
00:21:18.145 --> 00:21:20.681 line:-2
one after the other
in a simple sequence.


433
00:21:20.714 --> 00:21:22.916 line:-2
But other structures
are common as well.


434
00:21:22,950 --> 00:21:26,620
For example, networking APIs
are often designed


435
00:21:26,653 --> 00:21:29,056
in an asynchronous style.


436
00:21:29,089 --> 00:21:31,491
In these APIs,
after you've sent a request


437
00:21:31,525 --> 00:21:34,595
to the remote server,
there may be a long delay


438
00:21:34,628 --> 00:21:37,831
until you receive a response
and need to do more work.


439
00:21:37,865 --> 00:21:40,234
Ideally, your code
would be suspended


440
00:21:40,267 --> 00:21:42,636
during this delay
so it does not use any resources


441
00:21:42,669 --> 00:21:46,073
until you are able
to act on the response.


442
00:21:46,106 --> 00:21:49,109
In contrast,
concurrent code is when


443
00:21:49,142 --> 00:21:51,512
you have two or more
blocks of code


444
00:21:51,545 --> 00:21:54,715
that you would like to have
running at the same time.


445
00:21:54,748 --> 00:21:57,818
These are often independent
but related operations.


446
00:21:57,851 --> 00:21:59,887
Processing several frames
of a video, for instance,


447
00:21:59,920 --> 00:22:01,488
or running the next iteration


448
00:22:01.522 --> 00:22:03.924 line:-2
of an ML classifier
at the same time


449
00:22:03,957 --> 00:22:05,292
that you're updating the UI


450
00:22:05,325 --> 00:22:07,895
with the previous set
of results.


451
00:22:07.928 --> 00:22:10.063 line:-1
With those ideas in mind,


452
00:22:10.097 --> 00:22:13.233 line:-2
let's look at a simple
asynchronous programming example


453
00:22:13.267 --> 00:22:17.171 line:-2
without using
Swift's new features.


454
00:22:17.204 --> 00:22:20.240 line:-2
If you've done much
iOS or macOS programming,


455
00:22:20.274 --> 00:22:24.178 line:-2
you may have written code
similar to this many times.


456
00:22:24.211 --> 00:22:26.346 line:-2
This uses Foundation's
URLSession class


457
00:22:26.380 --> 00:22:27.714 line:-1
to make a network call.


458
00:22:27.748 --> 00:22:30.884 line:-2
The dataTask method
is an asynchronous operation.


459
00:22:30.918 --> 00:22:32.786 line:-2
You call it
with a closure argument.


460
00:22:32.819 --> 00:22:34.288 line:-2
When the result
becomes available,


461
00:22:34.321 --> 00:22:37.925 line:-2
your closure will be called
with the results to process.


462
00:22:37.958 --> 00:22:41.461 line:-2
Using closures in this way
to express asynchronous code


463
00:22:41.495 --> 00:22:44.498 line:-2
results in a somewhat awkward
order of operations, though,


464
00:22:44.531 --> 00:22:47.367 line:-2
as you can see
by walking through this code.


465
00:22:47.401 --> 00:22:49.136 line:-2
First, there's
some initial setup,


466
00:22:49.169 --> 00:22:53.440 line:-2
and the dataTask method
gives us back a task handle.


467
00:22:53.473 --> 00:22:55.175 line:-1
Then we resume the task handle


468
00:22:55.209 --> 00:22:57.878 line:-2
to start
the background operation.


469
00:22:57.911 --> 00:23:01.748 line:-2
The fetchImage function
actually returns at this point.


470
00:23:01.782 --> 00:23:04.318 line:-2
Whoever called us must be
ready to continue,


471
00:23:04.351 --> 00:23:06.653 line:-2
even though we haven't
actually done the work


472
00:23:06.687 --> 00:23:08.622 line:-1
we were asked to do.


473
00:23:08.655 --> 00:23:11.658 line:-2
Later, after the network
operation finishes,


474
00:23:11.692 --> 00:23:13.694 line:-2
this closure will have a chance
to deal with the results.


475
00:23:13.727 --> 00:23:16.330 line:-2
Hopefully, everything goes well,
and we can


476
00:23:16.363 --> 00:23:20.601 line:-2
call our completion handler
with the final result.


477
00:23:20.634 --> 00:23:23.604 line:-2
Besides the somewhat awkward
order of execution,


478
00:23:23.637 --> 00:23:26.306 line:-2
using completion handlers
also prevents us


479
00:23:26.340 --> 00:23:28.942 line:-2
from using
try/catch error handling.


480
00:23:28.976 --> 00:23:32.212 line:-2
Notice how dataTask provides
an extra error parameter


481
00:23:32.246 --> 00:23:35.115 line:-2
to its completion handler
and how we have to invoke


482
00:23:35.148 --> 00:23:38.886 line:-2
our completion handler
with every possible error.


483
00:23:38.919 --> 00:23:41.755 line:-2
To see how
Swift 5.5 improves this,


484
00:23:41.788 --> 00:23:44.858 line:-2
let's take a look
at this one line of code.


485
00:23:44.892 --> 00:23:47.828 line:-2
Notice how this call
returns a task,


486
00:23:47.861 --> 00:23:49.229 line:-1
an abstract handle


487
00:23:49.263 --> 00:23:51.965 line:-2
that represents
the background operation.


488
00:23:51.999 --> 00:23:53.934 line:-1
That's not really what we want.


489
00:23:53.967 --> 00:23:55.802 line:-1
We just want to get the data.


490
00:23:55.836 --> 00:23:59.473 line:-2
So let's push that idea a bit
and see where we end up.


491
00:23:59.506 --> 00:24:01.141 line:-1
Since we're dealing with HTTP,


492
00:24:01.175 --> 00:24:03.844 line:-2
we also need to capture
some response metadata.


493
00:24:03.877 --> 00:24:06.280 line:-2
So the function is really
going to return a pair,


494
00:24:06.313 --> 00:24:08.582 line:-2
with the actual data
as the first item


495
00:24:08.615 --> 00:24:11.418 line:-2
and additional information
as the second.


496
00:24:11.451 --> 00:24:13.353 line:-2
By structuring this
as a function call


497
00:24:13.387 --> 00:24:15.856 line:-2
that returns the data,
we can now use


498
00:24:15.889 --> 00:24:18.225 line:-2
try/catch error handling
to eliminate


499
00:24:18.258 --> 00:24:21.428 line:-2
a lot of the boilerplate
from the previous example.


500
00:24:21.461 --> 00:24:24.932 line:-2
We just need a bit of syntax
to tell the compiler


501
00:24:24.965 --> 00:24:26.633 line:-2
that our function
can be suspended


502
00:24:26.667 --> 00:24:28.936 line:-2
as soon
as the data method begins


503
00:24:28.969 --> 00:24:31.338 line:-2
and that we won't be able
to finish the assignment


504
00:24:31.371 --> 00:24:34.241 line:-2
until that operation
has completed.


505
00:24:34.274 --> 00:24:37.377 line:-2
Which is exactly what
the new await keyword does.


506
00:24:37.411 --> 00:24:40.347 line:-1
Let's look at that in context.


507
00:24:40.380 --> 00:24:43.650 line:-2
Here's what our fetchImage
function looks like now.


508
00:24:43.684 --> 00:24:46.687 line:-2
As you see, this code is
now much easier to follow.


509
00:24:46.720 --> 00:24:49.056 line:-2
Control flows
from top to bottom,


510
00:24:49.089 --> 00:24:51.191 line:-2
we no longer need
nested closures,


511
00:24:51.225 --> 00:24:53.694 line:-2
and we can use
try/catch error handling.


512
00:24:53.727 --> 00:24:55.629 line:-2
The await keyword
indicates a point


513
00:24:55.662 --> 00:24:58.532 line:-2
where this fetchImage function
can be suspended,


514
00:24:58.565 --> 00:25:00.701 line:-1
set aside to not run


515
00:25:00.734 --> 00:25:03.570 line:-2
until some event happens
that allows it to continue.


516
00:25:05.672 --> 00:25:08.542 line:-2
In this case,
as soon as URLSession


517
00:25:08.575 --> 00:25:10.043 line:-1
initiates the request,


518
00:25:10.077 --> 00:25:12.813 line:-2
our function will be
suspended by the Swift runtime


519
00:25:12.846 --> 00:25:15.215 line:-2
while the operation is
carried out elsewhere.


520
00:25:15.249 --> 00:25:16.950 line:-1
When the final result is ready,


521
00:25:16.984 --> 00:25:20.354 line:-2
whether that's a successful
response or a thrown error,


522
00:25:20.387 --> 00:25:23.257 line:-2
only then will our function
be resumed.


523
00:25:23.290 --> 00:25:25.926 line:-2
If it's a successful response,
we'll complete


524
00:25:25.959 --> 00:25:28.395 line:-2
the initialization of the data
and response variables.


525
00:25:28.428 --> 00:25:29.763 line:-1
If it's a thrown error,


526
00:25:29.796 --> 00:25:32.733 line:-2
we'll pass that back
to whoever called us.


527
00:25:32.766 --> 00:25:35.135 line:-2
An asynchronous function
does not use


528
00:25:35.169 --> 00:25:37.704 line:-2
any resources
while it's suspended.


529
00:25:37.738 --> 00:25:40.674 line:-2
In particular,
it's not blocking a thread.


530
00:25:40.707 --> 00:25:43.744 line:-2
This allows the Swift runtime
to reuse the thread


531
00:25:43.777 --> 00:25:46.446 line:-2
this function was running on
for other work.


532
00:25:46.480 --> 00:25:48.849 line:-2
This allows a very few threads
to be shared


533
00:25:48.882 --> 00:25:51.151 line:-2
among many
asynchronous processes.


534
00:25:52.786 --> 00:25:55.989 line:-2
Syntactically,
the async and await keywords


535
00:25:56.023 --> 00:25:58.492 line:-2
are used similarly
to throws and try.


536
00:25:58.525 --> 00:26:01.962 line:-2
async decorates the function
declaration to indicate


537
00:26:01.995 --> 00:26:05.599 line:-2
that this function must be
compiled to support suspension.


538
00:26:05.632 --> 00:26:08.302 line:-2
Use the await keyword
to mark any call


539
00:26:08.335 --> 00:26:11.672 line:-2
to an async function,
method, or closure.


540
00:26:11,705 --> 00:26:14,074
Of course, the full mechanism
is a lot more interesting


541
00:26:14,107 --> 00:26:15,509
than what I've shown here.


542
00:26:15,542 --> 00:26:18,212
You can watch
the "Meet async/await in Swift"


543
00:26:18,245 --> 00:26:20,547
and "Swift concurrency:
Behind the scenes" sessions


544
00:26:20,581 --> 00:26:23,217
to learn more
about how all of this works.


545
00:26:23.250 --> 00:26:25.919 line:-2
Next, let's take a look at
Swift's new concurrency support,


546
00:26:25.953 --> 00:26:29.423 line:-2
which builds on the async/await
concepts I just described.


547
00:26:30.624 --> 00:26:33.527 line:-2
Here's a function that renders
three different images


548
00:26:33.560 --> 00:26:35.596 line:-1
and then combines them.


549
00:26:35.629 --> 00:26:39.333 line:-2
As written here,
these operations are sequential.


550
00:26:39.366 --> 00:26:41.668 line:-2
The background, foreground,
and title images will be


551
00:26:41.702 --> 00:26:44.705 line:-2
rendered one after the other,
with each one starting


552
00:26:44.738 --> 00:26:47.975 line:-2
only after the previous one
has completed.


553
00:26:48.008 --> 00:26:51.411 line:-2
We'd like for the rendering
operations to occur in parallel.


554
00:26:51.445 --> 00:26:53.146 line:-2
But just running them
in different threads


555
00:26:53.180 --> 00:26:56.383 line:-2
isn't enough:
we also need the merge operation


556
00:26:56.416 --> 00:27:00.187 line:-2
to be held,
until we have all three results.


557
00:27:00.220 --> 00:27:01.622 line:-2
This is similar,
in some respects,


558
00:27:01.655 --> 00:27:04.091 line:-2
to the asynchronous coding
I was just talking about.


559
00:27:04.124 --> 00:27:06.193 line:-1
So we mark this function "async"


560
00:27:06.226 --> 00:27:08.428 line:-2
so that it will be able
to suspend if it needs to wait


561
00:27:08.462 --> 00:27:11.498 line:-2
for results that are being
computed in other threads.


562
00:27:11.532 --> 00:27:14.535 line:-2
Next, we use
the async let syntax


563
00:27:14.568 --> 00:27:17.538 line:-2
to run the first two operations
in parallel.


564
00:27:17.571 --> 00:27:20.407 line:-2
async let looks a lot
like a variable initialization,


565
00:27:20.440 --> 00:27:22.676 line:-1
and that's basically what it is.


566
00:27:22.709 --> 00:27:25.212 line:-2
But this initialization
will run in parallel


567
00:27:25.245 --> 00:27:28.949 line:-2
with other code until you try
to use the results.


568
00:27:28.982 --> 00:27:31.084 line:-2
Because the background
and foreground variables


569
00:27:31.118 --> 00:27:33.654 line:-2
are being initialized
with async let,


570
00:27:33.687 --> 00:27:36.023 line:-2
Swift's runtime will,
if necessary,


571
00:27:36.056 --> 00:27:40.561 line:-2
suspend the merge operation
until those values are ready.


572
00:27:40.594 --> 00:27:43.096 line:-2
We mark the merge function
with the await keyword


573
00:27:43.130 --> 00:27:46.099 line:-1
to indicate this.


574
00:27:46.133 --> 00:27:48.735 line:-2
The most important point
about this code


575
00:27:48.769 --> 00:27:52.773 line:-2
is that the background tasks
cannot outlive this function.


576
00:27:52.806 --> 00:27:54.942 line:-2
Put another way,
this function cannot


577
00:27:54.975 --> 00:27:57.911 line:-2
and will not return if either
of the two background tasks


578
00:27:57.945 --> 00:28:00.247 line:-1
is still running.


579
00:28:00.280 --> 00:28:02.049 line:-2
If an error is
thrown from anywhere


580
00:28:02.082 --> 00:28:04.585 line:-2
inside this function,
the Swift runtime will


581
00:28:04.618 --> 00:28:07.721 line:-2
still wait for the background
tasks to complete.


582
00:28:07.754 --> 00:28:10.891 line:-2
Here, I've highlighted
a try marker that indicates


583
00:28:10.924 --> 00:28:13.293 line:-2
the computation
of the title image may throw,


584
00:28:13.327 --> 00:28:15.495 line:-2
but the same applies
to all thrown errors,


585
00:28:15.529 --> 00:28:17.464 line:-2
even if they occur
in a separate thread.


586
00:28:17.497 --> 00:28:19.166 line:-2
In order
to keep things responsive,


587
00:28:19.199 --> 00:28:21.568 line:-2
when there is a thrown error,
the Swift runtime will signal


588
00:28:21.602 --> 00:28:25.472 line:-2
unfinished tasks to give them
a chance to complete early.


589
00:28:25,506 --> 00:28:27,107
Our session
on structured concurrency


590
00:28:27,140 --> 00:28:30,110
provides more details,
including a full discussion


591
00:28:30,143 --> 00:28:33,347
of this cancellation mechanism
and more flexible alternatives


592
00:28:33,380 --> 00:28:36,283
to the async let syntax
I've discussed here.


593
00:28:36.316 --> 00:28:40.554 line:-2
In the previous section,
I showed how Swift 5.5


594
00:28:40.587 --> 00:28:43.390 line:-2
makes it easy to run operations
on multiple threads


595
00:28:43.423 --> 00:28:45.926 line:-2
in a disciplined,
structured fashion.


596
00:28:45.959 --> 00:28:48.195 line:-2
Of course,
that's not quite enough.


597
00:28:48.228 --> 00:28:50.831 line:-2
Whenever two separate threads
share data,


598
00:28:50.864 --> 00:28:53.600 line:-2
you run the risk that the data
will be inconsistent,


599
00:28:53.634 --> 00:28:55.235 line:-1
or even corrupted.


600
00:28:55.269 --> 00:28:58.138 line:-2
Swift's new actor construct
helps protect your data


601
00:28:58.172 --> 00:28:59.506 line:-1
against such problems.


602
00:28:59.540 --> 00:29:01.742 line:-2
Again, let's start
with an example of code


603
00:29:01.775 --> 00:29:04.411 line:-1
you may have written yourself.


604
00:29:04.444 --> 00:29:06.813 line:-2
Here's a class
that collects statistics.


605
00:29:06.847 --> 00:29:09.349 line:-2
It contains a counter,
and various other code


606
00:29:09.383 --> 00:29:11.818 line:-2
will call the increment method
to update that counter


607
00:29:11.852 --> 00:29:14.254 line:-2
whenever something
interesting happens.


608
00:29:14.288 --> 00:29:16.590 line:-2
Unfortunately,
this code doesn't work well


609
00:29:16.623 --> 00:29:18.325 line:-1
in a multi-threaded system.


610
00:29:18.358 --> 00:29:20.460 line:-2
If two or more threads
call the increment method


611
00:29:20.494 --> 00:29:24.898 line:-2
at the same time, you can end up
with a badly-corrupted count.


612
00:29:24.932 --> 00:29:27.467 line:-2
Changing this class
into a Swift actor


613
00:29:27.501 --> 00:29:30.237 line:-2
protects against
such corruption.


614
00:29:30,270 --> 00:29:33,707
Actors work by suspending
any operation that might cause


615
00:29:33,740 --> 00:29:37,644
data corruption until it's safe
to make that particular change.


616
00:29:37,678 --> 00:29:40,380
This means you generally
need to use await


617
00:29:40,414 --> 00:29:44,117
when you call an actor method
from outside of the actor.


618
00:29:44,151 --> 00:29:47,588
Actors also work seamlessly
with async/await.


619
00:29:47,621 --> 00:29:50,257
Marking this publish method
as async allows it


620
00:29:50,290 --> 00:29:53,060
to be suspended while waiting
on network operations.


621
00:29:53,093 --> 00:29:55,162
While it's suspended,
other methods can run


622
00:29:55,195 --> 00:29:57,364
on this actor without waiting
for the network operation


623
00:29:57,397 --> 00:30:01,435
to complete and without risk
of data corruption.


624
00:30:01,468 --> 00:30:04,071
Actors are reference types,
like classes,


625
00:30:04,104 --> 00:30:06,940
but they obey a number
of rules designed to ensure


626
00:30:06,974 --> 00:30:10,444
that actors are safe to use
in a multi-threaded environment.


627
00:30:10,477 --> 00:30:12,679
By packaging your data
into actors,


628
00:30:12,713 --> 00:30:14,915
you are clearly stating
that you expect this data


629
00:30:14,948 --> 00:30:16,283
to be accessed concurrently


630
00:30:16,316 --> 00:30:18,919
and that you want
the Swift compiler and runtime


631
00:30:18,952 --> 00:30:22,789
to coordinate access so that
no corruption is possible.


632
00:30:22,823 --> 00:30:25,058
And, of course,
we have a full session


633
00:30:25,092 --> 00:30:27,828
devoted specifically to Swift's
new actor construct.


634
00:30:27,861 --> 00:30:29,730
There, you can find out
how to take advantage


635
00:30:29,763 --> 00:30:32,633
of the full range
of capabilities this brings.


636
00:30:32.666 --> 00:30:36.103 line:-2
Before we wrap up,
let's talk a little bit


637
00:30:36.136 --> 00:30:39.039 line:-1
about the future of Swift.


638
00:30:39.072 --> 00:30:40.874 line:-2
We believe
the three key concepts


639
00:30:40.908 --> 00:30:43.043 line:-1
we've introduced in Swift 5.5--


640
00:30:43.076 --> 00:30:44.378 line:-1
asynchronous functions,


641
00:30:44.411 --> 00:30:46.713 line:-2
structured concurrency,
and actors--


642
00:30:46.747 --> 00:30:48.849 line:-2
are a good basis
for creating safe


643
00:30:48.882 --> 00:30:51.051 line:-1
and high-performance code.


644
00:30:51.084 --> 00:30:53.620 line:-2
For Swift 6,
we're already researching ways


645
00:30:53.654 --> 00:30:56.757 line:-2
for the compiler to catch more
kinds of concurrency mistakes


646
00:30:56.790 --> 00:30:58.559 line:-2
earlier in
the development process


647
00:30:58.592 --> 00:31:00.594 line:-2
and give you
more detailed errors


648
00:31:00.627 --> 00:31:02.896 line:-2
and guidance
in fixing those issues.


649
00:31:02.930 --> 00:31:06.233 line:-2
Our goal, quite simply,
is to entirely eliminate


650
00:31:06.266 --> 00:31:08.335 line:-2
the most common kinds
of concurrency bugs,


651
00:31:08.368 --> 00:31:11.205 line:-2
in order to make asynchronous
and concurrent programming


652
00:31:11.238 --> 00:31:15.075 line:-2
no more complex than
any other kind of programming.


653
00:31:15.108 --> 00:31:18.011 line:-2
And, of course,
as we continue to improve


654
00:31:18.045 --> 00:31:20.547 line:-2
the compiler's understanding
of these concepts,


655
00:31:20.581 --> 00:31:22.950 line:-2
we also expect code
using these new constructs


656
00:31:22.983 --> 00:31:25.652 line:-2
to become even more efficient
than it is today.


657
00:31:27.354 --> 00:31:32.426 line:-2
Swift is an open, collaborative
effort that welcomes your input.


658
00:31:32.459 --> 00:31:34.962 line:-2
To help make Swift 6
even better,


659
00:31:34.995 --> 00:31:37.564 line:-2
tell us about your experiences
with Swift 5.5.


660
00:31:37.598 --> 00:31:40.000 line:-2
How well are these new features
working for you


661
00:31:40.033 --> 00:31:42.402 line:-1
in real-world app development?


662
00:31:42.436 --> 00:31:44.071 line:-2
Try one
of the compiler snapshots


663
00:31:44.104 --> 00:31:45.873 line:-1
that you can find on swift.org.


664
00:31:45.906 --> 00:31:49.042 line:-2
We provide these snapshots so
you can install them into Xcode


665
00:31:49.076 --> 00:31:52.179 line:-2
and try out new features
as we're developing them.


666
00:31:52.212 --> 00:31:53.780 line:-1
By using these snapshots,


667
00:31:53.814 --> 00:31:57.551 line:-2
you can help guide
the next version of Swift.


668
00:31:57.584 --> 00:31:59.820 line:-2
The Swift forums
are the lifeblood


669
00:31:59.853 --> 00:32:01.054 line:-1
of the project.


670
00:32:01.088 --> 00:32:03.490 line:-2
Each of the features
I've discussed started life


671
00:32:03.524 --> 00:32:05.926 line:-2
by being pitched
on the Swift Evolution forum,


672
00:32:05.959 --> 00:32:08.328 line:-2
where a diverse group of people
helped to refine it


673
00:32:08.362 --> 00:32:09.963 line:-1
into a working proposal.


674
00:32:09.997 --> 00:32:13.066 line:-2
We also have forums devoted
to many other aspects of Swift,


675
00:32:13.100 --> 00:32:15.469 line:-2
including a help area
for new users and a place


676
00:32:15.502 --> 00:32:19.072 line:-2
to exchange news of interest
to the Swift community.


677
00:32:19.106 --> 00:32:21.475 line:-2
There are many other ways
you can make Swift better,


678
00:32:21.508 --> 00:32:24.244 line:-2
and we are eager
to engage even more people,


679
00:32:24.278 --> 00:32:26.146 line:-2
such as through
the new Mentorship Program


680
00:32:26.180 --> 00:32:29.283 line:-2
that Nicole mentioned at
the beginning of this session.


681
00:32:29.316 --> 00:32:31.885 line:-2
The only requirement
is a sincere desire


682
00:32:31.919 --> 00:32:35.756 line:-2
to help improve Swift
for everyone in our community.


683
00:32:35.789 --> 00:32:37.157 line:-2
I look forward
to hearing from you,


684
00:32:37.191 --> 00:32:38.926 line:-2
and I hope you enjoy
the conference.


685
00:32:38.959 --> 00:32:41.962 line:-1
[upbeat music]

