2
00:00:00,000 --> 00:00:02,102 line:-1
[MAC STARTUP CHIME]


3
00:00:02.102 --> 00:00:06.073 line:-1 position:50%
â™ª Bass music playing â™ª


4
00:00:06,073 --> 00:00:07,808 line:-1
[KEYSTROKES]


5
00:00:07,808 --> 00:00:09,142 position:90% line:0 align:right
â™ª


6
00:00:09.142 --> 00:00:11.879 line:-1 position:50%
Jeff Nadeau: Hi, and welcome
to "What's new in AppKit."


7
00:00:11,879 --> 00:00:13,080 line:-1
I'm Jeff Nadeau.


8
00:00:13.080 --> 00:00:14.147 line:-1 position:50%
I work on AppKit,


9
00:00:14.147 --> 00:00:16.550 line:-1 position:50%
and I've got some great updates
to share with you.


10
00:00:16.550 --> 00:00:19.086 line:-1 position:50%
macOS Monterey includes
some great new features


11
00:00:19,086 --> 00:00:21,321 line:-1
and enhancements for Mac apps.


12
00:00:21,321 --> 00:00:23,824 line:-1
There's really something
for everyone in this release,


13
00:00:23,824 --> 00:00:27,194 line:-1
including updates
to our user interface design,


14
00:00:27,194 --> 00:00:29,963 line:-1
enhancements to many
of our controls,


15
00:00:29.963 --> 00:00:33.100 line:-1 position:50%
a big update to SF Symbols,


16
00:00:33,100 --> 00:00:36,670 line:-1
an all-new text engine
called TextKit 2,


17
00:00:36,670 --> 00:00:39,539 line:-1
powerful new
Swift language features,


18
00:00:39.539 --> 00:00:41.541 line:-1 position:50%
and automation with Shortcuts,


19
00:00:41.541 --> 00:00:44.878 line:-1 position:50%
which is now available
on the Mac.


20
00:00:44.878 --> 00:00:47.214 line:-1 position:50%
Let's dive right in,
starting with some updates


21
00:00:47.214 --> 00:00:50.417 line:-1 position:50%
on the design of
the macOS user interface.


22
00:00:50.417 --> 00:00:52.920 line:-1 position:50%
We're thrilled by the response
to the system-wide redesign


23
00:00:52,920 --> 00:00:55,389 line:-1
that debuted in macOS Big Sur.


24
00:00:55,389 --> 00:00:57,491 line:-1
So many of our favorite apps
have updated


25
00:00:57.491 --> 00:01:01.561 line:-1 position:50%
to adopt the new design
in only a few short months.


26
00:01:01,561 --> 00:01:03,163 line:-1
In macOS Monterey,


27
00:01:03.163 --> 00:01:06.266 line:-1 position:50%
we've continued to iterate
and refine this new design,


28
00:01:06.266 --> 00:01:09.670 line:-1 position:50%
so you'll notice a few new
touches across the system.


29
00:01:09.670 --> 00:01:12.306 line:-1 position:50%
Some of them
are big and noticeable,


30
00:01:12,306 --> 00:01:14,808 line:-1
like popovers that now
appear and recede


31
00:01:14,808 --> 00:01:17,344 line:-1
with a brand-new animation,


32
00:01:17.344 --> 00:01:20.447 line:-1 position:50%
or sliders that now
smoothly glide into position


33
00:01:20.447 --> 00:01:21.882 line:-1 position:50%
when you click them.


34
00:01:21.882 --> 00:01:24.151 line:-1 position:50%
There are also
much more subtle changes,


35
00:01:24,151 --> 00:01:27,688 line:-1
like refined metrics
in toolbar controls,


36
00:01:27,688 --> 00:01:29,823 line:-1
and spring-loading support
on the Search button,


37
00:01:29.823 --> 00:01:32.960 line:-1 position:50%
so it's easy to drag in
text and tokens.


38
00:01:32,960 --> 00:01:35,529 line:-1
And increased spacing
between table sections


39
00:01:35,529 --> 00:01:37,064 line:-1
to improve clarity.


40
00:01:37,064 --> 00:01:39,566 line:-1
We've continued to iterate
and enhance the new design


41
00:01:39,566 --> 00:01:41,768 line:-1
down to the smallest details.


42
00:01:41,768 --> 00:01:43,670 line:-1
And that leads me
to some control enhancements


43
00:01:43,670 --> 00:01:46,373 line:-1
that you can use
to refine your own designs.


44
00:01:46,373 --> 00:01:49,743 line:-1
The first big one
is control tinting.


45
00:01:49,743 --> 00:01:52,946 line:-1
We've enabled custom tinting
of individual buttons,


46
00:01:52,946 --> 00:01:56,817 line:-1
segmented controls, and sliders.


47
00:01:56,817 --> 00:01:59,386 line:-1
Each of these controls accepts
a custom tint color


48
00:01:59.386 --> 00:02:02.656 line:-1 position:50%
using one of these APIs:
bezelColor,


49
00:02:02,656 --> 00:02:06,426 line:-1
selectedSegmentColor,
and trackFillColor.


50
00:02:06,426 --> 00:02:08,962 line:-1
We introduced these APIs
in macOS Sierra


51
00:02:08,962 --> 00:02:12,499 line:-1
to allow tinting of individual
controls in the Touch Bar.


52
00:02:12,499 --> 00:02:14,334 line:-1
And starting in macOS Monterey,


53
00:02:14.334 --> 00:02:17.137 line:-1 position:50%
they're functional
for in-window controls as well.


54
00:02:17,137 --> 00:02:20,807 line:-1
To recap, most controls draw
using the accent color,


55
00:02:20.807 --> 00:02:24.044 line:-1 position:50%
which is configurable
in System Preferences.


56
00:02:24,044 --> 00:02:25,712 line:-1
This allows people
to theme their Mac


57
00:02:25,712 --> 00:02:27,881 line:-1
to match their favorite color.


58
00:02:27.881 --> 00:02:30.217 line:-1 position:50%
The Multicolor option allows
each app to define


59
00:02:30,217 --> 00:02:32,519 line:-1
its own custom color.


60
00:02:32.519 --> 00:02:33.887 line:-1 position:50%
For pervasive theming,


61
00:02:33.887 --> 00:02:35.689 line:-1 position:50%
you can define
a custom accent color


62
00:02:35.689 --> 00:02:38.358 line:-1 position:50%
in your app's asset catalog.


63
00:02:38,358 --> 00:02:41,128 line:-1
The new tinting API provides
a way to override the color


64
00:02:41,128 --> 00:02:43,697 line:-1
for one specific control.


65
00:02:43,697 --> 00:02:45,799 line:-1
This is great for controls
where you'd like to apply


66
00:02:45.799 --> 00:02:48.101 line:-1 position:50%
a semantically meaningful color.


67
00:02:48,101 --> 00:02:51,338 line:-1
For example, if your app uses
a specific shade of orange


68
00:02:51.338 --> 00:02:54.441 line:-1 position:50%
to distinguish a preorder
from a normal purchase,


69
00:02:54,441 --> 00:02:58,779 line:-1
you can reinforce that design
using a tinted button.


70
00:02:58.779 --> 00:03:01.615 line:-1 position:50%
Another example would be
a video conferencing app,


71
00:03:01,615 --> 00:03:03,483 line:-1
where the Start
and End Call buttons


72
00:03:03.483 --> 00:03:06.787 line:-1 position:50%
perform two of the most
meaningful actions in the app.


73
00:03:06,787 --> 00:03:09,389 line:-1
Tinting them green and red
adds emphasis


74
00:03:09,389 --> 00:03:12,826 line:-1
and it makes their function
instantly recognizable.


75
00:03:12,826 --> 00:03:15,128 line:-1
One important note
is that tinted buttons


76
00:03:15.128 --> 00:03:18.532 line:-1 position:50%
always show their tint color
in every active state,


77
00:03:18,532 --> 00:03:21,735 line:-1
unlike ordinary push buttons
which are white or gray.


78
00:03:21,735 --> 00:03:24,037 line:-1
This puts your tint color
front and center.


79
00:03:24,037 --> 00:03:26,973 line:-1
However, take care in your
design not to create confusion


80
00:03:26,973 --> 00:03:28,375 line:-1
with the default button,


81
00:03:28,375 --> 00:03:31,311 line:-1
which also uses
a colorful appearance.


82
00:03:31.311 --> 00:03:34.214 line:-1 position:50%
Finally, it's important
to convey your controls' purpose


83
00:03:34,214 --> 00:03:36,349 line:-1
using more than just color.


84
00:03:36,349 --> 00:03:38,285 line:-1
You want to make sure
that people who have difficultly


85
00:03:38.285 --> 00:03:41.721 line:-1 position:50%
distinguishing between colors
can still easily identify


86
00:03:41.721 --> 00:03:43.723 line:-1 position:50%
the purpose of a given control,


87
00:03:43.723 --> 00:03:47.594 line:-1 position:50%
so be sure to provide
a clear label or icon.


88
00:03:47,594 --> 00:03:49,429 line:-1
Another important
button design change


89
00:03:49,429 --> 00:03:51,631 line:-1
is that push buttons
no longer highlight


90
00:03:51,631 --> 00:03:54,201 line:-1
using the accent color on click.


91
00:03:54.201 --> 00:03:56.636 line:-1 position:50%
This brings them in line
with other clickable elements,


92
00:03:56,636 --> 00:04:01,942 line:-1
like segmented control segments,
slider knobs, and steppers.


93
00:04:01.942 --> 00:04:03.577 line:-1 position:50%
This is an important change,


94
00:04:03.577 --> 00:04:05.412 line:-1 position:50%
because if you're doing
any custom drawing


95
00:04:05,412 --> 00:04:08,081 line:-1
that assumes a colorful
appearance while highlighted --


96
00:04:08,081 --> 00:04:11,318 line:-1
say, if you're choosing to draw
white content over top --


97
00:04:11.318 --> 00:04:15.722 line:-1 position:50%
it might not look correct
on macOS Monterey.


98
00:04:15.722 --> 00:04:17.791 line:-1 position:50%
Instead of checking
for the highlight state,


99
00:04:17,791 --> 00:04:19,826 line:-1
you can drive your drawing
decisions using


100
00:04:19,826 --> 00:04:22,762 line:-1
the interiorBackgroundStyle
property.


101
00:04:22,762 --> 00:04:24,631 position:50%
This property reflects
the underlying style


102
00:04:24,631 --> 00:04:27,767 position:50%
of the button bezel,
so it'll always return .normal


103
00:04:27,767 --> 00:04:30,804 line:0
for colorless states,
and it'll return .emphasized


104
00:04:30,804 --> 00:04:33,140 line:0
for those colorful
emphasis states,


105
00:04:33,140 --> 00:04:35,842 line:0
like tinted buttons,
default buttons,


106
00:04:35,842 --> 00:04:39,412 line:0
and buttons that are toggled
into an "on" state.


107
00:04:39.412 --> 00:04:40.447 line:-1 position:50%
Finally, we've updated


108
00:04:40,447 --> 00:04:42,582 line:-1
the Flexible Push
style of button --


109
00:04:42,582 --> 00:04:44,651 line:-1
previously known
as Regular Square --


110
00:04:44,651 --> 00:04:47,621 line:-1
to serve as a variable-height
push button.


111
00:04:47,621 --> 00:04:49,723 line:-1
It now supports all
of the same configurations


112
00:04:49.723 --> 00:04:52.425 line:-1 position:50%
as an ordinary push button,
which means that it can serve


113
00:04:52,425 --> 00:04:55,862 line:-1
as the default button,
and you can tint it.


114
00:04:55.862 --> 00:04:58.698 line:-1 position:50%
The corner radius and content
padding now match those


115
00:04:58.698 --> 00:05:01.801 line:-1 position:50%
of a standard push button
at each control size,


116
00:05:01,801 --> 00:05:04,271 line:-1
so they'll fit in great
with your other controls,


117
00:05:04,271 --> 00:05:06,239 line:-1
but their vertically resizable
design


118
00:05:06.239 --> 00:05:08.642 line:-1 position:50%
means that they can accommodate
larger icons


119
00:05:08,642 --> 00:05:11,111 line:-1
or text with line breaks.


120
00:05:11,111 --> 00:05:13,547 line:-1
While the vast majority of
push buttons should continue


121
00:05:13.547 --> 00:05:16.016 line:-1 position:50%
to use the standard
fixed-height style,


122
00:05:16.016 --> 00:05:18.785 line:-1 position:50%
this newly expanded style
offers some flexibility


123
00:05:18.785 --> 00:05:21.221 line:-1 position:50%
for those special cases
when you need to accommodate


124
00:05:21,221 --> 00:05:23,456 line:-1
taller content.


125
00:05:23.456 --> 00:05:25.825 line:-1 position:50%
Another very important
control update comes in the form


126
00:05:25,825 --> 00:05:30,130 line:-1
of automatic localization
for menu keyboard shortcuts.


127
00:05:30,130 --> 00:05:32,499 line:-1
There are a lot of keyboard
layouts out there in the world,


128
00:05:32,499 --> 00:05:34,734 line:-1
and that can make
localizing keyboard shortcuts


129
00:05:34,734 --> 00:05:37,170 line:-1
fairly complex.


130
00:05:37.170 --> 00:05:39.940 line:-1 position:50%
Some key combinations are hard
to reach on some keyboards,


131
00:05:39,940 --> 00:05:42,742 line:-1
and others can't be typed
at all.


132
00:05:42,742 --> 00:05:45,278 line:-1
In addition, some directional
keyboard shortcuts


133
00:05:45.278 --> 00:05:48.648 line:-1 position:50%
really ought to mirror
in right-to-left languages.


134
00:05:48.648 --> 00:05:50.784 line:-1 position:50%
The great news is,
in macOS Monterey,


135
00:05:50.784 --> 00:05:53.053 line:-1 position:50%
AppKit can do it for you.


136
00:05:53.053 --> 00:05:54.788 line:-1 position:50%
Here's an example of a shortcut


137
00:05:54.788 --> 00:05:58.758 line:-1 position:50%
that could benefit from
localization: Command-backslash.


138
00:05:58,758 --> 00:06:01,595 line:-1
While this works fine
on a US English keyboard,


139
00:06:01,595 --> 00:06:04,698 line:-1
it's actually impossible to type
on a Japanese keyboard,


140
00:06:04,698 --> 00:06:07,167 line:-1
which doesn't have
a backslash key at all.


141
00:06:07.167 --> 00:06:09.002 line:-1 position:50%
Starting in macOS Monterey,


142
00:06:09,002 --> 00:06:11,938 line:-1
the system remaps the shortcut
automatically,


143
00:06:11.938 --> 00:06:15.742 line:-1 position:50%
providing an equivalent shortcut
that's natural to type.


144
00:06:15.742 --> 00:06:17.811 line:-1 position:50%
Another common case
is a keyboard shortcut


145
00:06:17,811 --> 00:06:19,379 line:-1
that has directional meaning.


146
00:06:19,379 --> 00:06:22,449 line:-1
For example, Safari uses
Command-square brackets


147
00:06:22.449 --> 00:06:25.518 line:-1 position:50%
to go backward
and forward in history.


148
00:06:25.518 --> 00:06:26.987 line:-1 position:50%
In a right-to-left language,


149
00:06:26.987 --> 00:06:30.357 line:-1 position:50%
using the left bracket to go
backward isn't very intuitive,


150
00:06:30.357 --> 00:06:33.393 line:-1 position:50%
so AppKit now automatically
swaps it to the right bracket


151
00:06:33.393 --> 00:06:35.996 line:-1 position:50%
when running
in a right-to-left language.


152
00:06:35.996 --> 00:06:38.431 line:-1 position:50%
This behavior applies
to brackets, braces,


153
00:06:38,431 --> 00:06:40,567 line:-1
parentheses, and arrow keys.


154
00:06:40.567 --> 00:06:44.571 line:-1 position:50%
In some cases, you might want to
disable this mirroring behavior.


155
00:06:44,571 --> 00:06:47,607 line:-1
For example, if your menu item
has absolute directionality --


156
00:06:47.607 --> 00:06:49.976 line:-1 position:50%
like align left, for example --


157
00:06:49,976 --> 00:06:51,478 line:-1
you'd want to use
the left bracket


158
00:06:51,478 --> 00:06:53,747 line:-1
even in
a right-to-left language.


159
00:06:53,747 --> 00:06:57,117 line:-1
We've provided an opt-out
for cases just like this.


160
00:06:57,117 --> 00:06:59,519 line:-1
You can control this behavior
using some new properties


161
00:06:59,519 --> 00:07:01,855 line:-1
on NSMenuItem.


162
00:07:01,855 --> 00:07:04,324 line:0
allowsAutomaticKey
EquivalentMirroring


163
00:07:04,324 --> 00:07:06,092 position:50%
lets you control
the mirroring behavior


164
00:07:06,092 --> 00:07:08,528 line:0
for directional keys
like  brackets,


165
00:07:08,528 --> 00:07:11,665 position:50%
and allowsAutomaticKey
EquivalentLocalization


166
00:07:11,665 --> 00:07:13,967 line:0
controls all of
the localization features,


167
00:07:13,967 --> 00:07:18,171 line:0
including keyboard mapping
and mirroring.


168
00:07:18,171 --> 00:07:19,906 position:50%
If you've already
carefully localized


169
00:07:19,906 --> 00:07:23,109 line:0
your keyboard shortcuts,
or if your application has


170
00:07:23,109 --> 00:07:26,780 line:0
a heavily custom implementation
of keyboard shortcut bindings,


171
00:07:26,780 --> 00:07:30,283 line:0
you might want to disable this
feature for your entire app.


172
00:07:30,283 --> 00:07:31,284 line:0
To do that,


173
00:07:31,284 --> 00:07:34,154 position:50%
you can implement this
application delegate method,


174
00:07:34,154 --> 00:07:37,691 line:0
applicationShouldAutomatically
LocalizeKeyEquivalents,


175
00:07:37,691 --> 00:07:39,125 position:50%
and return false.


176
00:07:39.125 --> 00:07:41.361 line:-1 position:50%
Most apps won't need
to use this.


177
00:07:41.361 --> 00:07:44.097 line:-1 position:50%
The individual menu item APIs
are strongly preferred


178
00:07:44.097 --> 00:07:46.199 line:-1 position:50%
for opting out specific items,


179
00:07:46.199 --> 00:07:49.402 line:-1 position:50%
and most apps shouldn't need
to opt out at all.


180
00:07:49,402 --> 00:07:53,039 line:-1
Next up, some big enhancements
to symbol images.


181
00:07:53,039 --> 00:07:56,009 line:-1
We brought SF Symbols
to macOS in Big Sur,


182
00:07:56.009 --> 00:07:58.611 line:-1 position:50%
opening up a massive
repertoire of beautiful,


183
00:07:58,611 --> 00:08:03,783 line:-1
typographically balanced
symbol images to all Mac apps.


184
00:08:03,783 --> 00:08:07,787 line:-1
In macOS Monterey, we've built
a new generation of symbol APIs


185
00:08:07,787 --> 00:08:11,224 line:-1
and tooling that we call
SF Symbols 3.


186
00:08:11.224 --> 00:08:13.526 line:-1 position:50%
It's a huge update
that spans every aspect


187
00:08:13.526 --> 00:08:15.295 line:-1 position:50%
of the symbol image workflow,


188
00:08:15,295 --> 00:08:18,431 line:-1
and it's all available
to your AppKit applications.


189
00:08:18,431 --> 00:08:20,767 line:-1
SF Symbols 3
expands the capabilities


190
00:08:20.767 --> 00:08:23.770 line:-1 position:50%
of the SF Symbols app
for previewing, exporting,


191
00:08:23.770 --> 00:08:26.506 line:-1 position:50%
and importing symbol images.


192
00:08:26.506 --> 00:08:28.174 line:-1 position:50%
It also comes with
an updated format


193
00:08:28.174 --> 00:08:31.411 line:-1 position:50%
for annotating custom symbols,
which allows you to define


194
00:08:31,411 --> 00:08:34,347 line:-1
distinct layers
within a symbol image,


195
00:08:34,347 --> 00:08:38,952 line:-1
and we've expanded our APIs
in AppKit, UIKit, and SwiftUI


196
00:08:38.952 --> 00:08:42.789 line:-1 position:50%
to allow to you to individually
color each layer of a symbol.


197
00:08:42,789 --> 00:08:45,358 line:-1
In Big Sur, we offered
two distinct rendering modes


198
00:08:45.358 --> 00:08:46.926 line:-1 position:50%
for symbols.


199
00:08:46.926 --> 00:08:49.796 line:-1 position:50%
First, there was
the traditional Template style,


200
00:08:49,796 --> 00:08:52,132 line:-1
which draws using a single
tint color or effect


201
00:08:52,132 --> 00:08:54,534 line:-1
over the entire symbol.


202
00:08:54,534 --> 00:08:56,369 line:-1
The second is Multicolor,


203
00:08:56,369 --> 00:08:58,972 line:-1
which draws more
like a full-color image,


204
00:08:58.972 --> 00:09:01.775 line:-1 position:50%
drawing each path element
using a color that's defined


205
00:09:01.775 --> 00:09:04.677 line:-1 position:50%
in the symbol image itself.


206
00:09:04,677 --> 00:09:07,881 line:-1
In SF Symbols 3, we've added
two new rendering modes


207
00:09:07,881 --> 00:09:09,783 line:-1
which take advantage
of the layer information


208
00:09:09,783 --> 00:09:12,919 line:-1
provided by the new
symbol image format.


209
00:09:12.919 --> 00:09:16.656 line:-1 position:50%
The first, Hierarchical,
draws using a single color,


210
00:09:16,656 --> 00:09:19,559 line:-1
while putting emphasis on
specific parts of the symbol


211
00:09:19,559 --> 00:09:22,028 line:-1
while deemphasizing others.


212
00:09:22,028 --> 00:09:25,698 line:-1
And the second, Palette, lets
you assign any color you'd like


213
00:09:25,698 --> 00:09:28,468 line:-1
to each layer of the symbol.


214
00:09:28,468 --> 00:09:31,204 line:-1
You can access these rendering
modes using new API


215
00:09:31.204 --> 00:09:34.274 line:-1 position:50%
on NSImage.SymbolConfiguration.


216
00:09:34,274 --> 00:09:36,743 line:0
I'm representing the
NSColor parameters as dots


217
00:09:36,743 --> 00:09:40,079 line:0
to show how they correspond
with the rendered symbol.


218
00:09:40,079 --> 00:09:42,816 position:50%
The Hierarchical rendering mode
take a single color,


219
00:09:42,816 --> 00:09:46,219 position:50%
which is applied to the symbol
layers with decreasing opacity.


220
00:09:46,219 --> 00:09:48,822 line:0
The Palette mode
accepts an array of colors


221
00:09:48,822 --> 00:09:51,357 line:0
which are applied
to the layers verbatim.


222
00:09:51,357 --> 00:09:52,959 line:0
You can also create
a configuration


223
00:09:52,959 --> 00:09:56,796 line:0
that prefers the Multicolor
rendering mode.


224
00:09:58,932 --> 00:10:01,267 line:-1
We've also added a new API
that lets you map


225
00:10:01,267 --> 00:10:04,704 line:-1
from one base symbol
into one of its variants.


226
00:10:04.704 --> 00:10:07.207 line:-1 position:50%
For example, you could map
the heart symbol


227
00:10:07.207 --> 00:10:09.075 line:-1 position:50%
to its filled variant,


228
00:10:09,075 --> 00:10:11,678 line:-1
or an inscribed variant
like circle,


229
00:10:11,678 --> 00:10:14,347 line:-1
or even to the variant
that has a slash through it.


230
00:10:14.347 --> 00:10:16.216 line:-1 position:50%
This is really useful
for situations where


231
00:10:16.216 --> 00:10:18.685 line:-1 position:50%
you prefer a particular
style of symbol


232
00:10:18,685 --> 00:10:21,020 line:-1
for a particular context.


233
00:10:21,020 --> 00:10:23,623 line:-1
For example,
you might have a picker control


234
00:10:23,623 --> 00:10:26,392 line:-1
where you prefer outlines
for the unselected states,


235
00:10:26,392 --> 00:10:28,962 line:-1
but a filled style
for your selection.


236
00:10:28,962 --> 00:10:30,763 line:-1
Normally, this control
would need


237
00:10:30.763 --> 00:10:33.433 line:-1 position:50%
two different image properties
to specify the selected


238
00:10:33,433 --> 00:10:35,969 line:-1
and unselected
versions of the image.


239
00:10:35.969 --> 00:10:38.471 line:-1 position:50%
But with the variants API,
it could just accept


240
00:10:38,471 --> 00:10:44,077 line:-1
a single base symbol and derive
the filled state automatically.


241
00:10:44.077 --> 00:10:46.880 line:-1 position:50%
This control could call
image(with: .fill)


242
00:10:46,880 --> 00:10:49,916 line:-1
to prefer a filled symbol
in its selection state,


243
00:10:49.916 --> 00:10:52.418 line:-1 position:50%
and it'll automatically choose
the right version of the symbol


244
00:10:52.418 --> 00:10:54.787 line:-1 position:50%
whenever a filled variant
is available.


245
00:10:54.787 --> 00:10:57.323 line:-1 position:50%
There are constants
for each type of symbol variant,


246
00:10:57.323 --> 00:10:58.791 line:-1 position:50%
and you can combine them


247
00:10:58.791 --> 00:11:01.060 line:-1 position:50%
to request
multiple variants together,


248
00:11:01,060 --> 00:11:03,596 line:-1
like circle and fill.


249
00:11:03,596 --> 00:11:05,932 line:0
This was just a brief
introduction to the features


250
00:11:05,932 --> 00:11:08,034 position:50%
of SF Symbols 3.


251
00:11:08,034 --> 00:11:09,836 line:0
There's a new collection
of videos where you can get


252
00:11:09,836 --> 00:11:12,005 position:50%
the full details
on everything that's new


253
00:11:12,005 --> 00:11:14,674 line:0
across the entire
symbols workflow.


254
00:11:14,674 --> 00:11:17,310 line:0
Be sure to add them
to your watch list.


255
00:11:17,310 --> 00:11:20,914 line:-1
macOS Monterey also features
a huge update to the text system


256
00:11:20.914 --> 00:11:22.782 line:-1 position:50%
in the form of TextKit 2.


257
00:11:22.782 --> 00:11:25.084 line:-1 position:50%
TextKit is the text layout
and rendering engine


258
00:11:25,084 --> 00:11:27,987 line:-1
for all Apple devices,
and it's a great text engine


259
00:11:27,987 --> 00:11:30,456 line:-1
with a proven track record.


260
00:11:30.456 --> 00:11:32.692 line:-1 position:50%
TextKit is a linear
text layout engine,


261
00:11:32.692 --> 00:11:34.460 line:-1 position:50%
which means that it typesets
a block of text


262
00:11:34.460 --> 00:11:36.863 line:-1 position:50%
from beginning to end.


263
00:11:36.863 --> 00:11:39.332 line:-1 position:50%
As we've evolved our platforms
and technologies,


264
00:11:39,332 --> 00:11:42,001 line:-1
we've found a lot of cases
where nonlinear text layout


265
00:11:42.001 --> 00:11:44.804 line:-1 position:50%
would serve us much better.


266
00:11:44,804 --> 00:11:46,639 line:-1
So we went back to the basics


267
00:11:46.639 --> 00:11:48.675 line:-1 position:50%
and created a new version
of TextKit


268
00:11:48.675 --> 00:11:52.078 line:-1 position:50%
and that's TextKit 2.


269
00:11:52.078 --> 00:11:55.048 line:-1 position:50%
We had a few key goals
for TextKit 2.


270
00:11:55,048 --> 00:11:57,951 line:-1
As always, we want to provide
the very best experience


271
00:11:57.951 --> 00:12:01.654 line:-1 position:50%
for international text
of every script and layout.


272
00:12:01,654 --> 00:12:02,922 line:-1
We also want to make it easier


273
00:12:02,922 --> 00:12:05,792 line:-1
to mix text
with other types of content.


274
00:12:05.792 --> 00:12:09.862 line:-1 position:50%
And finally, TextKit 2
is designed to be super fast,


275
00:12:09.862 --> 00:12:11.664 line:-1 position:50%
efficiently shaping
and rendering text,


276
00:12:11,664 --> 00:12:13,199 line:-1
whether it's a short label


277
00:12:13,199 --> 00:12:17,537 line:-1
or scrolled partway
through a massive document.


278
00:12:17,537 --> 00:12:20,106 line:-1
TextKit 2 coexists
with TextKit 1,


279
00:12:20,106 --> 00:12:23,610 line:-1
so you can choose which engine
to use for a given text view.


280
00:12:23,610 --> 00:12:25,745 line:-1
Now I'm going to let you in
on a secret.


281
00:12:25,745 --> 00:12:28,448 line:-1
You're already running TextKit 2
on your Mac


282
00:12:28.448 --> 00:12:30.016 line:-1 position:50%
because starting in Big Sur,


283
00:12:30,016 --> 00:12:32,685 line:-1
TextEdit uses it
for plain text documents,


284
00:12:32,685 --> 00:12:34,821 line:-1
and AppKit text fields
use TextKit 2


285
00:12:34.821 --> 00:12:36.856 line:-1 position:50%
for most configurations.


286
00:12:36,856 --> 00:12:40,026 line:-1
So you've actually been getting
a sneak peek this entire time.


287
00:12:40.026 --> 00:12:41.928 line:-1 position:50%
One of the key differences
in TextKit 2


288
00:12:41.928 --> 00:12:45.498 line:-1 position:50%
is that it always uses
a nonlinear layout system.


289
00:12:45.498 --> 00:12:47.266 line:-1 position:50%
That means that
it can perform text layout


290
00:12:47,266 --> 00:12:49,268 line:-1
at a more granular level,


291
00:12:49,268 --> 00:12:52,839 line:-1
which allows it to avoid
unnecessary work.


292
00:12:52,839 --> 00:12:55,408 line:-1
For example,
if we have a large document


293
00:12:55,408 --> 00:12:58,645 line:-1
where only a portion of the text
is scrolled to be visible,


294
00:12:58.645 --> 00:13:01.748 line:-1 position:50%
a linear system still has to
lay out all of the previous text


295
00:13:01.748 --> 00:13:04.550 line:-1 position:50%
in order to show this region.


296
00:13:04.550 --> 00:13:08.154 line:-1 position:50%
By comparison, a nonlinear
system like TextKit 2


297
00:13:08,154 --> 00:13:11,357 line:-1
can start layout at the nearest
paragraph boundary.


298
00:13:11,357 --> 00:13:14,460 line:-1
For large documents,
this is a huge speedup.


299
00:13:14.460 --> 00:13:16.496 line:-1 position:50%
The new layout engine
provides a robust set


300
00:13:16.496 --> 00:13:18.898 line:-1 position:50%
of customization points,
making it simple


301
00:13:18,898 --> 00:13:22,669 line:-1
to extend the layout system
and add your own behaviors.


302
00:13:22.669 --> 00:13:25.338 line:-1 position:50%
The nonlinear layout system
also lends itself well


303
00:13:25.338 --> 00:13:29.042 line:-1 position:50%
to mixing nontext elements
into your text layout.


304
00:13:29,042 --> 00:13:31,310 line:-1
And it does all of this
while improving performance


305
00:13:31,310 --> 00:13:33,780 line:-1
for even the largest documents.


306
00:13:33,780 --> 00:13:36,582 position:50%
To learn more,
check out "Meet TextKit 2,"


307
00:13:36,582 --> 00:13:39,686 line:0
which goes into full detail
about the design of the new API


308
00:13:39,686 --> 00:13:41,554 line:0
and how to use it.


309
00:13:41.554 --> 00:13:46.826 line:-1 position:50%
Next up, I'd like to share some
updates about AppKit in Swift


310
00:13:46.826 --> 00:13:49.195 line:-1 position:50%
starting with concurrency.


311
00:13:49.195 --> 00:13:51.631 line:-1 position:50%
Swift 5.5 introduces
some important


312
00:13:51,631 --> 00:13:54,834 line:-1
language-level features
for managing concurrency.


313
00:13:54,834 --> 00:13:59,005 line:-1
The first, async/await, allows
for asynchronous method calls


314
00:13:59,005 --> 00:14:01,507 line:-1
that behave a lot
like coroutines.


315
00:14:01.507 --> 00:14:06.012 line:-1 position:50%
The second, actor types, protect
mutable state from data races


316
00:14:06.012 --> 00:14:09.749 line:-1 position:50%
by isolating accesses to
a single thread of execution.


317
00:14:09,749 --> 00:14:12,752 line:-1
AppKit works great
with both of these new features.


318
00:14:12,752 --> 00:14:14,253 line:-1
For async/await,


319
00:14:14.253 --> 00:14:16.289 line:-1 position:50%
many asynchronous methods
in AppKit --


320
00:14:16.289 --> 00:14:18.291 line:-1 position:50%
that is, methods
that take a continuation


321
00:14:18,291 --> 00:14:22,295 line:-1
as a completion handler block --
have been transformed in the SDK


322
00:14:22,295 --> 00:14:25,064 line:-1
to offer async
variants as well.


323
00:14:25,064 --> 00:14:27,967 line:-1
One simple example
is NSColorSampler,


324
00:14:27,967 --> 00:14:31,871 line:-1
which allows the user to pick
a color from anywhere onscreen.


325
00:14:31.871 --> 00:14:34.741 line:-1 position:50%
This call is asynchronous
because it waits for the user


326
00:14:34.741 --> 00:14:36.275 line:-1 position:50%
to pick the color they'd like,


327
00:14:36.275 --> 00:14:39.345 line:-1 position:50%
and then it runs the completion
handler when they're done.


328
00:14:39.345 --> 00:14:40.646 line:-1 position:50%
With async/await,


329
00:14:40.646 --> 00:14:43.583 line:-1 position:50%
you can express this
as an async function call.


330
00:14:43,583 --> 00:14:45,418 line:-1
It yields its thread
of execution


331
00:14:45,418 --> 00:14:48,287 line:-1
while it's waiting for the
asynchronous work to complete,


332
00:14:48.287 --> 00:14:51.023 line:-1 position:50%
and then it picks right back up
where it left off.


333
00:14:51,023 --> 00:14:53,893 line:-1
You can even do it from within
a guard statement.


334
00:14:53.893 --> 00:14:57.196 line:-1 position:50%
Now, the continuation --
the work to be done next --


335
00:14:57,196 --> 00:15:00,733 line:-1
is no longer nested inside
a completion handler block.


336
00:15:00,733 --> 00:15:06,072 line:-1
Instead, the code reads
naturally in sequence.


337
00:15:06,072 --> 00:15:08,841 line:-1
Actors work to protect state
from concurrent access


338
00:15:08.841 --> 00:15:12.512 line:-1 position:50%
by isolating it to a single
thread of execution.


339
00:15:12.512 --> 00:15:13.780 line:-1 position:50%
If that sounds familiar,


340
00:15:13.780 --> 00:15:15.782 line:-1 position:50%
it's because most
of AppKit's state,


341
00:15:15,782 --> 00:15:18,251 line:-1
like the view hierarchy
and responder chain,


342
00:15:18,251 --> 00:15:21,053 line:-1
should also be accessed from
a single thread of execution,


343
00:15:21,053 --> 00:15:24,090 line:-1
specifically the main thread.


344
00:15:24,090 --> 00:15:26,826 line:-1
This restriction fits
the actor model nicely,


345
00:15:26,826 --> 00:15:29,629 line:-1
so we've introduced the concept
of a MainActor,


346
00:15:29.629 --> 00:15:34.867 line:-1 position:50%
which is a type that has to be
accessed from the main thread.


347
00:15:34,867 --> 00:15:37,804 line:-1
In AppKit,
we've designated NSResponder


348
00:15:37,804 --> 00:15:40,139 line:-1
including its subclasses
of NSView,


349
00:15:40,139 --> 00:15:42,341 line:-1
ViewController,
WindowController,


350
00:15:42.341 --> 00:15:46.846 line:-1 position:50%
and Application, plus NSCell,
Alert, Document,


351
00:15:46.846 --> 00:15:51.984 line:-1 position:50%
and DocumentController
as MainActors.


352
00:15:51,984 --> 00:15:54,387 line:-1
Code running in a MainActor
can freely call methods


353
00:15:54.387 --> 00:15:56.355 line:-1 position:50%
on other MainActor types,


354
00:15:56.355 --> 00:15:59.192 line:-1 position:50%
since you know that you're
already on the main thread.


355
00:15:59,192 --> 00:16:02,195 line:-1
However, code that's not running
in the MainActor


356
00:16:02.195 --> 00:16:06.165 line:-1 position:50%
must use the new async/await
features to perform that UI work


357
00:16:06.165 --> 00:16:09.669 line:-1 position:50%
in the context
of the MainActor.


358
00:16:09.669 --> 00:16:11.871 line:-1 position:50%
By enforcing this
at the compiler level,


359
00:16:11.871 --> 00:16:14.273 line:-1 position:50%
Swift can help you avoid
a common source of bugs


360
00:16:14,273 --> 00:16:17,577 line:-1
when mixing concurrency
with UI code.


361
00:16:17,577 --> 00:16:19,712 line:0
The Swift concurrency videos
go into great depth


362
00:16:19,712 --> 00:16:21,781 position:50%
about this powerful
new language feature.


363
00:16:21,781 --> 00:16:24,851 position:50%
You don't want to miss them.


364
00:16:24,851 --> 00:16:26,719 line:-1
Also new in Swift 5.5


365
00:16:26,719 --> 00:16:30,022 line:-1
is a value-typed version
of AttributedString.


366
00:16:30,022 --> 00:16:32,258 line:-1
On top of providing
value semantics,


367
00:16:32.258 --> 00:16:35.761 line:-1 position:50%
it also has type-safe attributes
and great Swift ergonomics


368
00:16:35.761 --> 00:16:39.799 line:-1 position:50%
for enumerating and manipulating
ranges of attributes.


369
00:16:39,799 --> 00:16:41,934 line:-1
When you're using
AttributedString with AppKit,


370
00:16:41.934 --> 00:16:44.070 line:-1 position:50%
you'll automatically get access
to the attributes


371
00:16:44.070 --> 00:16:47.240 line:-1 position:50%
that are relevant
to our text drawing system;


372
00:16:47,240 --> 00:16:51,377 line:-1
things like foreground color,
paragraph style, and so on.


373
00:16:51.377 --> 00:16:53.679 line:-1 position:50%
You can convert between
struct AttributedString


374
00:16:53.679 --> 00:16:56.015 line:-1 position:50%
and the reference-typed
NSAttributedString,


375
00:16:56.015 --> 00:16:57.884 line:-1 position:50%
so you can interoperate
with APIs


376
00:16:57.884 --> 00:17:00.353 line:-1 position:50%
that use NSAttributedString.


377
00:17:00,353 --> 00:17:03,089 position:50%
The "What's new in Foundation"
video goes into more detail


378
00:17:03,089 --> 00:17:06,459 line:0
on AttributedString's design
and how to use it.


379
00:17:06,459 --> 00:17:09,462 line:-1
Our last Swift enhancement
has to do with driving updates


380
00:17:09,462 --> 00:17:11,163 line:-1
to your NSViews.


381
00:17:11,163 --> 00:17:13,399 line:-1
It uses Swift's
property wrapper feature


382
00:17:13,399 --> 00:17:15,067 line:-1
to dramatically reduce
the boilerplate


383
00:17:15.067 --> 00:17:17.570 line:-1 position:50%
that's common
in view properties.


384
00:17:17,570 --> 00:17:19,472 line:-1
Let's go over an example.


385
00:17:19.472 --> 00:17:20.606 line:-1 position:50%
Here's a custom view


386
00:17:20,606 --> 00:17:23,709 line:-1
that's configurable
via a handful of properties.


387
00:17:23,709 --> 00:17:25,011 line:-1
And while this looks fine,


388
00:17:25,011 --> 00:17:27,847 line:-1
the reality is that
our view's property declarations


389
00:17:27.847 --> 00:17:30.349 line:-1 position:50%
are much more likely to contain
a lot of didSets


390
00:17:30.349 --> 00:17:32.084 line:-1 position:50%
and extra side effects,


391
00:17:32,084 --> 00:17:34,587 line:-1
because it's so common
that you need to redraw,


392
00:17:34,587 --> 00:17:36,622 line:-1
or layout, or update
your constraints


393
00:17:36,622 --> 00:17:38,524 line:-1
when something changes.


394
00:17:38,524 --> 00:17:40,993 position:50%
Now, that's a lot
of boilerplate.


395
00:17:40,993 --> 00:17:42,395 line:0
So we made this scenario better


396
00:17:42,395 --> 00:17:46,732 position:50%
by creating a new Swift property
wrapper just for this case.


397
00:17:46.732 --> 00:17:48.935 line:-1 position:50%
It's called Invalidating.


398
00:17:48,935 --> 00:17:51,837 line:-1
It's nested under NSView,
and it allows you to specify


399
00:17:51,837 --> 00:17:54,941 line:-1
one or more aspects
of the view to invalidate


400
00:17:54.941 --> 00:17:57.443 line:-1 position:50%
when the wrapped property
changes.


401
00:17:57.443 --> 00:18:00.046 line:-1 position:50%
All of the didSets
and brackets fall away,


402
00:18:00,046 --> 00:18:02,315 line:-1
making it easier
to focus on the definition


403
00:18:02.315 --> 00:18:04.517 line:-1 position:50%
of the property itself.


404
00:18:06,519 --> 00:18:09,655 line:-1
AppKit provides several
built-in invalidation cases:


405
00:18:09.655 --> 00:18:13.559 line:-1 position:50%
display, layout, constraints,
intrinsic content size,


406
00:18:13,559 --> 00:18:16,929 line:-1
and restorable state.


407
00:18:16,929 --> 00:18:19,999 line:-1
Since these invalidations
only make sense on views,


408
00:18:19,999 --> 00:18:21,734 line:-1
we've constrained
the property wrapper


409
00:18:21.734 --> 00:18:25.604 line:-1 position:50%
so that it only works
on subclasses of NSView.


410
00:18:25,604 --> 00:18:29,275 line:-1
We also require that the value
conforms to Equatable.


411
00:18:29,275 --> 00:18:30,609 line:-1
We use this conformance


412
00:18:30,609 --> 00:18:32,878 line:-1
to check for meaningful
changes in value


413
00:18:32,878 --> 00:18:37,049 line:-1
before performing a potentially
expensive redraw or layout pass.


414
00:18:37,049 --> 00:18:39,018 line:-1
If you'd like to do
something custom,


415
00:18:39.018 --> 00:18:41.020 line:-1 position:50%
you can even define
your own invalidation


416
00:18:41,020 --> 00:18:46,459 line:-1
by conforming a type to the
NSViewInvalidating protocol.


417
00:18:46,459 --> 00:18:49,095 line:-1
Finally, Shortcuts.


418
00:18:49,095 --> 00:18:52,164 line:-1
In macOS Monterey, we're excited
to bring the full power


419
00:18:52,164 --> 00:18:53,666 line:-1
of Shortcuts to the Mac,


420
00:18:53.666 --> 00:18:56.769 line:-1 position:50%
and that includes integrating
Shortcuts with your AppKit apps.


421
00:18:56,769 --> 00:18:59,705 line:-1
The great news is,
if you app supports Services,


422
00:18:59.705 --> 00:19:01.741 line:-1 position:50%
then it already
supports Shortcuts,


423
00:19:01,741 --> 00:19:03,943 line:-1
and Shortcuts appear
in all of the same places


424
00:19:03.943 --> 00:19:07.046 line:-1 position:50%
where you can access
Services today.


425
00:19:07.046 --> 00:19:08.614 line:-1 position:50%
If you're new
to this functionality,


426
00:19:08,614 --> 00:19:10,850 line:-1
it's really easy to adopt.


427
00:19:10,850 --> 00:19:13,953 line:-1
AppKit decides which shortcuts
are contextually-appropriate


428
00:19:13.953 --> 00:19:16.722 line:-1 position:50%
by checking the responder chain.


429
00:19:16,722 --> 00:19:19,859 line:-1
It asks each responder whether
it can provide or receive


430
00:19:19.859 --> 00:19:23.262 line:-1 position:50%
the types of data
expected by each shortcut.


431
00:19:23,262 --> 00:19:25,264 line:-1
We express this using
a pasteboard type,


432
00:19:25.264 --> 00:19:29.168 line:-1 position:50%
which in most cases, corresponds
to a uniform type identifier.


433
00:19:29,168 --> 00:19:31,804 line:-1
All you have to do is implement
the validRequestor


434
00:19:31,804 --> 00:19:34,373 line:-1
for sendType
and returnType method.


435
00:19:34,373 --> 00:19:37,476 line:-1
And if you can accept or provide
the specified types,


436
00:19:37,476 --> 00:19:38,911 line:-1
return an object conforming to


437
00:19:38,911 --> 00:19:42,415 line:-1
the NSServicesMenuRequestor
protocol.


438
00:19:42.415 --> 00:19:45.051 line:-1 position:50%
In most cases, you'll just
implement that protocol directly


439
00:19:45.051 --> 00:19:46.652 line:-1 position:50%
and then return self.


440
00:19:46.652 --> 00:19:48.220 line:-1 position:50%
Once a Shortcut is invoked,


441
00:19:48.220 --> 00:19:50.756 line:-1 position:50%
you'll get calls to write
and/or read data


442
00:19:50.756 --> 00:19:53.125 line:-1 position:50%
from a special pasteboard
that the Shortcut uses


443
00:19:53,125 --> 00:19:55,061 line:-1
for its input and output.


444
00:19:55,061 --> 00:19:56,262 line:-1
And that's it!


445
00:19:56,262 --> 00:19:59,598 line:-1
It's that easy to integrate
your app with Shortcuts.


446
00:19:59,598 --> 00:20:02,601 line:-1
We've also brought Siri Intents
to macOS.


447
00:20:02,601 --> 00:20:03,869 line:-1
You can now handle Intents


448
00:20:03.869 --> 00:20:06.772 line:-1 position:50%
by creating
an Intents Extension in Xcode.


449
00:20:06,772 --> 00:20:09,742 line:-1
Or, if you need to handle them
from your main application,


450
00:20:09,742 --> 00:20:13,712 line:-1
you can return an Intent handler
from your application delegate.


451
00:20:13.712 --> 00:20:15.548 line:-1 position:50%
In your app delegate,
implement the


452
00:20:15.548 --> 00:20:18.384 line:-1 position:50%
application handlerFor intent:
method,


453
00:20:18.384 --> 00:20:21.954 line:-1 position:50%
returning a handler object for
any intent that you can handle.


454
00:20:21,954 --> 00:20:24,623 line:-1
Every type of intent
has its own handler protocol


455
00:20:24,623 --> 00:20:26,959 line:-1
that the returned object
must conform to,


456
00:20:26,959 --> 00:20:29,161 line:-1
so check the Intents framework
documentation


457
00:20:29.161 --> 00:20:33.065 line:-1 position:50%
for more details on implementing
a handler object.


458
00:20:33,065 --> 00:20:35,468 line:-1
Now that you're equipped with
all of this new information,


459
00:20:35.468 --> 00:20:37.169 line:-1 position:50%
what's next?


460
00:20:37.169 --> 00:20:40.106 line:-1 position:50%
First, think about how features
like control tinting


461
00:20:40.106 --> 00:20:44.076 line:-1 position:50%
and SF Symbols 3 can help you
enhance the design of your app.


462
00:20:44,076 --> 00:20:46,445 line:-1
Next, if your app uses TextKit


463
00:20:46,445 --> 00:20:48,914 line:-1
to create a custom
text experience,


464
00:20:48.914 --> 00:20:52.852 line:-1 position:50%
watch the "Meet TextKit 2" video
and try out the new API.


465
00:20:52,852 --> 00:20:54,487 line:-1
You're going to love
how easy it is


466
00:20:54.487 --> 00:21:00.159 line:-1 position:50%
to express custom layouts
and rich content with TextKit 2.


467
00:21:00.159 --> 00:21:03.062 line:-1 position:50%
The that way your app manages
concurrency is a key part


468
00:21:03,062 --> 00:21:04,663 line:-1
of its architecture,


469
00:21:04.663 --> 00:21:06.232 line:-1 position:50%
and Swift's new
concurrency features


470
00:21:06,232 --> 00:21:08,801 line:-1
will be a huge improvement
in this area.


471
00:21:08,801 --> 00:21:10,169 line:-1
Now is the time
to start planning


472
00:21:10,169 --> 00:21:12,605 line:-1
for how features
like async/await will shape


473
00:21:12.605 --> 00:21:16.408 line:-1 position:50%
the way your app manages
its concurrent workloads.


474
00:21:16.408 --> 00:21:18.878 line:-1 position:50%
Finally, get your app ready
for Shortcuts


475
00:21:18,878 --> 00:21:21,647 line:-1
by adopting AppKit's
automation features.


476
00:21:21.647 --> 00:21:23.149 line:-1 position:50%
Thanks for your time
and attention.


477
00:21:23,149 --> 00:21:25,117 line:-1
We hope you enjoy all
of these great enhancements


478
00:21:25.117 --> 00:21:26.785 line:-1 position:50%
in macOS Monterey.


479
00:21:26,785 --> 00:21:29,188 align:center size:2% position:89%
â™ª

