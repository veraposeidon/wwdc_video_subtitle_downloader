2
00:00:00,133 --> 00:00:02,169 line:-1
[MAC STARTUP CHIME]


3
00:00:02.169 --> 00:00:05.739 line:-1 position:50%
♪ Bass music playing ♪


4
00:00:05.739 --> 00:00:07.975 line:-1 position:50%
[KEYSTROKES]


5
00:00:07,975 --> 00:00:09,309 position:90% line:0 align:right
♪


6
00:00:09.309 --> 00:00:12.679 line:-1 position:50%
Juan Rodriguez Cuellar: Hello,
welcome to WWDC.


7
00:00:12.679 --> 00:00:14.481 line:-1 position:50%
My name
is Juan Rodriguez Cuellar,


8
00:00:14,481 --> 00:00:17,184 line:-1
and I'm a GPU compiler engineer
at Apple.


9
00:00:17.184 --> 00:00:19.519 line:-1 position:50%
In this session,
we’re going to talk about


10
00:00:19.519 --> 00:00:21.955 line:-1 position:50%
the brand-new features
we’ve added this year


11
00:00:21,955 --> 00:00:24,791 line:-1
to enhance
our Metal ray tracing API.


12
00:00:24.791 --> 00:00:28.528 line:-1 position:50%
But first, let’s do
a quick recap about ray tracing.


13
00:00:28.528 --> 00:00:32.199 line:-1 position:50%
Ray-tracing applications
are based on tracing the paths


14
00:00:32,199 --> 00:00:35,335 line:-1
that rays take as they interact
with a scene.


15
00:00:35.335 --> 00:00:38.305 line:-1 position:50%
Ray tracing is applied in
a lot of domains such as audio,


16
00:00:38.305 --> 00:00:40.641 line:-1 position:50%
physics simulation, and AI;


17
00:00:40.641 --> 00:00:44.878 line:-1 position:50%
but one of the main applications
is photorealistic rendering.


18
00:00:44.878 --> 00:00:46.680 line:-1 position:50%
In rendering applications,


19
00:00:46.680 --> 00:00:49.950 line:-1 position:50%
ray tracing is used to model
individual rays of light,


20
00:00:49.950 --> 00:00:53.186 line:-1 position:50%
which allow us to simulate
effects such as reflections,


21
00:00:53,186 --> 00:00:55,756 line:-1
soft shadows,
and indirect lighting.


22
00:00:55,756 --> 00:00:58,659 line:-1
That is just a general
definition of ray tracing.


23
00:00:58.659 --> 00:01:01.962 line:-1 position:50%
Let’s talk about
Metal’s approach to it.


24
00:01:01.962 --> 00:01:03.864 line:-1 position:50%
We start with a compute kernel.


25
00:01:03.864 --> 00:01:06.266 line:-1 position:50%
In our kernel, we generate rays,


26
00:01:06,266 --> 00:01:08,702 line:-1
which are emitted
into the scene.


27
00:01:08.702 --> 00:01:11.138 line:-1 position:50%
We then test those rays
for intersections


28
00:01:11,138 --> 00:01:13,273 line:-1
against the geometry
in the scene


29
00:01:13.273 --> 00:01:17.044 line:-1 position:50%
with an intersector
and an acceleration structure.


30
00:01:17.044 --> 00:01:18.412 line:-1 position:50%
Each intersection point


31
00:01:18.412 --> 00:01:20.881 line:-1 position:50%
represents light
bouncing off a surface;


32
00:01:20,881 --> 00:01:23,684 line:-1
how much light bounces
and in what direction


33
00:01:23,684 --> 00:01:26,520 line:-1
determines what the object
looks like.


34
00:01:26.520 --> 00:01:29.089 line:-1 position:50%
We then compute a color
for each intersection


35
00:01:29.089 --> 00:01:30.757 line:-1 position:50%
and update the image.


36
00:01:30.757 --> 00:01:32.826 line:-1 position:50%
This process is called shading


37
00:01:32.826 --> 00:01:35.295 line:-1 position:50%
and it can also generate
additional rays,


38
00:01:35,295 --> 00:01:38,932 line:-1
and those rays are also tested
for intersection.


39
00:01:38.932 --> 00:01:42.002 line:-1 position:50%
We repeat the process
as many times as we’d like


40
00:01:42,002 --> 00:01:44,771 line:-1
to simulate light
bouncing around the scene.


41
00:01:44,771 --> 00:01:47,107 line:-1
This year, we focused
our new features


42
00:01:47,107 --> 00:01:49,376 line:-1
around three major areas.


43
00:01:49,376 --> 00:01:52,713 line:-1
First, I will talk about how
we’ve added ray-tracing support


44
00:01:52.713 --> 00:01:54.481 line:-1 position:50%
to our render pipelines,


45
00:01:54,481 --> 00:01:57,884 line:-1
which allows us to mix
ray tracing with our rendering.


46
00:01:57,884 --> 00:02:01,154 line:-1
Then I will introduce you
to the new features


47
00:02:01.154 --> 00:02:04.491 line:-1 position:50%
that focus on the usability
and portability.


48
00:02:04,491 --> 00:02:09,196 line:-1
These features will ease the use
of Metal ray tracing API.


49
00:02:09,196 --> 00:02:12,232 line:-1
Finally, I will cover the
production rendering features


50
00:02:12,232 --> 00:02:14,001 line:-1
we’ve added this year


51
00:02:14.001 --> 00:02:17.971 line:-1 position:50%
that will help you create
more realistic content.


52
00:02:17.971 --> 00:02:21.742 line:-1 position:50%
Let's start with ray tracing
from render pipelines.


53
00:02:21.742 --> 00:02:23.643 line:-1 position:50%
Let’s consider the basic case


54
00:02:23.643 --> 00:02:27.347 line:-1 position:50%
of a render
that has a single render pass.


55
00:02:27.347 --> 00:02:30.984 line:-1 position:50%
With our new support for ray
tracing from render pipelines,


56
00:02:30.984 --> 00:02:35.889 line:-1 position:50%
this makes it super easy to add
ray tracing into the render.


57
00:02:35,889 --> 00:02:37,891 line:-1
However, without this support,


58
00:02:37,891 --> 00:02:40,060 line:-1
to add ray tracing
to this render


59
00:02:40,060 --> 00:02:42,996 line:-1
with last year’s
Metal ray tracing API,


60
00:02:42.996 --> 00:02:45.465 line:-1 position:50%
we need to add a compute pass.


61
00:02:45.465 --> 00:02:48.168 line:-1 position:50%
Let’s just start by adding it
after rendering


62
00:02:48.168 --> 00:02:51.838 line:-1 position:50%
to augment the rendered image.


63
00:02:51,838 --> 00:02:54,574 position:50%
Adding this extra compute pass


64
00:02:54,574 --> 00:02:56,676 position:50%
means writing more output
to memory


65
00:02:56,676 --> 00:02:59,579 position:50%
for the compute pass
to use for ray tracing.


66
00:02:59,579 --> 00:03:02,783 position:50%
Now, what if we wanted
to use ray tracing


67
00:03:02,783 --> 00:03:06,186 line:0
in the middle of our render pass
to calculate a value


68
00:03:06,186 --> 00:03:09,389 position:50%
such as shadowing per pixel?


69
00:03:09.389 --> 00:03:11.825 line:-1 position:50%
This means that we need
to split our rendering


70
00:03:11.825 --> 00:03:15.595 line:-1 position:50%
and introduce a compute pass.


71
00:03:15,595 --> 00:03:17,798 line:0
Thinking more about
what this means,


72
00:03:17,798 --> 00:03:20,801 line:0
we need to write out
pixel positions and normals


73
00:03:20,801 --> 00:03:23,970 position:50%
to memory as inputs
to the ray tracing,


74
00:03:23,970 --> 00:03:26,573 position:50%
and then read
the intersection results back --


75
00:03:26,573 --> 00:03:29,543 position:50%
possibly several times.


76
00:03:29,543 --> 00:03:33,080 position:50%
But with the new support for
ray tracing from render stages,


77
00:03:33,080 --> 00:03:35,382 position:50%
we never need to leave
our render pass


78
00:03:35,382 --> 00:03:38,118 position:50%
and we just write our outputs
to memory.


79
00:03:38,118 --> 00:03:40,754 line:0
Let's see how we use
our new API.


80
00:03:40.754 --> 00:03:43.256 line:-1 position:50%
Preparing our render pipeline
for ray tracing


81
00:03:43.256 --> 00:03:45.725 line:-1 position:50%
is similar
to a compute pipeline.


82
00:03:45.725 --> 00:03:48.028 line:-1 position:50%
You start by building
your acceleration structure


83
00:03:48,028 --> 00:03:51,431 line:-1
and defining
custom intersection functions.


84
00:03:51,431 --> 00:03:53,600 line:-1
To support custom intersection,


85
00:03:53.600 --> 00:03:55.936 line:-1 position:50%
we need
an intersection function table


86
00:03:55,936 --> 00:03:59,005 line:-1
and we need to fill it
with intersection functions.


87
00:03:59.005 --> 00:04:02.976 line:-1 position:50%
This part has some differences
compared to last year’s API.


88
00:04:02,976 --> 00:04:05,512 line:-1
Let’s walk through
how we can do that.


89
00:04:05.512 --> 00:04:09.015 line:-1 position:50%
Let’s consider some
simple intersection functions.


90
00:04:09.015 --> 00:04:11.685 line:-1 position:50%
I have some functions here
that will allow us


91
00:04:11.685 --> 00:04:15.489 line:-1 position:50%
to analytically intersect
objects such as a sphere,


92
00:04:15.489 --> 00:04:19.025 line:-1 position:50%
a cone, or torus.


93
00:04:19.025 --> 00:04:21.795 line:-1 position:50%
When we create our pipeline,
we add these functions


94
00:04:21,795 --> 00:04:24,865 line:-1
as linked functions
that we may call.


95
00:04:24,865 --> 00:04:26,633 line:-1
In this case, we are adding them


96
00:04:26.633 --> 00:04:30.270 line:-1 position:50%
to the fragment stage
of the pipeline.


97
00:04:30,270 --> 00:04:32,139 position:50%
To use the functions,


98
00:04:32,139 --> 00:04:34,875 line:0
we need to create
an intersection function table


99
00:04:34,875 --> 00:04:38,078 position:50%
from the pipeline state
and stage.


100
00:04:38,078 --> 00:04:41,781 line:0
Once we have the table,
we can create function handles


101
00:04:41,781 --> 00:04:43,717 position:50%
from the pipeline state
and stage


102
00:04:43,717 --> 00:04:47,354 position:50%
and populate the table.


103
00:04:47,354 --> 00:04:50,123 position:50%
Specifying the functions
for the fragment stage


104
00:04:50,123 --> 00:04:52,759 position:50%
reuses the linkedFunctions
object


105
00:04:52,759 --> 00:04:55,362 position:50%
that we introduced last year.


106
00:04:55,362 --> 00:04:58,632 position:50%
Each stage has its own set
of linkedFunctions


107
00:04:58,632 --> 00:05:02,536 line:0
on the render pipeline
descriptor.


108
00:05:02,536 --> 00:05:05,639 position:50%
Creating an intersection
function table


109
00:05:05,639 --> 00:05:09,176 line:0
is much the same as when done
for the compute pipeline.


110
00:05:09,176 --> 00:05:14,948 position:50%
The only change is the addition
of the stage argument.


111
00:05:14,948 --> 00:05:19,119 line:0
To populate the table,
we create the function handle.


112
00:05:19,119 --> 00:05:22,355 position:50%
Again, the handle
is specific to the stage,


113
00:05:22,355 --> 00:05:27,861 position:50%
so we need to specify the stage
when requesting the handle.


114
00:05:27,861 --> 00:05:29,896 line:0
Once we have
the function handle,


115
00:05:29,896 --> 00:05:33,500 position:50%
we just insert it
in the function table.


116
00:05:33,500 --> 00:05:36,937 position:50%
And that’s all you need to do
to prepare your function tables


117
00:05:36,937 --> 00:05:38,905 line:0
in render pipeline.


118
00:05:38,905 --> 00:05:42,909 position:50%
Now we just have to use
everything we have built so far


119
00:05:42,909 --> 00:05:45,312 line:0
to intersect.


120
00:05:45.312 --> 00:05:47.714 line:-1 position:50%
Actual use is straightforward.


121
00:05:47,714 --> 00:05:52,052 line:-1
The accelerationStructure and
the intersection function table


122
00:05:52,052 --> 00:05:57,657 line:-1
are both bound to buffer indices
on the render encoder.


123
00:05:57,657 --> 00:06:00,460 position:50%
The shaders can then use
these resources


124
00:06:00,460 --> 00:06:03,730 position:50%
to intersect rays
with an intersector


125
00:06:03,730 --> 00:06:06,533 position:50%
the same way you would
in a compute kernel.


126
00:06:06,533 --> 00:06:09,169 position:50%
More details about how
to prepare your pipeline


127
00:06:09,169 --> 00:06:13,139 position:50%
for ray tracing can be found
in last year’s presentation.


128
00:06:13,139 --> 00:06:14,975 line:0
In that talk,
you will learn about


129
00:06:14,975 --> 00:06:17,010 line:0
building acceleration
structures,


130
00:06:17,010 --> 00:06:19,012 position:50%
creating function tables,


131
00:06:19,012 --> 00:06:22,382 position:50%
and using the intersector
in the shading language.


132
00:06:22,382 --> 00:06:24,851 line:-1
With ray-tracing support
from render pipelines,


133
00:06:24.851 --> 00:06:27.821 line:-1 position:50%
we are opening the door
for even more opportunities


134
00:06:27,821 --> 00:06:30,890 line:-1
like adding ray tracing
within a single render pass,


135
00:06:30,890 --> 00:06:33,093 line:-1
mixing ray tracing
with rasterization


136
00:06:33.093 --> 00:06:34.461 line:-1 position:50%
in hybrid rendering,


137
00:06:34.461 --> 00:06:36.563 line:-1 position:50%
and taking advantage
of optimizations


138
00:06:36.563 --> 00:06:39.099 line:-1 position:50%
such as tile functions
on Apple Silicon.


139
00:06:39,099 --> 00:06:43,470 position:50%
In fact, we will be soon adding
ray tracing to our sample app


140
00:06:43,470 --> 00:06:45,939 line:0
that we demoed during the
"Modern Rendering in Metal"


141
00:06:45,939 --> 00:06:49,209 line:0
session at WWDC 2019.


142
00:06:49,209 --> 00:06:51,578 position:50%
With ray tracing
from render pipelines,


143
00:06:51,578 --> 00:06:54,014 line:0
we can update the code
to use tile functions


144
00:06:54,014 --> 00:06:56,249 line:0
to keep everything
in tile memory.


145
00:06:56,249 --> 00:06:58,785 line:0
For more details about this,
see this year’s


146
00:06:58,785 --> 00:07:03,290 line:0
"Explore hybrid rendering with
Metal ray tracing" presentation.


147
00:07:03.290 --> 00:07:06.493 line:-1 position:50%
Next up, I want to introduce
the new features we've added


148
00:07:06,493 --> 00:07:09,596 line:-1
this year to improve
the usability and portability


149
00:07:09.596 --> 00:07:11.865 line:-1 position:50%
of Metal ray tracing API.


150
00:07:11,865 --> 00:07:13,733 line:-1
These features not only provide


151
00:07:13.733 --> 00:07:15.969 line:-1 position:50%
simpler use
of Metal ray tracing,


152
00:07:15.969 --> 00:07:17.971 line:-1 position:50%
but they also provide
portability


153
00:07:17.971 --> 00:07:20.707 line:-1 position:50%
from other ray tracing APIs.


154
00:07:20.707 --> 00:07:23.743 line:-1 position:50%
One of these new features
is intersection query.


155
00:07:23,743 --> 00:07:25,211 line:-1
With intersection query,


156
00:07:25.211 --> 00:07:27.047 line:-1 position:50%
we’re allowing you to have
more control


157
00:07:27.047 --> 00:07:29.816 line:-1 position:50%
over the intersection process.


158
00:07:29,816 --> 00:07:33,219 line:-1
Intersection query is aimed
toward simple use cases


159
00:07:33,219 --> 00:07:36,156 line:-1
where intersector
can create overhead.


160
00:07:36,156 --> 00:07:39,426 line:-1
It is a new way of traversing
the acceleration structure


161
00:07:39.426 --> 00:07:41.328 line:-1 position:50%
that gives you the option
of performing


162
00:07:41,328 --> 00:07:44,497 line:-1
in-line custom intersection
testing.


163
00:07:44,497 --> 00:07:46,733 line:-1
Let's take a look
at how we currently handle


164
00:07:46.733 --> 00:07:50.670 line:-1 position:50%
custom intersection
using last year’s intersector.


165
00:07:50,670 --> 00:07:53,907 position:50%
Going back to the alpha test
example from last year’s


166
00:07:53,907 --> 00:07:56,643 line:0
ray tracing with Metal
presentation,


167
00:07:56,643 --> 00:07:59,612 line:0
we demonstrated
how alpha testing is used


168
00:07:59,612 --> 00:08:03,149 position:50%
to add a lot of geometric detail
to the scene,


169
00:08:03,149 --> 00:08:06,353 position:50%
as you see here
in the chains and leaves.


170
00:08:06,353 --> 00:08:10,290 position:50%
We also learned how easy it is
to implement alpha testing


171
00:08:10,290 --> 00:08:12,859 line:0
by customizing an intersector


172
00:08:12,859 --> 00:08:16,262 line:0
using the triangle intersection
function.


173
00:08:16.262 --> 00:08:19.265 line:-1 position:50%
The logic inside this triangle
intersection function


174
00:08:19.265 --> 00:08:23.470 line:-1 position:50%
is responsible for accepting
or rejecting intersections


175
00:08:23,470 --> 00:08:27,340 line:-1
as the ray traverses
the acceleration structure.


176
00:08:27,340 --> 00:08:31,978 line:-1
In this case, test logic will
reject the first intersection,


177
00:08:31.978 --> 00:08:35.248 line:-1 position:50%
but it will accept
the second intersection


178
00:08:35,248 --> 00:08:38,985 line:-1
since an opaque surface
has been intersected.


179
00:08:38,985 --> 00:08:43,156 line:-1
Let’s see how
intersection functions are used.


180
00:08:43,156 --> 00:08:46,726 position:50%
When using Intersector,
when you call intersect(),


181
00:08:46,726 --> 00:08:49,829 line:0
we start traversing
the acceleration structure


182
00:08:49,829 --> 00:08:51,431 line:0
to find an intersection


183
00:08:51,431 --> 00:08:54,167 position:50%
and fill our
intersection_result.


184
00:08:54,167 --> 00:08:55,835 line:0
Within the intersector,


185
00:08:55,835 --> 00:08:58,071 position:50%
intersection function
gets called


186
00:08:58,071 --> 00:09:02,342 position:50%
each time a potential
intersection is found.


187
00:09:02,342 --> 00:09:05,345 position:50%
And intersections are then
accepted or rejected


188
00:09:05,345 --> 00:09:08,581 position:50%
based on intersection function
logic.


189
00:09:08,581 --> 00:09:12,118 line:0
This is a great programming
model using intersector


190
00:09:12,118 --> 00:09:14,921 position:50%
since it is both performant
and convenient,


191
00:09:14,921 --> 00:09:18,892 position:50%
but it does require creating
a new intersection function


192
00:09:18,892 --> 00:09:21,628 position:50%
and linking it to the pipeline.


193
00:09:21.628 --> 00:09:23.163 line:-1 position:50%
There might be cases


194
00:09:23.163 --> 00:09:26.199 line:-1 position:50%
where the logic inside
the intersection function


195
00:09:26,199 --> 00:09:28,401 line:-1
is only a few lines of code,


196
00:09:28.401 --> 00:09:32.806 line:-1 position:50%
as it is the case
for alpha test logic.


197
00:09:32.806 --> 00:09:34.641 line:-1 position:50%
This is
the intersection function


198
00:09:34,641 --> 00:09:38,044 line:-1
that contains the logic
to do alpha testing.


199
00:09:38,044 --> 00:09:41,881 line:0
With intersection query,
we can place this logic in-line


200
00:09:41,881 --> 00:09:44,851 line:0
without the need
of this intersection function.


201
00:09:44,851 --> 00:09:47,821 position:50%
Here is how.


202
00:09:47,821 --> 00:09:49,255 position:50%
With intersection query,


203
00:09:49,255 --> 00:09:51,925 position:50%
when you start
the intersection process,


204
00:09:51,925 --> 00:09:54,828 position:50%
your ray traverses
the acceleration structure,


205
00:09:54,828 --> 00:09:57,964 line:0
and the query object contains
the state of the traversal


206
00:09:57,964 --> 00:10:01,034 position:50%
and the result.


207
00:10:01,034 --> 00:10:03,803 position:50%
Each time the ray intersects
a custom primitive


208
00:10:03,803 --> 00:10:06,105 position:50%
or a nonopaque triangle,


209
00:10:06,105 --> 00:10:08,308 line:0
control is returned
to the shader


210
00:10:08,308 --> 00:10:12,412 position:50%
for you to evaluate
the intersection candidates.


211
00:10:12,412 --> 00:10:16,216 line:0
If the current candidate passes
your custom intersection logic,


212
00:10:16,216 --> 00:10:18,084 line:0
you commit it to update


213
00:10:18,084 --> 00:10:20,487 line:0
the current
committed intersection


214
00:10:20,487 --> 00:10:24,023 position:50%
and then continue
the intersection process.


215
00:10:24,023 --> 00:10:28,394 line:0
On the other hand, if candidate
fails custom intersection logic,


216
00:10:28,394 --> 00:10:31,231 line:0
you can just ignore it
and continue.


217
00:10:31,231 --> 00:10:33,733 position:50%
Let me show you the code
to do alpha testing


218
00:10:33,733 --> 00:10:36,302 position:50%
using intersection query.


219
00:10:36,302 --> 00:10:39,339 line:-1
First, you start the traversal.


220
00:10:39.339 --> 00:10:41.774 line:-1 position:50%
Note that we loop on next


221
00:10:41,774 --> 00:10:45,678 line:-1
to evaluate
all candidate intersections.


222
00:10:45,678 --> 00:10:48,381 line:-1
Second, you evaluate
each candidate


223
00:10:48.381 --> 00:10:51.684 line:-1 position:50%
starting by checking
the candidate type.


224
00:10:51,684 --> 00:10:54,287 line:-1
For alpha test example,
you're interested


225
00:10:54.287 --> 00:10:57.924 line:-1 position:50%
on intersections
of triangle type.


226
00:10:57.924 --> 00:11:00.460 line:-1 position:50%
After checking the type,
you'll want to query


227
00:11:00.460 --> 00:11:03.730 line:-1 position:50%
some intersection information
about the candidate.


228
00:11:03.730 --> 00:11:06.666 line:-1 position:50%
We perform three queries
for information needed


229
00:11:06.666 --> 00:11:11.304 line:-1 position:50%
in the alpha test logic
which is now in-lined.


230
00:11:11,304 --> 00:11:15,575 position:50%
Finally, if the candidate
intersection passes alpha test,


231
00:11:15,575 --> 00:11:17,243 position:50%
you will commit it
so that it becomes


232
00:11:17,243 --> 00:11:20,580 position:50%
the current committed
intersection.


233
00:11:20.580 --> 00:11:24.951 line:-1 position:50%
Up to now, you have traversed
the whole acceleration structure


234
00:11:24.951 --> 00:11:27.353 line:-1 position:50%
evaluating
candidate intersections


235
00:11:27.353 --> 00:11:28.922 line:-1 position:50%
and commit the intersections


236
00:11:28,922 --> 00:11:31,457 line:-1
that passed
the alpha test logic.


237
00:11:31,457 --> 00:11:35,628 line:-1
Now, you need to query committed
intersection information


238
00:11:35.628 --> 00:11:38.531 line:-1 position:50%
to do the shading.


239
00:11:38.531 --> 00:11:41.768 line:-1 position:50%
First, you will query
the committed type.


240
00:11:41,768 --> 00:11:44,504 line:-1
If none
of the candidate intersections


241
00:11:44,504 --> 00:11:48,007 line:-1
met your conditions to become
a committed intersection,


242
00:11:48.007 --> 00:11:49.842 line:-1 position:50%
committed type will be none,


243
00:11:49.842 --> 00:11:53.146 line:-1 position:50%
which means
the current ray missed.


244
00:11:53,146 --> 00:11:54,681 line:-1
On the other hand,


245
00:11:54,681 --> 00:11:56,950 line:-1
if there is
a committed intersection,


246
00:11:56,950 --> 00:11:58,851 line:-1
you would want
to query information


247
00:11:58.851 --> 00:12:00.553 line:-1 position:50%
about the intersection


248
00:12:00,553 --> 00:12:02,822 line:-1
applicable
to the intersection type


249
00:12:02.822 --> 00:12:05.258 line:-1 position:50%
and then use it for shading.


250
00:12:05,258 --> 00:12:08,261 line:-1
That’s all the code you need
to perform alpha testing


251
00:12:08.261 --> 00:12:10.163 line:-1 position:50%
using intersection query.


252
00:12:10.163 --> 00:12:13.066 line:-1 position:50%
With the introduction
of intersection query


253
00:12:13,066 --> 00:12:16,502 line:-1
and the introduction of
intersector to render pipeline,


254
00:12:16,502 --> 00:12:18,371 line:-1
we are giving you
more opportunities


255
00:12:18,371 --> 00:12:21,975 line:-1
to start bringing
Metal ray tracing to your apps.


256
00:12:21,975 --> 00:12:25,078 line:-1
Here are some things to consider
when choosing between


257
00:12:25,078 --> 00:12:29,515 line:-1
intersector objects
and intersection queries.


258
00:12:29.515 --> 00:12:32.952 line:-1 position:50%
Start by considering
if you have existing code,


259
00:12:32,952 --> 00:12:35,688 line:-1
such as using the intersector
in compute


260
00:12:35.688 --> 00:12:38.191 line:-1 position:50%
and your plans
for porting that code.


261
00:12:38.191 --> 00:12:42.128 line:-1 position:50%
If you have existing query code
from other APIs,


262
00:12:42,128 --> 00:12:46,366 line:-1
intersection query
can help to port that code.


263
00:12:46,366 --> 00:12:51,704 line:-1
Next, you have the complexity
of handling custom intersection.


264
00:12:51,704 --> 00:12:54,440 line:-1
Intersector requires
intersection functions


265
00:12:54.440 --> 00:12:58.411 line:-1 position:50%
and tables, and it might be
easier to use intersection query


266
00:12:58,411 --> 00:13:02,248 line:-1
to handle custom
intersection yourself.


267
00:13:02,248 --> 00:13:04,817 position:50%
The last question
is performance.


268
00:13:04,817 --> 00:13:06,486 position:50%
In simpler cases,


269
00:13:06,486 --> 00:13:09,055 line:0
intersection query
can avoid overhead


270
00:13:09,055 --> 00:13:11,791 position:50%
when building your pipeline
for ray tracing,


271
00:13:11,791 --> 00:13:13,760 line:0
but custom intersection handling


272
00:13:13,760 --> 00:13:16,663 position:50%
requires returning to your code
during traversal,


273
00:13:16,663 --> 00:13:18,998 line:0
which could have
a performance impact,


274
00:13:18,998 --> 00:13:21,267 position:50%
depending on the use case.


275
00:13:21,267 --> 00:13:23,803 position:50%
Also, use of multiple
query objects


276
00:13:23,803 --> 00:13:26,673 position:50%
will require more memory.


277
00:13:26,673 --> 00:13:28,274 position:50%
On the other hand,


278
00:13:28,274 --> 00:13:31,577 position:50%
intersector can support
those more complex cases


279
00:13:31,577 --> 00:13:34,947 position:50%
by encapsulating
all of the intersection work.


280
00:13:34,947 --> 00:13:37,817 line:0
If you have the opportunity,
we would recommend


281
00:13:37,817 --> 00:13:41,220 position:50%
comparing the performance
of both solutions.


282
00:13:41,220 --> 00:13:43,456 position:50%
That’s all about
intersection query.


283
00:13:43,456 --> 00:13:46,759 line:0
Now let’s move on
to some other new features.


284
00:13:46,759 --> 00:13:49,328 line:-1
The next two features
we’re going to talk about


285
00:13:49.328 --> 00:13:52.765 line:-1 position:50%
are user instance IDs
and instance transforms.


286
00:13:52.765 --> 00:13:55.468 line:-1 position:50%
These features will help
you add more information


287
00:13:55,468 --> 00:13:57,370 line:-1
to your acceleration structure


288
00:13:57,370 --> 00:14:01,007 line:-1
and access more of the data
that is already there.


289
00:14:01.007 --> 00:14:03.976 line:-1 position:50%
Here is why we think these
are really useful features.


290
00:14:03.976 --> 00:14:06.145 line:-1 position:50%
If we look back
to the sample code


291
00:14:06.145 --> 00:14:08.247 line:-1 position:50%
from last year’s presentation,


292
00:14:08.247 --> 00:14:11.918 line:-1 position:50%
we have multiple instances
of the kernel box.


293
00:14:11.918 --> 00:14:15.755 line:-1 position:50%
Underneath this, we have an
instance acceleration structure


294
00:14:15.755 --> 00:14:20.393 line:-1 position:50%
with a set of nodes that branch
until you reach the instances.


295
00:14:20,393 --> 00:14:22,562 line:0
Looking at two
of these instances,


296
00:14:22,562 --> 00:14:24,163 line:0
they are at the lowest level


297
00:14:24,163 --> 00:14:27,100 line:0
of the instance acceleration
structure.


298
00:14:27.100 --> 00:14:30.703 line:-1 position:50%
Currently, when you intersect
one of these instances,


299
00:14:30.703 --> 00:14:33.506 line:-1 position:50%
you only get
the system’s instance ID


300
00:14:33,506 --> 00:14:35,475 line:-1
from the intersection results.


301
00:14:35.475 --> 00:14:39.645 line:-1 position:50%
With this, you could maintain
your own table of data,


302
00:14:39.645 --> 00:14:41.414 line:-1 position:50%
but there’s data
that we can expose


303
00:14:41.414 --> 00:14:44.517 line:-1 position:50%
in the acceleration structure
to help you.


304
00:14:44,517 --> 00:14:48,654 line:0
Let’s talk about user-defined
instance IDs first.


305
00:14:48,654 --> 00:14:52,391 line:-1
With this feature, you can
specify a custom 32-bit value


306
00:14:52.391 --> 00:14:55.728 line:-1 position:50%
for each instance
and then you get this value


307
00:14:55,728 --> 00:14:58,197 line:-1
as part of the intersection
results.


308
00:14:58.197 --> 00:15:00.099 line:-1 position:50%
This is really useful for you


309
00:15:00.099 --> 00:15:02.301 line:-1 position:50%
to index into your own
data structures,


310
00:15:02.301 --> 00:15:06.139 line:-1 position:50%
but it can also be used
to encode custom data.


311
00:15:06.139 --> 00:15:09.642 line:-1 position:50%
For example, here we’re using
the user ID


312
00:15:09.642 --> 00:15:13.045 line:-1 position:50%
to encode a custom color
for each instance.


313
00:15:13,045 --> 00:15:15,515 line:-1
You could use this
for a simpler reflection


314
00:15:15.515 --> 00:15:19.685 line:-1 position:50%
with no need to look up any
additional material information.


315
00:15:19.685 --> 00:15:21.487 line:-1 position:50%
This is just one example,


316
00:15:21.487 --> 00:15:23.856 line:-1 position:50%
but the opportunities
are endless.


317
00:15:23,856 --> 00:15:26,325 line:-1
I can see how you would want
to encode things


318
00:15:26.325 --> 00:15:31.230 line:-1 position:50%
like per-instance material ID
or per-instance flags.


319
00:15:31,230 --> 00:15:33,466 line:-1
We have created
an extended version


320
00:15:33,466 --> 00:15:39,238 line:-1
of instance descriptor type that
is used to specify these IDs.


321
00:15:39,238 --> 00:15:42,942 line:0
Make sure you specify which type
of descriptor you’re using


322
00:15:42,942 --> 00:15:48,080 position:50%
on the instance acceleration
structure descriptor.


323
00:15:48.080 --> 00:15:49.682 line:-1 position:50%
In the shading language,


324
00:15:49.682 --> 00:15:52.552 line:-1 position:50%
the value of the current
user instance ID


325
00:15:52,552 --> 00:15:54,253 line:-1
is available as an input


326
00:15:54.253 --> 00:15:59.058 line:-1 position:50%
to intersection functions
with the instancing tag.


327
00:15:59.058 --> 00:16:02.295 line:-1 position:50%
To obtain the values
after intersection,


328
00:16:02,295 --> 00:16:04,864 line:-1
the user-defined instance ID


329
00:16:04.864 --> 00:16:07.633 line:-1 position:50%
is available
from the intersection result


330
00:16:07.633 --> 00:16:09.936 line:-1 position:50%
when using
an intersector object.


331
00:16:09,936 --> 00:16:12,772 position:50%
And when using
intersection query object,


332
00:16:12,772 --> 00:16:14,841 line:0
there is a corresponding query


333
00:16:14,841 --> 00:16:18,010 line:0
to access
the user-defined instance ID


334
00:16:18,010 --> 00:16:21,781 line:0
for both candidate
and committed intersections.


335
00:16:21.781 --> 00:16:25.284 line:-1 position:50%
Just like user instance ID,
we have added support


336
00:16:25,284 --> 00:16:28,688 line:-1
for accessing your instance
transformation matrices.


337
00:16:28.688 --> 00:16:33.025 line:-1 position:50%
This data is already specified
in the instance descriptor,


338
00:16:33,025 --> 00:16:37,797 line:-1
and it is stored
in the acceleration structure.


339
00:16:37,797 --> 00:16:40,733 line:-1
This year, we’ve exposed
these matrices


340
00:16:40,733 --> 00:16:42,668 line:-1
from the shading language.


341
00:16:42.668 --> 00:16:44.804 line:-1 position:50%
You can access
the instance transforms


342
00:16:44,804 --> 00:16:47,373 line:-1
in the intersection functions
when you apply


343
00:16:47.373 --> 00:16:51.244 line:-1 position:50%
the instancing
and world_space_data tags.


344
00:16:51.244 --> 00:16:54.914 line:-1 position:50%
Similarly, the instance
transforms are provided


345
00:16:54,914 --> 00:16:58,584 line:-1
in the intersection results
when using an intersector


346
00:16:58,584 --> 00:17:03,055 line:-1
with instancing
and world_space_data tags.


347
00:17:03.055 --> 00:17:06.726 line:-1 position:50%
When using intersection query
with instancing tag,


348
00:17:06.726 --> 00:17:08.394 line:-1 position:50%
there are corresponding queries


349
00:17:08,394 --> 00:17:10,529 line:-1
for accessing
the instance transforms


350
00:17:10.529 --> 00:17:14.634 line:-1 position:50%
for both candidate
and committed intersections.


351
00:17:14.634 --> 00:17:17.036 line:-1 position:50%
To summarize,
this year we are improving


352
00:17:17,036 --> 00:17:21,374 line:-1
the usability and portability
of Metal ray tracing API


353
00:17:21,374 --> 00:17:23,910 line:-1
by introducing
three new features.


354
00:17:23,910 --> 00:17:28,347 line:-1
Intersection query comes
as an alternative to intersector


355
00:17:28.347 --> 00:17:32.485 line:-1 position:50%
that provides more control
over the intersection process.


356
00:17:32.485 --> 00:17:35.588 line:-1 position:50%
And with the introduction
of user instance ID


357
00:17:35.588 --> 00:17:37.356 line:-1 position:50%
and instance transforms
features,


358
00:17:37.356 --> 00:17:40.159 line:-1 position:50%
we are providing you the ability
to access data


359
00:17:40.159 --> 00:17:43.462 line:-1 position:50%
from the acceleration structure
instead of having to handle


360
00:17:43,462 --> 00:17:46,532 line:-1
some external mapping
in your code.


361
00:17:46.532 --> 00:17:48.768 line:-1 position:50%
In addition,
these three features


362
00:17:48.768 --> 00:17:52.405 line:-1 position:50%
offer portability
from other ray tracing APIs,


363
00:17:52,405 --> 00:17:55,875 line:-1
making cross-platform
development easier.


364
00:17:55,875 --> 00:17:58,177 line:-1
So far in the session,
we have talked about


365
00:17:58.177 --> 00:18:01.380 line:-1 position:50%
our new support for ray tracing
in render pipeline


366
00:18:01.380 --> 00:18:04.016 line:-1 position:50%
and the different usability
and portability features


367
00:18:04.016 --> 00:18:05.651 line:-1 position:50%
we have added this year.


368
00:18:05.651 --> 00:18:08.788 line:-1 position:50%
Now, let me show you
what features we are introducing


369
00:18:08.788 --> 00:18:11.157 line:-1 position:50%
to enhance production rendering.


370
00:18:11.157 --> 00:18:15.328 line:-1 position:50%
Since Metal ray tracing API
was introduced last year,


371
00:18:15.328 --> 00:18:17.263 line:-1 position:50%
people have been using it
to render


372
00:18:17,263 --> 00:18:20,399 line:-1
some amazing
high-quality content.


373
00:18:20.399 --> 00:18:23.336 line:-1 position:50%
This year, we’ve added
two new features


374
00:18:23.336 --> 00:18:26.973 line:-1 position:50%
to make it possible to render
even better content.


375
00:18:26.973 --> 00:18:29.375 line:-1 position:50%
Let's start
with extended limits.


376
00:18:29.375 --> 00:18:32.845 line:-1 position:50%
Since we released
the Metal ray tracing API,


377
00:18:32.845 --> 00:18:35.715 line:-1 position:50%
some users have started hitting
the internal limits


378
00:18:35.715 --> 00:18:37.850 line:-1 position:50%
of our acceleration structures,


379
00:18:37,850 --> 00:18:41,320 line:-1
especially in production-scale
use cases.


380
00:18:41,320 --> 00:18:44,657 line:-1
So we are adding support
for an extended-limits mode


381
00:18:44,657 --> 00:18:48,027 line:-1
to support even larger scenes.


382
00:18:48.027 --> 00:18:50.529 line:-1 position:50%
Last year, we chose these limits


383
00:18:50,529 --> 00:18:53,332 line:-1
to balance
acceleration structure size


384
00:18:53.332 --> 00:18:57.570 line:-1 position:50%
in order to favor performance
with typical scene sizes.


385
00:18:57.570 --> 00:19:00.139 line:-1 position:50%
There is a potential
performance trade-off


386
00:19:00.139 --> 00:19:03.242 line:-1 position:50%
to turning on this feature,
so you’ll need to determine


387
00:19:03,242 --> 00:19:06,412 line:-1
which mode is best
for your application.


388
00:19:06,412 --> 00:19:09,248 position:50%
Extended-limits mode
increases the limit


389
00:19:09,248 --> 00:19:13,486 position:50%
on the number of primitives,
geometries, instances,


390
00:19:13,486 --> 00:19:15,588 position:50%
as well as the size of the mask


391
00:19:15,588 --> 00:19:18,691 line:0
used for filtering out
instances.


392
00:19:18,691 --> 00:19:23,129 line:-1
To turn it on, you first specify
extended limits mode


393
00:19:23.129 --> 00:19:25.998 line:-1 position:50%
when building
your acceleration structures.


394
00:19:25,998 --> 00:19:29,335 line:-1
Then specify
the extended_limits tag


395
00:19:29.335 --> 00:19:32.938 line:-1 position:50%
on the intersector object
in the shading language.


396
00:19:32.938 --> 00:19:36.509 line:-1 position:50%
That’s all you need to do
to turn on extended limits!


397
00:19:36,509 --> 00:19:39,512 line:-1
Next, let’s talk about motion.


398
00:19:39,512 --> 00:19:40,946 line:-1
In computer graphics,


399
00:19:40.946 --> 00:19:45.184 line:-1 position:50%
we often assume that the camera
exposure is instantaneous.


400
00:19:45,184 --> 00:19:47,620 line:-1
However, in real life,


401
00:19:47,620 --> 00:19:52,224 line:-1
the camera exposure lasts
for a nonzero period of time.


402
00:19:52,224 --> 00:19:55,394 line:-1
If an object moves relative
to the camera during that time,


403
00:19:55.394 --> 00:19:58.297 line:-1 position:50%
it will appear blurred
in the image.


404
00:19:58,297 --> 00:20:00,099 line:-1
In this extreme example,


405
00:20:00.099 --> 00:20:03.002 line:-1 position:50%
the person in the center
has been standing still


406
00:20:03.002 --> 00:20:05.071 line:-1 position:50%
during the whole exposure


407
00:20:05.071 --> 00:20:07.039 line:-1 position:50%
while everyone else
has been moving,


408
00:20:07.039 --> 00:20:09.275 line:-1 position:50%
causing them to be blurred.


409
00:20:09.275 --> 00:20:12.044 line:-1 position:50%
This effect can go a long way
towards making


410
00:20:12,044 --> 00:20:16,816 line:-1
computer-generated images
look more realistic.


411
00:20:16,816 --> 00:20:18,584 line:0
In this example,


412
00:20:18,584 --> 00:20:22,054 position:50%
the sphere is animated
across several frames,


413
00:20:22,054 --> 00:20:25,591 position:50%
but each frame is still
an instantaneous exposure,


414
00:20:25,591 --> 00:20:28,794 line:0
resulting in a choppy animation.


415
00:20:28,794 --> 00:20:30,863 position:50%
Using the motion API,


416
00:20:30,863 --> 00:20:33,199 line:0
we can simulate
camera exposure


417
00:20:33,199 --> 00:20:36,068 position:50%
lasting for a nonzero
amount of time.


418
00:20:36,068 --> 00:20:37,503 line:0
This results in a smoother


419
00:20:37,503 --> 00:20:41,240 line:0
and more realistic-looking
animation.


420
00:20:41,240 --> 00:20:43,375 position:50%
If we freeze the video,


421
00:20:43,375 --> 00:20:46,545 line:0
you can see that the boundaries
of the sphere are blurred


422
00:20:46,545 --> 00:20:50,516 line:0
in the direction of motion
just like a real camera.


423
00:20:50,516 --> 00:20:52,985 line:0
Real-time applications
like games


424
00:20:52,985 --> 00:20:56,522 position:50%
often approximate this effect
in screen space.


425
00:20:56,522 --> 00:20:58,891 position:50%
But ray tracing
allows us to simulate


426
00:20:58,891 --> 00:21:01,260 position:50%
physically accurate motion blur,


427
00:21:01,260 --> 00:21:03,863 position:50%
which even extends
to indirect effects


428
00:21:03,863 --> 00:21:06,599 line:0
like shadows and reflections.


429
00:21:06.599 --> 00:21:07.800 line:-1 position:50%
Let’s take a look


430
00:21:07.800 --> 00:21:11.770 line:-1 position:50%
at how the motion-blurred
version was rendered.


431
00:21:11,770 --> 00:21:15,674 line:-1
Motion blur is a straightforward
extension to ray tracing.


432
00:21:15,674 --> 00:21:18,978 line:-1
Most ray-tracing applications
already randomly sample


433
00:21:18.978 --> 00:21:22.581 line:-1 position:50%
the physical dimensions such as
incoming light directions


434
00:21:22,581 --> 00:21:24,984 line:-1
for indirect lighting.


435
00:21:24,984 --> 00:21:26,552 line:-1
To add motion blur,


436
00:21:26,552 --> 00:21:31,690 line:-1
we can just choose a random time
for each ray as well.


437
00:21:31,690 --> 00:21:35,394 line:0
Metal will intersect the scene
to match the point in time


438
00:21:35,394 --> 00:21:37,963 line:0
associated with each ray.


439
00:21:37,963 --> 00:21:42,535 line:0
For instance, this ray
will see the scene like this.


440
00:21:42,535 --> 00:21:46,805 position:50%
Another ray will see the scene
like this.


441
00:21:46,805 --> 00:21:49,475 position:50%
As we accumulate
more and more samples,


442
00:21:49,475 --> 00:21:52,912 line:0
we’ll start to converge
on a motion-blurred image.


443
00:21:52,912 --> 00:21:55,714 line:-1
You could actually already
implement this today


444
00:21:55,714 --> 00:21:58,817 line:-1
using custom intersection
functions.


445
00:21:58.817 --> 00:22:00.920 line:-1 position:50%
You could compute
the bounding boxes


446
00:22:00.920 --> 00:22:04.356 line:-1 position:50%
of each primitive
throughout the entire exposure


447
00:22:04.356 --> 00:22:05.791 line:-1 position:50%
and then use
these bounding boxes


448
00:22:05.791 --> 00:22:08.861 line:-1 position:50%
to build
an acceleration structure.


449
00:22:08,861 --> 00:22:11,564 line:-1
However,
this would be inefficient;


450
00:22:11,564 --> 00:22:14,066 line:-1
the bounding boxes
could be so large


451
00:22:14.066 --> 00:22:17.002 line:-1 position:50%
that some rays would need
to check for intersection


452
00:22:17.002 --> 00:22:21.140 line:-1 position:50%
with primitives that they will
never actually intersect.


453
00:22:21,140 --> 00:22:25,411 line:-1
Instead, we can use Metal’s
built-in support for motion blur


454
00:22:25.411 --> 00:22:30.616 line:-1 position:50%
which is designed to efficiently
handle cases like this.


455
00:22:30,616 --> 00:22:34,753 line:-1
The first thing we need to do
is associate a random time


456
00:22:34,753 --> 00:22:38,857 line:-1
with each ray in our
Metal shading language code.


457
00:22:38.857 --> 00:22:41.126 line:-1 position:50%
We start by generating
a random time


458
00:22:41.126 --> 00:22:43.862 line:-1 position:50%
within the exposure interval,


459
00:22:43,862 --> 00:22:47,433 line:-1
then we just pass it
to the intersector.


460
00:22:47,433 --> 00:22:49,435 line:-1
The next thing we need to do


461
00:22:49,435 --> 00:22:54,473 line:-1
is to provide our
animated geometry to Metal.


462
00:22:54,473 --> 00:22:57,376 line:-1
We do this using
a common method of animation


463
00:22:57,376 --> 00:22:59,578 line:-1
called keyframe animation.


464
00:22:59,578 --> 00:23:02,948 line:-1
The animation is created
by modeling the ball


465
00:23:02,948 --> 00:23:06,552 line:-1
at key points in time
called keyframes.


466
00:23:06,552 --> 00:23:09,488 line:0
These keyframes
are uniformly distributed


467
00:23:09,488 --> 00:23:14,526 line:0
between the start and end
of our animation.


468
00:23:14,526 --> 00:23:17,763 position:50%
As rays traverse
the acceleration structure,


469
00:23:17,763 --> 00:23:20,532 line:0
they can fetch data
from any keyframe


470
00:23:20,532 --> 00:23:23,135 line:0
based on their time value.


471
00:23:23,135 --> 00:23:26,805 line:0
For instance Ray A
would see the scene


472
00:23:26,805 --> 00:23:29,341 position:50%
as it was modeled in Keyframe 11


473
00:23:29,341 --> 00:23:33,212 position:50%
because its time
happens to match Keyframe 11.


474
00:23:33,212 --> 00:23:38,817 line:0
In contrast, Ray B’s time is
in between Keyframes 3 and 4.


475
00:23:38,817 --> 00:23:42,021 line:0
Therefore, the geometry
of the two keyframes


476
00:23:42,021 --> 00:23:46,258 position:50%
is interpolated for Ray B.


477
00:23:46,258 --> 00:23:48,427 position:50%
Motion is supported
at both the instance


478
00:23:48,427 --> 00:23:50,195 position:50%
and primitive level.


479
00:23:50,195 --> 00:23:52,298 line:0
Instance animation can be used


480
00:23:52,298 --> 00:23:55,034 position:50%
to rigidly transform
entire objects.


481
00:23:55,034 --> 00:23:57,569 position:50%
This is cheaper
than primitive animation


482
00:23:57,569 --> 00:24:00,406 position:50%
but doesn’t allow objects
to deform.


483
00:24:00,406 --> 00:24:01,774 position:50%
On the other hand,


484
00:24:01,774 --> 00:24:04,543 position:50%
primitive animation
is more expensive,


485
00:24:04,543 --> 00:24:09,782 position:50%
but can be used for things like
skinned-character animation.


486
00:24:09,782 --> 00:24:12,851 position:50%
Note that both instance
and primitive animation


487
00:24:12,851 --> 00:24:16,588 position:50%
are based on keyframe animation.


488
00:24:16,588 --> 00:24:20,059 line:-1
Let’s first talk about
instance motion.


489
00:24:20,059 --> 00:24:22,661 line:-1
In an instance acceleration
structure,


490
00:24:22,661 --> 00:24:27,333 line:-1
each instance is associated
with a transformation matrix.


491
00:24:27,333 --> 00:24:28,867 line:-1
This matrix describes


492
00:24:28,867 --> 00:24:31,804 line:-1
where to place the geometry
in the scene.


493
00:24:31,804 --> 00:24:33,272 line:0
In this example,


494
00:24:33,272 --> 00:24:36,275 position:50%
we have two primitive
acceleration structures:


495
00:24:36,275 --> 00:24:40,979 position:50%
one for the sphere and another
for the static geometry.


496
00:24:40,979 --> 00:24:45,818 line:0
Each primitive acceleration
structure has a single instance.


497
00:24:45,818 --> 00:24:47,920 line:0
To animate the sphere,


498
00:24:47,920 --> 00:24:50,823 position:50%
we will provide
two transformation matrices,


499
00:24:50,823 --> 00:24:55,694 line:0
representing the start
and end point of the animation.


500
00:24:55,694 --> 00:24:58,497 position:50%
Metal will then interpolate
these two matrices


501
00:24:58,497 --> 00:25:01,800 position:50%
based on the time parameter
for each ray.


502
00:25:01,800 --> 00:25:05,371 position:50%
Keep in mind that this is
a specific example


503
00:25:05,371 --> 00:25:07,106 position:50%
using two keyframes,


504
00:25:07,106 --> 00:25:12,010 line:0
but Metal supports an arbitrary
number of key frames.


505
00:25:12,010 --> 00:25:14,179 line:0
We provide these matrices


506
00:25:14,179 --> 00:25:18,016 line:0
using acceleration structure
descriptors.


507
00:25:18,016 --> 00:25:20,252 position:50%
The standard
Metal instance descriptor


508
00:25:20,252 --> 00:25:23,822 position:50%
only has room for a single
transformation matrix.


509
00:25:23,822 --> 00:25:28,227 line:0
So instead, we’ll use the new
motion instance descriptor.


510
00:25:28,227 --> 00:25:30,262 line:0
With this descriptor,


511
00:25:30,262 --> 00:25:35,300 line:0
the transformation matrices
are stored in a separate buffer.


512
00:25:35,300 --> 00:25:39,204 position:50%
The instance descriptor
then contains a start index


513
00:25:39,204 --> 00:25:43,509 line:0
and count representing a range
of transformation matrices


514
00:25:43,509 --> 00:25:45,477 position:50%
in the transform buffer.


515
00:25:45,477 --> 00:25:49,214 position:50%
Each matrix represents
a single keyframe.


516
00:25:49,214 --> 00:25:52,217 line:0
Let's see how to set up
an instance descriptor


517
00:25:52,217 --> 00:25:56,288 position:50%
with the new motion
instance descriptor type.


518
00:25:56.288 --> 00:25:58.190 line:-1 position:50%
We start by creating the usual


519
00:25:58,190 --> 00:26:01,326 line:-1
instance acceleration structure
descriptor.


520
00:26:01,326 --> 00:26:03,629 line:-1
We then specify we’re using


521
00:26:03.629 --> 00:26:07.766 line:-1 position:50%
the new motion instance
descriptor type.


522
00:26:07,766 --> 00:26:11,303 line:-1
Then, we specify
the instanceDescriptorBuffer


523
00:26:11.303 --> 00:26:15.641 line:-1 position:50%
that contains
the motion instance descriptors.


524
00:26:15,641 --> 00:26:18,977 line:0
Finally, we’ll need to bind
the transformsBuffer


525
00:26:18,977 --> 00:26:23,115 position:50%
containing the vertex buffer
for each keyframe.


526
00:26:23,115 --> 00:26:25,250 line:0
The remaining properties
are the same


527
00:26:25,250 --> 00:26:28,420 line:0
as any other
instance acceleration structure,


528
00:26:28,420 --> 00:26:30,189 position:50%
and we can build it
like any other


529
00:26:30,189 --> 00:26:33,292 line:0
acceleration structure as well.


530
00:26:33,292 --> 00:26:37,563 line:-1
We only need to make one change
in the shading language,


531
00:26:37,563 --> 00:26:41,033 line:-1
which is to specify
the instance_motion tag.


532
00:26:41.033 --> 00:26:43.735 line:-1 position:50%
This tells the intersector
to expect


533
00:26:43.735 --> 00:26:48.140 line:-1 position:50%
an acceleration structure
with instance motion.


534
00:26:48,140 --> 00:26:52,778 position:50%
And that’s all we need to do
to set up instance motion.


535
00:26:52,778 --> 00:26:56,215 line:-1
Next, let’s talk about
primitive motion.


536
00:26:56,215 --> 00:26:57,749 line:-1
With primitive motion,


537
00:26:57,749 --> 00:27:00,052 line:-1
each primitive
can move separately,


538
00:27:00,052 --> 00:27:02,020 line:-1
meaning it can be used
for things


539
00:27:02,020 --> 00:27:05,157 line:-1
like skinned-character
animation.


540
00:27:05.157 --> 00:27:08.927 line:-1 position:50%
Remember that we need
to provide a separate 3D model


541
00:27:08.927 --> 00:27:10.529 line:-1 position:50%
for each keyframe,


542
00:27:10,529 --> 00:27:13,565 line:-1
and Metal will then interpolate
between them.


543
00:27:13,565 --> 00:27:17,436 line:-1
We’ll need to provide
vertex data for each keyframe.


544
00:27:17.436 --> 00:27:20.372 line:-1 position:50%
Let’s see how to set this up.


545
00:27:20,372 --> 00:27:24,443 line:-1
We’ll start by collecting
each keyframe’s vertex buffer


546
00:27:24,443 --> 00:27:26,144 line:-1
into an array.


547
00:27:26,144 --> 00:27:29,548 line:-1
The MTLMotionKeyframeData
object


548
00:27:29.548 --> 00:27:32.484 line:-1 position:50%
allows you to specify
a buffer and offset.


549
00:27:32,484 --> 00:27:34,820 line:-1
We’ll use it to specify
the vertex buffer


550
00:27:34.820 --> 00:27:37.789 line:-1 position:50%
for each keyframe.


551
00:27:37.789 --> 00:27:42.327 line:-1 position:50%
Next, we’ll create a motion
triangle geometry descriptor.


552
00:27:42,327 --> 00:27:45,898 line:-1
This is just like creating
any other geometry descriptor,


553
00:27:45.898 --> 00:27:48.834 line:-1 position:50%
except we use
a slightly different type.


554
00:27:48.834 --> 00:27:52.271 line:-1 position:50%
And instead of providing
a single vertex buffer,


555
00:27:52,271 --> 00:27:56,375 line:-1
we’ll provide our array
of vertexBuffers.


556
00:27:56.375 --> 00:27:58.810 line:-1 position:50%
Finally, we’ll create the usual


557
00:27:58.810 --> 00:28:02.147 line:-1 position:50%
primitive acceleration
structure descriptor.


558
00:28:02.147 --> 00:28:06.184 line:-1 position:50%
Next, we provide
our geometryDescriptor.


559
00:28:06.184 --> 00:28:10.856 line:-1 position:50%
Then we’ll specify
the number of keyframes.


560
00:28:10.856 --> 00:28:13.292 line:-1 position:50%
Similar to instance motion,


561
00:28:13.292 --> 00:28:14.993 line:-1 position:50%
we’ll need to make
a small change


562
00:28:14,993 --> 00:28:16,328 line:-1
in the shading language


563
00:28:16.328 --> 00:28:19.231 line:-1 position:50%
to specify
the primitive_motion tag.


564
00:28:19.231 --> 00:28:22.768 line:-1 position:50%
And that’s all we need to do
to set up primitive motion!


565
00:28:22.768 --> 00:28:25.103 line:-1 position:50%
Keep in mind that you can
actually use


566
00:28:25,103 --> 00:28:28,006 line:-1
both types of animation
at the same time


567
00:28:28.006 --> 00:28:30.208 line:-1 position:50%
for even more dynamic scenes.


568
00:28:30,208 --> 00:28:34,813 line:-1
Next, let’s take a look
at this all in action!


569
00:28:34,813 --> 00:28:37,049 line:-1
This is a path-traced rendering


570
00:28:37,049 --> 00:28:39,618 line:-1
created by
our Advanced Content team.


571
00:28:39.618 --> 00:28:41.553 line:-1 position:50%
The video was rendered
on a Mac Pro


572
00:28:41,553 --> 00:28:45,357 line:-1
with an AMD Radeon
Pro Vega II GPU.


573
00:28:45.357 --> 00:28:47.659 line:-1 position:50%
The ninja character was animated


574
00:28:47,659 --> 00:28:50,629 line:-1
using a skinned skeletal
animation technique


575
00:28:50,629 --> 00:28:54,066 line:-1
which allows each primitive
to move separately.


576
00:28:54,066 --> 00:28:56,435 line:-1
Each frame was rendered
by combining


577
00:28:56,435 --> 00:29:02,541 line:-1
256 randomly timed samples taken
using the primitive motion API.


578
00:29:02,541 --> 00:29:06,278 line:0
We can slow it down to see
the difference more clearly.


579
00:29:06,278 --> 00:29:09,348 position:50%
The version on the left
doesn’t have motion blur,


580
00:29:09,348 --> 00:29:13,085 position:50%
while the version
on the right does.


581
00:29:13,085 --> 00:29:16,288 line:-1
And we can increase
the exposure time even further


582
00:29:16.288 --> 00:29:18.624 line:-1 position:50%
to simulate a long exposure.


583
00:29:18.624 --> 00:29:21.793 line:-1 position:50%
Motion blur can make
a big difference in realism


584
00:29:21.793 --> 00:29:25.664 line:-1 position:50%
and it’s now easy to add
with the new motion API.


585
00:29:25,664 --> 00:29:27,866 line:-1
So that’s it for motion.


586
00:29:27,866 --> 00:29:29,601 line:-1
Thanks for watching this talk.


587
00:29:29.601 --> 00:29:31.303 line:-1 position:50%
We have been putting
a lot of work


588
00:29:31,303 --> 00:29:33,572 line:-1
into our Metal ray tracing API


589
00:29:33,572 --> 00:29:36,875 line:-1
to provide the tools you need
to enhance your app.


590
00:29:36.875 --> 00:29:39.044 line:-1 position:50%
We can’t wait to see
the amazing content


591
00:29:39.044 --> 00:29:40.612 line:-1 position:50%
that you will create with it.


592
00:29:40,612 --> 00:29:44,082 line:-1
Thank you,
and have a great WWDC!


593
00:29:44,082 --> 00:29:47,619 size:2% align:right line:0
♪

