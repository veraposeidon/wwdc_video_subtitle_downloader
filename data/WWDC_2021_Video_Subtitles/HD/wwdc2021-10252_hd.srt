2
00:00:01.869 --> 00:00:04.872 line:-1 align:center
[upbeat music]


3
00:00:04,905 --> 00:00:09,009 line:-1
♪ ♪


4
00:00:09.042 --> 00:00:11.478 line:-1 align:center
[Aditya] Hello, I'm Aditya Krishnadevan,


5
00:00:11.512 --> 00:00:13.547 line:-1 align:center
an engineer on the UIKit team.


6
00:00:13,580 --> 00:00:17,284 position:29% line:-2
At the core of many apps
are lists or collection views.


7
00:00:17,317 --> 00:00:20,020 line:-2 position:27%
Having super-smooth scrolling
is a big part


8
00:00:20,053 --> 00:00:22,456 line:-1
of making those apps feel great.


9
00:00:22,489 --> 00:00:24,992 line:-1
This video will set you up for success


10
00:00:25,025 --> 00:00:28,095 align:start line:-2
when making blazing-fast lists
and collection views.


11
00:00:28,128 --> 00:00:31,331 line:-2 align:start
We'll build this app here
that uses collection views


12
00:00:31,365 --> 00:00:35,135 line:-2 position:24%
to display a list of image posts
of some great travel destinations.


13
00:00:35.169 --> 00:00:37.304 line:-1 align:center
It's fairly simple at first glance,


14
00:00:37.337 --> 00:00:41.175 line:-2 position:27% align:start
with a photo of the destination
and a couple of text labels.


15
00:00:41.208 --> 00:00:44.044 line:-2 align:start position:27%
Throughout this video,
we'll talk about how it's set up


16
00:00:44.077 --> 00:00:47.481 line:-2 align:start position:22%
and how it achieves
the performance that people expect.


17
00:00:47.514 --> 00:00:49.449 line:-1 align:center
First, we'll learn how to start


18
00:00:49,483 --> 00:00:51,652 line:-1
from a strong foundation when using APIs,


19
00:00:51,685 --> 00:00:54,788 line:-2 position:32%
like diffable data source
and cell registrations.


20
00:00:54,821 --> 00:00:57,624 line:-2 align:start
We'll refresh our understanding
of the life cycle


21
00:00:57,658 --> 00:00:59,693 line:-1
of a collection view cell.


22
00:00:59.726 --> 00:01:03.297 line:-2 position:23% align:start
We'll then talk about why you might
not see perfectly-smooth scrolling,


23
00:01:03,330 --> 00:01:06,333 align:start line:-2
and some advances
in prefetching that can help.


24
00:01:06,366 --> 00:01:10,170 position:28% line:-2
Finally, Patrick will explain
how to correctly update cells


25
00:01:10,204 --> 00:01:12,406 align:start line:-2
when their content
comes in asynchronously,


26
00:01:12,439 --> 00:01:14,641 line:-1
and how to use new UIImage API


27
00:01:14,675 --> 00:01:18,879 line:-2 position:25%
to get the absolute best scrolling
performance on all devices.


28
00:01:18,912 --> 00:01:20,214 line:-1
Okay.


29
00:01:20.247 --> 00:01:21.548 line:-1 align:center
Let's begin by talking


30
00:01:21.582 --> 00:01:24.284 line:-1 align:center
about how the app structures its data.


31
00:01:24,318 --> 00:01:27,387 align:start line:-2
The sample app retrieves
a list of posts for display,


32
00:01:27,421 --> 00:01:29,056 line:-1
where each post is represented


33
00:01:29,089 --> 00:01:31,458 line:-1
by this DestinationPost struct.


34
00:01:31,491 --> 00:01:34,228 line:-1
DestinationPost conforms to identifiable,


35
00:01:34.261 --> 00:01:36.296 line:-1 align:center
which means it has this ID property


36
00:01:36.330 --> 00:01:38.432 line:-1 align:center
that stores its identifier.


37
00:01:38,465 --> 00:01:41,768 line:-2 align:start
This is a unique identifier
for each DestinationPost


38
00:01:41.802 --> 00:01:45.372 line:-2 position:30% align:start
that remains stable even
if other properties change.


39
00:01:45,405 --> 00:01:47,608 line:-1
Diffable data source is built to store


40
00:01:47.641 --> 00:01:49.510 line:-1 align:center
identifiers of items in your model,


41
00:01:49.543 --> 00:01:52.112 line:-1 align:center
and not the model objects themselves.


42
00:01:52.145 --> 00:01:55.782 line:-2 position:22% align:start
So, in the sample app,
the diffable data source is populated


43
00:01:55.816 --> 00:01:57.651 line:-1 align:center
using the ID property here,


44
00:01:57,684 --> 00:02:00,821 line:-1
and not the DestinationPost itself.


45
00:02:00,854 --> 00:02:03,690 position:27% line:-2
Here's the diffable data source
used in the app.


46
00:02:03,724 --> 00:02:07,661 position:23% line:-2
Like we just discussed,
it uses the DestinationPost.ID type


47
00:02:07.694 --> 00:02:09.630 line:-1 align:center
for its item identifiers.


48
00:02:09,663 --> 00:02:12,533 line:-2 position:24%
The Section type here is an enum
with one case,


49
00:02:12,566 --> 00:02:15,269 line:-1
as the app has only one section.


50
00:02:15,302 --> 00:02:17,137 line:-1
To populate the data source,


51
00:02:17,171 --> 00:02:19,273 line:-1
the app first creates an empty snapshot


52
00:02:19.306 --> 00:02:21.808 line:-1 align:center
and appends the main section.


53
00:02:21.842 --> 00:02:25.279 line:-2 position:28% align:start
Then, it fetches all the posts
from its backing store


54
00:02:25,312 --> 00:02:27,614 line:-1
and appends their identifiers.


55
00:02:27,648 --> 00:02:30,417 line:-1
This way, if one of the other properties


56
00:02:30,450 --> 00:02:32,286 line:-1
of a DestinationPost changes,


57
00:02:32,319 --> 00:02:35,722 line:-2 position:21%
its representation
in diffable data source remains stable,


58
00:02:35,756 --> 00:02:38,458 line:-1
as the identifier does not change.


59
00:02:38,492 --> 00:02:42,262 line:-2 align:start
The final step is to apply
the snapshot to the data source.


60
00:02:42.296 --> 00:02:46.133 line:-2 align:start position:21%
Before iOS 15,
applying a snapshot without animation


61
00:02:46.166 --> 00:02:49.369 line:-2 position:30% align:start
would be translated
to a reloadData internally.


62
00:02:49,403 --> 00:02:51,538 line:-1
That wasn't great for performance,


63
00:02:51,572 --> 00:02:53,540 line:-1
as the collection view had to discard


64
00:02:53,574 --> 00:02:56,376 line:-1
and recreate all the cells on screen.


65
00:02:56,410 --> 00:03:00,147 align:start line:-2
From iOS 15 onwards,
applying a snapshot without animation


66
00:03:00.180 --> 00:03:02.082 line:-1 align:center
will only apply the differences


67
00:03:02,115 --> 00:03:04,852 line:-1
and not perform any extra work.


68
00:03:04.885 --> 00:03:08.155 line:-2 align:start position:27%
With iOS 15,
diffable data source also gains


69
00:03:08,188 --> 00:03:11,491 line:-2 align:start
a new reconfigureItems method
that makes it very easy


70
00:03:11.525 --> 00:03:14.528 line:-1 align:center
to update the contents of visible cells.


71
00:03:14,561 --> 00:03:17,397 align:start line:-2
We'll go through how it works
later in this video.


72
00:03:17,431 --> 00:03:19,833 line:-2 position:33%
First, let's get the data
from our data source


73
00:03:19.867 --> 00:03:22.269 line:-1 align:center
into cells and onto the screen.


74
00:03:22,302 --> 00:03:24,905 line:-1
Cell registrations are a great way


75
00:03:24.938 --> 00:03:28.275 line:-2 position:25% align:start
to keep all the configuration
for each type of cell in one place,


76
00:03:28,308 --> 00:03:30,344 line:-1
and they give us convenient access


77
00:03:30,377 --> 00:03:33,280 position:30% line:-2
to the identifiers
from diffable data source.


78
00:03:33,313 --> 00:03:35,716 line:-1
UICollectionView maintains a reuse queue


79
00:03:35,749 --> 00:03:37,918 line:-1
for each of instance of a registration,


80
00:03:37.951 --> 00:03:40.053 line:-1 align:center
so ensure that you create registrations


81
00:03:40.087 --> 00:03:43.156 line:-1 align:center
only once for each type of cell.


82
00:03:43.190 --> 00:03:46.660 line:-2 align:start position:27%
Here's a simplified registration
for cells in the app.


83
00:03:46,693 --> 00:03:49,196 line:-1
The postID that's passed in


84
00:03:49,229 --> 00:03:51,532 line:-2 align:start
is used to retrieve
a DestinationPost


85
00:03:51,565 --> 00:03:54,268 line:-1
and an asset object containing the image.


86
00:03:54.301 --> 00:03:57.271 line:-2 position:28% align:start
The properties from
the DestinationPost are used


87
00:03:57,304 --> 00:04:00,674 line:-1
to set the title and image in the cell.


88
00:04:00,707 --> 00:04:02,509 line:-1
To use a registration,


89
00:04:02.543 --> 00:04:04.978 line:-1 align:center
call dequeueConfiguredReusableCell


90
00:04:05,012 --> 00:04:08,148 line:-1
inside the data source's cell provider.


91
00:04:08,182 --> 00:04:11,718 line:-2 position:24%
Note how the registration
is created outside the cell provider


92
00:04:11,752 --> 00:04:13,754 line:-1
and then used inside.


93
00:04:13.787 --> 00:04:15.789 line:-1 align:center
This is important for performance,


94
00:04:15,822 --> 00:04:18,792 position:26% line:-2
as creating a registration
inside the provider would mean


95
00:04:18.825 --> 00:04:22.663 line:-2 align:start position:28%
that the collection view would
never reuse any of its cells.


96
00:04:22,696 --> 00:04:25,299 position:32% line:-2
Now that we understand
how to configure a cell,


97
00:04:25,332 --> 00:04:27,801 line:-1
we'll move on to when a cell is configured


98
00:04:27.835 --> 00:04:29.837 line:-1 align:center
and what its life cycle is like.


99
00:04:29,870 --> 00:04:32,773 line:-2 position:28%
The life of a cell is composed
of two phases:


100
00:04:32.806 --> 00:04:35.576 line:-1 align:center
preparation and display.


101
00:04:35.609 --> 00:04:37.544 line:-1 align:center
The first step for preparation


102
00:04:37,578 --> 00:04:39,746 line:-1
is fetching the cell to work on.


103
00:04:39,780 --> 00:04:42,349 line:-1
Whenever UICollectionView needs a cell,


104
00:04:42,382 --> 00:04:44,484 line:-1
it asks for one from its data source.


105
00:04:44.518 --> 00:04:46.520 line:-1 align:center
If this is a diffable data source,


106
00:04:46,553 --> 00:04:49,656 line:-2 position:32%
it runs the cell provider
and returns the result.


107
00:04:49,690 --> 00:04:53,160 position:28% line:-2
When the cell provider runs,
the collection view is asked


108
00:04:53,193 --> 00:04:55,863 line:-2 align:start
to dequeue a new cell
using a registration.


109
00:04:55,896 --> 00:04:58,165 line:-1
If a cell exists in the reuse pool,


110
00:04:58.198 --> 00:05:00.834 line:-2 align:start position:31%
UICollectionView will call
prepareForReuse on it,


111
00:05:00.868 --> 00:05:02.636 line:-1 align:center
and then dequeue the cell.


112
00:05:02,669 --> 00:05:04,638 line:-1
If the reuse pool is empty,


113
00:05:04,671 --> 00:05:07,941 line:-1
it will initialize a new cell.


114
00:05:07,975 --> 00:05:09,710 line:-1
That cell is then passed in


115
00:05:09,743 --> 00:05:12,446 position:29% line:-2
to the configuration handler
from the registration.


116
00:05:12,479 --> 00:05:15,115 line:-2 align:start
This is where apps set up
the cell for display


117
00:05:15,148 --> 00:05:18,352 position:31% line:-2
for a given item identifier
and index path.


118
00:05:18,385 --> 00:05:22,322 position:20% line:-2
The configured cell is returned
to the collection view for the next step.


119
00:05:23,557 --> 00:05:27,094 line:-2 align:start
The collection view queries the cell
for its preferred layout attributes


120
00:05:27.127 --> 00:05:29.463 line:-1 align:center
and sizes the cell appropriately.


121
00:05:29,496 --> 00:05:32,165 line:-1
At this point, the cell is fully prepared


122
00:05:32,199 --> 00:05:35,235 line:-1
and ready for phase two: display.


123
00:05:35,269 --> 00:05:37,738 line:-1
willDisplayCell is called on the delegate,


124
00:05:37.771 --> 00:05:40.674 line:-2 position:29% align:start
and the cell is made visible
inside the UICollectionView.


125
00:05:40.707 --> 00:05:42.442 line:-1 align:center
The cell is now on screen.


126
00:05:42,476 --> 00:05:44,778 align:start line:-2
There are no more changes
to its life cycle


127
00:05:44.811 --> 00:05:46.547 line:-1 align:center
while it remains visible.


128
00:05:46,580 --> 00:05:48,849 line:-1
When it is scrolled off screen,


129
00:05:48,882 --> 00:05:51,185 line:-1
didEndDisplaying is called for the cell,


130
00:05:51,218 --> 00:05:53,754 line:-2 position:31%
and it ends up right back
in the reuse pool.


131
00:05:53.787 --> 00:05:56.823 line:-2 position:27% align:start
From the reuse pool,
a cell can be dequeued again,


132
00:05:56.857 --> 00:05:58.625 line:-1 align:center
repeating this process.


133
00:05:58.659 --> 00:06:02.296 line:-2 align:start position:20%
Let's now check what the app feels like
with these basics in place.


134
00:06:02.329 --> 00:06:04.932 line:-1 align:center
The app is featuring Cusco in Peru,


135
00:06:04,965 --> 00:06:07,434 line:-1
and Saint Lucia in the Caribbean.


136
00:06:07,467 --> 00:06:10,437 line:-2 align:start
Let's scroll through the app
and see some other destinations,


137
00:06:10,470 --> 00:06:13,240 line:-1
but notice how it doesn't scroll smoothly.


138
00:06:23,917 --> 00:06:27,321 line:-2 position:23%
These interruptions during scrolling
are called "hitches."


139
00:06:27.354 --> 00:06:29.456 line:-1 align:center
To understand what causes a hitch,


140
00:06:29,489 --> 00:06:33,126 align:start line:-2
let's first learn how an app
updates the display.


141
00:06:33,160 --> 00:06:34,628 line:-1
For each frame,


142
00:06:34.661 --> 00:06:37.130 line:-2 position:32% align:start
events such as touches
are delivered to an app.


143
00:06:37,164 --> 00:06:41,001 align:start line:-2
In response, it updates the properties
of its views and layers.


144
00:06:41,034 --> 00:06:44,037 line:-1
For example, a scroll view's contentOffset


145
00:06:44,071 --> 00:06:45,439 line:-1
will change during a pan gesture,


146
00:06:45.472 --> 00:06:49.076 line:-2 position:26% align:start
changing the on-screen location
of all the views it contains.


147
00:06:49.109 --> 00:06:50.844 line:-1 align:center
As a result of those changes,


148
00:06:50.878 --> 00:06:53.714 line:-1 align:center
the app's views and layers perform layout.


149
00:06:53.747 --> 00:06:56.250 line:-1 align:center
This process is called a "commit."


150
00:06:56,283 --> 00:07:00,053 position:29% line:-2
Then, the layer tree is sent
to the render server.


151
00:07:00.087 --> 00:07:02.222 line:-1 align:center
Each frame has a commit deadline.


152
00:07:02,256 --> 00:07:04,391 line:-1
This is the time by which all commits


153
00:07:04,424 --> 00:07:06,460 line:-1
for that frame need to finish.


154
00:07:06,493 --> 00:07:09,730 line:-2 position:26%
The amount of time an app has
to commit for each frame


155
00:07:09,763 --> 00:07:12,733 position:29% line:-2
depends on the refresh rate
of the display.


156
00:07:12,766 --> 00:07:15,102 line:-1
For example, on an iPad Pro running


157
00:07:15,135 --> 00:07:17,704 line:-1
at a higher refresh rate of 120 Hz,


158
00:07:17,738 --> 00:07:20,307 line:-2 align:start
apps have less time
to finish work for each frame


159
00:07:20.340 --> 00:07:22.910 line:-1 align:center
compared to an iPhone running at 60 Hz.


160
00:07:22,943 --> 00:07:26,013 position:31% line:-2
Here's a typical example
of scrolling a list of cells


161
00:07:26.046 --> 00:07:28.348 line:-1 align:center
in a collection or table view.


162
00:07:28.382 --> 00:07:31.752 line:-2 align:start position:24%
When a new cell becomes visible,
there's a longer commit,


163
00:07:31,785 --> 00:07:35,222 line:-2 align:start
during which the new cell is configured
and performs layout.


164
00:07:35.255 --> 00:07:38.859 line:-2 align:start position:26%
Then, there's a couple frames
where it's just the existing cells


165
00:07:38,892 --> 00:07:41,828 line:-1
being moved around on screen.


166
00:07:41,862 --> 00:07:43,997 line:-1
The commits for these frames are quick


167
00:07:44.031 --> 00:07:46.500 line:-1 align:center
because no new cells are needed.


168
00:07:46,533 --> 00:07:49,303 line:-2 align:start
Eventually,
the scroll position changes enough


169
00:07:49.336 --> 00:07:51.338 line:-1 align:center
to cause a new cell to become visible,


170
00:07:51.371 --> 00:07:53.674 line:-1 align:center
and this pattern repeats.


171
00:07:53.707 --> 00:07:57.177 line:-2 position:32% align:start
So what causes hitches
like in the demo earlier?


172
00:07:57,211 --> 00:08:00,848 line:-2 align:start
When the commit for a frame takes
too long and misses the deadline,


173
00:08:00,881 --> 00:08:04,651 position:22% line:-2
those updates don't get incorporated
into the intended frame.


174
00:08:04,685 --> 00:08:06,954 line:-2 align:start
The display keeps
the previous frame on screen


175
00:08:06,987 --> 00:08:10,524 position:23% line:-2
until the commit finishes,
and this delayed frame can render.


176
00:08:10.557 --> 00:08:12.159 line:-1 align:center
This is a commit hitch


177
00:08:12,192 --> 00:08:15,195 line:-2 align:start
and is perceived as a momentary
interruption when scrolling.


178
00:08:16,363 --> 00:08:19,499 position:30% line:-2
To learn more about this
and other types of hitches,


179
00:08:19,533 --> 00:08:22,603 position:31% line:-2
watch the "Explore UI
animation hitches" video.


180
00:08:22,636 --> 00:08:24,938 line:-1
To help avoid these hitches,


181
00:08:24,972 --> 00:08:27,107 line:-1
UICollectionView and UITableView


182
00:08:27.140 --> 00:08:31.044 line:-2 align:start position:24%
both have a brand-new cell
prefetching mechanism in iOS 15.


183
00:08:32,045 --> 00:08:34,648 line:-2 align:start
We're back here to the example
of an expensive cell


184
00:08:34.681 --> 00:08:36.717 line:-1 align:center
causing a hitch during scrolling.


185
00:08:36,750 --> 00:08:38,485 line:-1
A key takeaway from this is


186
00:08:38,519 --> 00:08:41,255 position:29% line:-2
that you typically don't need
a cell every frame.


187
00:08:41.288 --> 00:08:44.358 line:-2 align:start position:28%
We have a couple of frames
with very short commits


188
00:08:44.391 --> 00:08:46.326 line:-1 align:center
doing minimal work.


189
00:08:46,360 --> 00:08:50,230 line:-2 align:start
Cell prefetching in iOS 15
takes advantage of this spare time


190
00:08:50.264 --> 00:08:54.001 line:-2 position:27% align:start
by preparing the next cell right
after finishing a short commit.


191
00:08:55,469 --> 00:08:58,071 line:-1
Then, when the cell is eventually needed,


192
00:08:58,105 --> 00:09:00,274 line:-1
it's just a matter of making it visible.


193
00:09:00.307 --> 00:09:01.875 line:-1 align:center
That's why the commit for the frame


194
00:09:01,909 --> 00:09:04,878 position:27% line:-2
where the prefetched cell
becomes visible is very quick,


195
00:09:04,912 --> 00:09:08,081 line:-1
because all of the work was done earlier.


196
00:09:08,115 --> 00:09:11,218 position:26% line:-2
The amount of time spent
prefetching the cell is the same


197
00:09:11.251 --> 00:09:13.153 line:-1 align:center
as when it causing a hitch.


198
00:09:13,187 --> 00:09:15,455 position:32% line:-2
But because we're able
to get a head-start,


199
00:09:15,489 --> 00:09:17,524 line:-1
we're able to avoid a hitch.


200
00:09:17,558 --> 00:09:19,593 line:-1
Let's understand why this works


201
00:09:19.626 --> 00:09:22.129 line:-1 align:center
by stepping through each commit.


202
00:09:22.162 --> 00:09:23.931 line:-1 align:center
Before the prefetching happened,


203
00:09:23,964 --> 00:09:26,099 line:-1
we performed the commit for this frame.


204
00:09:26,133 --> 00:09:29,269 line:-2 position:28%
Since no cells were needed,
it was a quick commit,


205
00:09:29.303 --> 00:09:32.739 line:-2 align:start position:24%
and it finished with lots of time left
before the deadline.


206
00:09:32,773 --> 00:09:35,609 position:27% line:-2
Instead of just waiting around
until the next frame,


207
00:09:35,642 --> 00:09:38,912 position:23% line:-2
in iOS 15,
the system recognizes the situation


208
00:09:38,946 --> 00:09:40,414 line:-1
and uses the spare time


209
00:09:40.447 --> 00:09:43.217 line:-1 align:center
to start prefetching the next cell.


210
00:09:43,250 --> 00:09:46,753 line:-2 align:start
Now, the following frame is
where things get interesting.


211
00:09:46,787 --> 00:09:49,523 position:24% line:-2
Because the cell being prefetched
is expensive,


212
00:09:49.556 --> 00:09:51.658 line:-2 align:start position:31%
it actually causes
the commit for that frame


213
00:09:51.692 --> 00:09:53.427 line:-1 align:center
to start later than normal.


214
00:09:53,460 --> 00:09:56,530 position:32% line:-2
However, even though
that commit starts late,


215
00:09:56.563 --> 00:09:58.799 line:-1 align:center
it still finishes well before its deadline


216
00:09:58,832 --> 00:10:00,767 line:-1
because it's quick.


217
00:10:00,801 --> 00:10:03,704 position:26% line:-2
Compare this
to the illustration we saw earlier


218
00:10:03.737 --> 00:10:05.339 line:-1 align:center
without prefetching.


219
00:10:05,372 --> 00:10:08,509 line:-2 align:start
Notice how there are no longer
any commits missing deadlines,


220
00:10:08,542 --> 00:10:12,412 align:start line:-2
and so, there are no more hitches
with cell prefetching.


221
00:10:12.446 --> 00:10:15.883 line:-2 position:24% align:start
This means that your apps get up
to twice the amount of time


222
00:10:15,916 --> 00:10:18,919 position:28% line:-2
to prepare each cell,
without causing any hitches.


223
00:10:18,952 --> 00:10:21,121 line:-1
What's more, all you need to do


224
00:10:21.154 --> 00:10:23.023 line:-1 align:center
to get this great new functionality is


225
00:10:23,056 --> 00:10:26,560 line:-1
to build your app with the iOS 15 SDK.


226
00:10:26,593 --> 00:10:28,395 line:-1
When I last ran the demo,


227
00:10:28.428 --> 00:10:31.265 line:-1 align:center
the app was built with the iOS 14 SDK.


228
00:10:31,298 --> 00:10:33,000 line:-1
Let's check out scrolling in the app


229
00:10:33,033 --> 00:10:36,003 line:-1
when built with the iOS 15 SDK.


230
00:10:41.341 --> 00:10:42.643 line:-1 align:center
This is great!


231
00:10:42,676 --> 00:10:45,712 position:27% line:-2
Looks like prefetching is doing
exactly what we'd want.


232
00:10:45.746 --> 00:10:47.714 line:-1 align:center
Scrolling is now perfectly smooth,


233
00:10:47,748 --> 00:10:50,817 position:28% line:-2
and we didn't have to change
a single line of code.


234
00:10:51,785 --> 00:10:53,987 line:-1
Remember, all you need to do is


235
00:10:54.021 --> 00:10:56.757 line:-1 align:center
to build your app using the iOS 15 SDK.


236
00:10:56.790 --> 00:11:00.060 line:-2 align:start position:28%
For UICollectionView,
this new prefetching expands


237
00:11:00.093 --> 00:11:02.529 line:-1 align:center
on what was introduced in iOS 10.


238
00:11:02,563 --> 00:11:05,132 align:start line:-2
Cell prefetching
is now supported for lists,


239
00:11:05,165 --> 00:11:07,768 line:-2 position:33%
as well as all other
compositional layouts.


240
00:11:07,801 --> 00:11:09,970 line:-1
This great new prefetching is now


241
00:11:10,003 --> 00:11:12,072 line:-1
even enabled in UITableView.


242
00:11:12,105 --> 00:11:15,409 position:23% line:-2
Prefetching can improve scrolling
performance by eliminating hitches,


243
00:11:15,442 --> 00:11:19,079 position:24% line:-2
but it will also reduce power usage
and increase battery life.


244
00:11:19,112 --> 00:11:23,016 position:19% line:-2
If your cells are quick to prepare,
the system can use the extra time to run


245
00:11:23,050 --> 00:11:26,887 line:-2 align:start
in a more energy-efficient state
and still avoid hitches.


246
00:11:26.920 --> 00:11:29.890 line:-1 align:center
So, even if you don't notice any hitches,


247
00:11:29,923 --> 00:11:32,826 line:-2 align:start
it's still very important to make
your cell configuration


248
00:11:32,860 --> 00:11:36,730 line:-2 position:29%
and layout implementations
as efficient as possible.


249
00:11:36,763 --> 00:11:40,467 position:22% line:-2
Let's now talk about how prefetching
affects cell life cycle.


250
00:11:40.501 --> 00:11:42.936 line:-2 align:start position:32%
This is the life cycle
we talked about earlier,


251
00:11:42,970 --> 00:11:46,139 line:-2 align:start
without prefetching,
with the two distinct phases.


252
00:11:46.173 --> 00:11:49.543 line:-2 align:start position:30%
When a cell is prefetched,
it is the preparation phase


253
00:11:49.576 --> 00:11:53.413 line:-2 align:start position:25%
that is executed ahead of the cell
being required on-screen.


254
00:11:53,447 --> 00:11:55,782 line:-1
To take full advantage of prefetching,


255
00:11:55,816 --> 00:11:58,452 line:-2 align:start
a cell must be fully configured
in this phase.


256
00:11:58,485 --> 00:12:02,055 line:-2 position:27%
Don't wait until a cell is visible
to perform any heavy work.


257
00:12:02,089 --> 00:12:04,324 line:-2 align:start
When a cell returns
to the collection view,


258
00:12:04,358 --> 00:12:06,760 line:-2 align:start
it is sized to get
its preferred layout attributes,


259
00:12:06,793 --> 00:12:09,830 line:-1
also as part of the prefetch.


260
00:12:09.863 --> 00:12:13.233 line:-2 align:start position:24%
After being prefetched,
there is now this in-between state,


261
00:12:13.267 --> 00:12:16.336 line:-1 align:center
where a cell is waiting to be displayed.


262
00:12:16.370 --> 00:12:18.005 line:-1 align:center
Given this new phase,


263
00:12:18,038 --> 00:12:21,408 align:start line:-2
there are two important
considerations for apps.


264
00:12:21,441 --> 00:12:25,212 position:26% line:-2
It is possible for a prepared cell
to never be displayed,


265
00:12:25,245 --> 00:12:29,049 position:21% line:-2
which could happen if the user
suddenly changed the scroll direction.


266
00:12:29,082 --> 00:12:31,718 line:-1
Then, once a cell is displayed,


267
00:12:31,752 --> 00:12:33,754 position:34% line:-2
it can go right back
into the waiting state


268
00:12:33,787 --> 00:12:36,056 line:-1
after it goes off screen.


269
00:12:36,089 --> 00:12:40,027 line:-2 align:start
The same cell can be displayed
more than once for the same index path.


270
00:12:40,060 --> 00:12:43,330 line:-2 align:start
It's no longer the case
that a cell will be immediately added


271
00:12:43,363 --> 00:12:46,099 line:-1
to the reuse pool when it ends displaying.


272
00:12:46,133 --> 00:12:48,602 line:-2 align:start
Prefetching helps us achieve
smooth scrolling,


273
00:12:48,635 --> 00:12:51,338 line:-1
but only because it gives us more time.


274
00:12:51,371 --> 00:12:53,974 line:-1
On other devices with a higher frame rate,


275
00:12:54.007 --> 00:12:57.911 line:-2 position:22% align:start
it's still possible that the app is going
to have hitches during scrolling.


276
00:12:57,945 --> 00:12:59,947 line:-1
Patrick will now give you more detail


277
00:12:59.980 --> 00:13:02.115 line:-1 align:center
about how the app configures its cells,


278
00:13:02.149 --> 00:13:03.884 line:-1 align:center
and also talk about strategies


279
00:13:03,917 --> 00:13:05,786 line:-1
to reduce the amount of time per commit


280
00:13:05.819 --> 00:13:08.121 line:-1 align:center
when displaying images.


281
00:13:08.155 --> 00:13:09.323 line:-1 align:center
[Patrick] Thanks, Adi.


282
00:13:09.356 --> 00:13:12.659 line:-2 position:24% align:start
Hi, I'm Patrick from
the High-Level Performance team.


283
00:13:12.693 --> 00:13:14.228 line:-1 align:center
Now, I'll guide us through


284
00:13:14.261 --> 00:13:16.697 line:-1 align:center
updating existing cells in the sample app,


285
00:13:16,730 --> 00:13:18,465 line:-1
and then how to display images


286
00:13:18,498 --> 00:13:20,367 line:-1
with the best-possible performance,


287
00:13:20,400 --> 00:13:23,837 line:-1
utilizing some new APIs in iOS 15.


288
00:13:23,871 --> 00:13:27,608 position:28% line:-2
The sample app was built
with local image files on disk.


289
00:13:27,641 --> 00:13:31,011 line:-2 align:start
As we scroll the app,
the cells are prepared off screen,


290
00:13:31.044 --> 00:13:33.180 line:-1 align:center
and the images within them are loaded


291
00:13:33,213 --> 00:13:35,849 line:-1
from the file system immediately.


292
00:13:35,883 --> 00:13:40,187 position:26% line:-2
Now, we wan display images
stored on a remote server.


293
00:13:40,220 --> 00:13:41,855 line:-1
So, when cells scroll in,


294
00:13:41,889 --> 00:13:45,325 line:-2 align:start
we may not have the image
to show in the image view.


295
00:13:45.359 --> 00:13:48.262 line:-2 align:start position:22%
When the image view is first visible,
it will be blank


296
00:13:48,295 --> 00:13:52,165 position:23% line:-2
and only filled in
once the server request completes.


297
00:13:52,199 --> 00:13:54,001 line:-1
Let's take a look at extending


298
00:13:54.034 --> 00:13:56.270 line:-1 align:center
our registration's configuration handler


299
00:13:56.303 --> 00:13:57.905 line:-1 align:center
to support this new approach.


300
00:13:57,938 --> 00:14:01,408 line:-2 align:start
Here in the registration's
configuration handler,


301
00:14:01,441 --> 00:14:04,878 align:start line:-2
we already fetched the asset
from the asset store.


302
00:14:04,912 --> 00:14:07,281 line:-1
The store will always return an image,


303
00:14:07.314 --> 00:14:09.683 line:-1 align:center
but it may not be the full asset.


304
00:14:09.716 --> 00:14:11.585 line:-1 align:center
It might need to be downloaded.


305
00:14:11.618 --> 00:14:14.221 line:-1 align:center
The asset object indicates this


306
00:14:14,254 --> 00:14:16,523 line:-1
with the isPlaceholder property.


307
00:14:16,557 --> 00:14:18,125 line:-1
When this is true,


308
00:14:18,158 --> 00:14:21,662 line:-2 align:start
we will ask the asset store
to download the full image.


309
00:14:21.695 --> 00:14:23.797 line:-1 align:center
When the load operation completes,


310
00:14:23,830 --> 00:14:26,733 line:-1
it's time to update the cell's image view.


311
00:14:26.767 --> 00:14:30.103 line:-1 align:center
Here, we take the existing cell object


312
00:14:30,137 --> 00:14:33,040 line:-1
and set the asset on its image view.


313
00:14:33,073 --> 00:14:35,142 line:-1
This is a mistake.


314
00:14:35,175 --> 00:14:37,578 align:start line:-2
Cells are reused
for different destinations,


315
00:14:37,611 --> 00:14:40,647 line:-2 position:26%
and by the time the asset store
loads the final asset,


316
00:14:40,681 --> 00:14:42,716 line:-1
the cell object we have captured


317
00:14:42,749 --> 00:14:45,485 line:-1
could be configured for a different post.


318
00:14:45.519 --> 00:14:47.521 line:-1 align:center
Instead of updating the cell directly,


319
00:14:47,554 --> 00:14:50,257 line:-2 position:25%
we must inform
the collection view's data source


320
00:14:50.290 --> 00:14:52.426 line:-1 align:center
of the needed update.


321
00:14:53.227 --> 00:14:55.262 line:-1 align:center
iOS 15 introduces


322
00:14:55,295 --> 00:14:58,065 line:-1
the reconfigureItems snapshot method.


323
00:14:58.098 --> 00:15:01.001 line:-2 align:start position:31%
Calling reconfigureItems
on a prepared cell


324
00:15:01,034 --> 00:15:04,505 line:-2 position:30%
will rerun its registration's
configuration handler.


325
00:15:04.538 --> 00:15:07.074 line:-1 align:center
Use this instead of reloadItems


326
00:15:07.107 --> 00:15:09.743 line:-2 align:start position:33%
because it reuses
the item's existing cell,


327
00:15:09,776 --> 00:15:13,647 align:start line:-2
rather than dequeuing
and configuring a new cell.


328
00:15:13.680 --> 00:15:15.182 line:-1 align:center
In our sample app,


329
00:15:15,215 --> 00:15:18,118 line:-1
we'll declare a setPostNeedsUpdate method,


330
00:15:18.151 --> 00:15:21.388 line:-2 align:start position:28%
which calls reconfigureItems
on the ID passed in.


331
00:15:22,723 --> 00:15:26,560 line:-2 align:start
Now, back in our registration's
configuration handler,


332
00:15:26,593 --> 00:15:28,562 line:-1
when the image is a placeholder,


333
00:15:28,595 --> 00:15:30,898 line:-1
we will download the full-size asset


334
00:15:30.931 --> 00:15:32.866 line:-1 align:center
and call the new method.


335
00:15:32,900 --> 00:15:36,503 line:-2 align:start
reconfigureItems
will then call this handler again,


336
00:15:36.537 --> 00:15:40.340 line:-2 position:32% align:start
but now, fetchByID
will return the full asset


337
00:15:40.374 --> 00:15:42.543 line:-1 align:center
and not the placeholder.


338
00:15:42,576 --> 00:15:46,246 line:-2 align:start
This allows us to keep all
our view-updating code


339
00:15:46,280 --> 00:15:49,683 position:22% line:-2
in one place
and asynchronously update our cells


340
00:15:49,716 --> 00:15:52,386 line:-1
once we have data.


341
00:15:52.419 --> 00:15:54.087 line:-1 align:center
To maximize prepare time,


342
00:15:54,121 --> 00:15:56,590 line:-1
we can also use our downloadAsset method


343
00:15:56.623 --> 00:15:59.259 line:-1 align:center
inside our prefetchingDataSource.


344
00:15:59,293 --> 00:16:01,695 line:-1
Data-source prefetching is a great place


345
00:16:01,728 --> 00:16:04,865 position:27% line:-2
to kick off network downloads
for a collection-view item.


346
00:16:04.898 --> 00:16:08.168 line:-2 align:start position:19%
It gives more time to download the asset
and have it ready


347
00:16:08,202 --> 00:16:09,903 line:-1
before the cell is visible,


348
00:16:09,937 --> 00:16:13,574 line:-2 position:31%
reducing the time users
see placeholder content.


349
00:16:14,575 --> 00:16:18,245 line:-2 position:28%
Let's take a look
at how this looks in our app.


350
00:16:18,278 --> 00:16:19,646 line:-1
It looks fine,


351
00:16:19.680 --> 00:16:22.549 line:-2 position:29% align:start
but there are visible hitches
while scrolling.


352
00:16:22,583 --> 00:16:24,818 line:-1
They also appear to coincide


353
00:16:24,852 --> 00:16:27,721 line:-1
with when new images are displayed.


354
00:16:27,754 --> 00:16:30,924 line:-2 align:start
When a new cell is prepared,
there is no hitching.


355
00:16:30.958 --> 00:16:33.260 line:-1 align:center
It's only when an image is updated


356
00:16:33,293 --> 00:16:36,330 line:-2 position:28%
with the full-resolution image
that we hitch.


357
00:16:36,363 --> 00:16:40,200 line:-2 align:start
That's because all images
take time to decode for display,


358
00:16:40,234 --> 00:16:41,668 line:-1
and some images,


359
00:16:41.702 --> 00:16:44.137 line:-1 align:center
like the larger non-placeholder assets,


360
00:16:44.171 --> 00:16:47.941 line:-2 align:start position:29%
are too large to be decoded
in time for display.


361
00:16:47.975 --> 00:16:51.411 line:-2 position:29% align:start
When the cell registration's
configuration handler


362
00:16:51.445 --> 00:16:54.281 line:-2 align:start position:27%
is first called
and the asset is a placeholder,


363
00:16:54.314 --> 00:16:56.750 line:-1 align:center
the code begins an async request


364
00:16:56.783 --> 00:16:58.285 line:-1 align:center
for the full-size image


365
00:16:58.318 --> 00:17:00.888 line:-1 align:center
and completes its configuration.


366
00:17:00,921 --> 00:17:03,657 position:30% line:-2
When the asset
is finally downloaded later,


367
00:17:03.690 --> 00:17:06.493 line:-1 align:center
the cell configuration handler is rerun


368
00:17:06,527 --> 00:17:08,829 line:-1
with the final image.


369
00:17:08,862 --> 00:17:11,632 line:-2 align:start
When an image view tries
to commit a new image,


370
00:17:11,665 --> 00:17:14,234 position:27% line:-2
it must first prepare the image
for display


371
00:17:14,268 --> 00:17:16,103 line:-1
on the main thread.


372
00:17:16,136 --> 00:17:19,139 line:-2 position:30%
This can take a long time,
and there's a hitch


373
00:17:19.173 --> 00:17:21.942 line:-1 align:center
when the app missed its commit deadline.


374
00:17:21.975 --> 00:17:24.745 line:-1 align:center
Image preparation is a mandatory process


375
00:17:24,778 --> 00:17:28,081 position:28% line:-2
that all images must undergo
to be displayed.


376
00:17:30,050 --> 00:17:31,385 line:-1
The render server


377
00:17:31,418 --> 00:17:34,354 line:-1
can only display images that are bitmaps,


378
00:17:34.388 --> 00:17:37.424 line:-1 align:center
which means they are raw pixel data.


379
00:17:37.457 --> 00:17:39.826 line:-1 align:center
Images come in many different formats,


380
00:17:39,860 --> 00:17:43,096 line:-1
like PNG, HEIC, and JPEG,


381
00:17:43,130 --> 00:17:45,966 line:-1
which are compressed and must be processed


382
00:17:45.999 --> 00:17:48.602 line:-1 align:center
and unpacked to be displayed.


383
00:17:48.635 --> 00:17:50.737 line:-1 align:center
Image views do this processing


384
00:17:50,771 --> 00:17:52,506 line:-1
when it commits a new image,


385
00:17:52.539 --> 00:17:55.275 line:-1 align:center
and it happens on the main thread.


386
00:17:55,309 --> 00:17:58,946 line:-2 align:start
Ideally, we could prepare
the image in advance


387
00:17:58,979 --> 00:18:01,348 line:-1
and only update the UI


388
00:18:01.381 --> 00:18:03.617 line:-1 align:center
when it's finally completed.


389
00:18:03,650 --> 00:18:06,520 line:-1
That way, we never block the main thread


390
00:18:06,553 --> 00:18:08,388 line:-1
and do not hitch.


391
00:18:08.422 --> 00:18:10.457 line:-1 align:center
iOS 15 introduces


392
00:18:10.490 --> 00:18:12.526 line:-1 align:center
the image preparation APIs,


393
00:18:12.559 --> 00:18:14.661 line:-1 align:center
giving you control over where


394
00:18:14,695 --> 00:18:17,764 line:-1
and when image preparation happens.


395
00:18:17,798 --> 00:18:20,801 line:-1
These APIs produce a new UIImage,


396
00:18:20,834 --> 00:18:22,936 line:-1
which only contains the pixel data


397
00:18:22,970 --> 00:18:24,872 line:-1
that the renderer needs.


398
00:18:24.905 --> 00:18:27.307 line:-1 align:center
There is no additional work needed


399
00:18:27,341 --> 00:18:29,877 line:-1
once it's set on an image view.


400
00:18:29.910 --> 00:18:32.913 line:-1 align:center
It comes in two forms: a synchronous one,


401
00:18:32.946 --> 00:18:34.915 line:-1 align:center
which you can run on any thread,


402
00:18:34.948 --> 00:18:36.416 line:-1 align:center
and asynchronous ones,


403
00:18:36.450 --> 00:18:40.087 line:-2 align:start position:32%
which run on an internal
UIKit serial queue.


404
00:18:41,488 --> 00:18:44,992 line:-1
To use it, we take a UIImage we've created


405
00:18:45,025 --> 00:18:48,295 position:28% line:-2
and set a placeholder image
on our image view.


406
00:18:48,328 --> 00:18:50,864 line:-1
Then, calling the new API


407
00:18:50,898 --> 00:18:52,533 line:-1
kicks off the preparation


408
00:18:52.566 --> 00:18:55.202 line:-1 align:center
in the background on the larger image.


409
00:18:55,235 --> 00:18:59,039 line:-2 align:start
When it completes,
we can just set it on the image view.


410
00:18:59.072 --> 00:19:02.142 line:-1 align:center
Prepared images solve a large problem


411
00:19:02.176 --> 00:19:04.244 line:-1 align:center
in any image-heavy app,


412
00:19:04,278 --> 00:19:07,481 line:-2 align:start
but they also come
with some considerations.


413
00:19:07.514 --> 00:19:09.683 line:-1 align:center
The prepared images contain


414
00:19:09.716 --> 00:19:12.653 line:-2 align:start position:32%
the raw pixel data
from the original image.


415
00:19:12.686 --> 00:19:15.556 line:-2 position:29% align:start
It will remain free to display
in an image view


416
00:19:15.589 --> 00:19:18.192 line:-1 align:center
as long as it's retained in memory.


417
00:19:18,225 --> 00:19:21,261 position:29% line:-2
But this also means
it takes up a lot of memory,


418
00:19:21.295 --> 00:19:23.697 line:-1 align:center
and they should be cached sparingly.


419
00:19:23,730 --> 00:19:25,966 line:-1
Finally, because of their format,


420
00:19:25,999 --> 00:19:28,068 line:-1
they are not ideal for disk storage.


421
00:19:28.101 --> 00:19:32.005 line:-1 align:center
Instead, save the original asset to disk.


422
00:19:32,039 --> 00:19:34,575 line:-1
One last consideration is how


423
00:19:34,608 --> 00:19:37,110 line:-1
image preparation can utilize prefetching.


424
00:19:37.144 --> 00:19:40.047 line:-1 align:center
Prefetching gives extra time


425
00:19:40,080 --> 00:19:42,883 line:-2 align:start
for the image to be downloaded
and prepared.


426
00:19:42.916 --> 00:19:45.385 line:-1 align:center
Giving the process more time


427
00:19:45,419 --> 00:19:48,655 position:28% line:-2
means the users will not see
the placeholder for long,


428
00:19:48.689 --> 00:19:51.525 line:-1 align:center
and probably not at all.


429
00:19:51.558 --> 00:19:52.759 line:-1 align:center
In the sample app,


430
00:19:52,793 --> 00:19:56,230 line:-2 align:start
we already have an asynchronous path
for image retrieval.


431
00:19:56,263 --> 00:19:58,498 line:-1
After the download completes,


432
00:19:58.532 --> 00:20:00.767 line:-1 align:center
we can then prepare the asset


433
00:20:00.801 --> 00:20:03.737 line:-1 align:center
before calling the completion handler.


434
00:20:03,770 --> 00:20:06,907 line:-2 align:start
These assets are large,
but also valuable,


435
00:20:06.940 --> 00:20:10.410 line:-2 position:26% align:start
so once the image is prepared,
we want to cache it.


436
00:20:10.444 --> 00:20:13.247 line:-1 align:center
Our image cache uses the image's size


437
00:20:13,280 --> 00:20:16,416 position:29% line:-2
to estimate the memory use
of the prepared image.


438
00:20:16,450 --> 00:20:19,686 line:-1
Now, when a cell asks for an asset,


439
00:20:19,720 --> 00:20:21,021 line:-1
we check that cache


440
00:20:21.054 --> 00:20:23.757 line:-1 align:center
before fetching it from our server.


441
00:20:23.790 --> 00:20:25.459 line:-1 align:center
If we had smaller images,


442
00:20:25.492 --> 00:20:27.661 line:-1 align:center
we would be able to cache more.


443
00:20:27.694 --> 00:20:29.396 line:-1 align:center
Images can be large,


444
00:20:29.429 --> 00:20:32.833 line:-1 align:center
and iOS 15 introduces a similar API


445
00:20:32,866 --> 00:20:35,636 line:-1
for preparing thumbnails of images.


446
00:20:36,436 --> 00:20:38,872 line:-1
These can scale and prepare an image


447
00:20:38,906 --> 00:20:40,774 line:-1
to a smaller size.


448
00:20:40.807 --> 00:20:44.178 line:-2 align:start position:31%
It ensures that the image
is read and processed


449
00:20:44.211 --> 00:20:46.580 line:-1 align:center
with its destination size in mind,


450
00:20:46,613 --> 00:20:49,716 line:-1
saving a lot of CPU time and memory.


451
00:20:51,251 --> 00:20:55,088 line:-2 align:start
You use it just like
the Image Preparation APIs.


452
00:20:55.122 --> 00:20:57.591 line:-1 align:center
First, take a UIImage


453
00:20:57,624 --> 00:21:00,761 line:-2 position:28%
and set a placeholder image
on the image view.


454
00:21:00,794 --> 00:21:03,897 line:-1
Then, call the new resizing API,


455
00:21:03,931 --> 00:21:07,568 line:-2 align:start
with the view's size
as the target size for the thumbnail.


456
00:21:08,602 --> 00:21:11,305 position:30% line:-2
When its prepared,
just update the image view


457
00:21:11,338 --> 00:21:13,140 line:-1
with the new thumbnail.


458
00:21:13.173 --> 00:21:15.709 line:-1 align:center
Along with the Image Preparation APIs,


459
00:21:15.742 --> 00:21:18.478 line:-1 align:center
it's much easier to accelerate images


460
00:21:18.512 --> 00:21:19.813 line:-1 align:center
and avoid hitches


461
00:21:19.847 --> 00:21:22.716 line:-1 align:center
in any app with iOS 15.


462
00:21:22,749 --> 00:21:24,418 line:-1
When working with images,


463
00:21:24,451 --> 00:21:27,387 line:-1
focus on having an asynchronous API


464
00:21:27,421 --> 00:21:30,991 line:-2 position:31%
that can update the UI
when an image is ready.


465
00:21:31.024 --> 00:21:33.794 line:-1 align:center
In the meantime, use a placeholder image,


466
00:21:33,827 --> 00:21:36,029 line:-1
which is small or cheap enough


467
00:21:36,063 --> 00:21:38,265 line:-1
to display synchronously.


468
00:21:38.298 --> 00:21:41.602 line:-2 position:29% align:start
When used with prefetching
and reconfigureItems,


469
00:21:41.635 --> 00:21:45.138 line:-2 align:start position:27%
showing asynchronous content
in collection and list views


470
00:21:45,172 --> 00:21:48,175 line:-1
has never been easier or more performant.


471
00:21:49.409 --> 00:21:52.546 line:-2 align:start position:23%
To get started
with fast collection and table views,


472
00:21:52.579 --> 00:21:56.116 line:-1 align:center
first, build your app with the iOS 15 SDK


473
00:21:56.149 --> 00:21:58.719 line:-1 align:center
to unlock many new optimizations.


474
00:21:58,752 --> 00:22:01,989 align:start line:-2
Particularly, ensure you
validate the behavior


475
00:22:02,022 --> 00:22:04,091 line:-1
of your collection and table views


476
00:22:04.124 --> 00:22:06.493 line:-1 align:center
with the new prefetching.


477
00:22:06,527 --> 00:22:08,695 line:-1
All the new APIs demonstrated here


478
00:22:08,729 --> 00:22:11,698 line:-2 position:25%
can be found in the sample code
for this talk.


479
00:22:11.732 --> 00:22:15.102 line:-2 position:27% align:start
Check it out and make sure
to adopt the image preparation


480
00:22:15.135 --> 00:22:17.638 line:-1 align:center
and resizing APIs across your app.


481
00:22:17,671 --> 00:22:19,940 line:-1
This will ensure your collection


482
00:22:19.973 --> 00:22:22.042 line:-1 align:center
and table views are blazing fast.


483
00:22:22,075 --> 00:22:23,877 line:-1
Thanks for watching.


484
00:22:23,911 --> 00:22:26,914 line:-1
[upbeat music]

