2
00:00:02.102 --> 00:00:07.107 line:-1 align:center
[music]


3
00:00:09.443 --> 00:00:10.911 line:-2 align:center
[Tony]
Hello, my name is Tony,


4
00:00:10.944 --> 00:00:12.613 line:-2 align:center
and I'm an engineer
on the Foundation team.


5
00:00:12,646 --> 00:00:15,616 line:-2
Welcome
to “What’s new in Foundation.”


6
00:00:15,649 --> 00:00:18,252 line:-2
The Foundation framework
provides base functionality


7
00:00:18.285 --> 00:00:19.920 line:-1 align:center
for all apps and frameworks.


8
00:00:19,953 --> 00:00:22,256 line:-2
It has plenty of features,
including everything


9
00:00:22,289 --> 00:00:25,559 line:-2
from file handling to networking
and notifications.


10
00:00:25.592 --> 00:00:28.328 line:-2 align:center
Today I’d like to focus
on something all apps need:


11
00:00:28.362 --> 00:00:31.098 line:-2 align:center
internationalization
and localization.


12
00:00:31.131 --> 00:00:32.799 line:-2 align:center
In this year’s releases,
we have some


13
00:00:32,833 --> 00:00:36,870 line:-2
of the biggest advancements ever
in this API.


14
00:00:36.904 --> 00:00:38.872 line:-1 align:center
We started at a low level,


15
00:00:38.906 --> 00:00:43.477 line:-2 align:center
rethinking what
an attributed string is in Swift.


16
00:00:43.510 --> 00:00:47.281 line:-2 align:center
We rebuilt our formatters
for Swift, making them faster,


17
00:00:47.314 --> 00:00:50.584 line:-2 align:center
easier to use,
and adding new features.


18
00:00:50.617 --> 00:00:52.753 line:-2 align:center
And finally,
we have a brand new feature


19
00:00:52.786 --> 00:00:55.722 line:-2 align:center
called automatic grammar
agreement.


20
00:00:55,756 --> 00:00:57,891 line:-2
It dramatically reduces
the number


21
00:00:57.925 --> 00:01:00.527 line:-2 align:center
of localized strings
you need to provide while,


22
00:01:00.561 --> 00:01:02.963 line:-2 align:center
at the same time,
making your code simpler.


23
00:01:02.996 --> 00:01:05.933 line:-2 align:center
Let’s jump right in
to attributed strings.


24
00:01:05.966 --> 00:01:09.503 line:-2 align:center
An attributed string is
a combination of characters,


25
00:01:09.536 --> 00:01:12.172 line:-2 align:center
a set of ranges,
and a dictionary.


26
00:01:12.206 --> 00:01:15.676 line:-2 align:center
Attributed strings allow
you to associate attributes,


27
00:01:15.709 --> 00:01:20.047 line:-2 align:center
which are key-value pairs,
to a specific range of a string.


28
00:01:20,080 --> 00:01:22,916 line:-2
The most common attributes
are defined by the SDK,


29
00:01:22,950 --> 00:01:25,452 line:-2
but you can also
create your own.


30
00:01:25,485 --> 00:01:27,454 line:-2
You’ll often
find attributed strings


31
00:01:27,487 --> 00:01:30,224 line:-1
in API that supports rich text.


32
00:01:30.257 --> 00:01:32.059 line:-1 align:center
Let’s look at an example.


33
00:01:32,092 --> 00:01:34,862 line:-2
Here is an app
I’m working on called Caffé.


34
00:01:34,895 --> 00:01:36,463 line:-1
It’s a simple menu.


35
00:01:36,496 --> 00:01:42,469 line:-2
I pick the food that I want,
the size, the quantity.


36
00:01:42.503 --> 00:01:44.905 line:-2 align:center
And at the end,
it shows me a receipt


37
00:01:44,938 --> 00:01:46,974 line:-2
with a list of everything I’ve
ordered.


38
00:01:47,007 --> 00:01:52,346 line:-2
At the bottom here, I decided
to add a short thank-you note.


39
00:01:52.379 --> 00:01:54.748 line:-1 align:center
This is an attributed string.


40
00:01:54.781 --> 00:01:58.118 line:-2 align:center
Part of the string is in bold
and part is in italics.


41
00:01:58,151 --> 00:02:00,921 line:-2
The last word has a link
as well.


42
00:02:00.954 --> 00:02:04.424 line:-2 align:center
As you can tell here,
attributes can overlap.


43
00:02:04,458 --> 00:02:06,026 line:-2
Since the beginning
of Foundation,


44
00:02:06,059 --> 00:02:09,196 line:-2
we’ve had a reference type
called NSAttributedString.


45
00:02:09.229 --> 00:02:11.498 line:-2 align:center
This year,
we introduce a new struct


46
00:02:11,532 --> 00:02:14,201 line:-2
AttributedString,
which takes full advantage


47
00:02:14,234 --> 00:02:17,671 line:-2
of all of the features
that Swift provides us.


48
00:02:17.704 --> 00:02:21.275 line:-2 align:center
First and foremost,
it’s a value type.


49
00:02:21.308 --> 00:02:23.610 line:-2 align:center
It also has the same
character-counting behavior


50
00:02:23.644 --> 00:02:26.313 line:-1 align:center
as Swift String.


51
00:02:26.346 --> 00:02:28.615 line:-2 align:center
As part of our commitment
to making it easy


52
00:02:28.649 --> 00:02:30.117 line:-1 align:center
to write inclusive software,


53
00:02:30.150 --> 00:02:34.254 line:-2 align:center
AttributedString is
now fully localizable.


54
00:02:34,288 --> 00:02:37,891 line:-2
Finally, it is built with safety
and security in mind.


55
00:02:37,925 --> 00:02:41,662 line:-2
This includes both compile time
safety by using strong typing


56
00:02:41.695 --> 00:02:45.399 line:-2 align:center
and also safety during
unarchiving using Codable.


57
00:02:45,432 --> 00:02:47,568 line:-2
Let’s take a brief tour
of what you can do


58
00:02:47.601 --> 00:02:51.305 line:-1 align:center
with the new AttributedString.


59
00:02:51.338 --> 00:02:54.074 line:-2 align:center
We’re going to build
our thank-you message.


60
00:02:54,107 --> 00:02:56,043 line:-2
First, we create
an attributed string


61
00:02:56,076 --> 00:02:58,178 line:-1
using a simple initializer.


62
00:02:58.212 --> 00:03:01.014 line:-2 align:center
I want to set an attribute
on this entire string.


63
00:03:01,048 --> 00:03:03,951 line:-2
That’s as simple
as setting the font property.


64
00:03:03.984 --> 00:03:07.020 line:-2 align:center
In struct AttributedString,
all attributes are available


65
00:03:07.054 --> 00:03:10.023 line:-2 align:center
directly,
and they use the correct types.


66
00:03:10.057 --> 00:03:14.294 line:-2 align:center
This property, for example,
is a SwiftUI Font.


67
00:03:14.328 --> 00:03:17.030 line:-2 align:center
Next, we create another
attributed string.


68
00:03:17,064 --> 00:03:19,766 line:-2
This one
is a reference to our website,


69
00:03:19,800 --> 00:03:23,136 line:-2
so we set the link property
to a URL.


70
00:03:23,170 --> 00:03:26,940 line:-2
Here I’m setting the font
and link on the whole string.


71
00:03:26,974 --> 00:03:30,611 line:-2
We’ll look at how to change just
part of a string later.


72
00:03:30,644 --> 00:03:33,680 line:-2
Another useful tool is
an attribute container.


73
00:03:33.714 --> 00:03:35.883 line:-2 align:center
It’s a place you can
hold attributes and values


74
00:03:35.916 --> 00:03:38.385 line:-1 align:center
on their own without the string.


75
00:03:38.418 --> 00:03:41.522 line:-2 align:center
Here, I create a container
and set some attributes on it,


76
00:03:41,555 --> 00:03:44,925 line:-2
depending
on the importance of my message.


77
00:03:44,958 --> 00:03:47,027 line:-2
And finally,
I merge those attributes


78
00:03:47,060 --> 00:03:49,730 line:-1
into both attributed strings.


79
00:03:49,763 --> 00:03:52,032 line:-2
As I mentioned,
attributed string is


80
00:03:52.065 --> 00:03:55.335 line:-2 align:center
a combination of characters,
ranges, and a dictionary.


81
00:03:55,369 --> 00:03:57,871 line:-2
The attributed string
itself is not a collection


82
00:03:57,905 --> 00:03:59,840 line:-2
of any single one
of those things.


83
00:03:59,873 --> 00:04:01,708 line:-1
Instead, in order to gain access


84
00:04:01,742 --> 00:04:05,012 line:-2
to these properties,
it has what we call views.


85
00:04:05,045 --> 00:04:07,447 line:-2
The two most important views
are characters,


86
00:04:07.481 --> 00:04:10.217 line:-2 align:center
which provides access
to the string, and runs,


87
00:04:10,250 --> 00:04:12,920 line:-2
which provides access
to the attributes.


88
00:04:12.953 --> 00:04:14.922 line:-2 align:center
These views
are Swift collections,


89
00:04:14.955 --> 00:04:17.824 line:-2 align:center
which means the functions
you are familiar with from types


90
00:04:17,858 --> 00:04:20,594 line:-2
like Array are available
here too.


91
00:04:20,627 --> 00:04:23,363 line:-1
Let’s look at another example.


92
00:04:23,397 --> 00:04:25,999 line:-2
Let’s say our designers told us
to add a little bit


93
00:04:26,033 --> 00:04:27,734 line:-2
of pizzazz
to our thank-you message


94
00:04:27,768 --> 00:04:30,871 line:-2
by making all punctuation
a fun orange color.


95
00:04:30.904 --> 00:04:32.873 line:-2 align:center
To do this,
first I need to find


96
00:04:32,906 --> 00:04:35,709 line:-2
where the punctuation is
in the attributed string.


97
00:04:35,742 --> 00:04:38,745 line:-2
Like other Swift collections,
attributed string views use


98
00:04:38,779 --> 00:04:41,481 line:-2
indices,
which are simply a position


99
00:04:41,515 --> 00:04:43,517 line:-2
for some element
in the collection.


100
00:04:43.550 --> 00:04:45.085 line:-1 align:center
To iterate by index,


101
00:04:45.118 --> 00:04:48.388 line:-2 align:center
I use the standard library
indices function.


102
00:04:48,422 --> 00:04:52,025 line:-2
Next, I use the function
isPunctuation to check


103
00:04:52,059 --> 00:04:55,295 line:-2
if this character is one
that we need to change.


104
00:04:55,329 --> 00:04:58,799 line:-2
Finally, I use another feature
of attributed string, slicing,


105
00:04:58,832 --> 00:05:02,236 line:-2
to apply an attribute to only
a subrange of the whole string.


106
00:05:02.269 --> 00:05:05.138 line:-2 align:center
The range starts at this index
and continues


107
00:05:05,172 --> 00:05:09,009 line:-2
until the next index after that,
so one character.


108
00:05:09.042 --> 00:05:11.678 line:-2 align:center
And now the punctuation is
orange.


109
00:05:11,712 --> 00:05:13,914 line:-2
Let’s look
at another view, runs.


110
00:05:13,947 --> 00:05:16,383 line:-2
A run is the starting location,
length,


111
00:05:16,416 --> 00:05:19,186 line:-2
and value
of a particular attribute.


112
00:05:19,219 --> 00:05:22,356 line:-2
We can start by counting all
the runs in our message.


113
00:05:22.389 --> 00:05:24.291 line:-2 align:center
This will iterate
each contiguous range


114
00:05:24.324 --> 00:05:26.493 line:-2 align:center
of attribute values
in the string.


115
00:05:26.527 --> 00:05:29.263 line:-2 align:center
There are four runs
in this string.


116
00:05:29,296 --> 00:05:32,833 line:-2
Each run has a value or nil
for each attribute.


117
00:05:32,866 --> 00:05:36,336 line:-2
The ranges from characters
and runs are interchangeable,


118
00:05:36.370 --> 00:05:40.541 line:-2 align:center
so you can find the string
for an attribute or vice-versa.


119
00:05:40.574 --> 00:05:43.310 line:-2 align:center
Here I use the range
of the attribute in a subscript


120
00:05:43,343 --> 00:05:45,579 line:-2
for the characters view,
converting the result


121
00:05:45,612 --> 00:05:48,949 line:-1
into a standalone string.


122
00:05:48.982 --> 00:05:51.552 line:-2 align:center
It’s often most useful
to look at runs by focusing


123
00:05:51,585 --> 00:05:53,754 line:-1
on a specific attribute.


124
00:05:53.787 --> 00:05:56.790 line:-2 align:center
Here, we use the key path link
to coalesce


125
00:05:56,823 --> 00:05:58,759 line:-1
for just the link attribute.


126
00:05:58,792 --> 00:06:01,528 line:-2
Each element of the resulting
collection will give us


127
00:06:01,562 --> 00:06:03,664 line:-2
the value of the link attribute,
not taking


128
00:06:03.697 --> 00:06:07.668 line:-2 align:center
into account other attributes
which may be set in the string.


129
00:06:07,701 --> 00:06:11,338 line:-2
If we only look at links,
we have three runs: the first,


130
00:06:11.371 --> 00:06:13.440 line:-2 align:center
where it is not set;
the second,


131
00:06:13.473 --> 00:06:15.742 line:-2 align:center
where it is set to a value;
and the third,


132
00:06:15.776 --> 00:06:19.146 line:-2 align:center
the last period in the sentence,
where it is not set again.


133
00:06:19,179 --> 00:06:21,181 line:-2
Iterating the runs
gives us a tuple


134
00:06:21,215 --> 00:06:23,016 line:-1
of the value and the range.


135
00:06:23.050 --> 00:06:25.652 line:-2 align:center
Since the values are type safe,
we can use an API,


136
00:06:25,686 --> 00:06:28,355 line:-2
like scheme,
which exists on URL,


137
00:06:28,388 --> 00:06:32,159 line:-2
without casting or worrying
about having the wrong type.


138
00:06:32,192 --> 00:06:33,794 line:-2
Here I’m checking
that every link


139
00:06:33,827 --> 00:06:37,264 line:-2
in the attributed string
is https.


140
00:06:37,297 --> 00:06:39,233 line:-2
Another useful technique
is to look


141
00:06:39.266 --> 00:06:41.201 line:-2 align:center
for a substring
and use that range


142
00:06:41,235 --> 00:06:43,637 line:-2
to edit the characters
or the attributes.


143
00:06:43,670 --> 00:06:45,973 line:-2
Let’s say I want to replace
the word "visit'


144
00:06:46,006 --> 00:06:48,876 line:-2
with something that has
a more throwback vibe.


145
00:06:48.909 --> 00:06:51.945 line:-2 align:center
First, I look for the range
of a substring.


146
00:06:51.979 --> 00:06:54.715 line:-2 align:center
Next, I use that range
to set the attributes


147
00:06:54.748 --> 00:06:58.185 line:-2 align:center
and characters on only
that subrange.


148
00:06:58.218 --> 00:07:00.120 line:-2 align:center
The result
is an attributed string


149
00:07:00.153 --> 00:07:02.589 line:-1 align:center
with six runs, like this.


150
00:07:02,623 --> 00:07:05,459 line:-2
Next, let’s talk
about localization.


151
00:07:05.492 --> 00:07:08.395 line:-2 align:center
AttributedString is
fully localizable.


152
00:07:08,428 --> 00:07:10,430 line:-2
We also added localization
support


153
00:07:10.464 --> 00:07:12.699 line:-2 align:center
to NSAttributedString
in Objective-C.


154
00:07:12,733 --> 00:07:14,668 line:-1
Attributed strings are located


155
00:07:14,701 --> 00:07:18,038 line:-2
in your app’s strings files,
just like a regular string.


156
00:07:18.071 --> 00:07:21.575 line:-2 align:center
In Swift, we now support
localized formatting of String


157
00:07:21,608 --> 00:07:24,778 line:-2
and AttributedString
using string interpolation


158
00:07:24.811 --> 00:07:27.214 line:-1 align:center
just like SwiftUI’s text view.


159
00:07:27,247 --> 00:07:29,483 line:-1
Here’s a simple example.


160
00:07:29,516 --> 00:07:31,785 line:-2
This function returns
a localized string


161
00:07:31,818 --> 00:07:35,022 line:-2
which is customized
with a user’s document name.


162
00:07:35,055 --> 00:07:39,293 line:-2
Instead of using format
specifiers like %@ or %d


163
00:07:39,326 --> 00:07:41,128 line:-1
and calling a format function,


164
00:07:41.161 --> 00:07:44.798 line:-2 align:center
you can now just
pass the value in directly.


165
00:07:44.831 --> 00:07:48.969 line:-2 align:center
The same approach works
for AttributedString.


166
00:07:49.002 --> 00:07:50.971 line:-2 align:center
Xcode can generate
your strings files


167
00:07:51.004 --> 00:07:53.707 line:-2 align:center
from these new initializers
using the compiler.


168
00:07:53,740 --> 00:07:56,243 line:-2
To turn it on,
go to your build settings,


169
00:07:56,276 --> 00:07:58,345 line:-2
look
for the localization settings,


170
00:07:58.378 --> 00:08:02.082 line:-2 align:center
and turn on Use Compiler
to Extract Swift Strings.


171
00:08:02.115 --> 00:08:03.550 line:-1 align:center
You may be wondering how


172
00:08:03.584 --> 00:08:06.119 line:-2 align:center
the localized attributed string
gets its attributes.


173
00:08:06.153 --> 00:08:08.322 line:-2 align:center
I’m excited to tell
you that we’ve added support


174
00:08:08.355 --> 00:08:10.591 line:-2 align:center
for Markdown
to AttributedString.


175
00:08:10,624 --> 00:08:12,759 line:-2
Here’s an example
of using a localized


176
00:08:12.793 --> 00:08:15.596 line:-2 align:center
attributed string,
right in a SwiftUI Text.


177
00:08:15.629 --> 00:08:18.632 line:-2 align:center
I start off
with just a plain string.


178
00:08:18.665 --> 00:08:20.968 line:-2 align:center
By adding two asterisks
around the text,


179
00:08:21,001 --> 00:08:25,906 line:-2
I make it strongly emphasized,
which SwiftUI renders as bold.


180
00:08:25,939 --> 00:08:29,409 line:-2
I can use underscores
to make the text emphasized,


181
00:08:29.443 --> 00:08:32.846 line:-1 align:center
which SwiftUI renders as italic.


182
00:08:32.880 --> 00:08:34.815 line:-1 align:center
We also support links.


183
00:08:34,848 --> 00:08:37,885 line:-2
This is a great opportunity
for localizers to provide


184
00:08:37.918 --> 00:08:41.121 line:-2 align:center
customized URLs
for different languages.


185
00:08:41,154 --> 00:08:43,156 line:-2
We also support
other inline styles


186
00:08:43,190 --> 00:08:45,392 line:-2
like strikethrough
and code voice.


187
00:08:45.425 --> 00:08:49.429 line:-2 align:center
Finally, let’s talk about
archiving attributed strings.


188
00:08:49.463 --> 00:08:52.599 line:-2 align:center
First, we need the ability
to convert to and from


189
00:08:52,633 --> 00:08:55,269 line:-2
the NSAttributedString
reference type.


190
00:08:55,302 --> 00:08:58,138 line:-2
Attributed strings can be
part of your data model,


191
00:08:58,172 --> 00:09:01,842 line:-2
which means we need to be able
to encode and decode them.


192
00:09:01,875 --> 00:09:04,745 line:-2
Finally, we want a way
to specify custom attributes


193
00:09:04.778 --> 00:09:06.113 line:-1 align:center
in Markdown.


194
00:09:06.146 --> 00:09:08.615 line:-2 align:center
These operations are all related
to each other.


195
00:09:08,649 --> 00:09:12,319 line:-2
Let’s start by looking
at conversion.


196
00:09:12.352 --> 00:09:16.123 line:-2 align:center
We’ve all written a lot of code
that uses NSAttributedString,


197
00:09:16.156 --> 00:09:18.292 line:-1 align:center
so we’ve made it easy to convert


198
00:09:18.325 --> 00:09:20.794 line:-2 align:center
from the struct
to the class type.


199
00:09:20,827 --> 00:09:24,398 line:-2
Here’s a view that has
an NSAttributedString property.


200
00:09:24.431 --> 00:09:27.401 line:-2 align:center
To convert, just pass
our struct AttributedString


201
00:09:27,434 --> 00:09:30,504 line:-2
to the NSAttributedString
initializer.


202
00:09:30,537 --> 00:09:32,673 line:-2
For attributes that are part
of the SDK,


203
00:09:32,706 --> 00:09:35,409 line:-1
this is all I need to do.


204
00:09:35.442 --> 00:09:38.612 line:-2 align:center
Now let’s look at encoding
and decoding.


205
00:09:38,645 --> 00:09:41,682 line:-2
Here is a struct that holds
a receipt from our Caffé app.


206
00:09:41,715 --> 00:09:43,617 line:-2
Again, I’m using the attributes
provided


207
00:09:43.650 --> 00:09:47.988 line:-2 align:center
by SwiftUI, UIKit, AppKit,
and Foundation.


208
00:09:48.021 --> 00:09:50.190 line:-2 align:center
That means
that AttributedString’s default


209
00:09:50,224 --> 00:09:53,160 line:-2
Codable implementation is
all I need.


210
00:09:53,193 --> 00:09:56,196 line:-2
I just add the Codable
conformance to Receipt,


211
00:09:56,230 --> 00:09:58,265 line:-1
and I’m done.


212
00:09:58,298 --> 00:10:00,067 line:-2
Let’s go
a bit further and add support


213
00:10:00.100 --> 00:10:02.302 line:-1 align:center
for encoding a custom attribute.


214
00:10:02.336 --> 00:10:05.472 line:-2 align:center
We’ll start by talking
about the attribute itself.


215
00:10:05.506 --> 00:10:09.076 line:-2 align:center
An attribute is two parts:
a key and a value.


216
00:10:09.109 --> 00:10:10.944 line:-1 align:center
The key is a type which conforms


217
00:10:10.978 --> 00:10:13.780 line:-2 align:center
with the new
AttributedStringKey protocol.


218
00:10:13,814 --> 00:10:16,483 line:-2
That defines what type
of value it requires


219
00:10:16,517 --> 00:10:19,186 line:-1
and a name for archiving.


220
00:10:19.219 --> 00:10:21.221 line:-2 align:center
This key can also conform
with other protocols


221
00:10:21,255 --> 00:10:25,025 line:-2
to customize how the value
is encoded or decoded.


222
00:10:25.058 --> 00:10:26.960 line:-2 align:center
Let’s say
we want to define a range


223
00:10:26.994 --> 00:10:30.264 line:-2 align:center
of an attributed string
to have some extra color.


224
00:10:30,297 --> 00:10:32,633 line:-2
This rainbow effect
comes in three levels:


225
00:10:32.666 --> 00:10:35.669 line:-1 align:center
plain, fun, or extreme.


226
00:10:35,702 --> 00:10:38,505 line:-2
We’ll use an enum
to represent that value


227
00:10:38,539 --> 00:10:41,608 line:-1
and set the name to rainbow.


228
00:10:41,642 --> 00:10:45,112 line:-2
Defining the type and the name
are the only requirements


229
00:10:45.145 --> 00:10:47.281 line:-1 align:center
of this protocol.


230
00:10:47,314 --> 00:10:49,983 line:-2
Now, let’s say we want to make
this attribute Codable


231
00:10:50,017 --> 00:10:53,687 line:-2
so that it will be part
of the encoded attributed string.


232
00:10:53.720 --> 00:10:57.658 line:-2 align:center
All I have to do is add
Codable conformance, like this.


233
00:10:57.691 --> 00:11:00.460 line:-2 align:center
Finally, let’s say
we want the rainbow level


234
00:11:00,494 --> 00:11:02,796 line:-2
to be part
of our localized string.


235
00:11:02,829 --> 00:11:05,566 line:-2
That means it can be applied
to the right part of the string,


236
00:11:05,599 --> 00:11:08,569 line:-2
no matter where that is,
in any language.


237
00:11:08.602 --> 00:11:14.141 line:-2 align:center
All we need is one more
protocol conformance to opt in.


238
00:11:14.174 --> 00:11:17.277 line:-2 align:center
When we say that an attribute
is Markdown decodable,


239
00:11:17,311 --> 00:11:19,346 line:-2
then we can decode it
straight from Markdown


240
00:11:19.379 --> 00:11:22.149 line:-2 align:center
and insert it
into an attributed string.


241
00:11:22,182 --> 00:11:25,285 line:-2
All that’s required is
that the value is Codable.


242
00:11:25,319 --> 00:11:28,121 line:-2
Next, let’s take a look
at the custom attribute syntax


243
00:11:28.155 --> 00:11:29.890 line:-1 align:center
for Markdown.


244
00:11:29,923 --> 00:11:32,492 line:-2
In this first example,
we have a reference to a link.


245
00:11:32,526 --> 00:11:34,895 line:-2
It uses square brackets
for the link text


246
00:11:34,928 --> 00:11:39,166 line:-2
and parentheses
for the link destination, a URL.


247
00:11:39,199 --> 00:11:42,436 line:-2
In this second example,
we have a reference to an image.


248
00:11:42.469 --> 00:11:44.671 line:-2 align:center
It starts
with an exclamation point,


249
00:11:44,705 --> 00:11:47,441 line:-2
then uses square brackets
for the image description


250
00:11:47,474 --> 00:11:50,110 line:-2
and parentheses
for the image source.


251
00:11:50,143 --> 00:11:53,547 line:-2
These first two examples
are common in Markdown.


252
00:11:53,580 --> 00:11:55,716 line:-2
The third example
shows our syntax


253
00:11:55,749 --> 00:11:57,317 line:-1
for custom attributes.


254
00:11:57,351 --> 00:11:59,987 line:-2
It starts with a caret,
then uses square brackets


255
00:12:00,020 --> 00:12:03,524 line:-2
for the text, and parentheses
for its attributes.


256
00:12:03.557 --> 00:12:06.760 line:-2 align:center
The attributes are represented
with JSON 5.


257
00:12:06,793 --> 00:12:11,398 line:-2
JSON 5 is compatible with JSON
and allows for unquoted keys,


258
00:12:11.431 --> 00:12:13.600 line:-2 align:center
comments,
and a few other features.


259
00:12:13.634 --> 00:12:15.736 line:-2 align:center
It’s a good match
for a human-friendly string


260
00:12:15,769 --> 00:12:17,137 line:-1
like this one.


261
00:12:17.171 --> 00:12:19.139 line:-1 align:center
We’ve also added JSON 5 support


262
00:12:19,173 --> 00:12:22,342 line:-2
to our other JSON API
in Foundation.


263
00:12:22.376 --> 00:12:25.812 line:-2 align:center
Because custom attributes
use JSON, anything that can


264
00:12:25.846 --> 00:12:29.316 line:-2 align:center
be decoded with JSONDecoder
is automatically compatible


265
00:12:29.349 --> 00:12:31.852 line:-2 align:center
with the new
custom Markdown syntax.


266
00:12:31,885 --> 00:12:33,587 line:-1
Here we have a single attribute,


267
00:12:33,620 --> 00:12:36,590 line:-2
two attributes,
one string and one number,


268
00:12:36,623 --> 00:12:39,526 line:-2
and a single attribute
with multiple properties.


269
00:12:39.560 --> 00:12:42.029 line:-2 align:center
There is just one additional
piece here, which is how


270
00:12:42,062 --> 00:12:45,165 line:-2
we connect these names
in Markdown to a Swift type.


271
00:12:45,199 --> 00:12:47,768 line:-2
That piece is called
an attribute scope.


272
00:12:47.801 --> 00:12:50.604 line:-2 align:center
Scopes are a group
of attribute keys.


273
00:12:50.637 --> 00:12:54.007 line:-2 align:center
Scopes are useful when decoding
from JSON or Markdown,


274
00:12:54.041 --> 00:12:56.310 line:-2 align:center
because they tell us
which attributes we expect


275
00:12:56,343 --> 00:13:00,314 line:-2
to find, their names,
and how to decode them.


276
00:13:00.347 --> 00:13:03.317 line:-2 align:center
We define one scope each
for Foundation,


277
00:13:03,350 --> 00:13:06,353 line:-1
UIKit, AppKit, and SwiftUI.


278
00:13:06,386 --> 00:13:10,891 line:-2
You can define a scope
of your own attributes as well.


279
00:13:10.924 --> 00:13:13.827 line:-2 align:center
Let’s define a scope
for our Caffé App.


280
00:13:13.861 --> 00:13:16.396 line:-2 align:center
We’ll nest the scope
inside AttributeScopes


281
00:13:16.430 --> 00:13:19.566 line:-2 align:center
and conform it
to the AttributeScope protocol.


282
00:13:19.600 --> 00:13:22.336 line:-2 align:center
Then all we need
to do is list the attributes


283
00:13:22,369 --> 00:13:25,005 line:-1
inside our scope with “let.”


284
00:13:25.038 --> 00:13:28.609 line:-2 align:center
So far, we have just
our rainbow attribute.


285
00:13:28,642 --> 00:13:32,112 line:-2
Next, we’ll include the SwiftUI
scope inside of ours.


286
00:13:32.145 --> 00:13:34.014 line:-2 align:center
That allows
all of those attributes


287
00:13:34,047 --> 00:13:36,116 line:-1
in addition to our own.


288
00:13:36.149 --> 00:13:37.885 line:-1 align:center
Scopes nest recursively,


289
00:13:37,918 --> 00:13:40,654 line:-2
so this also includes
Foundation attributes.


290
00:13:40.687 --> 00:13:43.924 line:-2 align:center
It’s useful to define a property
for our new scope.


291
00:13:43.957 --> 00:13:46.093 line:-2 align:center
That allows us to use
a key path syntax


292
00:13:46,126 --> 00:13:48,862 line:-2
in functions which take
the scope as an argument.


293
00:13:48,896 --> 00:13:51,231 line:-2
Finally,
we can now load our localized


294
00:13:51.265 --> 00:13:54.701 line:-2 align:center
and colorful attributed string
from custom Markdown.


295
00:13:54.735 --> 00:13:57.404 line:-2 align:center
You’ll also find scope-taking
functions for archiving


296
00:13:57,437 --> 00:14:00,541 line:-2
and conversion to
and from NSAttributedString.


297
00:14:00.574 --> 00:14:04.178 line:-2 align:center
This allows customization
of behavior at every step.


298
00:14:04,211 --> 00:14:06,813 line:-2
Here’s the first screen
of the Caffé app again,


299
00:14:06.847 --> 00:14:10.717 line:-2 align:center
where you can see our custom
rainbow attribute in the title.


300
00:14:10.751 --> 00:14:13.220 line:-2 align:center
After the localized string
is converted from Markdown


301
00:14:13.253 --> 00:14:16.557 line:-2 align:center
into an attributed string,
the app finds the attribute


302
00:14:16.590 --> 00:14:21.128 line:-2 align:center
and applies a fun effect to just
that range of the string.


303
00:14:21,161 --> 00:14:24,097 line:-2
Because the attribute comes
from our localized strings file,


304
00:14:24,131 --> 00:14:26,233 line:-2
this works correctly
for all languages


305
00:14:26,266 --> 00:14:29,570 line:-2
that Caffé supports,
like Spanish.


306
00:14:29.603 --> 00:14:31.138 line:-2 align:center
We’re just getting started,
though.


307
00:14:31,171 --> 00:14:35,008 line:-2
We also have
a totally new Formatter API.


308
00:14:35.042 --> 00:14:38.478 line:-2 align:center
Formatters are another
long-time Foundation feature.


309
00:14:38,512 --> 00:14:40,414 line:-2
They are responsible
for taking data,


310
00:14:40,447 --> 00:14:44,017 line:-2
like numbers, dates, times,
and more and converting it


311
00:14:44,051 --> 00:14:47,487 line:-2
into a localized
and user-presentable string.


312
00:14:47.521 --> 00:14:50.490 line:-2 align:center
Formatters are backed by quite
a bit of configuration data,


313
00:14:50.524 --> 00:14:54.027 line:-2 align:center
so it’s a common pattern
to cache and reuse them.


314
00:14:54.061 --> 00:14:57.631 line:-2 align:center
However, apps are composed
of many distinct pieces of code.


315
00:14:57,664 --> 00:15:00,267 line:-2
It may not always make
sense to share a formatter


316
00:15:00.300 --> 00:15:02.102 line:-1 align:center
between all of them.


317
00:15:02.135 --> 00:15:04.838 line:-2 align:center
Also, because of the large
variety of ways that people


318
00:15:04.872 --> 00:15:08.609 line:-2 align:center
read dates and times,
plus our desire as app authors


319
00:15:08,642 --> 00:15:11,745 line:-2
to present this data in a way
that fits our design,


320
00:15:11.778 --> 00:15:14.414 line:-2 align:center
there are a lot of opportunities
for edge cases.


321
00:15:14,448 --> 00:15:17,851 line:-2
This year, we improved both
performance and usability


322
00:15:17,885 --> 00:15:21,221 line:-2
by rethinking our Formatter API
from the ground up.


323
00:15:21.255 --> 00:15:25.025 line:-2 align:center
In short, our new APIs focus
on the format.


324
00:15:25.058 --> 00:15:28.161 line:-2 align:center
Let’s take a look at this code
from the Earthquakes sample app,


325
00:15:28.195 --> 00:15:31.431 line:-2 align:center
where we can see
the caching pattern in action.


326
00:15:31,465 --> 00:15:34,268 line:-1
It has a two-step process.


327
00:15:34,301 --> 00:15:37,604 line:-2
First, create
and configure a formatter.


328
00:15:37.638 --> 00:15:41.441 line:-2 align:center
Next, give the formatter
our date and get a string.


329
00:15:41,475 --> 00:15:43,010 line:-1
How could it be simpler?


330
00:15:43,043 --> 00:15:45,412 line:-2
Well, let’s start
by removing the requirement


331
00:15:45.445 --> 00:15:47.347 line:-2 align:center
to create
our own date formatter.


332
00:15:47,381 --> 00:15:50,317 line:-2
It was really easy to forget
that this needed to be cached,


333
00:15:50,350 --> 00:15:52,686 line:-2
which would lead to re-creating
the same formatter


334
00:15:52,719 --> 00:15:54,555 line:-1
for every cell in the table.


335
00:15:54,588 --> 00:15:56,356 line:-1
Next, the formatting step.


336
00:15:56.390 --> 00:15:58.792 line:-2 align:center
Instead of passing our date
through the formatter,


337
00:15:58.825 --> 00:16:01.261 line:-1 align:center
let’s just use the date itself.


338
00:16:01,295 --> 00:16:03,630 line:-1
Now it’s just one line of code.


339
00:16:03,664 --> 00:16:07,434 line:-2
You specify the format you want,
and that’s it.


340
00:16:07.467 --> 00:16:10.037 line:-2 align:center
Let’s talk more
about this number format.


341
00:16:10,070 --> 00:16:13,373 line:-2
It’s not a lot of code,
but it’s hiding some complexity


342
00:16:13,407 --> 00:16:15,776 line:-2
and has a few pitfalls
to be aware of.


343
00:16:15.809 --> 00:16:18.312 line:-2 align:center
If the argument is not
a floating point number,


344
00:16:18.345 --> 00:16:21.448 line:-2 align:center
you’ll get entirely
the wrong output here.


345
00:16:21.481 --> 00:16:24.718 line:-2 align:center
Readers have to be aware
of a special case syntax


346
00:16:24,751 --> 00:16:26,620 line:-2
for formatting
floating point numbers,


347
00:16:26,653 --> 00:16:30,691 line:-2
along with a set of modifiers
that are just string constants.


348
00:16:30.724 --> 00:16:33.227 line:-2 align:center
We think this code is easier
to understand,


349
00:16:33,260 --> 00:16:35,329 line:-1
maintain, and read.


350
00:16:35.362 --> 00:16:37.865 line:-2 align:center
It uses regular Swift functions
to specify


351
00:16:37,898 --> 00:16:40,701 line:-2
exactly how we want our number
to be formatted.


352
00:16:40,734 --> 00:16:44,171 line:-2
You also get autocompletion
and type safety.


353
00:16:44.204 --> 00:16:45.839 line:-1 align:center
We’ve applied this new approach


354
00:16:45.873 --> 00:16:48.141 line:-2 align:center
to all ten formatters
in Foundation.


355
00:16:48.175 --> 00:16:50.978 line:-2 align:center
We’ve cleaned up
and simplified the interfaces,


356
00:16:51,011 --> 00:16:53,780 line:-2
made changes
to help avoid common pitfalls,


357
00:16:53,814 --> 00:16:57,251 line:-2
and added a bunch
of new features along the way.


358
00:16:57.284 --> 00:16:59.786 line:-2 align:center
Let’s take a look in detail
at two


359
00:16:59.820 --> 00:17:01.922 line:-2 align:center
of the most popular
formatted types:


360
00:17:01,955 --> 00:17:04,291 line:-1
dates and numbers.


361
00:17:04,324 --> 00:17:06,827 line:-2
Date formatting is
about using a calendar


362
00:17:06,860 --> 00:17:10,030 line:-2
and time zone to convert
an absolute point in time


363
00:17:10.063 --> 00:17:13.066 line:-2 align:center
into something a human
understands as a date.


364
00:17:13,100 --> 00:17:15,536 line:-2
And even more than that,
it takes into account


365
00:17:15,569 --> 00:17:17,371 line:-2
all of the preferences
that humans have


366
00:17:17.404 --> 00:17:19.973 line:-2 align:center
about how they like
their own dates to look.


367
00:17:20.007 --> 00:17:23.043 line:-2 align:center
We call those preferences
locales.


368
00:17:23.076 --> 00:17:25.512 line:-2 align:center
Let’s take a look
at the tiny amount of code


369
00:17:25,546 --> 00:17:28,248 line:-2
you need in order
to format a date.


370
00:17:28,282 --> 00:17:33,187 line:-2
First, I’ll get the current
point in time by using Date.now.


371
00:17:33,220 --> 00:17:35,889 line:-2
Next,
I call the formatted function.


372
00:17:35,923 --> 00:17:37,157 line:-1
That's it.


373
00:17:37.191 --> 00:17:39.593 line:-2 align:center
Of course,
as we just saw in our example,


374
00:17:39,626 --> 00:17:42,663 line:-2
date formatting is something
that has a lot of options.


375
00:17:42,696 --> 00:17:45,832 line:-1
So let’s expand this out a bit.


376
00:17:45.866 --> 00:17:47.901 line:-2 align:center
The formatted function can
be configured


377
00:17:47,935 --> 00:17:51,638 line:-2
to show only the date
or only the time.


378
00:17:51.672 --> 00:17:55.342 line:-2 align:center
Both of those arguments have
several options to pick from.


379
00:17:55.375 --> 00:17:58.111 line:-2 align:center
An important goal
for this new formatting API is


380
00:17:58.145 --> 00:18:00.214 line:-2 align:center
to provide
as much compile time help


381
00:18:00.247 --> 00:18:03.483 line:-2 align:center
as possible
in creating correct formats.


382
00:18:03,517 --> 00:18:06,520 line:-2
Formatting using magic
string values is notorious


383
00:18:06.553 --> 00:18:09.423 line:-2 align:center
for creating pitfalls,
where the format looks correct


384
00:18:09.456 --> 00:18:12.326 line:-2 align:center
under normal circumstances
but produces entirely


385
00:18:12,359 --> 00:18:16,830 line:-2
the wrong value in edge cases,
like at the end of the year.


386
00:18:16.864 --> 00:18:19.299 line:-2 align:center
Here again is
our default format.


387
00:18:19.333 --> 00:18:20.868 line:-2 align:center
This is a short version
of asking


388
00:18:20,901 --> 00:18:24,371 line:-2
for the date and time style,
like this.


389
00:18:24.404 --> 00:18:27.074 line:-2 align:center
For both the no-argument
and simple style versions,


390
00:18:27,107 --> 00:18:29,376 line:-2
we pick a default format
for you.


391
00:18:29.409 --> 00:18:31.945 line:-2 align:center
However, if you want
to really customize the date,


392
00:18:31,979 --> 00:18:36,550 line:-2
you just go from here and add
the fields you care about.


393
00:18:36.583 --> 00:18:38.952 line:-2 align:center
In this example,
I build up a format


394
00:18:38.986 --> 00:18:41.688 line:-2 align:center
by appending fields
to the style.


395
00:18:41,722 --> 00:18:45,092 line:-2
I want only the year, day,
and month.


396
00:18:45.125 --> 00:18:47.661 line:-2 align:center
Other possibilities
include hours, minutes,


397
00:18:47.694 --> 00:18:49.696 line:-1 align:center
seconds, and so on.


398
00:18:49.730 --> 00:18:52.132 line:-2 align:center
The output format
will automatically adjust


399
00:18:52.165 --> 00:18:55.202 line:-1 align:center
according to the user’s locale.


400
00:18:55.235 --> 00:18:57.905 line:-2 align:center
These fields are
also configurable.


401
00:18:57.938 --> 00:19:01.008 line:-2 align:center
In this case, I change the month
to the wide format,


402
00:19:01.041 --> 00:19:04.878 line:-2 align:center
which means that the full
month name is printed.


403
00:19:04,912 --> 00:19:08,215 line:-2
Formatting just part of the date
is easy with this API as well.


404
00:19:08,248 --> 00:19:10,751 line:-2
Here I want
to get just the weekday.


405
00:19:10,784 --> 00:19:13,620 line:-2
Dates can be formatted
into different styles, too.


406
00:19:13.654 --> 00:19:20.627 line:-2 align:center
Here I choose to use the ISO 8601
format and iso8601, but only


407
00:19:20,661 --> 00:19:24,231 line:-2
with the year, month, and day,
and separated with a dash.


408
00:19:24,264 --> 00:19:25,566 line:-1
With these examples,


409
00:19:25,599 --> 00:19:28,202 line:-2
the formatting pattern
becomes clear.


410
00:19:28.235 --> 00:19:30.637 line:-2 align:center
We start with the value
we want to format.


411
00:19:30,671 --> 00:19:35,209 line:-2
We call the formatted function
and the argument is the style.


412
00:19:35.242 --> 00:19:38.378 line:-2 align:center
There may be more than one kind
of style for each type.


413
00:19:38,412 --> 00:19:42,883 line:-2
Date, for example,
has both dateTime and iso8601.


414
00:19:42.916 --> 00:19:45.586 line:-2 align:center
The style can be used
in a default configuration


415
00:19:45,619 --> 00:19:47,921 line:-1
or customized.


416
00:19:47.955 --> 00:19:52.059 line:-2 align:center
This formatting API works
by specifying a list of fields,


417
00:19:52.092 --> 00:19:54.795 line:-2 align:center
some of which have
additional options.


418
00:19:54.828 --> 00:19:57.698 line:-2 align:center
The order of the fields
you provide does not matter.


419
00:19:57,731 --> 00:20:01,168 line:-2
Each field just tells
the formatter what values should


420
00:20:01.201 --> 00:20:04.238 line:-2 align:center
be included somewhere
in the final output.


421
00:20:04.271 --> 00:20:07.140 line:-2 align:center
We choose a sensible default
for the shortest versions


422
00:20:07,174 --> 00:20:11,211 line:-2
of the API, those with no
arguments or just a style name.


423
00:20:11.245 --> 00:20:14.281 line:-2 align:center
Once you begin adding fields
to that, the output becomes


424
00:20:14.314 --> 00:20:17.818 line:-2 align:center
customized and reflects
only what you choose to display,


425
00:20:17.851 --> 00:20:22.356 line:-2 align:center
somewhat like placeholder text
in your UI.


426
00:20:22.389 --> 00:20:24.992 line:-2 align:center
There is also a new API
for formatting two dates


427
00:20:25,025 --> 00:20:26,693 line:-1
that are relative to each other.


428
00:20:26.727 --> 00:20:29.429 line:-1 align:center
Here are some examples.


429
00:20:29.463 --> 00:20:32.466 line:-2 align:center
First, formatting two dates
in a range.


430
00:20:32.499 --> 00:20:35.469 line:-2 align:center
You can just use
the regular Swift range syntax


431
00:20:35.502 --> 00:20:38.238 line:-1 align:center
with two dates.


432
00:20:38.272 --> 00:20:40.974 line:-2 align:center
Formatting ranges allows
configuration of showing


433
00:20:41,008 --> 00:20:45,379 line:-2
the date and time, just
as we did with a single date.


434
00:20:45.412 --> 00:20:50.450 line:-2 align:center
You can format this range
as a duration or as components


435
00:20:50.484 --> 00:20:53.287 line:-2 align:center
or a single date relative
to right now.


436
00:20:53,320 --> 00:20:55,155 line:-2
Another new feature
in formatting


437
00:20:55.189 --> 00:20:56.957 line:-1 align:center
is attributed output.


438
00:20:56,990 --> 00:20:59,459 line:-2
This allows you to find
the location a formatter


439
00:20:59,493 --> 00:21:02,296 line:-2
put a particular part
of a formatted value


440
00:21:02,329 --> 00:21:05,966 line:-2
after it is done rearranging it
to fit the user’s preferences.


441
00:21:05.999 --> 00:21:09.603 line:-2 align:center
This, of course, uses
our new struct AttributedString.


442
00:21:09,636 --> 00:21:12,172 line:-2
Applying styling
to formatted output shows up


443
00:21:12,206 --> 00:21:13,740 line:-1
in all kinds of places.


444
00:21:13.774 --> 00:21:15.809 line:-2 align:center
On watchOS,
many of the complications


445
00:21:15,843 --> 00:21:17,678 line:-1
are formatted strings.


446
00:21:17.711 --> 00:21:19.980 line:-2 align:center
Since Apple Watch is
such a personal device,


447
00:21:20.013 --> 00:21:23.183 line:-2 align:center
it’s important to take into
account the user’s preferences,


448
00:21:23.217 --> 00:21:25.419 line:-2 align:center
but it’s also a place
where we want to apply


449
00:21:25.452 --> 00:21:27.221 line:-2 align:center
a certain kind of
design language,


450
00:21:27,254 --> 00:21:30,824 line:-2
like giving part of a date
a color of the user’s choosing.


451
00:21:30.858 --> 00:21:33.994 line:-2 align:center
Setting this up is actually
quite a lot of fun in SwiftUI.


452
00:21:34.027 --> 00:21:36.797 line:-2 align:center
Let’s look at it together
in a demo.


453
00:21:36.830 --> 00:21:40.067 line:-2 align:center
Here I have the starting point
for my Caffé companion app,


454
00:21:40,100 --> 00:21:42,603 line:-2
which shows
when your next free coffee is.


455
00:21:42.636 --> 00:21:43.904 line:-1 align:center
I’ve got a SwiftUI view


456
00:21:43,937 --> 00:21:48,242 line:-2
which just shows
a formatted date.


457
00:21:48,275 --> 00:21:51,411 line:-1
I set the locale on the format


458
00:21:51,445 --> 00:21:56,884 line:-2
so I can control it
with my SwiftUI preview here.


459
00:21:56.917 --> 00:21:58.452 line:-1 align:center
It’s a pretty good start,


460
00:21:58,485 --> 00:22:02,322 line:-2
but I'd like to customize it
a bit more.


461
00:22:02,356 --> 00:22:05,092 line:-2
Let’s begin by making this
a little more specific


462
00:22:05.125 --> 00:22:06.326 line:-1 align:center
to my app.


463
00:22:06.360 --> 00:22:09.830 line:-1 align:center
I only care about the minute,


464
00:22:09.863 --> 00:22:15.102 line:-1 align:center
the hour, and the weekday.


465
00:22:15,135 --> 00:22:19,973 line:-2
OK, looking pretty good.
Now let’s add a splash of color.


466
00:22:20.007 --> 00:22:23.177 line:-2 align:center
First, we’ll change the return
type to AttributedString


467
00:22:23,210 --> 00:22:25,512 line:-2
and ask
for an attributed output.


468
00:22:33.287 --> 00:22:35.989 line:-2 align:center
Next, we’ll use
an attribute container.


469
00:22:36,023 --> 00:22:38,358 line:-2
These can hold attributes
without being attached


470
00:22:38.392 --> 00:22:40.928 line:-2 align:center
to any particular
characters in a string.


471
00:22:40,961 --> 00:22:43,096 line:-2
We’re going to create one
for the weekday attribute


472
00:22:43.130 --> 00:22:45.999 line:-2 align:center
that date formats
put on their output.


473
00:22:46.033 --> 00:22:47.835 line:-2 align:center
It’s set
on the range of the string


474
00:22:47,868 --> 00:22:49,603 line:-1
that contains the weekday.


475
00:22:52,806 --> 00:22:54,641 line:-1
Next, we’ll make a container


476
00:22:54,675 --> 00:22:57,711 line:-2
for the color attribute
we want to set.


477
00:23:00.414 --> 00:23:03.350 line:-2 align:center
And finally, we’ll use
an attributed string function


478
00:23:03.383 --> 00:23:05.352 line:-2 align:center
to replace
the attributes matching those


479
00:23:05.385 --> 00:23:07.521 line:-2 align:center
in the first container
with the values


480
00:23:07.554 --> 00:23:10.824 line:-2 align:center
in the second one
on our attributed string.


481
00:23:13.493 --> 00:23:16.763 line:-2 align:center
Because AttributedString
is a value type and replacing is


482
00:23:16,797 --> 00:23:21,401 line:-2
a mutating function, we need
to change our “let” to a “var.”


483
00:23:24,771 --> 00:23:26,073 line:-1
Looks great.


484
00:23:26.106 --> 00:23:28.942 line:-2 align:center
Even better,
it works for all locales.


485
00:23:28.976 --> 00:23:32.479 line:-2 align:center
Let’s add a few more
to our preview to double check.


486
00:23:37.284 --> 00:23:38.986 line:-2 align:center
You can
see here that the weekday


487
00:23:39.019 --> 00:23:41.822 line:-2 align:center
is orange no matter where
it is in the formatted date


488
00:23:41,855 --> 00:23:43,624 line:-1
for these locales.


489
00:23:43.657 --> 00:23:46.727 line:-2 align:center
Let’s keep learning about even
more new formatter APIs.


490
00:23:46,760 --> 00:23:49,730 line:-2
Now that we’ve seen how
to turn dates into strings,


491
00:23:49.763 --> 00:23:53.000 line:-2 align:center
let’s talk about how
to strings into dates.


492
00:23:53,033 --> 00:23:57,871 line:-2
Date now has an initializer
that takes a strategy argument.


493
00:23:57.905 --> 00:24:00.174 line:-2 align:center
The strategy is used
to tell the parser


494
00:24:00,207 --> 00:24:02,676 line:-2
what fields
to expect in the input.


495
00:24:02.709 --> 00:24:06.647 line:-2 align:center
For dates, the format is
also a kind of strategy.


496
00:24:06,680 --> 00:24:08,448 line:-2
That’s useful
for round-tripping dates,


497
00:24:08,482 --> 00:24:11,151 line:-2
like in a text field
that both displays output


498
00:24:11.185 --> 00:24:13.987 line:-2 align:center
and allows the user
to type in a new date.


499
00:24:14,021 --> 00:24:16,356 line:-2
Here is an example
of a round trip.


500
00:24:16,390 --> 00:24:18,725 line:-2
You’ll notice
that the parsing can throw.


501
00:24:18,759 --> 00:24:23,730 line:-2
This is because, depending
on the input, parsing can fail.


502
00:24:23.764 --> 00:24:27.901 line:-2 align:center
Some strategies have more
advanced options for parsing.


503
00:24:27,935 --> 00:24:30,170 line:-1
Here, we parse a fixed format,


504
00:24:30,204 --> 00:24:31,939 line:-2
which is useful
when the date format


505
00:24:31,972 --> 00:24:34,341 line:-2
is something received
from a server.


506
00:24:34.374 --> 00:24:37.811 line:-2 align:center
To use it, initialize a strategy
with a format string.


507
00:24:37,845 --> 00:24:40,080 line:-2
Instead of using magic
string values, though,


508
00:24:40.113 --> 00:24:42.449 line:-1 align:center
we use string interpolation.


509
00:24:42.482 --> 00:24:48.021 line:-2 align:center
In this case, we expect a string
of the format year-month-day.


510
00:24:48,055 --> 00:24:51,425 line:-2
Each interpolation is
clearly identified by field,


511
00:24:51,458 --> 00:24:55,562 line:-2
and each specifies exactly
what format to expect.


512
00:24:55,596 --> 00:24:57,865 line:-2
One really
nice thing about this is


513
00:24:57,898 --> 00:24:59,633 line:-1
the autocomplete experience.


514
00:24:59,666 --> 00:25:02,069 line:-2
If I want
to use a different day format,


515
00:25:02,102 --> 00:25:04,671 line:-2
autocomplete shows me
the valid options


516
00:25:04,705 --> 00:25:07,875 line:-2
along with documentation
about what each means.


517
00:25:07,908 --> 00:25:10,711 line:-2
No, more guessing how many Y
characters you should use


518
00:25:10,744 --> 00:25:12,112 line:-1
to parse a year.


519
00:25:12.145 --> 00:25:13.914 line:-1 align:center
Let’s move on to numbers.


520
00:25:13.947 --> 00:25:16.717 line:-2 align:center
Number formatting is
about converting an integer


521
00:25:16,750 --> 00:25:19,987 line:-2
or floating point value
into something a human can read.


522
00:25:20,020 --> 00:25:22,689 line:-2
Like all formatting, it takes
into account preferences


523
00:25:22,723 --> 00:25:24,825 line:-2
on how numbers should
be displayed.


524
00:25:24,858 --> 00:25:27,628 line:-2
This includes everything
from the kind of digit used


525
00:25:27,661 --> 00:25:30,397 line:-2
to what character is used
to group the digits.


526
00:25:30,430 --> 00:25:33,567 line:-2
As with date formatting,
getting great output is easy


527
00:25:33,600 --> 00:25:37,004 line:-2
with no additional parameters
required.


528
00:25:37.037 --> 00:25:40.607 line:-2 align:center
There are many supported kinds
of options and outputs.


529
00:25:40.641 --> 00:25:43.043 line:-1 align:center
Here we show percentage,


530
00:25:43.076 --> 00:25:47.214 line:-2 align:center
scientific notation,
and currency.


531
00:25:47.247 --> 00:25:50.284 line:-2 align:center
Finally, let’s put
a few formats together.


532
00:25:50.317 --> 00:25:54.421 line:-2 align:center
List formatting is now
just formatting an array.


533
00:25:54.454 --> 00:25:57.524 line:-2 align:center
This member style argument
specifies the format style


534
00:25:57,558 --> 00:25:59,393 line:-1
of each element in the array.


535
00:25:59,426 --> 00:26:02,596 line:-2
These are numbers,
so I’d like to use a percentage.


536
00:26:02,629 --> 00:26:05,632 line:-2
The output is correct
for every user’s locale.


537
00:26:05,666 --> 00:26:08,769 line:-2
So far we’ve focused on
formatting the values directly.


538
00:26:08.802 --> 00:26:13.173 line:-2 align:center
SwiftUI also supports attaching
a format style to a TextField.


539
00:26:13.207 --> 00:26:16.143 line:-2 align:center
Since format styles have
type information about the kinds


540
00:26:16,176 --> 00:26:18,946 line:-2
of values they format,
we can use a readable


541
00:26:18,979 --> 00:26:22,950 line:-2
but safe syntax for the tip
percentage on my receipt here.


542
00:26:22,983 --> 00:26:25,118 line:-2
Let’s look again
at our Caffé app


543
00:26:25.152 --> 00:26:28.622 line:-2 align:center
and see just how many places
formatting shows up.


544
00:26:28.655 --> 00:26:31.491 line:-2 align:center
We use a list format
for the ingredients.


545
00:26:31.525 --> 00:26:34.494 line:-2 align:center
We use a currency format
for the prices.


546
00:26:34.528 --> 00:26:36.630 line:-2 align:center
We use a number format
for the quantity


547
00:26:36.663 --> 00:26:39.466 line:-2 align:center
and also to localize the count
in the order button.


548
00:26:39,499 --> 00:26:41,168 line:-2
We can’t forget
about the date format


549
00:26:41.201 --> 00:26:43.136 line:-2 align:center
you always see
in the corner up here.


550
00:26:43,170 --> 00:26:46,340 line:-2
You’ll find formatted output all
over the place, and we think


551
00:26:46,373 --> 00:26:50,310 line:-2
this new API will make it easy,
even fun, in your app as well.


552
00:26:50.344 --> 00:26:52.279 line:-2 align:center
There are a lot more
resources available


553
00:26:52.312 --> 00:26:54.681 line:-2 align:center
to help with localized
strings and formatters.


554
00:26:54,715 --> 00:26:56,750 line:-2
We have two more sessions
on this topic,


555
00:26:56,783 --> 00:26:58,619 line:-1
“Localize your SwiftUI App”


556
00:26:58,652 --> 00:27:02,155 line:-2
and “Streamline
your localized strings.”


557
00:27:02.189 --> 00:27:04.591 line:-2 align:center
Next, let’s talk
about a new feature called


558
00:27:04,625 --> 00:27:07,194 line:-1
automatic grammar agreement.


559
00:27:07,227 --> 00:27:09,930 line:-2
Localizers in languages
like Spanish have been limited


560
00:27:09.963 --> 00:27:12.733 line:-2 align:center
in their ability
to express natural translations,


561
00:27:12.766 --> 00:27:15.569 line:-2 align:center
sometimes leading
to awkward dialog.


562
00:27:15,602 --> 00:27:17,738 line:-2
These languages require
transformations


563
00:27:17,771 --> 00:27:20,507 line:-2
to achieve gender
and pluralization agreement


564
00:27:20,541 --> 00:27:22,509 line:-2
between different parts
of speech


565
00:27:22.543 --> 00:27:24.545 line:-2 align:center
and sometimes even
require knowledge


566
00:27:24,578 --> 00:27:27,047 line:-2
of the user’s preferred term
of address.


567
00:27:27,080 --> 00:27:29,716 line:-2
English has this feature too,
with nouns


568
00:27:29.750 --> 00:27:33.253 line:-2 align:center
that have different forms
for singular and plural.


569
00:27:33.287 --> 00:27:35.222 line:-2 align:center
I threw out a lot
of language jargon there,


570
00:27:35,255 --> 00:27:37,624 line:-1
so let’s go through an example.


571
00:27:37.658 --> 00:27:40.460 line:-2 align:center
In my Caffé app,
I can pick a food item,


572
00:27:40,494 --> 00:27:42,796 line:-1
a size, and a quantity.


573
00:27:42,829 --> 00:27:46,600 line:-1
I choose 1 small salad.


574
00:27:46.633 --> 00:27:48.936 line:-2 align:center
Now my friend says
she will join me,


575
00:27:48.969 --> 00:27:51.905 line:-1 align:center
so I increase the count to 2.


576
00:27:51.939 --> 00:27:56.643 line:-2 align:center
In English, the word “salad” has
to change to match the number 2.


577
00:27:56.677 --> 00:27:58.779 line:-1 align:center
This is called agreement.


578
00:27:58.812 --> 00:28:00.681 line:-1 align:center
All that means is that the words


579
00:28:00,714 --> 00:28:03,283 line:-2
in this sentence have
to match each other.


580
00:28:03.317 --> 00:28:05.986 line:-2 align:center
In English, fixing up words
due to pluralization


581
00:28:06,019 --> 00:28:07,754 line:-1
is a common kind of agreement.


582
00:28:07,788 --> 00:28:10,824 line:-2
Now let’s switch our app
to Spanish


583
00:28:10,858 --> 00:28:16,830 line:-2
and order 1 ensalada pequeña,
or 1 small salad.


584
00:28:16.864 --> 00:28:19.466 line:-2 align:center
When I order for my friend,
this order button needs


585
00:28:19,499 --> 00:28:23,604 line:-2
the same pluralization
as in English but with a twist.


586
00:28:23.637 --> 00:28:27.774 line:-2 align:center
In Spanish, both the adjective,
pequeña, and the noun,


587
00:28:27.808 --> 00:28:31.311 line:-2 align:center
ensalada, have to agree
with the count, dos.


588
00:28:31,345 --> 00:28:33,914 line:-1
So instead of ensalada pequeña,


589
00:28:33,947 --> 00:28:37,117 line:-2
the button says
ensaladas pequeñas.


590
00:28:37,150 --> 00:28:40,687 line:-1
Next, I move on to drinks.


591
00:28:40.721 --> 00:28:43.790 line:-2 align:center
For this sentence,
the button not only needs


592
00:28:43.824 --> 00:28:46.360 line:-2 align:center
correct pluralization
but also agreement


593
00:28:46.393 --> 00:28:49.796 line:-2 align:center
in the grammatical gender
of these words.


594
00:28:49,830 --> 00:28:52,766 line:-1
Juice, jugo, is masculine.


595
00:28:52.799 --> 00:28:56.236 line:-2 align:center
The adjective pequeño
has to match as well.


596
00:28:56,270 --> 00:28:59,206 line:-2
In order to localize text
like this correctly,


597
00:28:59,239 --> 00:29:02,176 line:-2
we end up
with a combinatorial explosion.


598
00:29:02,209 --> 00:29:05,546 line:-2
A different localized string
is needed for each combination


599
00:29:05,579 --> 00:29:07,881 line:-1
of food, size, and count.


600
00:29:07,915 --> 00:29:10,717 line:-2
In code, it often ends up
looking like this,


601
00:29:10,751 --> 00:29:12,953 line:-2
where we need
to switch over each item,


602
00:29:12,986 --> 00:29:15,689 line:-2
then switch over each size,
and so on.


603
00:29:15.722 --> 00:29:19.059 line:-2 align:center
There is also a stringsdict
file, which can pluralize each


604
00:29:19,092 --> 00:29:21,962 line:-2
of these strings correctly
for counts.


605
00:29:21.995 --> 00:29:24.932 line:-2 align:center
Now, by leveraging the same
technology that powers


606
00:29:24,965 --> 00:29:28,302 line:-2
suggestions in keyboards,
we’ve created a new API


607
00:29:28,335 --> 00:29:31,605 line:-2
that can easily handle all
of these cases and more.


608
00:29:31,638 --> 00:29:35,175 line:-2
We call this feature
automatic grammar agreement,


609
00:29:35,209 --> 00:29:37,578 line:-2
because the system
automatically fixes up


610
00:29:37,611 --> 00:29:41,215 line:-2
localized strings so
that they have correct grammar.


611
00:29:41,248 --> 00:29:43,717 line:-2
Now the code becomes
far simpler.


612
00:29:43.750 --> 00:29:48.355 line:-2 align:center
You can combine the quantity,
size, and food in one string.


613
00:29:48.388 --> 00:29:50.858 line:-2 align:center
Automatic grammar agreement
will fix up the string


614
00:29:50.891 --> 00:29:53.360 line:-2 align:center
for you using a process
called inflection.


615
00:29:53,393 --> 00:29:54,895 line:-1
Let’s break it down.


616
00:29:54.928 --> 00:29:57.364 line:-2 align:center
In order to inflect,
we need to know which part


617
00:29:57,397 --> 00:29:59,666 line:-2
of the string needs
to be fixed up.


618
00:29:59,700 --> 00:30:02,336 line:-2
Luckily, we have a type
in Swift that can do that,


619
00:30:02,369 --> 00:30:05,506 line:-2
AttributedString, and a custom
attribute in Markdown.


620
00:30:05,539 --> 00:30:08,909 line:-2
In this string, I use
that syntax to wrap the food,


621
00:30:08,942 --> 00:30:12,412 line:-2
size, and count
with our inflect attribute.


622
00:30:12,446 --> 00:30:15,048 line:-2
The value of the attribute
is true.


623
00:30:15.082 --> 00:30:17.618 line:-2 align:center
When we export
this project’s localizations,


624
00:30:17,651 --> 00:30:20,821 line:-2
we'll get a strings file that
contains our annotated string


625
00:30:20.854 --> 00:30:23.891 line:-2 align:center
as well as other localized
strings in our source code,


626
00:30:23.924 --> 00:30:28.161 line:-2 align:center
like the names of the foods
and sizes.


627
00:30:28.195 --> 00:30:30.964 line:-2 align:center
Here are the strings
for Latin American Spanish.


628
00:30:30,998 --> 00:30:33,867 line:-2
The localizer has used
the argument reordering syntax


629
00:30:33,901 --> 00:30:36,770 line:-2
%1, %3, %2,
because an adjective


630
00:30:36,803 --> 00:30:40,674 line:-2
like "small" or “large” goes
before the noun in Spanish.


631
00:30:40,707 --> 00:30:42,743 line:-2
They keep
the custom attribute syntax


632
00:30:42.776 --> 00:30:45.112 line:-2 align:center
for inflecting this region
of the string


633
00:30:45,145 --> 00:30:48,148 line:-2
and supply translations
for the foods and sizes.


634
00:30:48,182 --> 00:30:50,050 line:-2
The automatic grammar
engine takes care


635
00:30:50,083 --> 00:30:51,451 line:-1
of fixing up the rest.


636
00:30:51,485 --> 00:30:53,620 line:-2
Some languages feature
agreement not only


637
00:30:53,654 --> 00:30:56,156 line:-2
between words
in the localized text itself


638
00:30:56.190 --> 00:30:59.193 line:-2 align:center
but between that text
and the person reading it.


639
00:30:59,226 --> 00:31:02,229 line:-2
Automatic grammar agreement
can help with that too.


640
00:31:02.262 --> 00:31:03.997 line:-1 align:center
For example, let’s take a look


641
00:31:04,031 --> 00:31:05,699 line:-2
at this welcome screen
for Notes.


642
00:31:05.732 --> 00:31:08.368 line:-2 align:center
In English,
we say “Welcome to Notes.”


643
00:31:08.402 --> 00:31:11.572 line:-2 align:center
In Spanish, we say “Te damos
la bienvenida a Notas,”


644
00:31:11.605 --> 00:31:14.107 line:-2 align:center
or “We give you our welcome
to Notes.”


645
00:31:14,141 --> 00:31:15,909 line:-2
We would like to have
the same experience


646
00:31:15,943 --> 00:31:17,845 line:-1
for Spanish as we do in English.


647
00:31:17.878 --> 00:31:21.348 line:-2 align:center
However, in Spanish,
the word “bienvenido” must


648
00:31:21,381 --> 00:31:24,251 line:-2
match with the user’s
preferred term of address.


649
00:31:24,284 --> 00:31:26,620 line:-2
This term could be one
of several choices,


650
00:31:26,653 --> 00:31:29,256 line:-2
and that choice
changes the text.


651
00:31:29.289 --> 00:31:31.258 line:-2 align:center
Using the correct term
of address results


652
00:31:31,291 --> 00:31:34,228 line:-2
in a more personal
and inclusive experience.


653
00:31:34.261 --> 00:31:37.297 line:-2 align:center
In this year’s releases, we’ve
made it possible for people


654
00:31:37.331 --> 00:31:40.367 line:-2 align:center
who use Spanish to specify
their term of address.


655
00:31:40,400 --> 00:31:42,102 line:-2
In the Language & Region
settings,


656
00:31:42.135 --> 00:31:44.838 line:-2 align:center
there is a new Term
of Address option.


657
00:31:44.872 --> 00:31:47.207 line:-2 align:center
When you choose it,
you can pick your preference


658
00:31:47.241 --> 00:31:50.978 line:-2 align:center
and also choose to share it
with all apps.


659
00:31:51,011 --> 00:31:53,313 line:-2
Here, you see the new
welcome screen in Notes


660
00:31:53,347 --> 00:31:55,082 line:-1
for a feminine term of address.


661
00:31:55,115 --> 00:31:57,818 line:-2
And here it is
for a masculine term of address.


662
00:31:57.851 --> 00:32:01.054 line:-2 align:center
If we do not know or the user
prefers not to specify,


663
00:32:01,088 --> 00:32:03,590 line:-2
we keep our original string
as an alternative.


664
00:32:03,624 --> 00:32:06,760 line:-2
The same inflection attribute
we saw earlier is also used


665
00:32:06,793 --> 00:32:09,496 line:-2
in localized strings
which refer to the user.


666
00:32:09,530 --> 00:32:11,832 line:-2
In our “welcome to” case,
we apply


667
00:32:11,865 --> 00:32:14,368 line:-2
the inflection attribute
to the word bienvenido.


668
00:32:14.401 --> 00:32:17.304 line:-2 align:center
The English string does
not need to change.


669
00:32:17,337 --> 00:32:19,907 line:-2
I can also
add an inflection alternative,


670
00:32:19.940 --> 00:32:22.910 line:-2 align:center
which is a replacement string
the engine will use if it has no


671
00:32:22.943 --> 00:32:25.946 line:-2 align:center
information on what the user’s
preferences are.


672
00:32:25,979 --> 00:32:27,781 line:-2
This year,
we support automatic agreement


673
00:32:27.814 --> 00:32:29.550 line:-1 align:center
for Spanish and English.


674
00:32:29,583 --> 00:32:32,352 line:-2
We’ve adopted it in several
places across the OS,


675
00:32:32.386 --> 00:32:34.354 line:-2 align:center
like the welcome screen
in Notes.


676
00:32:34,388 --> 00:32:36,657 line:-2
You can adopt it
in your apps too.


677
00:32:36,690 --> 00:32:39,560 line:-2
The code changes required
are mostly just deleting a lot


678
00:32:39,593 --> 00:32:41,428 line:-2
of logic
to pick different strings.


679
00:32:41,461 --> 00:32:44,064 line:-2
The instructions
on what to inflect are part


680
00:32:44,097 --> 00:32:47,901 line:-2
of the localized string itself,
allowing localizers more control


681
00:32:47,935 --> 00:32:50,470 line:-2
over how the string appears
in their language.


682
00:32:50,504 --> 00:32:52,806 line:-2
Let’s take a look
at automatic grammar agreement


683
00:32:52,840 --> 00:32:54,908 line:-1
in action for our Caffé app.


684
00:32:54.942 --> 00:32:57.911 line:-2 align:center
Let’s go through the Caffé app
running in English.


685
00:32:57.945 --> 00:33:01.982 line:-2 align:center
I’ll start by adding some pizza
to the order.


686
00:33:02,015 --> 00:33:05,853 line:-2
I think I’ll have a large one.
And just 1.


687
00:33:05,886 --> 00:33:08,255 line:-2
Notice how the text
on the button has changed


688
00:33:08.288 --> 00:33:10.958 line:-2 align:center
from 0 large pizzas
to 1 large pizza.


689
00:33:10,991 --> 00:33:12,626 line:-1
That was done automatically.


690
00:33:12.659 --> 00:33:16.029 line:-2 align:center
If I pick 2,
it fixes it up again.


691
00:33:16.063 --> 00:33:19.433 line:-1 align:center
I’ll just have one.


692
00:33:19.466 --> 00:33:20.667 line:-1 align:center
At the bottom of this screen,


693
00:33:20,701 --> 00:33:23,871 line:-2
the order button has changed
to say 1 item.


694
00:33:23.904 --> 00:33:27.574 line:-1 align:center
How about something to drink?


695
00:33:27,608 --> 00:33:31,645 line:-2
Small is fine,
and just 1 of these.


696
00:33:31,678 --> 00:33:34,414 line:-2
Notice how the button has
changed to say “items”


697
00:33:34,448 --> 00:33:35,482 line:-1
instead of “item”?


698
00:33:35,516 --> 00:33:37,851 line:-2
That string
was changed automatically.


699
00:33:37.885 --> 00:33:41.555 line:-1 align:center
Let’s check out.


700
00:33:41.588 --> 00:33:43.023 line:-1 align:center
Here is our receipt.


701
00:33:43,056 --> 00:33:46,927 line:-2
It lists our pizza and juice,
along with formatted prices.


702
00:33:46,960 --> 00:33:49,129 line:-2
At the bottom is
our attributed string,


703
00:33:49,162 --> 00:33:51,632 line:-2
with its custom fonts
and link to the website.


704
00:33:51,665 --> 00:33:54,134 line:-2
Let’s go back to Xcode
and take a look at the source.


705
00:33:54.168 --> 00:33:56.370 line:-2 align:center
I’ll start
in the food details view.


706
00:34:01,575 --> 00:34:04,444 line:-2
This is the view that shows
the size selection screen.


707
00:34:04,478 --> 00:34:06,079 line:-1
Let’s add a new size


708
00:34:06.113 --> 00:34:08.382 line:-2 align:center
so that we can
see how that only requires us


709
00:34:08,415 --> 00:34:11,051 line:-2
to add one localized string
for Spanish instead


710
00:34:11.084 --> 00:34:15.222 line:-2 align:center
of one for each kind of food,
each size, and each count.


711
00:34:15.255 --> 00:34:17.291 line:-1 align:center
This line shows the list.


712
00:34:17.324 --> 00:34:19.159 line:-2 align:center
The list comes
from our model object.


713
00:34:19,193 --> 00:34:21,929 line:-1
Let’s go there.


714
00:34:24,498 --> 00:34:27,234 line:-2
The size enum already
has small and large.


715
00:34:27.267 --> 00:34:28.802 line:-1 align:center
I’m going to add a new size


716
00:34:28,836 --> 00:34:31,471 line:-2
for our hungriest customers,
called “huge.”


717
00:34:31,505 --> 00:34:35,075 line:-2
To do that, I’ll add a new case,
along with a localized string.


718
00:34:38.278 --> 00:34:41.215 line:-2 align:center
Now I just need to add prices
for the huge size.


719
00:34:41.248 --> 00:34:44.885 line:-2 align:center
For this demo, I’ve just
put them in the initializers.


720
00:34:44,918 --> 00:34:47,855 line:-2
Now I just need to add prices
for the huge size.


721
00:34:47.888 --> 00:34:51.291 line:-2 align:center
For this demo, I’ve just
put them in our initializers.


722
00:34:57.631 --> 00:35:00.167 line:-1 align:center
Let’s check out our view again.


723
00:35:03,170 --> 00:35:06,139 line:-2
Here in the preview
is our new size.


724
00:35:06.173 --> 00:35:08.642 line:-2 align:center
Our source already contains
an English string.


725
00:35:08.675 --> 00:35:10.544 line:-1 align:center
I just need a Spanish one now.


726
00:35:10,577 --> 00:35:12,913 line:-2
To generate the new strings,
I’ll use the compiler


727
00:35:12,946 --> 00:35:15,115 line:-2
to find the new localized string
for “huge.”


728
00:35:15.148 --> 00:35:20.487 line:-2 align:center
To do that, I choose
Product > Export Localizations,


729
00:35:20,521 --> 00:35:22,923 line:-1
and save the Spanish strings.


730
00:35:24,892 --> 00:35:28,495 line:-2
Now let’s add a translation
for Spanish.


731
00:35:34,034 --> 00:35:38,672 line:-1
I can filter for our new string


732
00:35:38.705 --> 00:35:41.808 line:-1 align:center
and type in our Spanish word.


733
00:35:45.579 --> 00:35:47.648 line:-2 align:center
Next, I import
these localizations


734
00:35:47,681 --> 00:35:50,350 line:-1
to put them into my app.


735
00:35:57,724 --> 00:36:01,094 line:-2
Now I’ll run our app again
but in Spanish.


736
00:36:01.128 --> 00:36:07.100 line:-2 align:center
To do that, I choose
Product > Scheme > Edit Scheme.


737
00:36:08.035 --> 00:36:10.137 line:-2 align:center
In the Options,
I can pick the language


738
00:36:10,170 --> 00:36:12,206 line:-1
I want to test in.


739
00:36:17.044 --> 00:36:20.180 line:-1 align:center
And run.


740
00:36:20,214 --> 00:36:21,481 line:-1
You can tell from our header


741
00:36:21,515 --> 00:36:23,116 line:-2
that we're now running
in Spanish.


742
00:36:23,150 --> 00:36:27,454 line:-2
Let’s make another order,
starting with salad.


743
00:36:27.487 --> 00:36:32.426 line:-2 align:center
Notice as I change the quantity,
the order button is fixed up.


744
00:36:32.459 --> 00:36:37.698 line:-2 align:center
Our new huge size is correctly
pluralized for 2 salads.


745
00:36:37.731 --> 00:36:40.801 line:-2 align:center
Plus, it matches the grammatical
gender for "ensalada,"


746
00:36:40,834 --> 00:36:43,370 line:-1
all with just one string.


747
00:36:43,403 --> 00:36:45,672 line:-2
There are a lot
of great new features


748
00:36:45.706 --> 00:36:48.141 line:-2 align:center
in Foundation this year,
and they are ready


749
00:36:48,175 --> 00:36:51,011 line:-2
for you to try
in your apps today.


750
00:36:51,044 --> 00:36:53,180 line:-2
AttributedString provides
a fast,


751
00:36:53.213 --> 00:36:55.983 line:-2 align:center
easy-to-use,
and Swift-first interface


752
00:36:56,016 --> 00:36:59,686 line:-2
for adding key-value pairs
to ranges of a string.


753
00:36:59.720 --> 00:37:01.755 line:-2 align:center
You can use it with SwiftUI
in text


754
00:37:01.788 --> 00:37:05.792 line:-2 align:center
and start using Markdown
in your localized strings.


755
00:37:05,826 --> 00:37:09,096 line:-2
Our new Formatter API
puts the focus on the format,


756
00:37:09,129 --> 00:37:12,599 line:-2
simplifying your code
and improving performance.


757
00:37:12,633 --> 00:37:17,638 line:-2
Use formats in all of the places
you present data in your app.


758
00:37:17.671 --> 00:37:20.174 line:-2 align:center
Finally,
automatic grammar agreement


759
00:37:20,207 --> 00:37:22,776 line:-2
will intelligently
fix up localized strings


760
00:37:22,809 --> 00:37:25,746 line:-2
so that they match
grammatical gender, counts,


761
00:37:25.779 --> 00:37:28.515 line:-2 align:center
and the user’s own term
of address.


762
00:37:28,549 --> 00:37:30,450 line:-2
I hope you’ll love
these new features.


763
00:37:30.484 --> 00:37:32.853 line:-2 align:center
We’re looking forward
to finding them in your apps.


764
00:37:32,886 --> 00:37:34,054 line:-1
Thank you.


765
00:37:34.087 --> 00:37:36.190 line:-1 align:center
[music]

