2
00:00:00.000 --> 00:00:02.135 line:-1 position:50%
[MAC STARTUP CHIME]


3
00:00:02.135 --> 00:00:05.639 line:-1 position:50%
♪ Bass music playing ♪


4
00:00:05,639 --> 00:00:07,107 line:-1
[KEYSTROKES]


5
00:00:07,107 --> 00:00:09,009 line:0 size:2% position:89%
♪


6
00:00:09,009 --> 00:00:11,245 line:-1
Dario Rexin: Hi,
my name is Dario Rexin,


7
00:00:11,245 --> 00:00:14,248 line:-1
and I am an engineer on
the Swift team here at Apple.


8
00:00:14,248 --> 00:00:17,818 line:-1
Today, my colleague Doug and I
will talk about actors in Swift


9
00:00:17,818 --> 00:00:20,187 line:-1
and how they are utilized
to protect mutable state


10
00:00:20,187 --> 00:00:22,923 line:-1
in concurrent
Swift applications.


11
00:00:22.923 --> 00:00:24.691 line:-1 position:50%
One of the fundamentally
hard problems


12
00:00:24.691 --> 00:00:29.129 line:-1 position:50%
with writing concurrent programs
is avoiding data races.


13
00:00:29.129 --> 00:00:31.365 line:-1 position:50%
Data races occur
when two separate threads


14
00:00:31,365 --> 00:00:33,500 line:-1
concurrently access
the same data


15
00:00:33.500 --> 00:00:37.137 line:-1 position:50%
and at least one of those
accesses is a write.


16
00:00:37,137 --> 00:00:39,506 line:-1
Data races are trivial
to construct


17
00:00:39,506 --> 00:00:42,009 line:-1
but are notoriously hard
to debug.


18
00:00:42,009 --> 00:00:44,645 position:50%
Here's a simple counter class
with one operation


19
00:00:44,645 --> 00:00:48,548 line:0
that increments the counter
and returns its new value.


20
00:00:48,548 --> 00:00:50,450 line:0
Let's say we go ahead
and try to increment


21
00:00:50,450 --> 00:00:52,886 position:50%
from two concurrent tasks.


22
00:00:52,886 --> 00:00:54,655 position:50%
This is a bad idea.


23
00:00:54,655 --> 00:00:56,990 line:0
Depending on the timing
of the execution,


24
00:00:56,990 --> 00:01:00,560 position:50%
we might get 1 and then 2,
or 2 and then 1.


25
00:01:00,560 --> 00:01:02,696 line:0
This is expected,
and in both cases,


26
00:01:02,696 --> 00:01:05,499 position:50%
the counter would be left
in a consistent state.


27
00:01:05,499 --> 00:01:07,734 line:0
But because we've introduced
a data race,


28
00:01:07,734 --> 00:01:11,138 position:50%
we could also get 1 and 1
if both tasks read a 0


29
00:01:11,138 --> 00:01:12,472 line:0
and write a 1.


30
00:01:12,472 --> 00:01:15,242 line:0
Or even 2 and 2 if the return
statements happen


31
00:01:15,242 --> 00:01:18,512 line:0
after both increment operations.


32
00:01:18,512 --> 00:01:22,049 line:0
Data races are notoriously hard
to avoid and debug.


33
00:01:22,049 --> 00:01:25,352 position:50%
They require nonlocal reasoning
because the data accesses


34
00:01:25,352 --> 00:01:29,856 line:0
causing the race might be in
different parts of the program.


35
00:01:29,856 --> 00:01:32,826 position:50%
And they are nondeterministic
because the operating system's


36
00:01:32,826 --> 00:01:35,329 position:50%
scheduler might interleave
the concurrent tasks


37
00:01:35,329 --> 00:01:38,999 position:50%
in different ways each time
you run your program.


38
00:01:38,999 --> 00:01:42,336 line:-1
Data races are caused
by shared mutable state.


39
00:01:42,336 --> 00:01:43,937 line:-1
If your data doesn't change


40
00:01:43,937 --> 00:01:46,740 line:-1
or it isn't shared across
multiple concurrent tasks,


41
00:01:46,740 --> 00:01:49,943 line:-1
you can't have
a data race on it.


42
00:01:49,943 --> 00:01:51,712 line:-1
One way to avoid data races


43
00:01:51.712 --> 00:01:53.547 line:-1 position:50%
is to eliminate
shared mutable state


44
00:01:53,547 --> 00:01:56,383 line:-1
by using value semantics.


45
00:01:56.383 --> 00:02:00.387 line:-1 position:50%
With a variable of a value type,
all mutation is local.


46
00:02:00.387 --> 00:02:03.523 line:-1 position:50%
Moreover, "let" properties
of value-semantic types


47
00:02:03,523 --> 00:02:05,192 line:-1
are truly immutable,


48
00:02:05,192 --> 00:02:09,529 line:-1
so it's safe to access them
from different concurrent tasks.


49
00:02:09.529 --> 00:02:12.966 line:-1 position:50%
Swift has been promoting value
semantics since its inception


50
00:02:12,966 --> 00:02:15,802 line:-1
because they make it easier
to reason about our program


51
00:02:15,802 --> 00:02:17,804 line:-1
and those same things
also make them safe


52
00:02:17.804 --> 00:02:20.540 line:-1 position:50%
to use in concurrent programs.


53
00:02:20,540 --> 00:02:24,644 line:-1
In this example, we create
an array with some values.


54
00:02:24,644 --> 00:02:28,582 line:-1
Next, we assign that array
to a second variable.


55
00:02:28.582 --> 00:02:32.753 line:-1 position:50%
Now we append a different value
to each copy of the array.


56
00:02:32.753 --> 00:02:34.888 line:-1 position:50%
When we print both arrays
at the end,


57
00:02:34,888 --> 00:02:37,057 line:-1
we see that both copies
contain the values


58
00:02:37,057 --> 00:02:39,159 line:-1
that the array
was initialized with,


59
00:02:39,159 --> 00:02:41,194 line:-1
but each appended value
is only present


60
00:02:41,194 --> 00:02:44,498 line:-1
in the respective copy
we appended them to.


61
00:02:44,498 --> 00:02:47,034 line:-1
The majority of types
in Swift's standard library


62
00:02:47,034 --> 00:02:50,003 line:-1
have value semantics,
including collection types


63
00:02:50.003 --> 00:02:55.509 line:-1 position:50%
like dictionary,
or as in this example, array.


64
00:02:55.509 --> 00:02:57.677 line:-1 position:50%
Now that we have established
that value semantics


65
00:02:57.677 --> 00:02:59.813 line:-1 position:50%
solve all of our data races,


66
00:02:59,813 --> 00:03:02,082 line:-1
let's go ahead and make
our counter a value type


67
00:03:02,082 --> 00:03:05,452 line:-1
by turning it into a struct.


68
00:03:05,452 --> 00:03:08,188 line:0
We also have to mark the
increment function as mutating,


69
00:03:08,188 --> 00:03:12,426 line:0
so it can modify
the value property.


70
00:03:12,426 --> 00:03:14,795 position:50%
When we are now trying
to modify the counter


71
00:03:14,795 --> 00:03:17,898 position:50%
we will get a compiler error
because the counter is a let,


72
00:03:17,898 --> 00:03:21,501 position:50%
which prevents us
from mutating it.


73
00:03:21,501 --> 00:03:24,805 line:0
Now, it seems very tempting to
just change the counter variable


74
00:03:24,805 --> 00:03:27,941 line:0
to a var to make it mutable.


75
00:03:27,941 --> 00:03:30,510 line:0
But that would leave us,
again, with a race condition


76
00:03:30,510 --> 00:03:31,945 position:50%
because the counter
would be referenced


77
00:03:31,945 --> 00:03:34,414 position:50%
by both concurrent tasks.


78
00:03:34,414 --> 00:03:36,483 line:0
Luckily, the compiler
has us covered


79
00:03:36,483 --> 00:03:41,354 position:50%
and does not allow us
to compile this unsafe code.


80
00:03:41,354 --> 00:03:42,823 line:0
We can instead
assign the counter


81
00:03:42,823 --> 00:03:47,894 line:0
to a local mutable variable
inside each concurrent task.


82
00:03:47,894 --> 00:03:50,297 position:50%
When we execute our example now,


83
00:03:50,297 --> 00:03:54,434 line:0
it will always print 1
for both concurrent tasks.


84
00:03:54,434 --> 00:03:56,703 position:50%
But even though our code
is now race-free,


85
00:03:56,703 --> 00:03:59,506 line:0
the behavior is not
what we want anymore.


86
00:03:59,506 --> 00:04:01,808 line:0
This goes to show
that there are still cases


87
00:04:01,808 --> 00:04:06,713 line:0
where shared mutable state
is required.


88
00:04:06.713 --> 00:04:09.950 line:-1 position:50%
When we have shared mutable
state in a concurrent program,


89
00:04:09,950 --> 00:04:12,018 line:-1
we need some form
of synchronization


90
00:04:12.018 --> 00:04:15.055 line:-1 position:50%
to ensure that concurrent use
of our shared mutable state


91
00:04:15,055 --> 00:04:17,591 line:-1
won't cause data races.


92
00:04:17.591 --> 00:04:19.993 line:-1 position:50%
There are a number of primitives
for synchronization,


93
00:04:19,993 --> 00:04:22,929 line:-1
from low-level tools
like atomics and locks


94
00:04:22,929 --> 00:04:27,334 line:-1
to higher-level constructs
like serial dispatch queues.


95
00:04:27,334 --> 00:04:30,837 line:-1
Each of these primitives
has its various strengths,


96
00:04:30.837 --> 00:04:33.907 line:-1 position:50%
but they all share
the same critical weakness:


97
00:04:33.907 --> 00:04:37.144 line:-1 position:50%
they require careful discipline
to use exactly correctly,


98
00:04:37.144 --> 00:04:38.645 line:-1 position:50%
every single time,


99
00:04:38.645 --> 00:04:40.881 line:-1 position:50%
or we'll end up
with a data race.


100
00:04:40.881 --> 00:04:43.316 line:-1 position:50%
This is where actors come in.


101
00:04:43,316 --> 00:04:44,951 line:-1
Actors are
a synchronization mechanism


102
00:04:44,951 --> 00:04:47,354 line:-1
for shared mutable state.


103
00:04:47,354 --> 00:04:49,122 line:-1
An actor has its own state


104
00:04:49,122 --> 00:04:53,193 line:-1
and that state is isolated
from the rest of the program.


105
00:04:53.193 --> 00:04:55.061 line:-1 position:50%
The only way
to access that state


106
00:04:55.061 --> 00:04:57.230 line:-1 position:50%
is by going through the actor.


107
00:04:57.230 --> 00:04:59.099 line:-1 position:50%
And whenever you go
through the actor,


108
00:04:59,099 --> 00:05:01,201 line:-1
the actor's synchronization
mechanism ensures


109
00:05:01.201 --> 00:05:03.036 line:-1 position:50%
that no other code
is concurrently


110
00:05:03.036 --> 00:05:05.639 line:-1 position:50%
accessing the actor's state.


111
00:05:05,639 --> 00:05:08,074 line:-1
This gives us the same
mutual exclusion property


112
00:05:08,074 --> 00:05:10,310 line:-1
that we get from
manually using locks


113
00:05:10,310 --> 00:05:12,979 line:-1
or serial dispatch queues,
but with actors,


114
00:05:12,979 --> 00:05:16,616 line:-1
it is a fundamental guarantee
provided by Swift.


115
00:05:16,616 --> 00:05:18,818 line:-1
You can't forget to perform
the synchronization,


116
00:05:18.818 --> 00:05:22.222 line:-1 position:50%
because Swift will produce
a compiler error if you try.


117
00:05:22,222 --> 00:05:24,958 line:-1
Actors are a new
kind of type in Swift.


118
00:05:24,958 --> 00:05:26,593 line:-1
They provide
the same capabilities


119
00:05:26.593 --> 00:05:29.196 line:-1 position:50%
as all of the named types
in Swift.


120
00:05:29,196 --> 00:05:32,632 line:-1
They can have properties,
methods, initializers,


121
00:05:32.632 --> 00:05:34.801 line:-1 position:50%
subscripts, and so on.


122
00:05:34.801 --> 00:05:36.536 line:-1 position:50%
They can conform to protocols


123
00:05:36.536 --> 00:05:39.506 line:-1 position:50%
and be augmented
with extensions.


124
00:05:39,506 --> 00:05:41,608 line:-1
Like classes,
they are reference types;


125
00:05:41,608 --> 00:05:45,212 line:-1
because the purpose of actors is
to express shared mutable state.


126
00:05:45.212 --> 00:05:48.315 line:-1 position:50%
In fact, the primary
distinguishing characteristic


127
00:05:48.315 --> 00:05:51.518 line:-1 position:50%
of actor types is that they
isolate their instance data


128
00:05:51,518 --> 00:05:53,086 line:-1
from the rest of the program


129
00:05:53,086 --> 00:05:56,890 line:-1
and ensure synchronized
access to that data.


130
00:05:56.890 --> 00:06:00.760 line:-1 position:50%
All of their special behavior
follows from those core ideas.


131
00:06:00.760 --> 00:06:03.897 line:-1 position:50%
Here, we've defined our counter
as an actor type.


132
00:06:03,897 --> 00:06:05,966 line:-1
We still have the instance
property value


133
00:06:05,966 --> 00:06:07,234 line:-1
for the counter,


134
00:06:07.234 --> 00:06:09.402 line:-1 position:50%
and the increment method
to increment that value


135
00:06:09,402 --> 00:06:11,538 line:-1
and return the new value.


136
00:06:11,538 --> 00:06:14,107 line:-1
The difference is that the actor
will ensure the value


137
00:06:14,107 --> 00:06:16,343 line:-1
isn't accessed concurrently.


138
00:06:16,343 --> 00:06:18,612 line:-1
In this case, that means
the increment method,


139
00:06:18.612 --> 00:06:20.680 line:-1 position:50%
when called,
will run to completion


140
00:06:20.680 --> 00:06:23.984 line:-1 position:50%
without any other code
executing on the actor.


141
00:06:23,984 --> 00:06:27,187 line:-1
That guarantee eliminates
the potential for data races


142
00:06:27.187 --> 00:06:29.356 line:-1 position:50%
on the actor's state.


143
00:06:29,356 --> 00:06:33,526 line:-1
Let's bring back
our data race example.


144
00:06:33,526 --> 00:06:35,262 position:50%
We again have
two concurrent tasks


145
00:06:35,262 --> 00:06:37,931 line:0
attempting to increment
the same counter.


146
00:06:37,931 --> 00:06:40,500 position:50%
The actor's internal
synchronization mechanism


147
00:06:40,500 --> 00:06:43,637 line:0
ensures that one increment
call executes to completion


148
00:06:43,637 --> 00:06:46,339 line:0
before the other can start.


149
00:06:46,339 --> 00:06:49,776 position:50%
So we can get 1 and 2
or 2 and 1


150
00:06:49,776 --> 00:06:52,879 line:0
because both are valid
concurrent executions,


151
00:06:52,879 --> 00:06:55,081 line:0
but we cannot get
the same count twice


152
00:06:55,081 --> 00:06:58,251 line:0
or skip any values because
the internal synchronization


153
00:06:58,251 --> 00:07:01,821 position:50%
of the actor has eliminated
the potential for data races


154
00:07:01,821 --> 00:07:04,357 line:0
on the actor state.


155
00:07:04,357 --> 00:07:05,825 position:50%
Let's consider
what actually happens


156
00:07:05,825 --> 00:07:08,662 line:0
when both concurrent tasks
try to increment the counter


157
00:07:08,662 --> 00:07:11,264 line:0
at the same time.


158
00:07:11,264 --> 00:07:12,532 line:0
One will get there first,


159
00:07:12,532 --> 00:07:14,968 position:50%
and the other
will have to wait its turn.


160
00:07:14,968 --> 00:07:17,070 line:-1
But how can we ensure
that the second task


161
00:07:17,070 --> 00:07:20,140 line:-1
can patiently await
its turn on the actor?


162
00:07:20,140 --> 00:07:22,375 line:-1
Swift has a mechanism for that.


163
00:07:22,375 --> 00:07:24,978 line:-1
Whenever you interact
with an actor from the outside,


164
00:07:24,978 --> 00:07:27,280 line:-1
you do so asynchronously.


165
00:07:27,280 --> 00:07:29,649 line:0
If the actor is busy,
then your code will suspend


166
00:07:29,649 --> 00:07:34,020 line:0
so that the CPU you're running
on can do other useful work.


167
00:07:34,020 --> 00:07:35,755 position:50%
When the actor
becomes free again,


168
00:07:35,755 --> 00:07:38,758 line:0
it will wake up your code --
resuming execution --


169
00:07:38,758 --> 00:07:41,961 position:50%
so the call can run
on the actor.


170
00:07:41,961 --> 00:07:44,331 position:50%
The await keyword
in this example indicates


171
00:07:44,331 --> 00:07:46,166 line:0
that the asynchronous call
to the actor


172
00:07:46,166 --> 00:07:50,203 line:0
might involve such a suspension.


173
00:07:50,203 --> 00:07:52,939 position:50%
Let's stretch our counterexample
just a bit further


174
00:07:52,939 --> 00:07:56,843 position:50%
by adding an unnecessarily slow
reset operation.


175
00:07:56,843 --> 00:07:59,412 line:0
This operation sets the value
back to 0,


176
00:07:59,412 --> 00:08:02,182 line:0
then calls increment
an appropriate number of times


177
00:08:02,182 --> 00:08:05,385 position:50%
to get the counter
to the new value.


178
00:08:05,385 --> 00:08:08,121 position:50%
This resetSlowly method
is defined in an extension


179
00:08:08,121 --> 00:08:12,559 position:50%
of the counter actor type
so it is inside the actor.


180
00:08:12,559 --> 00:08:15,328 position:50%
That means it can directly
access the actor's state,


181
00:08:15,328 --> 00:08:19,699 line:0
which it does to reset
the counter value to 0.


182
00:08:19,699 --> 00:08:23,069 line:0
It can also synchronously
call other methods on the actor,


183
00:08:23,069 --> 00:08:26,406 position:50%
such as in the call
to increment.


184
00:08:26,406 --> 00:08:29,075 position:50%
There's no await required
because we already know


185
00:08:29,075 --> 00:08:31,411 position:50%
we're running on the actor.


186
00:08:31,411 --> 00:08:34,047 position:50%
This is an important
property of actors.


187
00:08:34,047 --> 00:08:36,983 line:0
Synchronous code on the actor
always runs to completion


188
00:08:36,983 --> 00:08:39,486 line:0
without being interrupted.


189
00:08:39,486 --> 00:08:42,455 line:0
So we can reason about
synchronous code sequentially,


190
00:08:42,455 --> 00:08:44,991 position:50%
without needing to consider
the effects of concurrency


191
00:08:44,991 --> 00:08:47,961 line:0
on our actor state.


192
00:08:47.961 --> 00:08:49.796 line:-1 position:50%
We have stressed
that our synchronous code


193
00:08:49,796 --> 00:08:53,533 line:-1
runs uninterrupted, but actors
often interact with each other


194
00:08:53,533 --> 00:08:56,536 line:-1
or with other asynchronous code
in the system.


195
00:08:56,536 --> 00:08:58,938 line:-1
Let's take a few minutes
to talk about asynchronous code


196
00:08:58.938 --> 00:09:00.473 line:-1 position:50%
and actors.


197
00:09:00,473 --> 00:09:02,842 line:-1
But first,
we need a better example.


198
00:09:02,842 --> 00:09:05,678 line:-1
Here we are building
an image downloader actor.


199
00:09:05,678 --> 00:09:07,547 line:-1
It is responsible
for downloading an image


200
00:09:07,547 --> 00:09:09,682 line:-1
from another service.


201
00:09:09,682 --> 00:09:12,185 line:-1
It also stores
downloaded images in a cache


202
00:09:12.185 --> 00:09:16.389 line:-1 position:50%
to avoid downloading
the same image multiple times.


203
00:09:16,389 --> 00:09:18,758 line:-1
The logical flow
is straightforward:


204
00:09:18.758 --> 00:09:21.961 line:-1 position:50%
check the cache,
download the image,


205
00:09:21.961 --> 00:09:26.099 line:-1 position:50%
then record the image
in the cache before returning.


206
00:09:26,099 --> 00:09:27,500 line:-1
Because we are in an actor,


207
00:09:27.500 --> 00:09:30.303 line:-1 position:50%
this code is free
from low-level data races;


208
00:09:30,303 --> 00:09:33,907 line:-1
any number of images can be
downloaded concurrently.


209
00:09:33,907 --> 00:09:36,709 line:-1
The actor's synchronization
mechanisms guarantee


210
00:09:36,709 --> 00:09:38,745 line:-1
that only one task
can execute code


211
00:09:38,745 --> 00:09:41,915 line:-1
that accesses the cache
instance property at a time,


212
00:09:41.915 --> 00:09:45.318 line:-1 position:50%
so there is no way
that the cache can be corrupted.


213
00:09:45,318 --> 00:09:47,287 line:-1
That said,
the await keyword here


214
00:09:47,287 --> 00:09:51,424 line:-1
is communicating something
very important.


215
00:09:51,424 --> 00:09:53,326 line:-1
Whenever an await occurs,


216
00:09:53,326 --> 00:09:57,230 line:-1
it means that the function
can be suspended at this point.


217
00:09:57.230 --> 00:10:00.934 line:-1 position:50%
It gives up its CPU so other
code in the program can execute,


218
00:10:00,934 --> 00:10:04,571 line:-1
which affects
the overall program state.


219
00:10:04.571 --> 00:10:06.506 line:-1 position:50%
At the point where
your function resumes,


220
00:10:06.506 --> 00:10:09.576 line:-1 position:50%
the overall program state
will have changed.


221
00:10:09.576 --> 00:10:12.779 line:-1 position:50%
It is important to ensure that
you haven't made assumptions


222
00:10:12.779 --> 00:10:14.981 line:-1 position:50%
about that state
prior to the await


223
00:10:14.981 --> 00:10:18.651 line:-1 position:50%
that may not hold
after the await.


224
00:10:18.651 --> 00:10:20.687 line:-1 position:50%
Imagine we have
two different concurrent tasks


225
00:10:20.687 --> 00:10:23.790 line:-1 position:50%
trying to fetch the same image
at the same time.


226
00:10:23,790 --> 00:10:26,359 line:-1
The first sees that
there is no cache entry,


227
00:10:26.359 --> 00:10:29.329 line:-1 position:50%
proceeds to start downloading
the image from the server,


228
00:10:29.329 --> 00:10:33.466 line:-1 position:50%
and then gets suspended because
the download will take a while.


229
00:10:33.466 --> 00:10:35.635 line:-1 position:50%
While the first task
is downloading the image,


230
00:10:35.635 --> 00:10:40.139 line:-1 position:50%
a new image might be deployed to
the server under the same URL.


231
00:10:40.139 --> 00:10:42.675 line:-1 position:50%
Now, a second concurrent task
tries to fetch the image


232
00:10:42,675 --> 00:10:44,477 line:-1
under that URL.


233
00:10:44,477 --> 00:10:46,179 line:-1
It also sees no cache entry


234
00:10:46,179 --> 00:10:49,082 line:-1
because the first download
has not finished yet,


235
00:10:49,082 --> 00:10:52,418 line:-1
then starts a second
download of the image.


236
00:10:52,418 --> 00:10:56,456 line:-1
It also gets suspended
while its download completes.


237
00:10:56.456 --> 00:10:58.691 line:-1 position:50%
After a while,
one of the downloads --


238
00:10:58,691 --> 00:11:01,294 line:-1
let's assume it's the first --
will complete


239
00:11:01.294 --> 00:11:04.597 line:-1 position:50%
and its task will resume
execution on the actor.


240
00:11:04,597 --> 00:11:06,065 line:-1
It populates the cache


241
00:11:06,065 --> 00:11:09,569 line:-1
and returns the resulting
image of a cat.


242
00:11:09,569 --> 00:11:12,105 line:-1
Now the second task
has its download complete,


243
00:11:12,105 --> 00:11:13,640 line:-1
so it wakes up.


244
00:11:13.640 --> 00:11:15.475 line:-1 position:50%
It overwrites the same entry
in the cache


245
00:11:15,475 --> 00:11:18,745 line:-1
with the image
of the sad cat that it got.


246
00:11:18.745 --> 00:11:22.015 line:-1 position:50%
So even though the cache was
already populated with an image,


247
00:11:22.015 --> 00:11:25.218 line:-1 position:50%
we now get a different image
for the same URL.


248
00:11:25.218 --> 00:11:27.220 line:-1 position:50%
That's a bit of a surprise.


249
00:11:27,220 --> 00:11:29,489 line:-1
We expected that once
we cache an image,


250
00:11:29.489 --> 00:11:32.292 line:-1 position:50%
we always get that same
image back for the same URL


251
00:11:32.292 --> 00:11:35.028 line:-1 position:50%
so our user interface
remains consistent,


252
00:11:35,028 --> 00:11:38,298 line:-1
at least until we go and
manually clear out of the cache.


253
00:11:38.298 --> 00:11:42.101 line:-1 position:50%
But here, the cached image
changed unexpectedly.


254
00:11:42,101 --> 00:11:44,203 line:-1
We don't have
any low-level data races,


255
00:11:44,203 --> 00:11:46,339 line:-1
but because we carried
assumptions about state


256
00:11:46.339 --> 00:11:47.440 line:-1 position:50%
across an await,


257
00:11:47.440 --> 00:11:49.909 line:-1 position:50%
we ended up with
a potential bug.


258
00:11:49.909 --> 00:11:53.580 line:-1 position:50%
The fix here is to check
our assumptions after the await.


259
00:11:53.580 --> 00:11:56.382 line:-1 position:50%
If there's already an entry
in the cache when we resume,


260
00:11:56,382 --> 00:12:00,153 line:-1
we keep that original version
and throw away the new one.


261
00:12:00,153 --> 00:12:01,254 line:-1
A better solution would be


262
00:12:01,254 --> 00:12:04,157 line:-1
to avoid redundant
downloads entirely.


263
00:12:04.157 --> 00:12:05.658 line:-1 position:50%
We've put that solution
in the code


264
00:12:05.658 --> 00:12:08.461 line:-1 position:50%
associated with this video.


265
00:12:08,461 --> 00:12:10,630 line:-1
Actor reentrancy
prevents deadlocks


266
00:12:10,630 --> 00:12:12,665 line:-1
and guarantees forward progress,


267
00:12:12.665 --> 00:12:14.434 line:-1 position:50%
but it requires you
to check your assumptions


268
00:12:14,434 --> 00:12:16,669 line:-1
across each await.


269
00:12:16,669 --> 00:12:18,671 line:-1
To design well for reentrancy,


270
00:12:18.671 --> 00:12:22.742 line:-1 position:50%
perform mutation of actor state
within synchronous code.


271
00:12:22.742 --> 00:12:25.111 line:-1 position:50%
Ideally, do it within
a synchronous function


272
00:12:25,111 --> 00:12:29,449 line:-1
so all state changes
are well-encapsulated.


273
00:12:29,449 --> 00:12:32,352 line:-1
State changes can involve
temporarily putting our actor


274
00:12:32,352 --> 00:12:34,821 line:-1
into an inconsistent state.


275
00:12:34,821 --> 00:12:38,458 line:-1
Make sure to restore consistency
before an await.


276
00:12:38.458 --> 00:12:41.961 line:-1 position:50%
And remember that await
is a potential suspension point.


277
00:12:41.961 --> 00:12:43.463 line:-1 position:50%
If your code gets suspended,


278
00:12:43,463 --> 00:12:45,431 line:-1
the program and world
will move on


279
00:12:45.431 --> 00:12:47.433 line:-1 position:50%
before your code gets resumed.


280
00:12:47.433 --> 00:12:50.036 line:-1 position:50%
Any assumptions you've made
about global state,


281
00:12:50.036 --> 00:12:53.239 line:-1 position:50%
clocks, timers, or your actor
will need to be checked


282
00:12:53,239 --> 00:12:55,875 line:-1
after the await.


283
00:12:55.875 --> 00:12:57.844 line:-1 position:50%
And now my colleague Doug
will tell you more


284
00:12:57,844 --> 00:13:01,814 line:-1
about actor isolation.
Doug?


285
00:13:01,814 --> 00:13:03,316 line:-1
Doug Gregor: Thanks, Dario.


286
00:13:03,316 --> 00:13:08,621 line:-1
Actor isolation is fundamental
to the behavior of actor types.


287
00:13:08,621 --> 00:13:12,091 line:-1
Dario discussed how
actor isolation is guaranteed


288
00:13:12,091 --> 00:13:13,693 line:-1
by the Swift language model,


289
00:13:13,693 --> 00:13:15,662 line:-1
through asynchronous
interactions


290
00:13:15.662 --> 00:13:17.397 line:-1 position:50%
from outside the actor.


291
00:13:17.397 --> 00:13:20.533 line:-1 position:50%
In this section, we'll talk
about how actor isolation


292
00:13:20,533 --> 00:13:22,835 line:-1
interacts with other
language features,


293
00:13:22.835 --> 00:13:29.175 line:-1 position:50%
including protocol conformances,
closures, and classes.


294
00:13:29.175 --> 00:13:32.679 line:-1 position:50%
Like other types, actors
can conform to protocols


295
00:13:32,679 --> 00:13:36,649 line:-1
so long as they can satisfy the
requirements of the protocol.


296
00:13:36,649 --> 00:13:39,786 line:-1
For example, let's make this
LibraryAccount actor


297
00:13:39,786 --> 00:13:42,388 line:-1
conform to the
Equatable protocol.


298
00:13:42,388 --> 00:13:46,159 line:-1
The static equality method
compares two library accounts


299
00:13:46,159 --> 00:13:48,361 line:-1
based on their ID numbers.


300
00:13:48,361 --> 00:13:51,831 line:-1
Because the method is static,
there is no self instance


301
00:13:51.831 --> 00:13:55.301 line:-1 position:50%
and so it is not
isolated to the actor.


302
00:13:55,301 --> 00:13:58,438 line:-1
Instead, we have two parameters
of actor type,


303
00:13:58,438 --> 00:14:02,175 line:-1
and this static method
is outside of both of them.


304
00:14:02,175 --> 00:14:05,912 line:-1
That's OK because the
implementation is only accessing


305
00:14:05,912 --> 00:14:09,348 line:-1
immutable state on the actor.


306
00:14:09,348 --> 00:14:11,451 line:-1
Let's extend
our example further


307
00:14:11,451 --> 00:14:13,019 line:-1
to make our library
account conform


308
00:14:13.019 --> 00:14:15.121 line:-1 position:50%
to the Hashable protocol.


309
00:14:15,121 --> 00:14:18,591 line:-1
Doing so requires implementing
the hash(into) operation,


310
00:14:18,591 --> 00:14:20,560 line:-1
which we can do like this.


311
00:14:20.560 --> 00:14:23.062 line:-1 position:50%
However, the Swift compiler
will complain


312
00:14:23.062 --> 00:14:26.933 line:-1 position:50%
that this conformance
isn't allowed.


313
00:14:26,933 --> 00:14:28,234 line:-1
What happened?


314
00:14:28.234 --> 00:14:31.137 line:-1 position:50%
Well, conforming to Hashable
this way means that


315
00:14:31,137 --> 00:14:34,741 line:-1
this function could be called
from outside the actor,


316
00:14:34,741 --> 00:14:37,176 line:-1
but hash(into) is not async,


317
00:14:37.176 --> 00:14:41.214 line:-1 position:50%
so there is no way
to maintain actor isolation.


318
00:14:41,214 --> 00:14:46,586 line:-1
To fix this, we can make
this method nonisolated.


319
00:14:46.586 --> 00:14:49.522 line:-1 position:50%
Nonisolated means
that this method is treated


320
00:14:49,522 --> 00:14:51,657 line:-1
as being outside the actor,


321
00:14:51,657 --> 00:14:53,760 line:-1
even though it is,
syntactically,


322
00:14:53.760 --> 00:14:55.695 line:-1 position:50%
described on the actor.


323
00:14:55.695 --> 00:14:59.098 line:-1 position:50%
This means that it can satisfy
the synchronous requirement


324
00:14:59.098 --> 00:15:02.268 line:-1 position:50%
from the Hashable protocol.


325
00:15:02,268 --> 00:15:03,503 line:-1
Because nonisolated methods


326
00:15:03,503 --> 00:15:06,105 line:-1
are treated as being
outside the actor,


327
00:15:06,105 --> 00:15:09,575 line:-1
they cannot reference
mutable state on the actor.


328
00:15:09.575 --> 00:15:10.877 line:-1 position:50%
This method is fine


329
00:15:10.877 --> 00:15:14.113 line:-1 position:50%
because it's referring
to the immutable ID number.


330
00:15:14,113 --> 00:15:18,050 line:-1
If we were to try to hash
based on something else,


331
00:15:18,050 --> 00:15:22,088 line:-1
such as the array of books
on loan, we will get an error


332
00:15:22.088 --> 00:15:25.057 line:-1 position:50%
because access to mutable state
from the outside


333
00:15:25,057 --> 00:15:28,227 line:-1
would permit data races.


334
00:15:28,227 --> 00:15:30,263 line:-1
That's enough
of protocol conformances.


335
00:15:30,263 --> 00:15:33,999 line:-1
Let's talk about closures.


336
00:15:33,999 --> 00:15:35,635 line:-1
Closures are little functions


337
00:15:35.635 --> 00:15:37.804 line:-1 position:50%
that are defined
within one function,


338
00:15:37,804 --> 00:15:39,939 line:-1
that can then be passed
to another function


339
00:15:39,939 --> 00:15:42,308 line:-1
to be called some time later.


340
00:15:42.308 --> 00:15:45.812 line:-1 position:50%
Like functions, a closure
might be actor-isolated


341
00:15:45,812 --> 00:15:48,648 line:-1
or it might be nonisolated.


342
00:15:48,648 --> 00:15:51,017 line:-1
In this example,
we're going to read some


343
00:15:51,017 --> 00:15:52,752 line:-1
from each book
we have on loan


344
00:15:52,752 --> 00:15:55,788 line:-1
and return the total number
of pages we've read.


345
00:15:55.788 --> 00:15:58.191 line:-1 position:50%
The call to reduce
involves a closure


346
00:15:58,191 --> 00:16:00,226 line:-1
that performs the reading.


347
00:16:00,226 --> 00:16:03,963 line:-1
Note that there is no await
in this call to readSome.


348
00:16:03.963 --> 00:16:05.598 line:-1 position:50%
That's because this closure,


349
00:16:05,598 --> 00:16:08,835 line:-1
which is formed within the
actor-isolated function "read",


350
00:16:08,835 --> 00:16:11,370 line:-1
is itself actor-isolated.


351
00:16:11,370 --> 00:16:14,040 line:-1
We know this is safe
because the reduce operation


352
00:16:14,040 --> 00:16:16,442 line:-1
is going to execute
synchronously,


353
00:16:16,442 --> 00:16:19,412 line:-1
and can't escape the closure
out to some other thread


354
00:16:19,412 --> 00:16:22,448 line:-1
where it could cause
concurrent access.


355
00:16:22,448 --> 00:16:25,284 line:-1
Now, let's do something
a little different.


356
00:16:25,284 --> 00:16:27,620 line:-1
I don't have time to read
just now,


357
00:16:27.620 --> 00:16:30.022 line:-1 position:50%
so let's read later.


358
00:16:30,022 --> 00:16:32,925 line:-1
Here, we create a detached task.


359
00:16:32,925 --> 00:16:36,028 line:-1
A detached task executes
the closure concurrently


360
00:16:36.028 --> 00:16:38.931 line:-1 position:50%
with other work
that the actor is doing.


361
00:16:38,931 --> 00:16:41,667 line:-1
Therefore, the closure
cannot be on the actor


362
00:16:41,667 --> 00:16:44,103 line:-1
or we would introduce
data races.


363
00:16:44,103 --> 00:16:47,573 line:-1
So this closure is not
isolated to the actor.


364
00:16:47,573 --> 00:16:49,609 line:-1
When it wants to call
the read method,


365
00:16:49,609 --> 00:16:55,181 line:-1
it must do so asynchronously,
as indicated by the await.


366
00:16:55.181 --> 00:16:58.117 line:-1 position:50%
We've talked a bit about
actor isolation of code,


367
00:16:58.117 --> 00:17:02.855 line:-1 position:50%
which is whether that code runs
inside the actor or outside it.


368
00:17:02.855 --> 00:17:07.827 line:-1 position:50%
Now, let's talk about
actor isolation and data.


369
00:17:07.827 --> 00:17:09.829 line:-1 position:50%
In our library account example,


370
00:17:09.829 --> 00:17:14.200 line:-1 position:50%
we've studiously avoided saying
what the book type actually is.


371
00:17:14,200 --> 00:17:16,235 line:-1
I've been assuming
it's a value type,


372
00:17:16.235 --> 00:17:17.303 line:-1 position:50%
like a struct.


373
00:17:17,303 --> 00:17:19,405 line:-1
That's a good choice
because it means that


374
00:17:19.405 --> 00:17:22.408 line:-1 position:50%
all the state for an instance
of the library account actor


375
00:17:22,408 --> 00:17:25,244 line:-1
is self-contained.


376
00:17:25,244 --> 00:17:26,979 line:0
If we go ahead
and call this method


377
00:17:26,979 --> 00:17:29,348 line:0
to select a random book to read,


378
00:17:29,348 --> 00:17:32,785 position:50%
we'll get a copy of the book
that we can read.


379
00:17:32,785 --> 00:17:34,754 line:0
Changes we make
to our copy of the book


380
00:17:34,754 --> 00:17:39,458 position:50%
won't affect the actor
and vice versa.


381
00:17:39,458 --> 00:17:42,528 line:-1
However, if the turn the book
into a class,


382
00:17:42.528 --> 00:17:45.131 line:-1 position:50%
things are a little different.


383
00:17:45.131 --> 00:17:48.267 line:-1 position:50%
Our library account actor
now references instances


384
00:17:48,267 --> 00:17:49,936 line:-1
of the book class.


385
00:17:49.936 --> 00:17:52.705 line:-1 position:50%
That's not a problem in itself.


386
00:17:52.705 --> 00:17:55.608 line:-1 position:50%
However, what happens
when we call the method


387
00:17:55.608 --> 00:17:58.477 line:-1 position:50%
to select a random book?


388
00:17:58,477 --> 00:18:02,682 position:50%
Now we have a reference into
the mutable state of the actor,


389
00:18:02,682 --> 00:18:05,618 line:0
which has been shared
outside of the actor.


390
00:18:05,618 --> 00:18:09,188 line:0
We've created the potential
for data races.


391
00:18:09,188 --> 00:18:12,191 line:0
Now, if we go and update
the title of the book,


392
00:18:12,191 --> 00:18:15,161 line:0
the modification happens
in state that is accessible


393
00:18:15,161 --> 00:18:18,331 line:0
within the actor.


394
00:18:18,331 --> 00:18:20,900 line:0
Because the visit method
is not on the actor,


395
00:18:20,900 --> 00:18:25,938 line:0
this modification could end up
being a data race.


396
00:18:25,938 --> 00:18:29,408 position:50%
Value types and actors are both
safe to use concurrently,


397
00:18:29,408 --> 00:18:32,478 line:0
but classes can still
pose problems.


398
00:18:32,478 --> 00:18:35,948 line:0
We have a name for types that
are safe to use concurrently:


399
00:18:35,948 --> 00:18:38,918 line:0
Sendable.


400
00:18:38.918 --> 00:18:42.154 line:-1 position:50%
A Sendable type is one
whose values can be shared


401
00:18:42.154 --> 00:18:44.223 line:-1 position:50%
across different actors.


402
00:18:44,223 --> 00:18:47,226 line:-1
If you copy a value
from one place to another,


403
00:18:47,226 --> 00:18:50,296 line:-1
and both places can safely
modify their own copies


404
00:18:50.296 --> 00:18:53.432 line:-1 position:50%
of that value without
interfering with each other,


405
00:18:53,432 --> 00:18:56,068 line:-1
the type can be Sendable.


406
00:18:56,068 --> 00:18:59,972 line:-1
Value types are Sendable because
each copy is independent,


407
00:18:59,972 --> 00:19:02,608 line:-1
as Dario talked about earlier.


408
00:19:02,608 --> 00:19:04,143 line:-1
Actor types are Sendable


409
00:19:04.143 --> 00:19:08.080 line:-1 position:50%
because they synchronize
access to their mutable state.


410
00:19:08.080 --> 00:19:10.116 line:-1 position:50%
Classes can be Sendable,


411
00:19:10.116 --> 00:19:12.852 line:-1 position:50%
but only if they are carefully
implemented.


412
00:19:12,852 --> 00:19:15,888 line:-1
For example, if a class
and all of its subclasses


413
00:19:15,888 --> 00:19:17,990 line:-1
only hold immutable data,


414
00:19:17,990 --> 00:19:20,059 line:-1
then it can be called Sendable.


415
00:19:20.059 --> 00:19:23.496 line:-1 position:50%
Or if the class internally
performs synchronization,


416
00:19:23.496 --> 00:19:25.031 line:-1 position:50%
for example with a lock,


417
00:19:25.031 --> 00:19:29.268 line:-1 position:50%
to ensure safe concurrent
access, it can be Sendable.


418
00:19:29,268 --> 00:19:31,737 line:-1
But most classes
are neither of these,


419
00:19:31.737 --> 00:19:34.607 line:-1 position:50%
and cannot be Sendable.


420
00:19:34,607 --> 00:19:37,209 line:-1
Functions aren't necessarily
Sendable,


421
00:19:37,209 --> 00:19:39,178 line:-1
so there is a new kind
of function type


422
00:19:39,178 --> 00:19:42,581 line:-1
for functions that are safe
to pass across actors.


423
00:19:42,581 --> 00:19:44,650 line:-1
We'll get back to those shortly.


424
00:19:44,650 --> 00:19:46,018 line:-1
Your actors --


425
00:19:46,018 --> 00:19:48,354 line:-1
in fact,
all of your concurrent code --


426
00:19:48,354 --> 00:19:52,058 line:-1
should primarily communicate
in terms of Sendable types.


427
00:19:52.058 --> 00:19:55.594 line:-1 position:50%
Sendable types protect code
from data races.


428
00:19:55,594 --> 00:19:56,495 line:-1
This is a property


429
00:19:56,495 --> 00:19:59,465 line:-1
that Swift will eventually
start checking statically.


430
00:19:59,465 --> 00:20:00,399 line:0
At that point,


431
00:20:00,399 --> 00:20:03,235 line:0
it will become an error
to pass a non-Sendable type


432
00:20:03,235 --> 00:20:06,372 line:0
across actor boundaries.


433
00:20:06,372 --> 00:20:09,141 position:50%
How does one know
that a type is Sendable?


434
00:20:09,141 --> 00:20:11,277 line:-1
Well, Sendable is a protocol,


435
00:20:11,277 --> 00:20:13,879 line:-1
and you state that your type
conforms to Sendable


436
00:20:13.879 --> 00:20:16.949 line:-1 position:50%
the same way you do
with other protocols.


437
00:20:16,949 --> 00:20:19,452 line:-1
Swift will then check
to make sure your type


438
00:20:19.452 --> 00:20:22.121 line:-1 position:50%
makes sense
as a Sendable type.


439
00:20:22.121 --> 00:20:25.591 line:-1 position:50%
A Book struct can be Sendable
if all of its stored properties


440
00:20:25,591 --> 00:20:27,827 line:-1
are of Sendable type.


441
00:20:27.827 --> 00:20:30.896 line:-1 position:50%
Let's say Author
is actually a class,


442
00:20:30.896 --> 00:20:34.467 line:-1 position:50%
which means it -- and therefore
the array of authors --


443
00:20:34,467 --> 00:20:36,368 line:-1
are not Sendable.


444
00:20:36.368 --> 00:20:38.504 line:-1 position:50%
Swift will produce
a compiler error


445
00:20:38.504 --> 00:20:43.242 line:-1 position:50%
indicating that Book
cannot be Sendable.


446
00:20:43,242 --> 00:20:45,578 line:-1
For generic types,
whether they are Sendable


447
00:20:45,578 --> 00:20:48,080 line:-1
can depend on
their generic arguments.


448
00:20:48,080 --> 00:20:50,483 line:-1
We can use
conditional conformance


449
00:20:50,483 --> 00:20:53,486 line:-1
to propagate Sendable
when it's appropriate.


450
00:20:53,486 --> 00:20:56,222 line:0
For example,
a pair type will be Sendable


451
00:20:56,222 --> 00:21:00,259 position:50%
only when both of its generic
arguments are Sendable.


452
00:21:00,259 --> 00:21:03,362 line:0
The same approach is used
to conclude that an array


453
00:21:03,362 --> 00:21:07,233 line:0
of Sendable types
is itself Sendable.


454
00:21:07,233 --> 00:21:10,336 line:0
We encourage you introduce
Sendable conformances


455
00:21:10,336 --> 00:21:14,073 line:0
to the types whose values
are safe to share concurrently.


456
00:21:14,073 --> 00:21:16,475 line:0
Use those types
within your actors.


457
00:21:16,475 --> 00:21:19,178 position:50%
Then when Swift begins
to start enforcing Sendable


458
00:21:19,178 --> 00:21:23,415 line:0
across actors,
your code will be ready.


459
00:21:23,415 --> 00:21:25,651 position:50%
Functions themselves
can be Sendable,


460
00:21:25,651 --> 00:21:28,287 line:0
meaning that it is safe
to pass the function value


461
00:21:28,287 --> 00:21:29,989 position:50%
across actors.


462
00:21:29,989 --> 00:21:33,692 line:0
This is particularly important
for closures where it restricts


463
00:21:33,692 --> 00:21:37,229 line:0
what the closure can do
to help prevent data races.


464
00:21:37,229 --> 00:21:39,431 line:-1
For example,
a Sendable closure


465
00:21:39,431 --> 00:21:42,101 line:-1
cannot capture
a mutable local variable,


466
00:21:42,101 --> 00:21:43,669 line:-1
because that would allow
data races


467
00:21:43.669 --> 00:21:46.038 line:-1 position:50%
on the local variable.


468
00:21:46,038 --> 00:21:48,007 line:-1
Anything the closure
does capture


469
00:21:48,007 --> 00:21:49,608 line:-1
needs to be Sendable,


470
00:21:49.608 --> 00:21:52.077 line:-1 position:50%
to make sure that
the closure cannot be used


471
00:21:52,077 --> 00:21:55,848 line:-1
to move non-Sendable types
across actor boundaries.


472
00:21:55,848 --> 00:21:58,784 line:-1
And finally, a synchronous
Sendable closure


473
00:21:58.784 --> 00:22:01.754 line:-1 position:50%
cannot be actor-isolated,
because that would allow code


474
00:22:01,754 --> 00:22:05,558 line:-1
to be run on the actor
from the outside.


475
00:22:05,558 --> 00:22:08,527 line:-1
We've actually be relying
on the idea of Sendable closures


476
00:22:08,527 --> 00:22:10,362 line:-1
in this talk.


477
00:22:10.362 --> 00:22:13.132 line:-1 position:50%
The operation that creates
detached tasks


478
00:22:13,132 --> 00:22:14,900 line:-1
takes a Sendable function,


479
00:22:14.900 --> 00:22:20.372 line:-1 position:50%
written here with the @Sendable
in the function type.


480
00:22:20,372 --> 00:22:23,542 line:-1
Remember our counterexample
from the beginning of the talk?


481
00:22:23,542 --> 00:22:26,946 line:-1
We were trying to build
a value-typed counter.


482
00:22:26.946 --> 00:22:28.981 line:-1 position:50%
Then, we tried to go
and modify it


483
00:22:28.981 --> 00:22:33.118 line:-1 position:50%
from two different closures
at the same time.


484
00:22:33,118 --> 00:22:36,789 line:-1
This would be a data race
on the mutable local variable.


485
00:22:36.789 --> 00:22:40.859 line:-1 position:50%
However, because the closure
for a detached task is Sendable,


486
00:22:40.859 --> 00:22:44.663 line:-1 position:50%
Swift will produce
an error here.


487
00:22:44.663 --> 00:22:46.265 line:-1 position:50%
Sendable function types are used


488
00:22:46,265 --> 00:22:49,235 line:-1
to indicate where concurrent
execution can occur,


489
00:22:49.235 --> 00:22:51.503 line:-1 position:50%
and therefore prevent
data races.


490
00:22:51.503 --> 00:22:55.407 line:-1 position:50%
Here's another example
we saw earlier.


491
00:22:55,407 --> 00:22:58,777 line:-1
Because the closure for
the detached task is Sendable,


492
00:22:58,777 --> 00:23:02,248 line:-1
we know that it should not
be isolated to the actor.


493
00:23:02,248 --> 00:23:08,754 line:-1
Therefore, interactions with it
will have to be asynchronous.


494
00:23:08.754 --> 00:23:12.858 line:-1 position:50%
Sendable types and closures
help maintain actor isolation


495
00:23:12,858 --> 00:23:16,695 line:-1
by checking that mutable state
isn't shared across actors,


496
00:23:16,695 --> 00:23:20,733 line:-1
and cannot be modified
concurrently.


497
00:23:20.733 --> 00:23:23.669 line:-1 position:50%
We've been talking primarily
about actor types,


498
00:23:23.669 --> 00:23:26.739 line:-1 position:50%
and how they interact
with protocols, closures,


499
00:23:26.739 --> 00:23:28.641 line:-1 position:50%
and Sendable types.


500
00:23:28.641 --> 00:23:30.976 line:-1 position:50%
There is one more actor
to discuss --


501
00:23:30.976 --> 00:23:34.813 line:-1 position:50%
a special one that we call
the main actor.


502
00:23:34.813 --> 00:23:36.148 line:-1 position:50%
When you are building an app,


503
00:23:36,148 --> 00:23:38,951 line:-1
you need to think about
the main thread.


504
00:23:38,951 --> 00:23:42,187 line:-1
It is where the core user
interface rendering happens,


505
00:23:42,187 --> 00:23:44,523 line:-1
as well as where
user interaction events


506
00:23:44,523 --> 00:23:46,058 line:-1
are processed.


507
00:23:46.058 --> 00:23:48.027 line:-1 position:50%
Operations that work
with the UI


508
00:23:48.027 --> 00:23:51.997 line:-1 position:50%
generally need to be performed
from the main thread.


509
00:23:51,997 --> 00:23:54,400 line:-1
However, you don't want
to do all of your work


510
00:23:54.400 --> 00:23:55.768 line:-1 position:50%
on the main thread.


511
00:23:55,768 --> 00:23:58,437 line:-1
If you do too much work
on the main thread, say,


512
00:23:58.437 --> 00:24:01.340 line:-1 position:50%
because you have some slow
input/output operation


513
00:24:01,340 --> 00:24:03,642 line:-1
or blocking interaction
with a server,


514
00:24:03.642 --> 00:24:06.111 line:-1 position:50%
your UI will freeze.


515
00:24:06,111 --> 00:24:09,181 line:-1
So, you need to be careful
to do work on the main thread


516
00:24:09.181 --> 00:24:11.150 line:-1 position:50%
when it interacts with the UI


517
00:24:11,150 --> 00:24:13,018 line:-1
but get off
the main thread quickly


518
00:24:13,018 --> 00:24:18,557 line:-1
for computationally expensive
or long-waiting operations.


519
00:24:18,557 --> 00:24:21,193 line:0
So, we do work off the
main thread when we can


520
00:24:21,193 --> 00:24:23,829 line:0
and then call
DispatchQueue.main.async


521
00:24:23,829 --> 00:24:26,665 line:0
in your code whenever you have
a particular operation


522
00:24:26,665 --> 00:24:29,601 position:50%
that must be executed
on the main thread.


523
00:24:29,601 --> 00:24:32,338 position:50%
Stepping back from the details
of the mechanism,


524
00:24:32,338 --> 00:24:35,774 position:50%
the structure of this code
looks vaguely familiar.


525
00:24:35,774 --> 00:24:38,310 position:50%
In fact, interacting
with the main thread


526
00:24:38,310 --> 00:24:41,347 line:0
is a whole lot like
interacting with an actor.


527
00:24:41,347 --> 00:24:43,949 line:0
If you know you're already
running on the main thread,


528
00:24:43,949 --> 00:24:47,353 line:0
you can safely access
and update your UI state.


529
00:24:47,353 --> 00:24:49,421 line:0
If you aren't running
on the main thread,


530
00:24:49,421 --> 00:24:52,725 line:0
you need to interact
with it asynchronously.


531
00:24:52,725 --> 00:24:55,494 line:0
This is exactly how actors work.


532
00:24:55,494 --> 00:24:58,330 position:50%
There's a special actor
to describe the main thread,


533
00:24:58,330 --> 00:25:02,167 position:50%
which we call the main actor.


534
00:25:02,167 --> 00:25:03,836 position:50%
The main actor is an actor


535
00:25:03,836 --> 00:25:06,238 position:50%
that represents
the main thread.


536
00:25:06,238 --> 00:25:10,275 position:50%
It differs from a normal actor
in two important ways.


537
00:25:10,275 --> 00:25:14,079 line:0
First, the main actor performs
all of its synchronization


538
00:25:14,079 --> 00:25:16,615 line:0
through the main dispatch queue.


539
00:25:16,615 --> 00:25:19,485 line:0
This means that,
from a runtime perspective,


540
00:25:19,485 --> 00:25:21,387 line:0
the main actor
is interchangeable


541
00:25:21,387 --> 00:25:24,456 line:0
with using DispatchQueue.main.


542
00:25:24,456 --> 00:25:28,060 line:0
Second, the code and data that
needs to be on the main thread


543
00:25:28,060 --> 00:25:30,262 position:50%
is scattered everywhere.


544
00:25:30,262 --> 00:25:35,501 line:0
It's in SwiftUI, AppKit, UIKit,
and other system frameworks.


545
00:25:35,501 --> 00:25:38,203 position:50%
It's spread across your
own views, view controllers,


546
00:25:38,203 --> 00:25:41,507 line:0
and the UI-facing parts
of your data model.


547
00:25:41,507 --> 00:25:44,410 position:50%
With Swift concurrency,
you can mark a declaration


548
00:25:44,410 --> 00:25:47,613 position:50%
with the main actor attribute
to say that it must be executed


549
00:25:47,613 --> 00:25:49,314 line:0
on the main actor.


550
00:25:49,314 --> 00:25:51,917 line:0
We've done that with
the checked-out operation here,


551
00:25:51,917 --> 00:25:54,853 line:0
so it always runs
on the main actor.


552
00:25:54,853 --> 00:25:57,289 line:0
If you call it from outside
the main actor,


553
00:25:57,289 --> 00:26:00,692 line:0
you need to await, so that
the call will be performed


554
00:26:00,692 --> 00:26:04,263 position:50%
asynchronously
on the main thread.


555
00:26:04,263 --> 00:26:06,632 position:50%
By marking code that must run
on the main thread


556
00:26:06,632 --> 00:26:09,868 position:50%
as being on the main actor,
there is no more guesswork


557
00:26:09,868 --> 00:26:12,604 line:0
about when to use
DispatchQueue.main.


558
00:26:12,604 --> 00:26:14,473 line:0
Swift ensures that this code


559
00:26:14,473 --> 00:26:20,179 line:0
is always executed
on the main thread.


560
00:26:20,179 --> 00:26:22,581 position:50%
Types can be placed
on the main actor as well,


561
00:26:22,581 --> 00:26:25,083 position:50%
which makes all of their members
and subclasses


562
00:26:25,083 --> 00:26:26,785 line:0
be on the main actor.


563
00:26:26,785 --> 00:26:29,021 position:50%
This is useful for the parts
of your code base


564
00:26:29,021 --> 00:26:31,256 position:50%
that must interact with the UI,


565
00:26:31,256 --> 00:26:34,760 line:0
where most everything needs
to run on the main thread.


566
00:26:34,760 --> 00:26:38,797 line:0
Individual methods can opt-out
via the nonisolated keyword,


567
00:26:38,797 --> 00:26:40,899 line:0
with the same rules
you're familiar with


568
00:26:40,899 --> 00:26:43,836 position:50%
from normal actors.


569
00:26:43,836 --> 00:26:46,572 line:0
By using the main actor
for your UI-facing types


570
00:26:46,572 --> 00:26:49,808 line:0
and operations,
and introducing your own actors


571
00:26:49,808 --> 00:26:51,944 position:50%
for managing
other program state,


572
00:26:51,944 --> 00:26:54,379 position:50%
you can architect your app
to ensure safe,


573
00:26:54,379 --> 00:26:57,983 line:0
correct use of concurrency.


574
00:26:57,983 --> 00:27:00,853 line:-1
In this session,
we've talked about how actors


575
00:27:00.853 --> 00:27:03.989 line:-1 position:50%
protect their mutable state
from concurrent access,


576
00:27:03,989 --> 00:27:07,860 line:-1
using actor isolation and by
requiring asynchronous access


577
00:27:07,860 --> 00:27:11,430 line:-1
from outside the actor
to serialize execution.


578
00:27:11,430 --> 00:27:14,366 line:-1
Use actors to build safe,
concurrent abstractions


579
00:27:14.366 --> 00:27:16.802 line:-1 position:50%
in your Swift code.


580
00:27:16,802 --> 00:27:20,706 line:-1
In implementing your actors,
and in any asynchronous code,


581
00:27:20.706 --> 00:27:24.643 line:-1 position:50%
always design for reentrancy;
an await in your code


582
00:27:24,643 --> 00:27:29,781 line:-1
means the world can move on
and invalidate your assumptions.


583
00:27:29.781 --> 00:27:31.984 line:-1 position:50%
Value types and actors
work together


584
00:27:31,984 --> 00:27:33,952 line:-1
to eliminate data races.


585
00:27:33.952 --> 00:27:36.054 line:-1 position:50%
Be aware of classes
that don't handle


586
00:27:36.054 --> 00:27:39.391 line:-1 position:50%
their own synchronization,
and other non-Sendable types


587
00:27:39.391 --> 00:27:42.794 line:-1 position:50%
that reintroduce
shared mutable state.


588
00:27:42.794 --> 00:27:45.697 line:-1 position:50%
Finally, use the main actor
on your code


589
00:27:45,697 --> 00:27:48,667 line:-1
that interacts with the UI
to ensure that the code


590
00:27:48,667 --> 00:27:53,272 line:-1
that must be on the main thread
always runs on the main thread.


591
00:27:53,272 --> 00:27:55,374 line:0
To learn more about
how to use actors


592
00:27:55,374 --> 00:27:58,010 line:0
within your own application,
check out our session


593
00:27:58,010 --> 00:28:01,513 line:0
on updating an app
for Swift concurrency.


594
00:28:01,513 --> 00:28:03,282 position:50%
And to learn more about
the implementation


595
00:28:03,282 --> 00:28:06,151 position:50%
of Swift's concurrency model,
including actors,


596
00:28:06,151 --> 00:28:11,290 position:50%
check out our
"Behind the scenes" session.


597
00:28:11,290 --> 00:28:14,893 line:-1
Actors are a core part
of the Swift concurrency model.


598
00:28:14,893 --> 00:28:17,029 line:-1
They work together
with async/await


599
00:28:17.029 --> 00:28:20.032 line:-1 position:50%
and structured concurrency
to make it easier to build


600
00:28:20.032 --> 00:28:23.035 line:-1 position:50%
correct and efficient
concurrent programs.


601
00:28:23,035 --> 00:28:25,337 line:-1
We can't wait to see
what you build with them.


602
00:28:25,337 --> 00:28:28,373 position:89% align:center line:0
♪

