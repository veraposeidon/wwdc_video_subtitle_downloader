2
00:00:00.000 --> 00:00:01.969 line:-1 position:50%
[MAC STARTUP CHIME]


3
00:00:01,969 --> 00:00:05,572 line:-1
♪ Bass music playing ♪


4
00:00:05,572 --> 00:00:07,708 line:-1
[KEYSTROKES]


5
00:00:07,708 --> 00:00:09,810 size:2% position:89% align:center
♪


6
00:00:09,810 --> 00:00:11,545 line:-1
Kyle Macomber: Hi, I'm Kyle.


7
00:00:11,545 --> 00:00:14,548 line:-1
The Swift Standard Library team
maintains a growing roster


8
00:00:14,548 --> 00:00:17,784 line:-1
of open-source packages
including Swift ArgumentParser,


9
00:00:17,784 --> 00:00:20,520 line:-1
Swift Numerics,
and Swift System.


10
00:00:20.520 --> 00:00:22.122 line:-1 position:50%
Today, we're excited
to introduce


11
00:00:22.122 --> 00:00:24.892 line:-1 position:50%
two big new additions
to the family:


12
00:00:24.892 --> 00:00:28.962 line:-1 position:50%
Swift Algorithms
and Swift Collections!


13
00:00:28,962 --> 00:00:31,131 line:-1
Swift Algorithms
is an open-source package


14
00:00:31.131 --> 00:00:32.999 line:-1 position:50%
of sequence
and collection algorithms


15
00:00:32.999 --> 00:00:35.302 line:-1 position:50%
that augments
the Swift standard library.


16
00:00:35.302 --> 00:00:37.204 line:-1 position:50%
One of the most powerful
features of Swift


17
00:00:37.204 --> 00:00:39.473 line:-1 position:50%
is the rich taxonomy
of algorithms


18
00:00:39.473 --> 00:00:41.508 line:-1 position:50%
that come built in.


19
00:00:41,508 --> 00:00:44,211 line:-1
It takes a little investment
to learn the vocabulary,


20
00:00:44,211 --> 00:00:46,880 line:-1
but once you do,
it can be striking to discover


21
00:00:46,880 --> 00:00:49,716 line:-1
just how many algorithms
are hiding in plain sight


22
00:00:49,716 --> 00:00:52,019 line:-1
and how much you can improve
the quality of your code


23
00:00:52,019 --> 00:00:53,654 line:-1
by adopting them.


24
00:00:53.654 --> 00:00:56.156 line:-1 position:50%
To see what I mean,
let's take a look at some code


25
00:00:56,156 --> 00:00:59,726 line:-1
from a messaging application
that I've been working on.


26
00:00:59.726 --> 00:01:02.963 line:-1 position:50%
Consider this loop which
iterates over the index paths


27
00:01:02.963 --> 00:01:05.999 line:-1 position:50%
for the selected rows
in a table view,


28
00:01:05.999 --> 00:01:07.968 line:-1 position:50%
collecting all
the corresponding messages


29
00:01:07,968 --> 00:01:10,904 line:-1
for forwarding or deletion.


30
00:01:10,904 --> 00:01:14,174 line:-1
This is just a map.


31
00:01:14.174 --> 00:01:16.743 line:-1 position:50%
Using map makes this code
clearer to the reader


32
00:01:16.743 --> 00:01:18.378 line:-1 position:50%
because it provides
extra context


33
00:01:18,378 --> 00:01:20,147 line:-1
that the body of the closure,


34
00:01:20.147 --> 00:01:22.249 line:-1 position:50%
regardless of its length
or complexity,


35
00:01:22.249 --> 00:01:24.785 line:-1 position:50%
is just transforming the input.


36
00:01:24.785 --> 00:01:27.421 line:-1 position:50%
Using map also
makes this code faster


37
00:01:27,421 --> 00:01:29,623 line:-1
because it avoids
intermediate allocations


38
00:01:29,623 --> 00:01:32,726 line:-1
due to array resizing
by reserving capacity --


39
00:01:32.726 --> 00:01:36.229 line:-1 position:50%
something our raw loop
wasn't bothering to do.


40
00:01:36,229 --> 00:01:40,734 line:-1
Or consider this loop which,
if the user taps on an image,


41
00:01:40.734 --> 00:01:43.804 line:-1 position:50%
iterates the messages
in the transcript,


42
00:01:43.804 --> 00:01:48.942 line:-1 position:50%
collecting all the attachments
for display using Quick Look.


43
00:01:48.942 --> 00:01:51.878 line:-1 position:50%
This is just a map and a filter!


44
00:01:51,878 --> 00:01:55,983 line:-1
In fact, this pattern
of filtering out nils


45
00:01:55.983 --> 00:01:58.418 line:-1 position:50%
and mapping
to unwrap optionals


46
00:01:58,418 --> 00:02:00,620 line:-1
is so common that
we have a special name


47
00:02:00.620 --> 00:02:06.226 line:-1 position:50%
and algorithm for it:
compactMap.


48
00:02:06,226 --> 00:02:08,095 line:-1
Next, consider this code.


49
00:02:08.095 --> 00:02:11.698 line:-1 position:50%
I have an array of messages,
and I want to transform it


50
00:02:11.698 --> 00:02:14.835 line:-1 position:50%
into an array
of transcript items.


51
00:02:14,835 --> 00:02:17,304 line:-1
The tricky thing is that
any given message


52
00:02:17.304 --> 00:02:22.376 line:-1 position:50%
might correspond to multiple
items in the chat transcript.


53
00:02:22,376 --> 00:02:25,445 line:-1
Using map here produces
an array of arrays.


54
00:02:25.445 --> 00:02:29.683 line:-1 position:50%
But that's not what I want;
I just want a flat array.


55
00:02:29.683 --> 00:02:33.420 line:-1 position:50%
Does this mean I have to go back
to using a raw for loop?


56
00:02:33.420 --> 00:02:37.024 line:-1 position:50%
Of course not; we've got
another algorithm for that.


57
00:02:37.024 --> 00:02:39.493 line:-1 position:50%
It's called "joined".


58
00:02:39,493 --> 00:02:42,396 line:-1
What it does is join together
all the inner arrays


59
00:02:42,396 --> 00:02:45,766 line:-1
into a single, flat collection
of elements.


60
00:02:45,766 --> 00:02:49,269 line:-1
This pattern of mapping
and joining is so common


61
00:02:49.269 --> 00:02:55.242 line:-1 position:50%
that we define another special
kind of map for it: flatMap.


62
00:02:55.242 --> 00:02:59.613 line:-1 position:50%
Of course, map and filter
are just the tip of the iceberg.


63
00:02:59.613 --> 00:03:03.316 line:-1 position:50%
Consider this raw loop from the
chat detail screen in my app.


64
00:03:03.316 --> 00:03:05.952 line:-1 position:50%
I want to display
the last six photos in a chat,


65
00:03:05,952 --> 00:03:08,321 line:-1
from newest to oldest.


66
00:03:08.321 --> 00:03:10.557 line:-1 position:50%
So I iterate the transcript
in reverse --


67
00:03:10,557 --> 00:03:12,259 line:-1
from newest to oldest --


68
00:03:12.259 --> 00:03:16.997 line:-1 position:50%
and if the item is a photo,
I add it to the array.


69
00:03:16.997 --> 00:03:19.599 line:-1 position:50%
And once I have six, I stop.


70
00:03:19,599 --> 00:03:21,935 line:-1
We can express this
more concisely


71
00:03:21,935 --> 00:03:26,106 line:-1
by chaining together algorithms
from the standard library --


72
00:03:26.106 --> 00:03:31.445 line:-1 position:50%
reversed, compactMap,
and prefix --


73
00:03:31.445 --> 00:03:35.916 line:-1 position:50%
to take no more
than the first six.


74
00:03:35.916 --> 00:03:38.852 line:-1 position:50%
Chaining together algorithms
also gives us more flexibility


75
00:03:38.852 --> 00:03:42.289 line:-1 position:50%
to express this code
more clearly.


76
00:03:42,289 --> 00:03:45,225 position:50%
For example, I find it
more natural to think about


77
00:03:45,225 --> 00:03:48,395 position:50%
this operation in terms
of the suffix of the transcript


78
00:03:48,395 --> 00:03:52,165 line:0
rather than the prefix
of the reversed transcript.


79
00:03:52.165 --> 00:03:55.202 line:-1 position:50%
So the chain of algorithms
is clearer and more concise


80
00:03:55.202 --> 00:03:56.536 line:-1 position:50%
than the raw loop,


81
00:03:56.536 --> 00:03:58.839 line:-1 position:50%
but how does
the performance compare?


82
00:03:58,839 --> 00:04:02,375 line:-1
If each step in the chain
allocates an intermediate array,


83
00:04:02,375 --> 00:04:06,213 line:-1
isn't it going to be slower
than the raw loop?


84
00:04:06.213 --> 00:04:08.548 line:-1 position:50%
The answer would be yes


85
00:04:08,548 --> 00:04:10,650 line:-1
if the standard library
weren't playing


86
00:04:10,650 --> 00:04:13,186 line:-1
some clever tricks here.


87
00:04:13,186 --> 00:04:15,789 line:-1
Let's return to the
joined algorithm we saw earlier


88
00:04:15.789 --> 00:04:19.392 line:-1 position:50%
to take a closer look
at what's going on.


89
00:04:19.392 --> 00:04:21.761 line:-1 position:50%
It turns out joined
doesn't actually allocate


90
00:04:21.761 --> 00:04:23.763 line:-1 position:50%
and return a new array here.


91
00:04:23,763 --> 00:04:26,333 line:-1
Instead, it returns
a FlattenSequence.


92
00:04:26,333 --> 00:04:30,770 line:-1
FlattenSequence is what
we call a "lazy adapter".


93
00:04:30,770 --> 00:04:33,640 line:-1
For most purposes,
it works like an array,


94
00:04:33,640 --> 00:04:35,175 line:-1
but it's just a thin wrapper,


95
00:04:35.175 --> 00:04:37.144 line:-1 position:50%
so it's effectively
free to create.


96
00:04:37,144 --> 00:04:40,947 line:-1
And it's lazy, so it processes
its elements on demand,


97
00:04:40.947 --> 00:04:43.683 line:-1 position:50%
rather than doing
all the work up front.


98
00:04:43,683 --> 00:04:45,752 line:-1
Lazy adapters
like FlattenSequence


99
00:04:45.752 --> 00:04:49.089 line:-1 position:50%
are what enable algorithm chains
to have competitive performance


100
00:04:49.089 --> 00:04:51.158 line:-1 position:50%
with raw for loops.


101
00:04:51.158 --> 00:04:53.727 line:-1 position:50%
Let's return to the detail
screen and take a closer look


102
00:04:53.727 --> 00:04:59.499 line:-1 position:50%
at our algorithm to compute
the last six photos in a chat.


103
00:04:59.499 --> 00:05:02.903 line:-1 position:50%
We see that suffix actually
just returns an array slice --


104
00:05:02.903 --> 00:05:05.338 line:-1 position:50%
that's clever --


105
00:05:05.338 --> 00:05:09.109 line:-1 position:50%
and that reversed is also
implemented as a lazy adapter,


106
00:05:09,109 --> 00:05:11,144 line:-1
one which intercedes
to start at the end


107
00:05:11,144 --> 00:05:14,814 line:-1
and end at the start.


108
00:05:14.814 --> 00:05:17.083 line:-1 position:50%
What about compactMap?


109
00:05:17.083 --> 00:05:20.820 line:-1 position:50%
It's still returning an array.
Can that be lazy?


110
00:05:20.820 --> 00:05:22.055 line:-1 position:50%
It can.


111
00:05:22,055 --> 00:05:25,425 line:-1
You just have to add a .lazy
to the start of the chain,


112
00:05:25.425 --> 00:05:28.094 line:-1 position:50%
and it makes any of the
algorithms that take a closure,


113
00:05:28,094 --> 00:05:31,998 line:-1
like map and filter, lazy!


114
00:05:31.998 --> 00:05:34.000 line:-1 position:50%
Lazy algorithm chains
are a great fit


115
00:05:34,000 --> 00:05:35,936 line:-1
for use cases like this one,


116
00:05:35.936 --> 00:05:38.538 line:-1 position:50%
where you're only processing
a small number of elements


117
00:05:38,538 --> 00:05:41,408 line:-1
from a potentially
very large collection.


118
00:05:41.408 --> 00:05:45.345 line:-1 position:50%
Of course, sometimes you do need
or want an array.


119
00:05:45,345 --> 00:05:48,181 line:-1
And in that case, you can always
just wrap your algorithm chain


120
00:05:48.181 --> 00:05:50.350 line:-1 position:50%
in an array initializer.


121
00:05:50.350 --> 00:05:53.253 line:-1 position:50%
This is one more reason why,
on the Standard Library team,


122
00:05:53,253 --> 00:05:55,989 line:-1
we're a big fan
of lazy algorithms.


123
00:05:55.989 --> 00:05:59.993 line:-1 position:50%
It's really easy to turn a lazy
algorithm into an eager result,


124
00:05:59,993 --> 00:06:02,495 line:-1
but it's impossible
to go the other way.


125
00:06:02,495 --> 00:06:05,332 line:-1
So I've been making great
progress on my messaging app,


126
00:06:05,332 --> 00:06:08,134 line:-1
and my designer approaches me
with a feature request.


127
00:06:08,134 --> 00:06:10,904 line:-1
They'd like to include
time stamps in the transcript,


128
00:06:10.904 --> 00:06:12.339 line:-1 position:50%
if more than an hour has passed


129
00:06:12,339 --> 00:06:15,041 line:-1
between any two
consecutive messages.


130
00:06:15.041 --> 00:06:16.443 line:-1 position:50%
Seems reasonable.


131
00:06:16.443 --> 00:06:18.812 line:-1 position:50%
There's got to be another
algorithm I can use for this,


132
00:06:18.812 --> 00:06:20.413 line:-1 position:50%
right?


133
00:06:20,413 --> 00:06:22,148 line:-1
There is.
But to access it,


134
00:06:22.148 --> 00:06:26.753 line:-1 position:50%
I'm going to need to import
the Swift Algorithms package.


135
00:06:26,753 --> 00:06:27,821 position:50%
Every once in a while,


136
00:06:27,821 --> 00:06:30,156 position:50%
you're going to encounter
use cases like these


137
00:06:30,156 --> 00:06:33,994 line:0
that the Swift standard library
doesn't have coverage for yet.


138
00:06:33.994 --> 00:06:36.563 line:-1 position:50%
The purpose of the Algorithms
package is to provide


139
00:06:36.563 --> 00:06:39.566 line:-1 position:50%
a low-friction venue for us --
with your help --


140
00:06:39.566 --> 00:06:42.335 line:-1 position:50%
to incubate new families
of missing algorithms


141
00:06:42,335 --> 00:06:45,739 line:-1
for eventual inclusion
in the standard library.


142
00:06:45,739 --> 00:06:49,309 line:-1
We've already added over 40
algorithms to Swift Algorithms.


143
00:06:49,309 --> 00:06:51,945 line:-1
For things like generating
all the combinations


144
00:06:51,945 --> 00:06:54,914 line:-1
or permutations
of a collection of elements;


145
00:06:54,914 --> 00:06:56,950 line:-1
or iterating the elements
of a sequence


146
00:06:56.950 --> 00:07:01.488 line:-1 position:50%
by two or three or in groups
determined by a predicate;


147
00:07:01.488 --> 00:07:04.257 line:-1 position:50%
or selecting the five smallest
elements in a collection,


148
00:07:04,257 --> 00:07:07,494 line:-1
the five largest,
or just any five at random.


149
00:07:07,494 --> 00:07:10,530 line:-1
Let's take a closer look at some
of the powerful iteration tools


150
00:07:10,530 --> 00:07:13,133 line:-1
that come with Swift Algorithms.


151
00:07:13,133 --> 00:07:16,036 line:-1
windows(ofCount:)
provides a sliding window,


152
00:07:16,036 --> 00:07:20,774 line:-1
here of size 3, into the
elements of a collection.


153
00:07:20.774 --> 00:07:24.110 line:-1 position:50%
For each turn of the loop,
window is just a subsequence


154
00:07:24.110 --> 00:07:26.746 line:-1 position:50%
of the base collection --
here an ArraySlice --


155
00:07:26,746 --> 00:07:30,250 line:-1
which avoids any intermediate
allocation.


156
00:07:30,250 --> 00:07:32,852 line:-1
windows(ofCount: 2)
are particularly common


157
00:07:32,852 --> 00:07:35,155 line:-1
and so we have
a convenience for it.


158
00:07:35,155 --> 00:07:37,590 line:-1
It's called "adjacentPairs".


159
00:07:37.590 --> 00:07:40.860 line:-1 position:50%
adjacentPairs vends a tuple
rather than a subsequence,


160
00:07:40,860 --> 00:07:44,597 line:-1
allowing for more convenient
element access.


161
00:07:44,597 --> 00:07:49,069 line:-1
Another powerful iteration tool
is chunks(ofCount:).


162
00:07:49,069 --> 00:07:54,307 line:-1
Unlike windows,
chunks don't overlap.


163
00:07:54.307 --> 00:07:57.377 line:-1 position:50%
If a collection isn't evenly
divisible by the chunk count,


164
00:07:57.377 --> 00:08:01.081 line:-1 position:50%
the last chunk in the sequence
will contain the remainder.


165
00:08:01.081 --> 00:08:03.983 line:-1 position:50%
And just like windows,
chunks are subsequences


166
00:08:03.983 --> 00:08:07.354 line:-1 position:50%
of the base collection,
so they're cheap to create.


167
00:08:07.354 --> 00:08:08.988 line:-1 position:50%
Sometimes you want
to chunk a collection


168
00:08:08.988 --> 00:08:12.158 line:-1 position:50%
into runs of like-elements.


169
00:08:12,158 --> 00:08:15,462 line:-1
Here we're chunking
on isPrime.


170
00:08:15.462 --> 00:08:18.498 line:-1 position:50%
This means we'll iterate the
chunks of consecutive elements


171
00:08:18.498 --> 00:08:22.268 line:-1 position:50%
that return the same value
for isPrime.


172
00:08:22,268 --> 00:08:26,606 line:-1
For convenience, chunked(on:)
vends a tuple of both the chunk


173
00:08:26,606 --> 00:08:29,409 line:-1
and the value being chunked on.


174
00:08:29,409 --> 00:08:30,777 line:-1
Have you ever found yourself


175
00:08:30,777 --> 00:08:32,712 line:-1
writing a raw loop
like this one


176
00:08:32,712 --> 00:08:33,880 line:-1
that only does some work


177
00:08:33.880 --> 00:08:37.083 line:-1 position:50%
if the previous
and current elements differ?


178
00:08:37,083 --> 00:08:39,552 line:-1
This is just chunked!


179
00:08:39.552 --> 00:08:42.655 line:-1 position:50%
Let's return now to that feature
request from my designer


180
00:08:42.655 --> 00:08:44.624 line:-1 position:50%
to include time stamps
in the transcript


181
00:08:44.624 --> 00:08:48.628 line:-1 position:50%
whenever more than an hour
has passed between messages.


182
00:08:48,628 --> 00:08:50,663 line:-1
If you recall,
we create the transcript


183
00:08:50,663 --> 00:08:52,632 line:-1
by flat mapping
over the messages


184
00:08:52.632 --> 00:08:55.535 line:-1 position:50%
to make the transcript items.


185
00:08:55,535 --> 00:09:00,306 line:-1
Well, every transcript item
has access to its date.


186
00:09:00.306 --> 00:09:02.041 line:-1 position:50%
We can chunk on the date


187
00:09:02,041 --> 00:09:03,910 line:-1
to group transcript items
together


188
00:09:03.910 --> 00:09:07.447 line:-1 position:50%
if less than an hour has passed
between them.


189
00:09:07.447 --> 00:09:09.649 line:-1 position:50%
We've already seen
how to chunk a collection


190
00:09:09,649 --> 00:09:11,818 line:-1
into runs of like elements.


191
00:09:11,818 --> 00:09:14,487 line:-1
Swift Algorithms comes with
another variant of chunked


192
00:09:14,487 --> 00:09:17,690 line:-1
that allows you to provide
a custom predicate.


193
00:09:17,690 --> 00:09:20,427 line:-1
It passes you adjacent pairs
of elements,


194
00:09:20,427 --> 00:09:24,931 line:-1
and you return true if they
belong in the same group.


195
00:09:24,931 --> 00:09:27,734 line:-1
Here, we return true
if the time interval


196
00:09:27.734 --> 00:09:32.572 line:-1 position:50%
between transcript items
is less than an hour.


197
00:09:32.572 --> 00:09:34.874 line:-1 position:50%
Next, we need to create
the time stamps


198
00:09:34,874 --> 00:09:39,512 line:-1
and join everything together
into a single, flat collection.


199
00:09:39,512 --> 00:09:44,717 line:-1
Earlier, we used joined
to flatten a nested collection.


200
00:09:44.717 --> 00:09:47.454 line:-1 position:50%
The standard library comes with
another variant of joined


201
00:09:47.454 --> 00:09:50.690 line:-1 position:50%
that can insert a separator.


202
00:09:50.690 --> 00:09:53.426 line:-1 position:50%
It's really common to use
this algorithm to join together


203
00:09:53,426 --> 00:09:57,931 line:-1
strings with, say, a new line
or a comma separator.


204
00:09:57,931 --> 00:09:59,132 line:-1
However, in this case,


205
00:09:59,132 --> 00:10:02,802 line:-1
a constant separator
isn't sufficient.


206
00:10:02.802 --> 00:10:05.872 line:-1 position:50%
We need access to the first date
in the next chunk


207
00:10:05.872 --> 00:10:09.142 line:-1 position:50%
in order to construct
the time stamp.


208
00:10:09.142 --> 00:10:12.545 line:-1 position:50%
Well, the Algorithms package
includes another variant


209
00:10:12.545 --> 00:10:14.881 line:-1 position:50%
of joined that lets you
compute the separator


210
00:10:14.881 --> 00:10:18.218 line:-1 position:50%
from the previous
and next chunks.


211
00:10:18,218 --> 00:10:20,787 line:-1
We can use that here
to join back together


212
00:10:20,787 --> 00:10:25,925 line:-1
the chunks of transcript items,
now separated by time stamps.


213
00:10:25.925 --> 00:10:28.294 line:-1 position:50%
Pretty satisfying, huh?


214
00:10:28,294 --> 00:10:29,996 line:-1
Of course, we don't need
to be paying


215
00:10:29,996 --> 00:10:33,032 line:-1
for any of these
intermediate allocations.


216
00:10:33,032 --> 00:10:35,134 line:-1
All of this can be computed
on demand


217
00:10:35,134 --> 00:10:38,438 line:-1
just by adding a .lazy.


218
00:10:38,438 --> 00:10:40,707 line:-1
Voilà!


219
00:10:40,707 --> 00:10:44,410 line:-1
I want to caution, though, that
laziness is not a silver bullet.


220
00:10:44.410 --> 00:10:47.347 line:-1 position:50%
When you're only iterating
a sequence a single time,


221
00:10:47,347 --> 00:10:51,251 line:-1
computing on demand can save
work and avoid allocations.


222
00:10:51,251 --> 00:10:54,120 line:-1
But when you're iterating
a sequence again and again --


223
00:10:54.120 --> 00:10:56.990 line:-1 position:50%
like I am with the transcript
in my messaging app --


224
00:10:56,990 --> 00:11:01,060 line:-1
computing on demand will repeat
the same work over and over --


225
00:11:01,060 --> 00:11:02,795 line:-1
mapping, chunking, and joining


226
00:11:02.795 --> 00:11:04.998 line:-1 position:50%
every time the user
enters edit mode,


227
00:11:04,998 --> 00:11:08,201 line:-1
taps on an image,
or visits the detail screen.


228
00:11:08.201 --> 00:11:09.369 line:-1 position:50%
In cases like this,


229
00:11:09.369 --> 00:11:11.771 line:-1 position:50%
you should still use
a lazy algorithm chain.


230
00:11:11,771 --> 00:11:13,873 line:-1
It's just that as a last step,


231
00:11:13,873 --> 00:11:15,975 line:-1
it'll be more efficient
if you save your work


232
00:11:15.975 --> 00:11:19.412 line:-1 position:50%
by collecting everything
together into an array.


233
00:11:19,412 --> 00:11:21,881 line:-1
We've looked at over a dozen
different algorithms


234
00:11:21.881 --> 00:11:24.784 line:-1 position:50%
from the Swift standard library
and the Algorithms package.


235
00:11:24,784 --> 00:11:27,086 line:-1
All of them work
not only on array,


236
00:11:27,086 --> 00:11:29,556 line:-1
but also string,
and every other Swift type


237
00:11:29,556 --> 00:11:32,191 line:-1
that conforms to the sequence
and collection protocols --


238
00:11:32.191 --> 00:11:34.193 line:-1 position:50%
including every data structure


239
00:11:34.193 --> 00:11:37.297 line:-1 position:50%
in the new
Swift Collections package.


240
00:11:37,297 --> 00:11:40,099 line:-1
Chaining together algorithms
makes your code clearer,


241
00:11:40.099 --> 00:11:42.569 line:-1 position:50%
faster, and more correct.


242
00:11:42,569 --> 00:11:45,471 line:-1
And becoming proficient at it
isn't complicated;


243
00:11:45.471 --> 00:11:48.942 line:-1 position:50%
it's just about building
your vocabulary.


244
00:11:48.942 --> 00:11:52.145 line:-1 position:50%
So next time you find yourself
reading or writing a raw loop,


245
00:11:52.145 --> 00:11:55.415 line:-1 position:50%
stop and think about
if it's a map, a filter,


246
00:11:55,415 --> 00:11:58,651 line:-1
or one of the other algorithms
you've just seen.


247
00:11:58,651 --> 00:12:01,521 line:-1
If nothing comes to mind,
search the documentation


248
00:12:01.521 --> 00:12:04.023 line:-1 position:50%
on the sequence
and collection protocols,


249
00:12:04.023 --> 00:12:08.027 line:-1 position:50%
or read the guides in the Swift
Algorithms GitHub repository,


250
00:12:08.027 --> 00:12:09.929 line:-1 position:50%
or visit us on the Swift forums


251
00:12:09.929 --> 00:12:12.298 line:-1 position:50%
where we can figure it out
together.


252
00:12:12,298 --> 00:12:14,567 line:-1
Who knows, it might serve
as the inspiration


253
00:12:14.567 --> 00:12:17.604 line:-1 position:50%
for a new addition
to the Algorithms package!


254
00:12:17,604 --> 00:12:19,539 line:-1
Next up, Karoy will teach you


255
00:12:19.539 --> 00:12:21.207 line:-1 position:50%
about the versatile
data structures


256
00:12:21.207 --> 00:12:24.077 line:-1 position:50%
that come with the new
Swift Collections package.


257
00:12:24,077 --> 00:12:25,678 line:-1
Karoy?


258
00:12:25,678 --> 00:12:26,713 line:-1
Karoy Lorentey: Thanks, Kyle!


259
00:12:26.713 --> 00:12:29.482 line:-1 position:50%
Let's talk about
data structures.


260
00:12:29,482 --> 00:12:32,385 line:-1
As it stands today,
the Swift standard library


261
00:12:32,385 --> 00:12:36,589 line:-1
implements just three major
general-purpose data structures:


262
00:12:36,589 --> 00:12:39,459 line:-1
it provides arrays,
unordered sets,


263
00:12:39,459 --> 00:12:42,895 line:-1
and unordered dictionaries.


264
00:12:42,895 --> 00:12:46,566 line:-1
These have proved great choices
as universal collection types,


265
00:12:46,566 --> 00:12:49,335 line:-1
and they're especially nice
for transferring data


266
00:12:49.335 --> 00:12:51.871 line:-1 position:50%
across module boundaries.


267
00:12:51.871 --> 00:12:55.108 line:-1 position:50%
They all implement
copy-on-write value semantics,


268
00:12:55,108 --> 00:12:58,578 line:-1
providing efficient in-place
mutation operations


269
00:12:58,578 --> 00:13:00,847 line:-1
while also ensuring that
collection values


270
00:13:00.847 --> 00:13:03.850 line:-1 position:50%
are safe to pass around
without these mutations


271
00:13:03.850 --> 00:13:08.154 line:-1 position:50%
leading to unexpected changes
in any of the copies created.


272
00:13:08,154 --> 00:13:11,824 line:-1
However, there are so many more
data structures out there.


273
00:13:11,824 --> 00:13:16,195 line:-1
It would be useful to have a
larger selection to choose from.


274
00:13:16,195 --> 00:13:19,899 position:50%
Earlier this year, we released
the Swift Collections package,


275
00:13:19,899 --> 00:13:22,969 position:50%
with new data structure
implementations.


276
00:13:22,969 --> 00:13:24,904 position:50%
This package lets
Swift developers


277
00:13:24,904 --> 00:13:27,573 position:50%
gain real-life production
experience


278
00:13:27,573 --> 00:13:31,177 line:0
with new collection types before
we eventually propose them


279
00:13:31,177 --> 00:13:35,481 position:50%
for inclusion in the Swift
standard library.


280
00:13:35,481 --> 00:13:37,950 line:-1
By importing the
Swift Collections package,


281
00:13:37,950 --> 00:13:40,753 line:-1
we get access
to additional types.


282
00:13:40,753 --> 00:13:42,822 line:-1
The initial version
of the package implements


283
00:13:42,822 --> 00:13:46,526 line:-1
three of the most frequently
requested data structures.


284
00:13:46,526 --> 00:13:48,461 line:-1
These happen
to be new variations


285
00:13:48,461 --> 00:13:51,998 line:-1
of the three
standard collection types.


286
00:13:51.998 --> 00:13:56.302 line:-1 position:50%
We have a double-ended queue,
an OrderedSet,


287
00:13:56,302 --> 00:13:59,472 line:-1
and an OrderedDictionary.


288
00:13:59.472 --> 00:14:03.042 line:-1 position:50%
These are similar to array,
set, and dictionary;


289
00:14:03.042 --> 00:14:05.044 line:-1 position:50%
they are variants
of the same theme,


290
00:14:05.044 --> 00:14:08.114 line:-1 position:50%
adding new features
to the existing constructs.


291
00:14:08,114 --> 00:14:10,817 line:-1
That said, these new types
aren't replacements


292
00:14:10.817 --> 00:14:15.555 line:-1 position:50%
for the existing ones;
they are complementary to them.


293
00:14:15.555 --> 00:14:16.656 line:-1 position:50%
For some use cases,


294
00:14:16.656 --> 00:14:18.758 line:-1 position:50%
the new types
will be a better fit.


295
00:14:18,758 --> 00:14:20,159 line:-1
However, for many others,


296
00:14:20,159 --> 00:14:23,396 line:-1
the existing types continue
to be the right choice.


297
00:14:23.396 --> 00:14:26.132 line:-1 position:50%
In order to know which
data structure to reach for,


298
00:14:26,132 --> 00:14:30,636 line:-1
we need to learn how these
differ from the existing types.


299
00:14:30,636 --> 00:14:32,839 line:-1
So let's take a brief look
at each of these,


300
00:14:32,839 --> 00:14:34,640 line:-1
starting with
double-ended queues --


301
00:14:34.640 --> 00:14:38.411 line:-1 position:50%
or, rather, queues in general.


302
00:14:38.411 --> 00:14:41.914 line:-1 position:50%
Queues pop up everywhere where
an arbitrary number of items


303
00:14:41.914 --> 00:14:44.016 line:-1 position:50%
need to be processed
one by one,


304
00:14:44,016 --> 00:14:47,253 line:-1
from customers waiting in line
in a supermarket


305
00:14:47.253 --> 00:14:51.157 line:-1 position:50%
to asynchronous tasks
in an application.


306
00:14:51,157 --> 00:14:52,825 line:-1
In their most abstract form,


307
00:14:52.825 --> 00:14:55.962 line:-1 position:50%
queues provide
two major operations:


308
00:14:55,962 --> 00:14:59,766 line:-1
we can push items
to the back of the queue,


309
00:14:59,766 --> 00:15:02,368 line:-1
and we can pop elements
off the front.


310
00:15:06,873 --> 00:15:10,543 line:0
A double-ended queue makes these
queue operations symmetric.


311
00:15:10,543 --> 00:15:13,246 line:0
It supports efficiently
pushing new items


312
00:15:13,246 --> 00:15:16,682 line:0
to the front of the queue...


313
00:15:16,682 --> 00:15:20,086 line:0
...as well as popping elements
off the back.


314
00:15:23.689 --> 00:15:26.325 line:-1 position:50%
The name "double-ended queue"
is quite a mouthful


315
00:15:26.325 --> 00:15:27.960 line:-1 position:50%
for such a useful type,


316
00:15:27,960 --> 00:15:30,396 line:-1
so we like to shorten
it to "deque".


317
00:15:30,396 --> 00:15:32,598 line:-1
And to shave off
one more syllable,


318
00:15:32,598 --> 00:15:35,101 line:-1
this is traditionally
pronounced "deck",


319
00:15:35.101 --> 00:15:37.403 line:-1 position:50%
like a deck of cards.


320
00:15:37.403 --> 00:15:38.938 line:-1 position:50%
In the Collections package,


321
00:15:38,938 --> 00:15:42,775 line:-1
deque has roughly the same API
as the familiar array type,


322
00:15:42.775 --> 00:15:45.945 line:-1 position:50%
and it implements many
of the same protocols.


323
00:15:45.945 --> 00:15:51.350 line:-1 position:50%
For example, we can use an
array literal to create a deque.


324
00:15:51,350 --> 00:15:54,654 line:-1
Deque conforms to the
RandomAccessCollection protocol.


325
00:15:54.654 --> 00:15:58.257 line:-1 position:50%
Like array, deque uses
integer indices that are offsets


326
00:15:58.257 --> 00:16:00.793 line:-1 position:50%
measured from the start
of the collection.


327
00:16:00.793 --> 00:16:04.630 line:-1 position:50%
This makes it easy to access any
element based on its position.


328
00:16:04,630 --> 00:16:06,032 line:-1
For example,


329
00:16:06,032 --> 00:16:11,704 line:-1
the element at index 1
in this deque is the letter E.


330
00:16:11.704 --> 00:16:14.073 line:-1 position:50%
Now, I'm sure I'm not
the only one who is bothered


331
00:16:14.073 --> 00:16:17.343 line:-1 position:50%
by that lowercase f
at the end of this collection.


332
00:16:17,343 --> 00:16:20,413 line:0
Luckily, deque conforms to the
MutableCollection protocol,


333
00:16:20,413 --> 00:16:24,217 line:0
so we can fix this by assigning
through the index 2,


334
00:16:24,217 --> 00:16:28,187 line:0
replacing the lowercase f
with an uppercase one.


335
00:16:28,187 --> 00:16:30,890 line:0
Ah, that looks so much better!


336
00:16:30.890 --> 00:16:32.091 line:-1 position:50%
Deque also implements


337
00:16:32.091 --> 00:16:34.327 line:-1 position:50%
the RangeReplaceableCollection
protocol,


338
00:16:34.327 --> 00:16:37.029 line:-1 position:50%
so it provides all of
the familiar operations


339
00:16:37.029 --> 00:16:42.101 line:-1 position:50%
for inserting, removing, or
replacing subranges of elements.


340
00:16:42,101 --> 00:16:44,604 position:50%
For example,
we can insert a sequence


341
00:16:44,604 --> 00:16:46,239 line:0
at the front of our deque
by calling


342
00:16:46,239 --> 00:16:50,343 line:0
the insert(contentsOf:) method
with an index of zero.


343
00:16:50,343 --> 00:16:53,813 line:0
How it executes this
is where deque starts to differ


344
00:16:53,813 --> 00:16:55,481 line:0
from an array.


345
00:16:55,481 --> 00:16:58,451 position:50%
If we used an array
to store our items,


346
00:16:58,451 --> 00:17:01,153 line:0
then inserting new elements
at the front


347
00:17:01,153 --> 00:17:04,090 position:50%
would need to start by moving
the existing elements


348
00:17:04,090 --> 00:17:06,859 line:0
to make room for the new ones.


349
00:17:06,859 --> 00:17:09,528 position:50%
To make accesses
as simple as possible,


350
00:17:09,528 --> 00:17:12,732 line:0
arrays keep their elements
in a single contiguous buffer,


351
00:17:12,732 --> 00:17:15,968 line:0
starting at the beginning
of their storage.


352
00:17:15,968 --> 00:17:17,503 position:50%
If the array is large,


353
00:17:17,503 --> 00:17:21,307 position:50%
this makes prepending new
elements relatively expensive;


354
00:17:21.307 --> 00:17:24.610 line:-1 position:50%
so inserting a new element
at the front takes time


355
00:17:24.610 --> 00:17:27.179 line:-1 position:50%
that is roughly proportional
to the number of elements


356
00:17:27.179 --> 00:17:30.316 line:-1 position:50%
that are already in the array.


357
00:17:30,316 --> 00:17:32,618 line:-1
A deque works differently.


358
00:17:32,618 --> 00:17:35,688 line:0
It wraps its storage buffer
around its boundaries


359
00:17:35,688 --> 00:17:37,857 line:0
so that it can prepend
new elements


360
00:17:37,857 --> 00:17:41,861 line:0
without moving
any of the existing ones.


361
00:17:41,861 --> 00:17:43,930 line:0
The indices are still offsets


362
00:17:43,930 --> 00:17:46,232 position:50%
from the logical start
of the collection,


363
00:17:46,232 --> 00:17:51,337 line:0
so after the insertion, the
element at index 1 is now B.


364
00:17:51.337 --> 00:17:54.373 line:-1 position:50%
This means that deques
need to do some work


365
00:17:54,373 --> 00:17:56,842 line:-1
to translate between
their logical indices


366
00:17:56,842 --> 00:17:59,145 line:-1
and their actual
storage positions,


367
00:17:59,145 --> 00:18:03,249 line:-1
but accessing elements
is still quite efficient.


368
00:18:03,249 --> 00:18:05,985 line:0
And because prepending
to a deque doesn't involve


369
00:18:05,985 --> 00:18:07,987 line:0
sliding any existing members,


370
00:18:07,987 --> 00:18:10,189 line:0
they are able to perform
this operation


371
00:18:10,189 --> 00:18:12,525 position:50%
radically faster than array.


372
00:18:12.525 --> 00:18:14.760 line:-1 position:50%
Inserting a new element
at the front


373
00:18:14.760 --> 00:18:16.729 line:-1 position:50%
takes a constant amount of time,


374
00:18:16,729 --> 00:18:20,800 line:-1
no matter how many elements
are already in the collection.


375
00:18:20,800 --> 00:18:23,302 line:-1
This is the power
of data structures.


376
00:18:23,302 --> 00:18:25,071 line:-1
Once we have them
in our toolbox,


377
00:18:25.071 --> 00:18:26.872 line:-1 position:50%
we can use them
to solve problems


378
00:18:26,872 --> 00:18:28,975 line:-1
that were previously
out of reach.


379
00:18:28.975 --> 00:18:31.010 line:-1 position:50%
Switching to the right
data structure


380
00:18:31,010 --> 00:18:32,845 line:-1
can make all the difference.


381
00:18:32,845 --> 00:18:35,047 line:-1
It can turn an unusably slow app


382
00:18:35,047 --> 00:18:39,485 line:-1
into a responsive wonder
that is a joy to use.


383
00:18:39,485 --> 00:18:41,587 line:-1
Of course,
deques can also be clever


384
00:18:41,587 --> 00:18:43,456 line:-1
about how they perform
operations


385
00:18:43,456 --> 00:18:46,425 line:-1
in the middle of their storage.


386
00:18:46.425 --> 00:18:49.295 line:-1 position:50%
For instance, when removing
a range of elements,


387
00:18:49,295 --> 00:18:52,732 line:-1
deque has the option of closing
the resulting gap by


388
00:18:52,732 --> 00:18:56,369 line:-1
moving the preceding elements
rather than the subsequent ones,


389
00:18:56.369 --> 00:18:58.270 line:-1 position:50%
and this can reduce
the number of elements


390
00:18:58.270 --> 00:19:00.339 line:-1 position:50%
that need to be moved.


391
00:19:00,339 --> 00:19:02,808 line:-1
This isn't as drastic
an improvement


392
00:19:02.808 --> 00:19:04.810 line:-1 position:50%
as prepending an element was,


393
00:19:04.810 --> 00:19:07.279 line:-1 position:50%
but when we are removing
elements at random,


394
00:19:07.279 --> 00:19:10.916 line:-1 position:50%
it does make things twice
as fast on average.


395
00:19:10,916 --> 00:19:12,952 line:-1
So, that's deque.


396
00:19:12.952 --> 00:19:17.089 line:-1 position:50%
Now, let's take a look
at ordered sets.


397
00:19:17.089 --> 00:19:20.760 line:-1 position:50%
The standard, preexisting
set type is a collection


398
00:19:20,760 --> 00:19:23,863 line:-1
that guarantees that all
of its elements are unique.


399
00:19:23,863 --> 00:19:27,533 line:-1
However, it doesn't preserve
their original ordering.


400
00:19:27.533 --> 00:19:33.205 line:-1 position:50%
In fact, the order of elements
in a set is effectively random.


401
00:19:33,205 --> 00:19:37,209 position:50%
This means that two instances
of the same set often list them


402
00:19:37,209 --> 00:19:43,049 position:50%
in two entirely different
permutations.


403
00:19:43,049 --> 00:19:46,619 line:0
Despite this, two sets
containing the same elements


404
00:19:46,619 --> 00:19:51,424 position:50%
are considered equal;
the order is not significant.


405
00:19:51,424 --> 00:19:54,860 line:-1
This is great when all we want
is to guarantee uniqueness,


406
00:19:54.860 --> 00:19:57.129 line:-1 position:50%
but sometimes we
also want to be in control


407
00:19:57.129 --> 00:19:59.498 line:-1 position:50%
of how the elements are ordered.


408
00:19:59,498 --> 00:20:02,768 line:-1
For example, if we are writing
a to-do list app,


409
00:20:02.768 --> 00:20:06.906 line:-1 position:50%
we may want to ensure that
it lists each item only once,


410
00:20:06,906 --> 00:20:09,175 line:-1
but we also need to keep them
in the specific order


411
00:20:09,175 --> 00:20:11,710 line:-1
set by the user.


412
00:20:11,710 --> 00:20:14,613 line:-1
So that is what
an ordered set does.


413
00:20:14,613 --> 00:20:16,082 line:-1
Depending on our viewpoint,


414
00:20:16,082 --> 00:20:19,985 line:-1
it works either like an array
that keeps its elements unique,


415
00:20:19.985 --> 00:20:21.720 line:-1 position:50%
or we can view it as a set


416
00:20:21,720 --> 00:20:26,759 line:-1
that preserves the order
we establish on its members.


417
00:20:26,759 --> 00:20:28,494 line:-1
Like arrays and sets,


418
00:20:28,494 --> 00:20:32,932 line:-1
ordered sets are also
expressible by array literals.


419
00:20:32,932 --> 00:20:34,467 line:-1
However, unlike a set,


420
00:20:34,467 --> 00:20:38,804 line:-1
the order of elements is
guaranteed to be preserved.


421
00:20:38,804 --> 00:20:43,676 line:0
The order is also significant;
two ordered sets compare equal


422
00:20:43,676 --> 00:20:46,045 line:0
if they contain not
just the same members,


423
00:20:46,045 --> 00:20:49,281 position:50%
but they must
also be in the same order.


424
00:20:49,281 --> 00:20:51,417 line:-1
If we just need to know
if two ordered sets


425
00:20:51.417 --> 00:20:54.253 line:-1 position:50%
contain the same elements,
in any order,


426
00:20:54.253 --> 00:20:57.923 line:-1 position:50%
then we can compare them through
the special unordered view.


427
00:20:57,923 --> 00:21:00,893 line:0
This lightweight view
ignores element ordering,


428
00:21:00,893 --> 00:21:02,528 line:0
so it provides
a more conventional,


429
00:21:02,528 --> 00:21:05,397 position:50%
set-like interface.


430
00:21:05,397 --> 00:21:09,335 line:-1
By default, though, ordered sets
resemble how arrays work.


431
00:21:09.335 --> 00:21:11.937 line:-1 position:50%
This is reinforced by
the fact that ordered sets


432
00:21:11.937 --> 00:21:16.976 line:-1 position:50%
are random access collections
with integer offset indices.


433
00:21:16.976 --> 00:21:20.246 line:-1 position:50%
We can use integer subscripts
to access items,


434
00:21:20,246 --> 00:21:23,716 line:-1
just like in an array
or a deque.


435
00:21:23,716 --> 00:21:25,351 line:-1
As expected from a set,


436
00:21:25.351 --> 00:21:27.586 line:-1 position:50%
we can also add
and remove elements,


437
00:21:27,586 --> 00:21:30,289 line:-1
although these operations
do need to take the position


438
00:21:30.289 --> 00:21:32.358 line:-1 position:50%
into account.


439
00:21:32.358 --> 00:21:35.528 line:-1 position:50%
For instance,
we have an append operation


440
00:21:35,528 --> 00:21:37,796 line:-1
that adds a new element
to the end of the set


441
00:21:37,796 --> 00:21:40,132 line:-1
if it isn't already a member.


442
00:21:40,132 --> 00:21:42,001 line:-1
Its return value indicates


443
00:21:42.001 --> 00:21:44.436 line:-1 position:50%
whether the element
needed to be added,


444
00:21:44,436 --> 00:21:48,641 line:-1
and it also reports
the index of the item.


445
00:21:48,641 --> 00:21:51,577 line:0
We also have an insert operation
that puts the new element


446
00:21:51,577 --> 00:21:53,612 position:50%
at the specified location.


447
00:21:53,612 --> 00:21:56,882 line:0
In this case, the letter B
already exists,


448
00:21:56,882 --> 00:21:59,351 line:0
so the operation
simply returns the index


449
00:21:59,351 --> 00:22:01,854 position:50%
of the existing member.


450
00:22:01,854 --> 00:22:05,824 position:50%
Removing an element leaves
a hole in the ordered set,


451
00:22:05,824 --> 00:22:08,861 line:0
and the rest of the members
need to be moved to fill it,


452
00:22:08,861 --> 00:22:11,197 position:50%
just like in an array.


453
00:22:11,197 --> 00:22:13,666 position:50%
Ordered sets need to keep
their elements unique,


454
00:22:13,666 --> 00:22:17,136 line:0
so they can't support arbitrary
item replacements.


455
00:22:17,136 --> 00:22:19,171 line:0
This means that unlike arrays,


456
00:22:19,171 --> 00:22:21,473 position:50%
they can't conform
to the MutableCollection


457
00:22:21,473 --> 00:22:24,810 line:0
or RangeReplaceableCollection
protocols.


458
00:22:24,810 --> 00:22:28,414 position:50%
However, they do support
standard reordering operations


459
00:22:28,414 --> 00:22:32,985 position:50%
such as sorting or shuffling.


460
00:22:32,985 --> 00:22:36,689 position:50%
Ordered sets also implement
all high-level set operations


461
00:22:36,689 --> 00:22:42,761 position:50%
from the SetAlgebra protocol,
in an order-preserving manner.


462
00:22:42,761 --> 00:22:46,532 line:0
For example, forming a union
appends any missing elements,


463
00:22:46,532 --> 00:22:51,704 line:0
in the order they appear
in the second set.


464
00:22:51,704 --> 00:22:54,273 line:0
Subtracting a set keeps
the remaining elements


465
00:22:54,273 --> 00:22:56,909 line:0
in their original order.


466
00:22:56,909 --> 00:22:58,377 position:50%
Even though the ordered sets


467
00:22:58,377 --> 00:23:01,146 line:0
implement most
SetAlgebra operations,


468
00:23:01,146 --> 00:23:03,816 position:50%
they cannot officially conform
to that protocol


469
00:23:03,816 --> 00:23:06,352 position:50%
because it requires that
the order of elements


470
00:23:06,352 --> 00:23:08,687 line:0
must not matter.


471
00:23:08,687 --> 00:23:10,823 position:50%
However, their unordered view


472
00:23:10,823 --> 00:23:13,592 position:50%
has an order-insensitive
concept of equality.


473
00:23:13,592 --> 00:23:16,762 position:50%
So it can and does conform
to SetAlgebra.


474
00:23:16,762 --> 00:23:19,331 line:0
We can use it to pass
OrderedSet values


475
00:23:19,331 --> 00:23:23,636 position:50%
to any function that requires
a SetAlgebra value.


476
00:23:23,636 --> 00:23:25,904 line:-1
Looking under the hood,
the standard,


477
00:23:25,904 --> 00:23:28,774 line:-1
unordered set type
stores its elements


478
00:23:28,774 --> 00:23:30,609 line:-1
directly in a flat hash table


479
00:23:30.609 --> 00:23:34.413 line:-1 position:50%
using a randomly seeded
universal hash function.


480
00:23:34.413 --> 00:23:37.549 line:-1 position:50%
This provides great lookup
performance for the elements,


481
00:23:37,549 --> 00:23:40,686 line:-1
but it discards
their original ordering.


482
00:23:40,686 --> 00:23:42,021 line:-1
To support arbitrary,


483
00:23:42.021 --> 00:23:44.256 line:-1 position:50%
user-specified
element orderings,


484
00:23:44,256 --> 00:23:46,558 line:-1
an ordered set
stores its elements


485
00:23:46.558 --> 00:23:50.562 line:-1 position:50%
in a regular array
instance, instead.


486
00:23:50,562 --> 00:23:52,865 line:-1
Ordered set still uses
the same fast


487
00:23:52.865 --> 00:23:55.167 line:-1 position:50%
and secure hash table
implementation,


488
00:23:55,167 --> 00:23:56,302 line:-1
but in this case,


489
00:23:56.302 --> 00:23:59.038 line:-1 position:50%
the table only needs
to store integer indices


490
00:23:59.038 --> 00:24:01.540 line:-1 position:50%
into the storage array.


491
00:24:01.540 --> 00:24:04.209 line:-1 position:50%
The range of these integers
is bound by the size


492
00:24:04.209 --> 00:24:06.945 line:-1 position:50%
of the hash table,
so we can compress the table


493
00:24:06.945 --> 00:24:11.984 line:-1 position:50%
by packing the integer values
into as few bits as possible.


494
00:24:11,984 --> 00:24:15,354 line:-1
This can sometimes save
a considerable amount of memory


495
00:24:15,354 --> 00:24:17,056 line:-1
compared to a regular set


496
00:24:17.056 --> 00:24:19.491 line:-1 position:50%
while still maintaining
competitive performance


497
00:24:19,491 --> 00:24:22,361 line:-1
for most operations.


498
00:24:22.361 --> 00:24:25.698 line:-1 position:50%
Lookup performance is comparable
to the standard set.


499
00:24:25,698 --> 00:24:28,867 line:-1
Finding a random member
takes roughly constant time,


500
00:24:28,867 --> 00:24:31,437 line:-1
no matter the size
of the collection.


501
00:24:31,437 --> 00:24:34,373 position:50%
Array needs to laboriously
look at each element,


502
00:24:34,373 --> 00:24:38,277 position:50%
which takes longer time
as the collection grows.


503
00:24:38,277 --> 00:24:40,546 position:50%
Appending a new element
to an ordered set


504
00:24:40,546 --> 00:24:44,149 position:50%
also performs roughly comparably
to inserting an element


505
00:24:44,149 --> 00:24:46,185 line:0
into a standard set.


506
00:24:46,185 --> 00:24:48,354 line:0
This still needs to hash
the new item,


507
00:24:48,354 --> 00:24:51,357 line:0
and it also includes a check
if the element already exists,


508
00:24:51,357 --> 00:24:54,059 line:0
so this is a far
more complicated operation


509
00:24:54,059 --> 00:24:57,262 position:50%
than directly appending
an element to a simple array.


510
00:24:57,262 --> 00:24:59,431 line:0
But these still take
constant time,


511
00:24:59,431 --> 00:25:03,268 position:50%
no matter how large
the collections become.


512
00:25:03,268 --> 00:25:06,271 position:50%
However, while OrderedSet
is able to quickly look up


513
00:25:06,271 --> 00:25:08,974 position:50%
existing elements
and append new ones,


514
00:25:08,974 --> 00:25:12,978 position:50%
it cannot efficiently implement
removing or inserting an item


515
00:25:12,978 --> 00:25:15,914 position:50%
at the front or middle
of the set.


516
00:25:15.914 --> 00:25:19.184 line:-1 position:50%
Like array, these operations
need to slide elements around


517
00:25:19,184 --> 00:25:20,652 line:-1
in the storage array,


518
00:25:20,652 --> 00:25:23,389 line:-1
but they also need to renumber
subsequent indices


519
00:25:23.389 --> 00:25:24.957 line:-1 position:50%
in the hash table.


520
00:25:24.957 --> 00:25:27.426 line:-1 position:50%
This means that removals
and insertions


521
00:25:27.426 --> 00:25:30.195 line:-1 position:50%
turn into operations
with linear complexity,


522
00:25:30,195 --> 00:25:34,133 line:-1
making these slower
than the regular set.


523
00:25:34.133 --> 00:25:36.235 line:-1 position:50%
There is always a trade-off!


524
00:25:36,235 --> 00:25:39,905 line:-1
But once we get familiar with
how these data structures work,


525
00:25:39,905 --> 00:25:42,408 line:-1
we will be able to confidently
select the right one


526
00:25:42.408 --> 00:25:43.942 line:-1 position:50%
to solve any problem,


527
00:25:43,942 --> 00:25:46,445 line:-1
based on the requirements
we need to satisfy


528
00:25:46.445 --> 00:25:50.382 line:-1 position:50%
and the operations
that are important to optimize.


529
00:25:50.382 --> 00:25:52.818 line:-1 position:50%
Selecting the right data
structure can lead


530
00:25:52.818 --> 00:25:56.121 line:-1 position:50%
to an algorithmic improvement
that can result in hundreds,


531
00:25:56,121 --> 00:25:59,057 line:-1
or even thousands,
of times faster code.


532
00:25:59,057 --> 00:26:01,994 line:-1
Selecting the wrong one
can do the opposite.


533
00:26:01,994 --> 00:26:04,430 line:-1
So I think it's useful
to learn about these


534
00:26:04.430 --> 00:26:07.399 line:-1 position:50%
because, ultimately,
it results in great apps


535
00:26:07.399 --> 00:26:10.335 line:-1 position:50%
and happy users.


536
00:26:10.335 --> 00:26:13.205 line:-1 position:50%
This new OrderedSet type
is a pure Swift variant


537
00:26:13,205 --> 00:26:16,875 line:-1
of the existing NSOrderedSet
type in Foundation.


538
00:26:16.875 --> 00:26:20.112 line:-1 position:50%
However, because OrderedSet
is implemented in a package,


539
00:26:20,112 --> 00:26:22,681 line:-1
it doesn't bridge
with NSOrderedSet.


540
00:26:22,681 --> 00:26:25,918 line:-1
This means existing
Objective-C APIs


541
00:26:25,918 --> 00:26:29,455 line:-1
won't get automatically imported
to use the new type.


542
00:26:29.455 --> 00:26:32.057 line:-1 position:50%
These are separate things.


543
00:26:33.759 --> 00:26:35.160 line:-1 position:50%
The third data structure


544
00:26:35.160 --> 00:26:37.095 line:-1 position:50%
provided by
the Collections package


545
00:26:37.095 --> 00:26:42.367 line:-1 position:50%
is an ordered analogue
of the standard dictionary type.


546
00:26:42,367 --> 00:26:44,069 line:-1
Like the standard dictionary,


547
00:26:44.069 --> 00:26:46.338 line:-1 position:50%
this is a sequence
of key-value pairs


548
00:26:46.338 --> 00:26:48.674 line:-1 position:50%
that lets us use
a key as a subscript


549
00:26:48.674 --> 00:26:52.778 line:-1 position:50%
to quickly look up
its corresponding value.


550
00:26:52.778 --> 00:26:54.580 line:-1 position:50%
Unlike the regular dictionary,


551
00:26:54.580 --> 00:26:57.282 line:-1 position:50%
the order of key-value pairs
is well-defined.


552
00:26:57.282 --> 00:26:59.852 line:-1 position:50%
By default, it follows the order
in which the keys


553
00:26:59.852 --> 00:27:03.889 line:-1 position:50%
were originally inserted.


554
00:27:03,889 --> 00:27:05,757 position:50%
To append a new element,


555
00:27:05,757 --> 00:27:09,361 position:50%
we can assign a value
to a new key.


556
00:27:09,361 --> 00:27:12,030 position:50%
We can remove elements
by assigning nil


557
00:27:12,030 --> 00:27:14,700 line:0
to an existing key.


558
00:27:14,700 --> 00:27:17,436 position:50%
Throughout these operations,
the ordered dictionary


559
00:27:17,436 --> 00:27:21,440 line:0
maintains its contents
in a well-defined order.


560
00:27:23,942 --> 00:27:27,513 position:50%
Ordered dictionaries use
array-like integer indices,


561
00:27:27,513 --> 00:27:30,549 position:50%
but this introduces
an interesting issue.


562
00:27:30,549 --> 00:27:32,317 position:50%
In our example dictionary,


563
00:27:32,317 --> 00:27:34,152 position:50%
the indexing
subscript operation


564
00:27:34,152 --> 00:27:37,055 line:0
conflicts with
the key subscript.


565
00:27:37,055 --> 00:27:39,124 line:-1
When we subscript with zero,


566
00:27:39,124 --> 00:27:42,794 line:-1
do we mean to access the value
for the key zero


567
00:27:42,794 --> 00:27:47,466 line:-1
or do we mean to retrieve the
key-value pair at offset zero?


568
00:27:49,201 --> 00:27:51,270 line:-1
We think that
the key-based subscript


569
00:27:51.270 --> 00:27:54.106 line:-1 position:50%
is the primary operation
for a dictionary type,


570
00:27:54,106 --> 00:27:56,108 line:-1
so to prevent this ambiguity,


571
00:27:56,108 --> 00:27:58,911 line:-1
subscripting an ordered
dictionary always means


572
00:27:58,911 --> 00:28:00,712 line:-1
the keying subscript.


573
00:28:00.712 --> 00:28:02.748 line:-1 position:50%
OrderedDictionary
doesn't provide


574
00:28:02,748 --> 00:28:06,552 line:-1
an indexing subscript
operation at all.


575
00:28:06,552 --> 00:28:08,220 line:-1
This means that
OrderedDictionary


576
00:28:08.220 --> 00:28:09.888 line:-1 position:50%
cannot be a collection,


577
00:28:09,888 --> 00:28:14,359 line:-1
because the collection protocol
requires such a subscript.


578
00:28:14.359 --> 00:28:16.194 line:-1 position:50%
Therefore, OrderedDictionary


579
00:28:16,194 --> 00:28:19,831 line:-1
only conforms
to the sequence protocol.


580
00:28:19.831 --> 00:28:22.301 line:-1 position:50%
However, for cases where
a collection conformance


581
00:28:22.301 --> 00:28:23.502 line:-1 position:50%
is desirable,


582
00:28:23,502 --> 00:28:27,072 line:-1
OrderedDictionary provides
the special elements view.


583
00:28:27,072 --> 00:28:29,207 line:0
Elements is
a random-access collection


584
00:28:29,207 --> 00:28:31,209 position:50%
that provides
an indexing subscript


585
00:28:31,209 --> 00:28:35,581 line:0
returning a key-value pair.


586
00:28:35,581 --> 00:28:38,250 line:0
Looking at the underlying
implementation,


587
00:28:38,250 --> 00:28:41,286 line:0
while the regular dictionary
type uses two separate


588
00:28:41,286 --> 00:28:45,157 position:50%
hash tables for storing keys
and values respectively,


589
00:28:45,157 --> 00:28:49,161 position:50%
an ordered dictionary uses a
single compressed hash table


590
00:28:49,161 --> 00:28:52,164 position:50%
and two parallel arrays instead.


591
00:28:52,164 --> 00:28:56,835 line:0
This can save even more space
than ordered sets do.


592
00:28:56,835 --> 00:28:59,171 line:-1
So these are the three
new data structures


593
00:28:59.171 --> 00:29:01.740 line:-1 position:50%
available in the
Collections package.


594
00:29:01.740 --> 00:29:03.241 line:-1 position:50%
By using these constructs,


595
00:29:03.241 --> 00:29:05.444 line:-1 position:50%
we can boost the performance
of our apps,


596
00:29:05.444 --> 00:29:08.513 line:-1 position:50%
or reduce memory use or --
just as importantly --


597
00:29:08.513 --> 00:29:09.982 line:-1 position:50%
we can express constraints


598
00:29:09.982 --> 00:29:14.019 line:-1 position:50%
that we weren't able to easily
satisfy with the standard types,


599
00:29:14,019 --> 00:29:17,489 line:-1
such as preserving
element ordering in a set.


600
00:29:17,489 --> 00:29:18,657 line:-1
Because these new types


601
00:29:18,657 --> 00:29:21,860 line:-1
all conform to some sequence
and collection protocols,


602
00:29:21,860 --> 00:29:24,129 line:-1
they also interoperate
with the algorithms


603
00:29:24.129 --> 00:29:26.098 line:-1 position:50%
provided by the standard library


604
00:29:26,098 --> 00:29:27,933 line:-1
as well as the new
Algorithms package


605
00:29:27.933 --> 00:29:30.969 line:-1 position:50%
that Kyle showed us earlier.


606
00:29:30,969 --> 00:29:33,338 line:-1
Swift Collections
and Swift Algorithms


607
00:29:33,338 --> 00:29:35,774 line:-1
are only two of the new members
of our growing list


608
00:29:35.774 --> 00:29:38.076 line:-1 position:50%
of open-source packages.


609
00:29:38,076 --> 00:29:41,813 line:-1
The future of the Swift library
ecosystem is being molded


610
00:29:41.813 --> 00:29:44.282 line:-1 position:50%
right now, as we push
onto new platforms


611
00:29:44,282 --> 00:29:45,917 line:-1
and into new domains.


612
00:29:45.917 --> 00:29:48.053 line:-1 position:50%
And this is being done
in plain sight


613
00:29:48,053 --> 00:29:51,590 line:-1
as we increasingly leverage
open-source packages.


614
00:29:51,590 --> 00:29:54,860 line:-1
We're deliberately releasing
these packages early,


615
00:29:54.860 --> 00:29:56.795 line:-1 position:50%
while they're still pliable,


616
00:29:56,795 --> 00:30:01,199 line:-1
and we're developing them
as community efforts on GitHub.


617
00:30:01,199 --> 00:30:02,668 line:-1
So try them out.


618
00:30:02,668 --> 00:30:05,704 line:-1
File an issue.
Open a pull request.


619
00:30:05,704 --> 00:30:08,974 line:-1
It's never been a better time,
and it's never been easier


620
00:30:08,974 --> 00:30:11,610 line:-1
to get involved
and make an impact.


621
00:30:11,610 --> 00:30:15,047 line:-1
I hope you're as excited about
these new Swift packages


622
00:30:15.047 --> 00:30:16.248 line:-1 position:50%
as we are.


623
00:30:16.248 --> 00:30:19.451 line:-1 position:50%
We can't wait to see
what you build with these!


624
00:30:19.451 --> 00:30:20.886 line:-1 position:50%
Thank you for watching,


625
00:30:20,886 --> 00:30:23,021 line:-1
and enjoy
the rest of the conference!


626
00:30:23,021 --> 00:30:26,258 align:center size:2% position:89%
♪

