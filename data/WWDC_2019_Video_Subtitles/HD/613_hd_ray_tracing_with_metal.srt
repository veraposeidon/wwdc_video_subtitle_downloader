1
00:00:01,176 --> 00:00:04,500
[ Music ]


2
00:00:10,516 --> 00:00:14,546
[ Applause ]


3
00:00:15,046 --> 00:00:15,836
>> Good morning everyone.


4
00:00:16,245 --> 00:00:17,746
My name is Sean and I'm an


5
00:00:17,746 --> 00:00:19,376
engineer on Apple's GPU Software


6
00:00:19,376 --> 00:00:19,736
Team.


7
00:00:20,856 --> 00:00:21,686
In this session we're going to


8
00:00:21,686 --> 00:00:22,706
talk about Ray Tracing.


9
00:00:23,336 --> 00:00:24,606
So, let's first review what Ray


10
00:00:24,606 --> 00:00:25,866
Tracing is.


11
00:00:26,556 --> 00:00:27,976
Ray Tracing applications are


12
00:00:27,976 --> 00:00:29,346
based on tracing the paths the


13
00:00:29,346 --> 00:00:30,816
rays take as they interact with


14
00:00:30,816 --> 00:00:31,296
a scene.


15
00:00:32,076 --> 00:00:33,796
So, Ray Tracing has applications


16
00:00:33,796 --> 00:00:35,666
in rendering, audio, physics


17
00:00:35,666 --> 00:00:36,836
simulation, and more.


18
00:00:37,926 --> 00:00:39,336
In particular Ray Tracing is


19
00:00:39,336 --> 00:00:41,016
often used in offline rendering


20
00:00:41,016 --> 00:00:42,686
applications to simulate


21
00:00:42,686 --> 00:00:43,886
individual rays of light


22
00:00:43,886 --> 00:00:44,886
bouncing around a scene.


23
00:00:45,586 --> 00:00:47,086
This allows these applications


24
00:00:47,086 --> 00:00:48,166
to render photo realistic


25
00:00:48,196 --> 00:00:49,756
reflections, refractions,


26
00:00:49,926 --> 00:00:51,706
shadows, global illumination,


27
00:00:51,976 --> 00:00:56,336
and more.


28
00:00:56,556 --> 00:00:58,076
Recently, Ray Tracing has also


29
00:00:58,076 --> 00:00:59,336
started to be used in real-time


30
00:00:59,336 --> 00:01:00,366
applications such as games.


31
00:01:00,366 --> 00:01:02,606
And this actually introduces


32
00:01:02,606 --> 00:01:03,596
some new requirements.


33
00:01:05,016 --> 00:01:07,036
First, in real-time applications


34
00:01:07,036 --> 00:01:08,256
objects tend to move around.


35
00:01:08,326 --> 00:01:09,436
So, we need to be able to


36
00:01:09,436 --> 00:01:10,926
support both camera and object


37
00:01:10,926 --> 00:01:11,406
motion.


38
00:01:12,376 --> 00:01:14,466
Second, performance is now even


39
00:01:14,466 --> 00:01:15,136
more critical.


40
00:01:15,896 --> 00:01:16,726
This means that the ray


41
00:01:16,726 --> 00:01:18,206
intersection itself has to be as


42
00:01:18,206 --> 00:01:20,016
efficient as possible and we


43
00:01:20,016 --> 00:01:21,406
also have to make effective use


44
00:01:21,406 --> 00:01:22,546
of our limited ray budget.


45
00:01:23,576 --> 00:01:24,746
So, we need to careful with our


46
00:01:24,746 --> 00:01:26,196
sampling strategies, random


47
00:01:26,196 --> 00:01:28,256
number generation, and so on.


48
00:01:29,236 --> 00:01:30,746
Finally, even with these


49
00:01:30,746 --> 00:01:31,956
techniques we won't be able to


50
00:01:31,956 --> 00:01:33,376
cast enough rays to remove all


51
00:01:33,376 --> 00:01:33,756
the noise.


52
00:01:34,386 --> 00:01:35,446
So, we need a sophisticated


53
00:01:35,446 --> 00:01:36,606
noise reduction strategy.


54
00:01:37,366 --> 00:01:39,336
Fortunately, Metal has built in


55
00:01:39,336 --> 00:01:41,006
support for Ray Tracing and


56
00:01:41,006 --> 00:01:41,576
Denoising.


57
00:01:41,766 --> 00:01:42,876
So, it's easy to get started.


58
00:01:43,956 --> 00:01:45,146
So, let's first review how Ray


59
00:01:45,146 --> 00:01:46,686
Tracing works in Metal and then


60
00:01:46,686 --> 00:01:47,496
we'll move on to some more


61
00:01:47,496 --> 00:01:48,306
advanced topics.


62
00:01:48,866 --> 00:01:51,656
So, if you look at a typical Ray


63
00:01:51,656 --> 00:01:53,246
Tracing application, they all


64
00:01:53,246 --> 00:01:54,686
follow roughly the same outline.


65
00:01:55,516 --> 00:01:56,946
First, we generate some rays.


66
00:01:57,646 --> 00:01:58,846
Each ray is defined by its


67
00:01:58,886 --> 00:02:00,206
origin point and its direction


68
00:02:00,206 --> 00:02:00,616
vector.


69
00:02:01,816 --> 00:02:03,086
Those rays are then intersected


70
00:02:03,086 --> 00:02:04,136
against the geometry in the


71
00:02:04,136 --> 00:02:05,566
scene, which is usually made of


72
00:02:05,566 --> 00:02:06,076
triangles.


73
00:02:06,746 --> 00:02:08,286
The intersection data could just


74
00:02:08,286 --> 00:02:09,076
be the distance to the


75
00:02:09,076 --> 00:02:10,536
intersection point, but it


76
00:02:10,606 --> 00:02:11,726
typically includes additional


77
00:02:11,726 --> 00:02:13,186
data such as the index of the


78
00:02:13,186 --> 00:02:14,636
triangle that was hit and the


79
00:02:14,636 --> 00:02:15,766
very center coordinates of the


80
00:02:15,766 --> 00:02:17,206
intersection point.


81
00:02:18,636 --> 00:02:19,906
The next step consumes the


82
00:02:19,906 --> 00:02:20,846
intersection results.


83
00:02:21,106 --> 00:02:22,176
For example, in a rendering


84
00:02:22,176 --> 00:02:23,866
application this is typically a


85
00:02:23,866 --> 00:02:25,436
shading step which outputs an


86
00:02:25,436 --> 00:02:25,806
image.


87
00:02:26,566 --> 00:02:27,876
And this step may also generate


88
00:02:27,876 --> 00:02:29,646
additional rays, so we repeat


89
00:02:29,646 --> 00:02:31,056
this process however many times


90
00:02:31,056 --> 00:02:33,996
we need until we're done.


91
00:02:34,176 --> 00:02:35,676
Applications typically intersect


92
00:02:35,786 --> 00:02:37,116
millions of rays with the scene


93
00:02:37,116 --> 00:02:37,736
every frame.


94
00:02:38,786 --> 00:02:40,166
And this core intersection step


95
00:02:40,226 --> 00:02:41,536
is common to all Ray Tracing


96
00:02:41,536 --> 00:02:42,246
applications.


97
00:02:42,936 --> 00:02:44,326
So, this intersection step is


98
00:02:44,326 --> 00:02:47,426
what we accelerate in Metal.


99
00:02:47,566 --> 00:02:49,136
Last year, we introduced the


100
00:02:49,136 --> 00:02:51,486
MPSRayIntersector API, which is


101
00:02:51,486 --> 00:02:52,486
part of the Metal performance


102
00:02:52,486 --> 00:02:53,226
shaders framework.


103
00:02:54,296 --> 00:02:55,806
This API accelerates ray


104
00:02:55,806 --> 00:02:57,946
intersection on the GPU on all


105
00:02:57,946 --> 00:02:59,456
of our Mac and iOS devices.


106
00:03:00,366 --> 00:03:01,556
We talked a lot about this API


107
00:03:01,626 --> 00:03:02,866
in last year's talk, so we'd


108
00:03:02,866 --> 00:03:03,926
encourage you to go back and


109
00:03:03,926 --> 00:03:05,056
review this talk for more


110
00:03:05,056 --> 00:03:05,526
information.


111
00:03:06,486 --> 00:03:08,336
At a high level, this API takes


112
00:03:08,336 --> 00:03:09,496
in batches of rays through a


113
00:03:09,496 --> 00:03:10,176
Metal buffer.


114
00:03:10,996 --> 00:03:11,846
It finds the closest


115
00:03:11,846 --> 00:03:13,406
intersection along each ray and


116
00:03:13,406 --> 00:03:14,746
returns the results in another


117
00:03:14,746 --> 00:03:15,136
buffer.


118
00:03:15,666 --> 00:03:18,376
And all of this work is encoded


119
00:03:18,416 --> 00:03:20,006
into a Metal commandBuffer at


120
00:03:20,006 --> 00:03:21,146
the point in your application


121
00:03:21,146 --> 00:03:21,716
where you'd like to do


122
00:03:21,716 --> 00:03:22,626
intersection testing.


123
00:03:23,236 --> 00:03:26,016
Much of the speed up comes from


124
00:03:26,016 --> 00:03:27,106
building a data structure we


125
00:03:27,106 --> 00:03:28,466
call an acceleration structure.


126
00:03:29,156 --> 00:03:30,546
This data structure recursively


127
00:03:30,546 --> 00:03:32,426
partitions triangles in space so


128
00:03:32,976 --> 00:03:34,266
that we can quickly eliminate


129
00:03:34,266 --> 00:03:35,756
triangles which cannot possibly


130
00:03:35,756 --> 00:03:37,306
intersect a given ray during the


131
00:03:37,306 --> 00:03:38,196
intersection search.


132
00:03:38,706 --> 00:03:41,036
Metal takes care of building


133
00:03:41,036 --> 00:03:42,326
this data structure for you.


134
00:03:42,746 --> 00:03:44,066
All you have to do is specify


135
00:03:44,066 --> 00:03:44,996
when you'd like to build the


136
00:03:44,996 --> 00:03:46,616
acceleration structure, then


137
00:03:46,616 --> 00:03:47,486
simply pass it to the


138
00:03:47,486 --> 00:03:48,696
intersector for intersection


139
00:03:48,696 --> 00:03:49,126
testing.


140
00:03:50,266 --> 00:03:51,436
Now, building this data


141
00:03:51,436 --> 00:03:52,756
structure is typically a fixed


142
00:03:52,756 --> 00:03:54,156
cost paid when your app starts


143
00:03:54,156 --> 00:03:54,366
up.


144
00:03:55,666 --> 00:03:56,536
In last year's version of the


145
00:03:56,536 --> 00:03:58,106
API this data structure was


146
00:03:58,106 --> 00:03:59,386
always built on the CPU.


147
00:04:00,056 --> 00:04:01,156
This year, we've moved the


148
00:04:01,156 --> 00:04:02,756
acceleration structure build to


149
00:04:02,756 --> 00:04:04,716
the GPU, which can significantly


150
00:04:04,716 --> 00:04:06,076
reduce the startup cost.


151
00:04:06,646 --> 00:04:08,006
And even better, the GPU will be


152
00:04:08,006 --> 00:04:09,226
used automatically whenever


153
00:04:09,226 --> 00:04:09,726
possible.


154
00:04:09,856 --> 00:04:10,726
So, you don't need to do


155
00:04:10,726 --> 00:04:12,166
anything to see the speed up in


156
00:04:12,166 --> 00:04:12,796
your applications.


157
00:04:14,406 --> 00:04:15,796
So, let's now revisit our


158
00:04:15,796 --> 00:04:17,305
typical Ray Tracing application


159
00:04:17,396 --> 00:04:18,315
and see what we need to do to


160
00:04:18,315 --> 00:04:19,466
translate it into a Metal Ray


161
00:04:19,466 --> 00:04:20,375
Tracing application.


162
00:04:21,005 --> 00:04:23,346
So, like I said, we'll start by


163
00:04:23,376 --> 00:04:24,106
generating rays.


164
00:04:24,896 --> 00:04:26,076
This is typically done using a


165
00:04:26,076 --> 00:04:27,326
compute kernel, but it could


166
00:04:27,326 --> 00:04:28,416
also be done from a fragment


167
00:04:28,416 --> 00:04:30,286
shader or really any mechanism


168
00:04:30,286 --> 00:04:31,116
that can write to a Metal


169
00:04:31,116 --> 00:04:31,486
buffer.


170
00:04:32,676 --> 00:04:33,946
We then pass the ray buffer to


171
00:04:33,946 --> 00:04:34,646
the intersector.


172
00:04:35,596 --> 00:04:37,196
It'll find the intersections and


173
00:04:37,196 --> 00:04:38,236
return the result in our


174
00:04:38,236 --> 00:04:39,116
intersection buffer.


175
00:04:39,556 --> 00:04:40,956
And remember that to use the


176
00:04:40,956 --> 00:04:42,486
intersector we need to provide


177
00:04:42,486 --> 00:04:43,596
an acceleration structure.


178
00:04:44,386 --> 00:04:45,926
We can often build this just one


179
00:04:46,076 --> 00:04:47,186
and reuse it many times.


180
00:04:48,496 --> 00:04:50,056
Finally, we'll launch one last


181
00:04:50,056 --> 00:04:52,016
compute kernel which will use


182
00:04:52,016 --> 00:04:53,456
the intersection data to write a


183
00:04:53,456 --> 00:04:55,026
shaded image into a texture.


184
00:04:55,986 --> 00:04:57,616
And this compute kernel can also


185
00:04:57,616 --> 00:04:59,006
write additional rays back into


186
00:04:59,006 --> 00:05:00,176
the ray buffer for iterative


187
00:05:00,176 --> 00:05:00,846
applications.


188
00:05:02,286 --> 00:05:03,166
So, let's see how this works in


189
00:05:03,166 --> 00:05:03,936
a real application.


190
00:05:05,226 --> 00:05:06,676
For this example, we'll talk


191
00:05:06,676 --> 00:05:08,006
about how Ray Tracing is being


192
00:05:08,006 --> 00:05:09,236
used in AR Quick Look.


193
00:05:09,686 --> 00:05:11,236
AR Quick Look was introduced


194
00:05:11,236 --> 00:05:12,436
last year and allows you to


195
00:05:12,506 --> 00:05:14,346
preview 3D assets in augmented


196
00:05:14,346 --> 00:05:14,676
reality.


197
00:05:15,996 --> 00:05:17,176
We talked a lot about AR Quick


198
00:05:17,176 --> 00:05:18,456
Look in this morning's session.


199
00:05:18,526 --> 00:05:19,686
So, I'd encourage you to watch


200
00:05:19,686 --> 00:05:20,436
that talk as well.


201
00:05:20,436 --> 00:05:22,336
For this talk, we'll focus on


202
00:05:22,336 --> 00:05:23,816
how AR Quick Look is using Ray


203
00:05:23,816 --> 00:05:25,446
Tracing to render an Ambient


204
00:05:25,446 --> 00:05:26,146
Occlusion effect.


205
00:05:27,076 --> 00:05:28,086
We'll talk more about Ambient


206
00:05:28,086 --> 00:05:29,766
Occlusion later, but for now,


207
00:05:29,766 --> 00:05:31,116
what you need to know is that


208
00:05:31,156 --> 00:05:32,356
Ambient Occlusion computes an


209
00:05:32,356 --> 00:05:34,326
approximation of how much light


210
00:05:34,386 --> 00:05:35,436
can reach each point in the


211
00:05:35,506 --> 00:05:35,816
scene.


212
00:05:36,616 --> 00:05:37,376
So, this results in the


213
00:05:37,376 --> 00:05:38,316
darkening of the ground


214
00:05:38,316 --> 00:05:39,926
underneath the robot model as


215
00:05:39,926 --> 00:05:41,436
well as soft contact shadows


216
00:05:41,486 --> 00:05:42,776
between the robot's legs and the


217
00:05:42,776 --> 00:05:43,136
ground.


218
00:05:43,656 --> 00:05:46,236
The effect is somewhat subtle,


219
00:05:46,236 --> 00:05:47,556
but if we turn it off, we can


220
00:05:47,556 --> 00:05:48,766
see that it actually goes a long


221
00:05:48,766 --> 00:05:50,066
way towards grounding the robot


222
00:05:50,066 --> 00:05:50,606
in the scene.


223
00:05:51,206 --> 00:05:52,566
And this is really important for


224
00:05:52,566 --> 00:05:54,226
AR applications to prevent


225
00:05:54,226 --> 00:05:55,126
objects from looking like


226
00:05:55,126 --> 00:05:56,876
they're floating above the


227
00:05:58,496 --> 00:05:58,656
ground.


228
00:05:58,806 --> 00:05:59,946
In last year's version of AR


229
00:05:59,946 --> 00:06:01,036
Quick Look, the shadows are


230
00:06:01,036 --> 00:06:02,876
actually precomputed, so they


231
00:06:02,936 --> 00:06:04,246
wouldn't move as objects moved


232
00:06:04,246 --> 00:06:04,606
around.


233
00:06:05,956 --> 00:06:07,736
This year, we've used Metal


234
00:06:07,776 --> 00:06:09,466
support for dynamic scenes to


235
00:06:09,466 --> 00:06:10,606
render these shadows in real


236
00:06:10,606 --> 00:06:10,956
time.


237
00:06:11,426 --> 00:06:13,226
So now as objects move their


238
00:06:13,226 --> 00:06:14,276
shadows will move with them.


239
00:06:14,836 --> 00:06:17,106
And this even works for


240
00:06:17,106 --> 00:06:18,516
deforming objects such as


241
00:06:18,516 --> 00:06:19,246
skinned models.


242
00:06:19,686 --> 00:06:20,886
We can see the shadows follow


243
00:06:20,886 --> 00:06:22,176
the motions of the fish as it


244
00:06:22,176 --> 00:06:23,706
swims around the scene.


245
00:06:25,916 --> 00:06:27,326
So, what we just saw actually


246
00:06:27,326 --> 00:06:28,456
has three types of animation


247
00:06:28,456 --> 00:06:28,946
going on.


248
00:06:28,946 --> 00:06:30,486
If we were just using the


249
00:06:30,486 --> 00:06:31,796
rasterizer, we'd simply


250
00:06:31,796 --> 00:06:33,006
rasterize the triangles in their


251
00:06:33,006 --> 00:06:33,576
new position.


252
00:06:34,346 --> 00:06:35,266
But because we're using Ray


253
00:06:35,266 --> 00:06:36,646
Tracing, we need to maintain an


254
00:06:36,646 --> 00:06:37,726
acceleration structure.


255
00:06:38,826 --> 00:06:40,446
So, the first type of animation


256
00:06:40,446 --> 00:06:41,476
is simple camera movement.


257
00:06:41,476 --> 00:06:43,186
And this is movement due to just


258
00:06:43,326 --> 00:06:44,436
moving the iPad around.


259
00:06:45,516 --> 00:06:46,386
We don't need to update the


260
00:06:46,386 --> 00:06:47,436
acceleration structure just


261
00:06:47,436 --> 00:06:48,586
because the cameras moved.


262
00:06:48,876 --> 00:06:49,956
So, we actually get this type of


263
00:06:49,956 --> 00:06:50,916
animation for free.


264
00:06:51,646 --> 00:06:53,056
We can simply start firing rays


265
00:06:53,056 --> 00:06:54,006
from the new camera position.


266
00:06:55,156 --> 00:06:56,436
The other two types of animation


267
00:06:56,436 --> 00:06:57,536
do require updating the


268
00:06:57,536 --> 00:06:58,476
acceleration structure.


269
00:06:58,666 --> 00:07:00,746
So, the first is Vertex


270
00:07:00,746 --> 00:07:01,286
Animation.


271
00:07:02,236 --> 00:07:03,346
This could be skinned models


272
00:07:03,346 --> 00:07:04,876
like the fish, but it could also


273
00:07:04,876 --> 00:07:06,226
be plants blowing in the wind,


274
00:07:06,376 --> 00:07:07,676
cloth, or other types of


275
00:07:07,676 --> 00:07:08,206
deformation.


276
00:07:09,276 --> 00:07:10,336
Metal includes a special


277
00:07:10,336 --> 00:07:11,636
acceleration structure update


278
00:07:11,636 --> 00:07:13,166
mechanism optimized for cases


279
00:07:13,166 --> 00:07:13,646
like this.


280
00:07:14,176 --> 00:07:16,446
And the last type of animation


281
00:07:16,446 --> 00:07:17,626
is rigid body animation.


282
00:07:18,346 --> 00:07:19,566
This is where objects can move,


283
00:07:19,646 --> 00:07:21,556
rotate, and scale, but otherwise


284
00:07:21,556 --> 00:07:22,796
completely maintain their shape.


285
00:07:23,606 --> 00:07:24,496
So, a large portion of the


286
00:07:24,496 --> 00:07:25,646
acceleration structure is


287
00:07:25,646 --> 00:07:26,566
actually still valid.


288
00:07:27,266 --> 00:07:28,406
So, Metal also includes a


289
00:07:28,406 --> 00:07:30,006
special mechanism to reuse the


290
00:07:30,006 --> 00:07:30,976
parts of the acceleration


291
00:07:30,976 --> 00:07:32,186
structure that hasn't changed.


292
00:07:33,456 --> 00:07:34,316
So, let's first talk about


293
00:07:34,316 --> 00:07:35,086
Vertex Animation.


294
00:07:36,206 --> 00:07:38,166
As the geometry changes, we need


295
00:07:38,166 --> 00:07:39,176
to update the acceleration


296
00:07:39,176 --> 00:07:39,626
structure.


297
00:07:40,616 --> 00:07:42,046
We could rebuild it from scratch


298
00:07:42,046 --> 00:07:43,706
every frame, but we can actually


299
00:07:44,496 --> 00:07:45,246
do better.


300
00:07:45,436 --> 00:07:47,146
In Vertex Animation use cases


301
00:07:47,446 --> 00:07:48,896
objects tend to mostly retain


302
00:07:48,896 --> 00:07:49,306
their shape.


303
00:07:49,646 --> 00:07:50,986
For example, a character's hands


304
00:07:50,986 --> 00:07:51,816
will stay connected to their


305
00:07:51,816 --> 00:07:52,186
arms.


306
00:07:52,546 --> 00:07:53,606
Their arms will stay connected


307
00:07:53,606 --> 00:07:54,866
to their body and so on.


308
00:07:55,506 --> 00:07:57,046
So, the spatial hierarchy


309
00:07:57,046 --> 00:07:58,406
encoded into the acceleration


310
00:07:58,406 --> 00:08:00,326
structure is mostly still valid.


311
00:08:00,856 --> 00:08:02,046
It just needs to be adjusted to


312
00:08:02,046 --> 00:08:02,866
the new geometry.


313
00:08:03,636 --> 00:08:04,586
Let's look at an example.


314
00:08:06,046 --> 00:08:06,966
So, here's the acceleration


315
00:08:06,966 --> 00:08:08,036
structure we saw earlier.


316
00:08:09,356 --> 00:08:10,656
If the triangles move, we can


317
00:08:10,656 --> 00:08:11,806
see that the bounding boxes no


318
00:08:11,806 --> 00:08:12,586
longer line up with the


319
00:08:12,586 --> 00:08:13,026
triangles.


320
00:08:13,786 --> 00:08:15,086
But the tree structure itself


321
00:08:15,086 --> 00:08:16,226
mostly still makes sense.


322
00:08:16,596 --> 00:08:18,006
So rather than rebuild it from


323
00:08:18,006 --> 00:08:19,566
scratch, we can simply snap the


324
00:08:19,566 --> 00:08:20,816
bounding boxes to the new


325
00:08:20,816 --> 00:08:22,616
triangle positions from bottom


326
00:08:23,066 --> 00:08:24,286
to top.


327
00:08:24,496 --> 00:08:25,456
We call this operation


328
00:08:25,456 --> 00:08:25,956
Refitting.


329
00:08:26,786 --> 00:08:27,766
As we can see, this still


330
00:08:27,766 --> 00:08:29,146
results in a valid acceleration


331
00:08:29,146 --> 00:08:31,016
structure, but it's much faster


332
00:08:31,016 --> 00:08:32,256
than building from scratch


333
00:08:32,385 --> 00:08:33,356
because we can reuse the


334
00:08:33,356 --> 00:08:34,126
existing tree.


335
00:08:34,666 --> 00:08:37,186
This also runs entirely on the


336
00:08:37,186 --> 00:08:39,216
GPU, which makes it even faster,


337
00:08:39,296 --> 00:08:40,426
but also means that we can


338
00:08:40,476 --> 00:08:41,666
safely encode a Refitting


339
00:08:41,666 --> 00:08:43,596
operation after say a compute


340
00:08:43,596 --> 00:08:44,986
kernel which updates the


341
00:08:44,986 --> 00:08:45,606
vertices.


342
00:08:46,136 --> 00:08:48,406
The downside is that we can't


343
00:08:48,406 --> 00:08:49,886
add or remove any geometry


344
00:08:49,886 --> 00:08:50,866
because the tree will still


345
00:08:50,866 --> 00:08:52,086
encode references to the old


346
00:08:52,086 --> 00:08:52,646
geometry.


347
00:08:54,156 --> 00:08:55,786
This also potentially degrades


348
00:08:55,786 --> 00:08:56,856
the acceleration structures


349
00:08:56,856 --> 00:08:58,206
quality which can impact Ray


350
00:08:58,206 --> 00:08:59,156
Tracing performance.


351
00:08:59,966 --> 00:09:00,946
This is because the triangles


352
00:09:00,946 --> 00:09:02,136
were originally partitioned


353
00:09:02,316 --> 00:09:03,636
using a set of futuristics which


354
00:09:03,636 --> 00:09:04,786
won't be accurate after the


355
00:09:04,786 --> 00:09:05,536
triangles move.


356
00:09:06,016 --> 00:09:08,376
The impact is usually minor, but


357
00:09:08,376 --> 00:09:09,886
extreme cases like teleporting


358
00:09:09,886 --> 00:09:11,396
geometry could cause performance


359
00:09:11,396 --> 00:09:11,826
problems.


360
00:09:12,606 --> 00:09:13,766
Nonetheless, this works great


361
00:09:13,766 --> 00:09:15,456
for typical deformation and


362
00:09:15,456 --> 00:09:16,796
character skinning use cases.


363
00:09:17,236 --> 00:09:18,606
So, let's see how to set this up


364
00:09:18,606 --> 00:09:18,976
in code.


365
00:09:20,056 --> 00:09:21,526
First, before we build the


366
00:09:21,526 --> 00:09:22,856
accelerations structure, we need


367
00:09:22,856 --> 00:09:24,336
to enable support for Refitting.


368
00:09:24,886 --> 00:09:26,306
And note that just enabling


369
00:09:26,306 --> 00:09:27,606
Refitting is enough to reduce


370
00:09:27,646 --> 00:09:28,636
the acceleration structure's


371
00:09:28,636 --> 00:09:29,056
quality.


372
00:09:29,056 --> 00:09:31,006
So definitely only turn this on


373
00:09:31,036 --> 00:09:32,136
if you really need to refit the


374
00:09:32,136 --> 00:09:33,076
acceleration structure.


375
00:09:34,536 --> 00:09:36,376
Then we simple call encodeRefit


376
00:09:36,376 --> 00:09:37,596
into a Metal commandBuffer.


377
00:09:38,176 --> 00:09:39,786
And that's all we need to do for


378
00:09:39,786 --> 00:09:40,736
Vertex Animation.


379
00:09:41,636 --> 00:09:43,176
So next, let's talk about Rigid


380
00:09:43,176 --> 00:09:43,826
Body Animation.


381
00:09:44,936 --> 00:09:46,526
So as the name implies, this is


382
00:09:46,526 --> 00:09:47,576
animation where objects can


383
00:09:47,576 --> 00:09:49,396
move, rotate, and scale, but


384
00:09:49,396 --> 00:09:50,676
otherwise completely maintain


385
00:09:50,676 --> 00:09:51,086
their shape.


386
00:09:51,876 --> 00:09:53,166
So, in the example on the right,


387
00:09:53,436 --> 00:09:54,246
even though it looks like the


388
00:09:54,246 --> 00:09:55,846
robot is deforming, actually all


389
00:09:55,846 --> 00:09:57,366
of its joins are moving rigidly.


390
00:09:57,776 --> 00:09:58,906
So, this is still an example of


391
00:09:58,906 --> 00:09:59,856
Rigid Body Animation.


392
00:10:01,316 --> 00:10:02,816
So, in a typical scene, most of


393
00:10:02,816 --> 00:10:04,036
the geometry is probably only


394
00:10:04,036 --> 00:10:04,846
moving rigidly.


395
00:10:05,546 --> 00:10:07,026
In fact, most of the geometry is


396
00:10:07,026 --> 00:10:08,196
probably not moving at all.


397
00:10:09,636 --> 00:10:11,346
We may also have multiple copies


398
00:10:11,436 --> 00:10:12,596
of the same objects in the


399
00:10:12,656 --> 00:10:13,006
scene.


400
00:10:13,426 --> 00:10:14,766
It would be wasteful to


401
00:10:14,766 --> 00:10:16,196
replicate these objects multiple


402
00:10:16,196 --> 00:10:17,256
times in the accelerations


403
00:10:17,256 --> 00:10:18,976
structure and it would also be


404
00:10:18,976 --> 00:10:20,506
inefficient to refit or rebuild


405
00:10:20,506 --> 00:10:21,556
the entire acceleration


406
00:10:21,556 --> 00:10:23,306
structure just because a subset


407
00:10:23,306 --> 00:10:24,346
of the geometry is moving.


408
00:10:25,526 --> 00:10:26,816
So, to solve both of these


409
00:10:26,846 --> 00:10:28,176
problems, we can use what we


410
00:10:28,176 --> 00:10:29,486
call a Two-Level Acceleration


411
00:10:29,486 --> 00:10:29,956
Structure.


412
00:10:30,526 --> 00:10:33,586
So, what we'll do is first build


413
00:10:33,586 --> 00:10:34,766
a high-quality triangle


414
00:10:34,766 --> 00:10:36,186
acceleration structure for each


415
00:10:36,186 --> 00:10:37,626
unique object in the scene.


416
00:10:37,626 --> 00:10:38,896
And we can do this just once


417
00:10:38,896 --> 00:10:41,326
when the app starts up.


418
00:10:41,356 --> 00:10:42,826
We'll then create two copies of


419
00:10:42,826 --> 00:10:44,296
those -- of those triangle


420
00:10:44,296 --> 00:10:45,936
acceleration structures using a


421
00:10:46,016 --> 00:10:47,266
second acceleration structure.


422
00:10:47,976 --> 00:10:49,876
Each copy is called an instance


423
00:10:49,876 --> 00:10:51,166
of one of the original triangle


424
00:10:51,166 --> 00:10:52,156
acceleration structures.


425
00:10:53,866 --> 00:10:55,196
Each instance is associated with


426
00:10:55,196 --> 00:10:56,396
a transformation matrix,


427
00:10:57,126 --> 00:10:58,356
describing where to place it in


428
00:10:58,356 --> 00:10:58,796
the scene.


429
00:10:59,696 --> 00:11:00,786
So, we'll do this all using two


430
00:11:00,786 --> 00:11:02,106
buffers and each buffer will


431
00:11:02,106 --> 00:11:03,556
contain one entry for each


432
00:11:03,556 --> 00:11:04,526
instance in the scene.


433
00:11:05,846 --> 00:11:06,806
The first buffer will contain


434
00:11:06,806 --> 00:11:08,146
the transformation matrices for


435
00:11:08,146 --> 00:11:08,926
all the instances.


436
00:11:10,376 --> 00:11:11,816
The second buffer will contain


437
00:11:11,816 --> 00:11:13,286
indices into an array of


438
00:11:13,286 --> 00:11:14,256
triangle accelerations


439
00:11:14,256 --> 00:11:16,056
structures describing which


440
00:11:16,056 --> 00:11:17,286
acceleration structure to use


441
00:11:17,286 --> 00:11:18,096
for each instance.


442
00:11:18,716 --> 00:11:21,246
We'll then build a second


443
00:11:21,246 --> 00:11:22,976
acceleration structure over just


444
00:11:22,976 --> 00:11:24,466
the instances in the scene.


445
00:11:25,556 --> 00:11:26,926
We can then quickly rebuild just


446
00:11:26,926 --> 00:11:28,016
the instance acceleration


447
00:11:28,016 --> 00:11:29,446
structure as the objects move.


448
00:11:30,346 --> 00:11:31,346
So, let's see how to set this


449
00:11:31,346 --> 00:11:31,666
up.


450
00:11:32,566 --> 00:11:33,816
First, we'll create what's


451
00:11:33,816 --> 00:11:34,266
called an


452
00:11:34,266 --> 00:11:35,606
AccelerationStructureGroup.


453
00:11:36,386 --> 00:11:37,566
All the acceleration structures


454
00:11:37,566 --> 00:11:38,746
in the instance's hierarchy must


455
00:11:38,746 --> 00:11:39,796
belong to the same group.


456
00:11:39,796 --> 00:11:41,126
And this allows them to share


457
00:11:41,126 --> 00:11:42,166
resources internally.


458
00:11:42,786 --> 00:11:45,106
Next, we'll create an array to


459
00:11:45,106 --> 00:11:46,436
hold our triangle acceleration


460
00:11:46,436 --> 00:11:46,916
structures.


461
00:11:47,866 --> 00:11:49,206
Then finally, we'll loop over


462
00:11:49,206 --> 00:11:50,376
all the unique objects in the


463
00:11:50,376 --> 00:11:51,776
scene, building a triangle


464
00:11:51,776 --> 00:11:52,926
acceleration structure for each


465
00:11:52,926 --> 00:11:53,246
of them.


466
00:11:53,526 --> 00:11:55,496
Adding them to the array as we


467
00:11:56,896 --> 00:11:56,976
go.


468
00:11:57,216 --> 00:11:58,006
We're now ready to create the


469
00:11:58,006 --> 00:11:59,076
second level acceleration


470
00:11:59,076 --> 00:11:59,526
structure.


471
00:12:00,156 --> 00:12:02,006
We do this using the NPSInstance


472
00:12:02,006 --> 00:12:03,286
AccelerationStructure class.


473
00:12:04,266 --> 00:12:05,446
We'll start by attaching our


474
00:12:05,446 --> 00:12:06,746
array of triangle acceleration


475
00:12:06,746 --> 00:12:08,686
structures as well as the two


476
00:12:08,686 --> 00:12:09,606
buffers I talked about


477
00:12:09,606 --> 00:12:10,136
previously.


478
00:12:10,836 --> 00:12:12,146
Then finally, we'll specify the


479
00:12:12,146 --> 00:12:15,106
num of instances in the scene.


480
00:12:15,306 --> 00:12:16,916
Then, whenever the objects move


481
00:12:16,916 --> 00:12:18,086
or if an object is added or


482
00:12:18,086 --> 00:12:19,816
removed from the scene, we can


483
00:12:19,816 --> 00:12:21,256
simply rebuild just the instance


484
00:12:21,256 --> 00:12:22,256
acceleration structure.


485
00:12:23,246 --> 00:12:24,326
This acceleration structure is


486
00:12:24,326 --> 00:12:25,566
typically much smaller than a


487
00:12:25,566 --> 00:12:27,016
triangle acceleration structure,


488
00:12:27,336 --> 00:12:28,336
so we can afford to do this


489
00:12:28,336 --> 00:12:28,956
every frame.


490
00:12:29,236 --> 00:12:30,366
But note that similar to


491
00:12:30,366 --> 00:12:31,506
Refitting, there is some


492
00:12:31,506 --> 00:12:32,896
overhead when using instancing.


493
00:12:33,696 --> 00:12:34,776
So, if your scene only has one


494
00:12:34,776 --> 00:12:36,446
object or a handful of objects,


495
00:12:36,526 --> 00:12:37,496
or especially if none of the


496
00:12:37,496 --> 00:12:39,156
objects are moving, it might be


497
00:12:39,156 --> 00:12:40,446
worthwhile to pack those into a


498
00:12:40,446 --> 00:12:41,776
single triangle acceleration


499
00:12:41,776 --> 00:12:42,226
structure.


500
00:12:43,026 --> 00:12:43,966
This will increase your memory


501
00:12:44,016 --> 00:12:45,806
footprint, but it should gain


502
00:12:45,806 --> 00:12:46,856
back some of the performance.


503
00:12:47,226 --> 00:12:48,686
So, you need to experiment to


504
00:12:48,716 --> 00:12:49,806
find the right tradeoff for your


505
00:12:49,806 --> 00:12:50,286
application.


506
00:12:50,286 --> 00:12:53,386
So that's it for dynamic scenes.


507
00:12:53,826 --> 00:12:54,736
We talked about how to support


508
00:12:54,736 --> 00:12:56,146
Vertex Animation and Skinning


509
00:12:56,146 --> 00:12:57,006
using Refitting.


510
00:12:57,606 --> 00:12:58,816
As well as how to support Rigid


511
00:12:58,816 --> 00:13:00,306
Body Animation using a Two-Level


512
00:13:00,306 --> 00:13:01,276
Acceleration Structure.


513
00:13:02,196 --> 00:13:03,726
So next, let's switch gears and


514
00:13:03,726 --> 00:13:04,676
talk about Denoising.


515
00:13:05,306 --> 00:13:08,516
So far, all the images that we


516
00:13:08,516 --> 00:13:09,396
have seen have been free of


517
00:13:09,396 --> 00:13:09,766
noise.


518
00:13:10,326 --> 00:13:11,556
That's because they've all been


519
00:13:11,556 --> 00:13:12,786
using a denoising filter.


520
00:13:13,676 --> 00:13:14,966
If we turn it off, we could see


521
00:13:14,966 --> 00:13:15,896
what it would have looked like


522
00:13:15,896 --> 00:13:16,796
without the denoiser.


523
00:13:17,826 --> 00:13:19,036
We can see that these images are


524
00:13:19,036 --> 00:13:20,276
too noisy to use in a real


525
00:13:20,276 --> 00:13:20,986
application.


526
00:13:21,526 --> 00:13:22,576
That's because we're only using


527
00:13:22,576 --> 00:13:23,966
a handful of samples per pixel.


528
00:13:25,266 --> 00:13:26,516
Usually we would just solve this


529
00:13:26,516 --> 00:13:27,506
by averaging together more


530
00:13:27,506 --> 00:13:28,526
samples over time.


531
00:13:28,926 --> 00:13:30,236
But if the camera or objects are


532
00:13:30,236 --> 00:13:31,466
moving it's not quite that


533
00:13:31,466 --> 00:13:31,846
simple.


534
00:13:32,226 --> 00:13:34,236
Fortunately, Metal now includes


535
00:13:34,236 --> 00:13:35,506
a sophisticated Denoising


536
00:13:35,546 --> 00:13:35,936
filter.


537
00:13:36,726 --> 00:13:37,566
Let's see how this works.


538
00:13:37,676 --> 00:13:40,376
Ideally what we'd be able to do


539
00:13:40,376 --> 00:13:41,856
is simply take the noisy image


540
00:13:41,856 --> 00:13:43,556
output by a renderer, run it


541
00:13:43,556 --> 00:13:44,766
through a denoiser and get back


542
00:13:44,766 --> 00:13:45,506
a clean image.


543
00:13:46,236 --> 00:13:47,436
In practice, the denoiser needs


544
00:13:47,436 --> 00:13:48,736
a little more information about


545
00:13:48,736 --> 00:13:49,186
the scene.


546
00:13:50,296 --> 00:13:51,236
We'll start by providing the


547
00:13:51,236 --> 00:13:52,296
depths and normal for the


548
00:13:52,296 --> 00:13:53,616
directly visible geometry.


549
00:13:54,386 --> 00:13:55,586
Many renderers have these


550
00:13:55,586 --> 00:13:57,156
textures lying around, and if


551
00:13:57,156 --> 00:13:59,076
not, it's easy to produce them.


552
00:13:59,716 --> 00:14:00,946
The denoiser will then run a


553
00:14:00,946 --> 00:14:01,926
bunch of image processing


554
00:14:01,926 --> 00:14:03,326
operations and output a cleaner


555
00:14:03,326 --> 00:14:03,696
image.


556
00:14:04,336 --> 00:14:05,466
But since we started with just a


557
00:14:05,466 --> 00:14:06,846
handful of samples per pixel,


558
00:14:06,846 --> 00:14:07,926
the result will still have some


559
00:14:07,926 --> 00:14:08,196
noise.


560
00:14:08,936 --> 00:14:10,316
So, we'll revisit the idea of


561
00:14:10,316 --> 00:14:11,706
combining samples over multiple


562
00:14:11,706 --> 00:14:12,116
frames.


563
00:14:12,786 --> 00:14:14,646
So, we'll first set aside the


564
00:14:14,646 --> 00:14:16,246
clean image to reuse in the next


565
00:14:16,246 --> 00:14:16,566
frame.


566
00:14:17,726 --> 00:14:18,866
We'll also set aside the depth


567
00:14:18,866 --> 00:14:20,356
and normal so we can compare


568
00:14:20,356 --> 00:14:21,186
them to the next frame.


569
00:14:22,256 --> 00:14:23,336
Then finally, we'll provide a


570
00:14:23,336 --> 00:14:24,886
motion vector texture which


571
00:14:24,886 --> 00:14:26,266
describes how much each pixel


572
00:14:26,266 --> 00:14:27,476
has moved between frames.


573
00:14:28,116 --> 00:14:30,916
In the next frame, the denoiser


574
00:14:30,916 --> 00:14:32,126
will churn through all of these


575
00:14:32,126 --> 00:14:33,406
textures to produce an even


576
00:14:33,406 --> 00:14:34,136
better image.


577
00:14:34,706 --> 00:14:35,856
And this image will continue to


578
00:14:35,856 --> 00:14:37,506
get better over time even if the


579
00:14:37,506 --> 00:14:38,686
camera or objects move.


580
00:14:39,076 --> 00:14:41,156
The denoiser will use the depths


581
00:14:41,156 --> 00:14:43,116
and normal to detect cases where


582
00:14:43,116 --> 00:14:44,296
the history for a pixel has


583
00:14:44,296 --> 00:14:46,426
become invalid due to an object


584
00:14:46,426 --> 00:14:47,656
moving or getting in the way.


585
00:14:49,196 --> 00:14:50,056
So, this is all implemented


586
00:14:50,056 --> 00:14:51,946
using the MPSSVGF family of


587
00:14:51,986 --> 00:14:52,506
classes.


588
00:14:53,456 --> 00:14:54,756
This is an implementation of the


589
00:14:54,756 --> 00:14:56,246
popular MPSSVGF denoising


590
00:14:56,246 --> 00:14:56,716
algorithm.


591
00:14:57,356 --> 00:14:58,276
This algorithm makes a good


592
00:14:58,276 --> 00:14:59,536
tradeoff between high quality


593
00:14:59,536 --> 00:15:00,596
and real-time performance.


594
00:15:01,236 --> 00:15:03,146
So, the denoising process is all


595
00:15:03,146 --> 00:15:04,386
coordinated by the


596
00:15:04,386 --> 00:15:06,096
MPSSVGFDenoiser class.


597
00:15:07,206 --> 00:15:08,976
Meanwhile, low-level control is


598
00:15:08,976 --> 00:15:10,896
provided using the MPSSVGF


599
00:15:10,896 --> 00:15:11,316
class.


600
00:15:12,186 --> 00:15:12,996
This class provides the


601
00:15:12,996 --> 00:15:14,516
individual compute kernels used


602
00:15:14,516 --> 00:15:16,516
by the denoiser and exposes many


603
00:15:16,516 --> 00:15:17,726
parameters you can use to fine


604
00:15:17,726 --> 00:15:18,736
tune the Denoising in your


605
00:15:18,736 --> 00:15:19,236
application.


606
00:15:20,006 --> 00:15:21,026
And you also just call this


607
00:15:21,026 --> 00:15:22,306
classes' methods directly to


608
00:15:22,306 --> 00:15:23,526
build a customized denoiser.


609
00:15:24,126 --> 00:15:26,416
Now the denoiser creates and


610
00:15:26,416 --> 00:15:27,706
destroys quite a few temporary


611
00:15:27,706 --> 00:15:28,576
textures throughout the


612
00:15:28,576 --> 00:15:29,566
Denoising process.


613
00:15:30,246 --> 00:15:32,456
To the MPSSVGF texture allocator


614
00:15:32,456 --> 00:15:34,216
protocol serves as a cache for


615
00:15:34,216 --> 00:15:35,346
these memory allocations.


616
00:15:36,536 --> 00:15:37,646
You can either use the default


617
00:15:37,646 --> 00:15:39,416
implementation or implement this


618
00:15:39,416 --> 00:15:40,606
protocol yourself to share


619
00:15:40,606 --> 00:15:41,356
memory with your own


620
00:15:41,356 --> 00:15:41,966
application.


621
00:15:42,986 --> 00:15:44,376
So as usual, we've optimized


622
00:15:44,376 --> 00:15:45,666
these classes for all of our Mac


623
00:15:45,666 --> 00:15:46,646
and iOS devices.


624
00:15:47,536 --> 00:15:48,836
The denoiser can process two


625
00:15:48,836 --> 00:15:49,736
independent images


626
00:15:49,736 --> 00:15:50,576
simultaneously.


627
00:15:50,706 --> 00:15:51,966
For example, you might want to


628
00:15:51,966 --> 00:15:53,346
split your direct and indirect


629
00:15:53,346 --> 00:15:54,576
lighting terms into separate


630
00:15:54,576 --> 00:15:55,066
textures.


631
00:15:56,036 --> 00:15:57,166
There's also a fast path for


632
00:15:57,166 --> 00:15:58,756
single channel textures such as


633
00:15:58,756 --> 00:15:59,946
Ambient Occlusion or shadow


634
00:15:59,946 --> 00:16:01,456
textures, which is faster than


635
00:16:01,456 --> 00:16:03,146
Denoising a full RBG image.


636
00:16:04,276 --> 00:16:06,706
Let's see how to set this up.


637
00:16:06,706 --> 00:16:08,016
So first we'll create the


638
00:16:08,096 --> 00:16:09,996
MPSSVGF object and configure its


639
00:16:10,036 --> 00:16:10,516
properties.


640
00:16:11,136 --> 00:16:12,106
All we need to provide is the


641
00:16:12,106 --> 00:16:13,366
Metal device we want to use for


642
00:16:13,366 --> 00:16:13,946
Denoising.


643
00:16:14,416 --> 00:16:16,146
Next, we'll create the


644
00:16:16,146 --> 00:16:16,996
TextureAllocator.


645
00:16:17,276 --> 00:16:18,296
In this case we'll just use the


646
00:16:18,296 --> 00:16:19,446
default implementation.


647
00:16:20,616 --> 00:16:21,716
Then finally, we'll create the


648
00:16:21,716 --> 00:16:23,256
high level Denoiser object which


649
00:16:23,256 --> 00:16:24,216
will manage the denoising


650
00:16:24,246 --> 00:16:24,696
process.


651
00:16:26,146 --> 00:16:27,086
So now we're ready to do some


652
00:16:27,086 --> 00:16:27,636
denoising.


653
00:16:28,156 --> 00:16:29,406
We'll start by attaching all of


654
00:16:29,406 --> 00:16:30,446
the input textures to the


655
00:16:30,446 --> 00:16:30,896
Denoiser.


656
00:16:31,546 --> 00:16:32,866
Now we simply encode the entire


657
00:16:32,866 --> 00:16:34,366
denoising process to a Metal


658
00:16:34,366 --> 00:16:34,996
commandBuffer.


659
00:16:35,876 --> 00:16:37,146
And finally, we can retrieve the


660
00:16:37,146 --> 00:16:38,516
clean image from the denoiser.


661
00:16:39,106 --> 00:16:40,416
And that's all you need to do to


662
00:16:40,416 --> 00:16:41,306
enable denoising your


663
00:16:41,306 --> 00:16:41,926
applications.


664
00:16:42,646 --> 00:16:45,086
So, we now talked about all of


665
00:16:45,086 --> 00:16:46,136
the basic building blocks


666
00:16:46,136 --> 00:16:47,246
available in Metal for Ray


667
00:16:47,246 --> 00:16:48,416
Tracing and Denoising.


668
00:16:48,646 --> 00:16:50,186
We reviewed how to do basic


669
00:16:50,186 --> 00:16:52,476
ray/triangle intersection using


670
00:16:52,526 --> 00:16:53,826
the MPS Ray Intersector API.


671
00:16:54,996 --> 00:16:55,816
We then talked about how to


672
00:16:55,816 --> 00:16:57,196
extend this to dynamic scenes


673
00:16:57,196 --> 00:16:58,866
using Refitting and Two-Level


674
00:16:58,866 --> 00:16:59,886
Acceleration Structures.


675
00:17:00,876 --> 00:17:02,156
And finally, we talked about how


676
00:17:02,156 --> 00:17:03,376
to remove the noise from your


677
00:17:03,376 --> 00:17:04,856
images using the MPSSVGF


678
00:17:04,945 --> 00:17:05,376
classes.


679
00:17:05,376 --> 00:17:07,406
Now, don't worry if this is all


680
00:17:07,406 --> 00:17:09,096
a little bit overwhelming.


681
00:17:09,396 --> 00:17:10,576
We've written a sample, which


682
00:17:10,576 --> 00:17:11,695
demonstrates how to use all of


683
00:17:11,695 --> 00:17:12,656
these concepts which is


684
00:17:12,656 --> 00:17:13,566
available online.


685
00:17:14,146 --> 00:17:16,316
Now, I mentioned earlier that we


686
00:17:16,316 --> 00:17:17,116
need to be careful with


687
00:17:17,116 --> 00:17:17,715
performance.


688
00:17:17,715 --> 00:17:18,705
Especially in a real-time


689
00:17:18,705 --> 00:17:19,086
setting.


690
00:17:19,626 --> 00:17:20,536
So next, I'd like to bring out


691
00:17:20,536 --> 00:17:22,036
my colleague Wayne who will talk


692
00:17:22,036 --> 00:17:22,996
about how to make all of this


693
00:17:22,996 --> 00:17:24,796
work on real devices with real


694
00:17:24,796 --> 00:17:25,576
performance budgets.


695
00:17:27,516 --> 00:17:31,636
[ Applause ]


696
00:17:32,136 --> 00:17:32,556
>> Hi everyone.


697
00:17:33,106 --> 00:17:34,596
Now, what I'd like to show you


698
00:17:34,596 --> 00:17:36,556
in this part of the talk is how


699
00:17:36,596 --> 00:17:38,416
to use the Ray Tracing features


700
00:17:38,416 --> 00:17:40,006
that we have in Metal to


701
00:17:40,006 --> 00:17:41,126
implement a few different


702
00:17:41,126 --> 00:17:42,486
rendering techniques in your


703
00:17:42,486 --> 00:17:43,266
applications.


704
00:17:43,746 --> 00:17:45,316
So, in particular, I'll be


705
00:17:45,316 --> 00:17:46,506
focusing on hard and soft


706
00:17:46,506 --> 00:17:48,566
shadows, Ambient Occlusion, and


707
00:17:48,696 --> 00:17:49,756
global illumination.


708
00:17:49,896 --> 00:17:52,176
So, let's start with hard


709
00:17:52,176 --> 00:17:52,656
shadows.


710
00:17:52,656 --> 00:17:54,956
Now, the way that we model this


711
00:17:54,956 --> 00:17:56,516
with Ray Tracing is to take


712
00:17:56,516 --> 00:17:58,366
points on our surface and fire


713
00:17:58,366 --> 00:17:59,566
rays up in the direction of the


714
00:17:59,566 --> 00:17:59,806
sun.


715
00:18:00,616 --> 00:18:02,616
If a ray hits something, then


716
00:18:02,616 --> 00:18:03,816
the associated point is in


717
00:18:03,816 --> 00:18:04,126
shadow.


718
00:18:04,776 --> 00:18:06,266
Otherwise, it's in sunlight.


719
00:18:07,476 --> 00:18:10,066
Now, to incorporate this into an


720
00:18:10,066 --> 00:18:11,946
existing application, I'm going


721
00:18:11,946 --> 00:18:12,896
to assume that you're starting


722
00:18:12,896 --> 00:18:15,106
with something a bit like this.


723
00:18:15,106 --> 00:18:16,986
You've rasterized a G-Buffer and


724
00:18:16,986 --> 00:18:17,896
run a compute pass for your


725
00:18:17,896 --> 00:18:18,286
lighting.


726
00:18:18,466 --> 00:18:19,936
And the output of that is your


727
00:18:19,936 --> 00:18:21,106
final shaded image.


728
00:18:21,856 --> 00:18:24,036
Now, to take advantage of Ray


729
00:18:24,036 --> 00:18:25,516
Tracing here we'll start by


730
00:18:25,516 --> 00:18:27,416
taking the G-Buffer and then run


731
00:18:27,416 --> 00:18:28,826
a compute shader to generate


732
00:18:28,826 --> 00:18:29,226
some rays.


733
00:18:30,836 --> 00:18:31,836
We'll then pass those rays to


734
00:18:31,836 --> 00:18:33,256
Metal to intersect with an


735
00:18:33,256 --> 00:18:34,256
acceleration structure.


736
00:18:34,956 --> 00:18:35,906
And Metal will output the


737
00:18:35,906 --> 00:18:37,076
results to an intersection


738
00:18:37,076 --> 00:18:37,356
buffer.


739
00:18:38,786 --> 00:18:40,026
You can now use this buffer in


740
00:18:40,026 --> 00:18:41,356
your shading kernel to decide


741
00:18:41,356 --> 00:18:42,336
whether your surface points are


742
00:18:42,336 --> 00:18:42,816
in shadow.


743
00:18:43,446 --> 00:18:46,066
Now the main part I'd like us to


744
00:18:46,066 --> 00:18:47,776
focus on here is Ray Generation.


745
00:18:48,626 --> 00:18:49,916
So, let's start with a quick


746
00:18:49,916 --> 00:18:51,196
reminder of how rays are


747
00:18:51,196 --> 00:18:52,006
described in Metal.


748
00:18:54,256 --> 00:18:55,606
So, Metal provides a few


749
00:18:55,606 --> 00:18:56,616
different ray structures for you


750
00:18:56,616 --> 00:18:58,456
to use, and at a minimum these


751
00:18:58,456 --> 00:18:59,676
contain fields for your ray


752
00:18:59,676 --> 00:19:01,406
origin and your ray direction.


753
00:19:02,496 --> 00:19:03,596
So just fill out one of these


754
00:19:03,596 --> 00:19:04,986
structures for each ray that you


755
00:19:04,986 --> 00:19:06,566
want to trace and write it out


756
00:19:06,566 --> 00:19:09,346
to your ray buffer.


757
00:19:09,926 --> 00:19:10,896
Now, the way in which you


758
00:19:10,896 --> 00:19:12,176
arrange your rays in your ray


759
00:19:12,176 --> 00:19:13,926
buffer, that has a performance


760
00:19:13,926 --> 00:19:14,326
impact.


761
00:19:15,436 --> 00:19:16,446
So, often you might start like


762
00:19:16,446 --> 00:19:16,876
this.


763
00:19:17,166 --> 00:19:18,506
We call this row linear order.


764
00:19:19,246 --> 00:19:22,326
Now, the problem here is that as


765
00:19:22,326 --> 00:19:23,506
Metal works its way through


766
00:19:23,506 --> 00:19:25,336
these rays, they tend to hit


767
00:19:25,336 --> 00:19:26,556
very different nodes in the


768
00:19:26,556 --> 00:19:28,166
internal data structures that


769
00:19:28,166 --> 00:19:29,586
Metal uses to accelerate ray


770
00:19:29,586 --> 00:19:30,126
traversal.


771
00:19:30,606 --> 00:19:32,646
Now this in turn can flash the


772
00:19:32,646 --> 00:19:33,816
underlying hardware caches.


773
00:19:33,816 --> 00:19:37,116
So, a better approach is to use


774
00:19:37,116 --> 00:19:38,386
block linear ordering.


775
00:19:39,646 --> 00:19:40,946
So, rays from nearby pixels on


776
00:19:40,946 --> 00:19:42,336
the screen, they tend to hit the


777
00:19:42,336 --> 00:19:43,606
same parts of your acceleration


778
00:19:43,606 --> 00:19:45,626
structure, and so by storing


779
00:19:45,626 --> 00:19:47,136
your rays like this it enables


780
00:19:47,136 --> 00:19:48,536
Metal to drive the hardware much


781
00:19:48,536 --> 00:19:49,246
more efficiently.


782
00:19:49,616 --> 00:19:52,226
Now, in the visualization here,


783
00:19:52,226 --> 00:19:53,826
I'm showing you a block size of


784
00:19:53,886 --> 00:19:54,716
4 by 4.


785
00:19:55,056 --> 00:19:56,446
In practice we found that 8 by 8


786
00:19:56,446 --> 00:19:58,026
works really, really well.


787
00:19:59,796 --> 00:20:01,526
So, optimizing your ray storage


788
00:20:01,526 --> 00:20:02,796
is a great way to improve


789
00:20:02,796 --> 00:20:03,686
performance.


790
00:20:03,776 --> 00:20:05,216
But where possible, an even


791
00:20:05,216 --> 00:20:06,836
better way is just not to fire


792
00:20:06,836 --> 00:20:07,336
rays at all.


793
00:20:07,336 --> 00:20:10,246
Now, in the context of shadows,


794
00:20:10,246 --> 00:20:11,826
the reason that you might want


795
00:20:11,826 --> 00:20:13,386
to do this is because not all


796
00:20:13,386 --> 00:20:14,646
pixels need a shadow ray.


797
00:20:14,986 --> 00:20:16,786
For example, pixels on your


798
00:20:16,786 --> 00:20:18,656
background, on your skybox, or


799
00:20:18,656 --> 00:20:19,976
on surfaces that are facing away


800
00:20:19,976 --> 00:20:22,876
from the sun.


801
00:20:23,056 --> 00:20:24,056
Now, it's likely that your ray


802
00:20:24,056 --> 00:20:25,716
buffer contains a ray structure


803
00:20:25,986 --> 00:20:27,416
for each pixel on the screen.


804
00:20:27,676 --> 00:20:29,496
So, what we need here is a way


805
00:20:29,496 --> 00:20:31,156
to tell Metal to skip firing


806
00:20:31,156 --> 00:20:32,616
ways for the pixels that we just


807
00:20:32,616 --> 00:20:33,866
don't care about.


808
00:20:34,456 --> 00:20:35,696
Now, there's a few ways to do


809
00:20:35,696 --> 00:20:36,076
this.


810
00:20:36,076 --> 00:20:37,316
The approach I'm showing you


811
00:20:37,316 --> 00:20:38,656
here is simply to set the


812
00:20:38,656 --> 00:20:39,966
maxDistance field in your ray


813
00:20:39,966 --> 00:20:41,776
structure to a negative value.


814
00:20:42,346 --> 00:20:45,146
And that's the main things you


815
00:20:45,146 --> 00:20:46,446
need to know for Hard Shadows.


816
00:20:47,506 --> 00:20:48,636
As you can see, Ray Tracing


817
00:20:48,636 --> 00:20:50,036
gives really great results.


818
00:20:50,106 --> 00:20:51,376
The shadows are very crisp and


819
00:20:51,376 --> 00:20:52,346
they're very precise.


820
00:20:53,386 --> 00:20:56,316
But in reality, shadows cast by


821
00:20:56,316 --> 00:20:58,636
the sun, they tend not to look


822
00:20:58,636 --> 00:20:59,196
that sharp.


823
00:20:59,976 --> 00:21:00,736
they look more like this.


824
00:21:01,726 --> 00:21:02,916
They're soft around the edges


825
00:21:03,156 --> 00:21:04,276
and that softness varies with


826
00:21:04,276 --> 00:21:04,926
distance.


827
00:21:05,686 --> 00:21:07,316
And you can see a great example


828
00:21:07,316 --> 00:21:08,436
of this on the left there.


829
00:21:09,356 --> 00:21:10,446
the shadow from the lamp post


830
00:21:10,446 --> 00:21:11,896
starts off hard at the base and


831
00:21:11,896 --> 00:21:13,356
it softens as the distance to


832
00:21:13,356 --> 00:21:14,176
the ground increases.


833
00:21:14,846 --> 00:21:17,116
So, to model that with Ray


834
00:21:17,116 --> 00:21:18,776
Tracing, instead of using the


835
00:21:18,776 --> 00:21:19,966
parallel rays that I was showing


836
00:21:19,966 --> 00:21:21,556
you earlier, we'll instead


837
00:21:21,726 --> 00:21:23,056
extend the cone from our surface


838
00:21:23,126 --> 00:21:24,596
point all the way up to the sun.


839
00:21:25,506 --> 00:21:27,176
And then, we'll generate some


840
00:21:27,176 --> 00:21:28,666
ray directions randomly within


841
00:21:29,606 --> 00:21:31,066
this cone.


842
00:21:31,286 --> 00:21:32,446
Now you can see there that some


843
00:21:32,446 --> 00:21:34,096
rays intersect geometry and some


844
00:21:34,156 --> 00:21:34,396
don't.


845
00:21:34,396 --> 00:21:36,356
And it's this ratio that


846
00:21:36,356 --> 00:21:37,506
controls the softness of your


847
00:21:37,506 --> 00:21:38,136
shadow.


848
00:21:38,866 --> 00:21:41,186
So, here's what that looks like.


849
00:21:42,066 --> 00:21:44,496
What I'm showing you here is the


850
00:21:44,496 --> 00:21:46,556
raw direct lighting term ray


851
00:21:46,556 --> 00:21:48,006
traced with one ray per pixel.


852
00:21:49,006 --> 00:21:50,386
So, in this image, all other


853
00:21:50,386 --> 00:21:52,716
effects such as reflections and


854
00:21:52,716 --> 00:21:54,616
global illumination, they're all


855
00:21:54,616 --> 00:21:56,216
disabled so we can focus purely


856
00:21:56,216 --> 00:21:56,726
on the shadow.


857
00:21:57,876 --> 00:22:00,096
And as you can see, the result


858
00:22:00,096 --> 00:22:01,406
is really quite noisy.


859
00:22:02,086 --> 00:22:04,856
Now, to deal with that, we could


860
00:22:04,856 --> 00:22:06,086
just keep firing more and more


861
00:22:06,086 --> 00:22:06,346
rays.


862
00:22:06,756 --> 00:22:08,086
But since that's something we're


863
00:22:08,086 --> 00:22:09,486
really trying to avoid in a real


864
00:22:09,486 --> 00:22:11,706
time application, what we can do


865
00:22:11,706 --> 00:22:13,786
instead is use the Denoiser that


866
00:22:13,786 --> 00:22:14,706
Sean was telling us about


867
00:22:14,706 --> 00:22:14,926
earlier.


868
00:22:15,606 --> 00:22:19,266
And here's the results of that.


869
00:22:19,346 --> 00:22:20,376
Most of the noise is filtered


870
00:22:20,376 --> 00:22:21,796
away and we get these great


871
00:22:21,796 --> 00:22:23,166
looking soft shadows with just


872
00:22:23,166 --> 00:22:24,066
one ray per pixel.


873
00:22:24,956 --> 00:22:26,666
And I'll be showing you this in


874
00:22:26,666 --> 00:22:28,226
action in our live demo later


875
00:22:28,226 --> 00:22:28,426
on.


876
00:22:29,026 --> 00:22:33,466
So now let's talk about Ambient


877
00:22:33,466 --> 00:22:33,956
Occlusion.


878
00:22:34,606 --> 00:22:37,016
So essentially, this is an


879
00:22:37,016 --> 00:22:38,346
approximation of how much


880
00:22:38,406 --> 00:22:39,776
ambient light is able to reach


881
00:22:39,776 --> 00:22:40,446
the surface.


882
00:22:41,306 --> 00:22:42,946
And as you saw in our AR Quick


883
00:22:42,946 --> 00:22:44,506
Look demo earlier, it's a really


884
00:22:44,506 --> 00:22:45,716
great technique for grounding


885
00:22:45,716 --> 00:22:47,266
objects in their environments.


886
00:22:48,596 --> 00:22:50,176
So, let's visualize how this


887
00:22:50,176 --> 00:22:51,126
works with Ray Tracing.


888
00:22:52,066 --> 00:22:53,866
We have a surface point in the


889
00:22:53,866 --> 00:22:54,736
middle of the screen there and


890
00:22:55,556 --> 00:22:57,206
there's a blue block over on the


891
00:22:57,206 --> 00:22:58,216
right that's going to play the


892
00:22:58,216 --> 00:22:59,146
role of our occluder.


893
00:23:00,676 --> 00:23:01,686
We define an imaginary


894
00:23:01,686 --> 00:23:03,176
hemisphere around our surface


895
00:23:03,216 --> 00:23:04,916
points and then we fire some


896
00:23:04,916 --> 00:23:05,136
rays.


897
00:23:05,836 --> 00:23:09,106
If a ray hits something, and we


898
00:23:09,106 --> 00:23:10,426
found that object is blocking


899
00:23:10,426 --> 00:23:11,616
ambient light from reaching the


900
00:23:11,726 --> 00:23:11,886
surface.


901
00:23:14,376 --> 00:23:15,866
Now, as I've mentioned a couple


902
00:23:15,866 --> 00:23:17,356
of times now, in a real time


903
00:23:17,356 --> 00:23:18,826
application, we're really trying


904
00:23:18,826 --> 00:23:20,186
to limit ourselves to just one


905
00:23:20,186 --> 00:23:21,156
or two rays per pixel.


906
00:23:22,136 --> 00:23:23,616
So, we need to use these rays as


907
00:23:23,616 --> 00:23:26,616
efficiently as we can.


908
00:23:26,646 --> 00:23:28,236
Now, one of the ways to do this


909
00:23:28,236 --> 00:23:29,246
is importance sampling.


910
00:23:29,846 --> 00:23:31,446
And the general idea here is to


911
00:23:31,446 --> 00:23:33,286
fire rays in the directions


912
00:23:33,286 --> 00:23:34,036
where we expect they'll


913
00:23:34,036 --> 00:23:35,626
contribute most to our final


914
00:23:35,626 --> 00:23:36,066
image.


915
00:23:36,666 --> 00:23:39,536
Now with Ambient Occlusion the


916
00:23:39,536 --> 00:23:40,836
most important rays are the ones


917
00:23:40,836 --> 00:23:41,826
closer to the normal.


918
00:23:43,026 --> 00:23:44,676
So instead of firing rays evenly


919
00:23:44,676 --> 00:23:45,776
in a hemisphere like you see


920
00:23:45,776 --> 00:23:47,216
here, we instead use cosine


921
00:23:47,216 --> 00:23:47,946
sampling.


922
00:23:48,546 --> 00:23:51,196
Now, this distributes fewer rays


923
00:23:51,196 --> 00:23:52,656
around the horizons and more


924
00:23:52,656 --> 00:23:53,876
rays around the surface normal.


925
00:23:54,256 --> 00:23:54,786
And that's great.


926
00:23:54,786 --> 00:23:56,766
That's exactly where we need


927
00:23:58,836 --> 00:23:58,946
them.


928
00:23:59,156 --> 00:24:00,536
Now in addition to this angular


929
00:24:00,536 --> 00:24:02,626
falloff, Ambient Occlusion also


930
00:24:02,626 --> 00:24:03,666
has a distance term.


931
00:24:04,326 --> 00:24:05,576
So, objects close to the


932
00:24:05,576 --> 00:24:06,786
surface, they tend to block the


933
00:24:06,786 --> 00:24:07,196
most light.


934
00:24:07,196 --> 00:24:09,226
And there's usually a fall off


935
00:24:09,226 --> 00:24:10,286
function in there too,


936
00:24:10,286 --> 00:24:11,536
proportional to the square of


937
00:24:11,536 --> 00:24:12,226
distance.


938
00:24:13,876 --> 00:24:15,376
Now, interesting thing we can do


939
00:24:15,376 --> 00:24:16,976
here is bake that fall off


940
00:24:16,976 --> 00:24:18,336
function right into the ray


941
00:24:18,336 --> 00:24:19,476
distribution itself.


942
00:24:20,316 --> 00:24:21,736
And the way we do this is by


943
00:24:21,846 --> 00:24:22,936
firing rays of different


944
00:24:23,856 --> 00:24:24,036
lengths.


945
00:24:25,076 --> 00:24:26,676
So, as you can see here, because


946
00:24:26,676 --> 00:24:28,446
of that distance squared fall


947
00:24:28,446 --> 00:24:29,376
off function I was telling you


948
00:24:29,376 --> 00:24:31,426
about, the majority of rays end


949
00:24:31,426 --> 00:24:32,256
up being quite short.


950
00:24:32,256 --> 00:24:33,956
Now this is great for


951
00:24:33,956 --> 00:24:34,656
performance.


952
00:24:34,726 --> 00:24:36,366
Short rays are much easier for


953
00:24:36,366 --> 00:24:37,366
Metal to trace through the


954
00:24:37,366 --> 00:24:38,366
acceleration structures.


955
00:24:38,986 --> 00:24:43,386
So, a couple of times now, I've


956
00:24:43,386 --> 00:24:45,186
talked about generating rays in


957
00:24:45,186 --> 00:24:46,666
various shapes and various


958
00:24:46,666 --> 00:24:48,596
distributions, such as the cones


959
00:24:48,596 --> 00:24:49,826
we were using for Soft Shadows


960
00:24:50,006 --> 00:24:51,186
and the hemisphere's that we're


961
00:24:51,186 --> 00:24:52,366
using for Ambient Occlusion.


962
00:24:52,966 --> 00:24:55,606
Now, the way that this works in


963
00:24:55,606 --> 00:24:57,366
practice is we begin by


964
00:24:57,396 --> 00:24:58,866
generating points in 2D


965
00:24:58,866 --> 00:25:00,556
parameter space and then we map


966
00:25:00,716 --> 00:25:02,206
that space with whichever ray


967
00:25:02,206 --> 00:25:03,516
distribution you want to use.


968
00:25:04,106 --> 00:25:06,826
Now the position of these points


969
00:25:06,826 --> 00:25:08,426
in parameter space can have a


970
00:25:08,426 --> 00:25:09,796
big effect on image quality.


971
00:25:11,206 --> 00:25:12,856
If you choose them randomly, you


972
00:25:12,856 --> 00:25:14,056
tend to end up with regions


973
00:25:14,056 --> 00:25:15,076
where sample points clump


974
00:25:15,076 --> 00:25:15,366
together.


975
00:25:15,366 --> 00:25:18,896
Now this causes us to fire rays


976
00:25:18,896 --> 00:25:19,896
in pretty much the same


977
00:25:19,896 --> 00:25:21,296
direction and that's just


978
00:25:21,296 --> 00:25:21,926
wasting rays.


979
00:25:22,576 --> 00:25:26,536
You can also get areas without


980
00:25:26,536 --> 00:25:27,606
any sample points at all.


981
00:25:28,106 --> 00:25:30,226
Now this impacts image quality


982
00:25:30,226 --> 00:25:31,346
because we're undersampling the


983
00:25:31,346 --> 00:25:32,266
scene in these areas.


984
00:25:32,946 --> 00:25:35,336
So, a better approach to


985
00:25:35,336 --> 00:25:37,046
generate sample points is to use


986
00:25:37,046 --> 00:25:37,846
something called a low


987
00:25:37,846 --> 00:25:39,206
discrepancy sequence.


988
00:25:39,906 --> 00:25:40,726
So, the one I'm showing you up


989
00:25:40,756 --> 00:25:41,986
on the screen here is the Halton


990
00:25:41,986 --> 00:25:43,286
2,3 sequence.


991
00:25:44,756 --> 00:25:46,206
You can see that sample points


992
00:25:46,206 --> 00:25:47,406
generated in this way, they


993
00:25:47,556 --> 00:25:49,446
cover the space far more evenly


994
00:25:49,446 --> 00:25:50,746
and we vanish the void by


995
00:25:50,896 --> 00:25:52,436
plumping and undersampling.


996
00:25:53,046 --> 00:25:57,856
So that's how to generate good


997
00:25:57,856 --> 00:25:59,406
rays for a single pixel.


998
00:26:00,036 --> 00:26:01,216
And what we need to do now is


999
00:26:01,316 --> 00:26:02,936
scale that to generate good rays


1000
00:26:02,936 --> 00:26:04,406
for all pixels on the screen.


1001
00:26:04,496 --> 00:26:06,846
Now, the way that we're doing


1002
00:26:06,846 --> 00:26:08,586
this is by taking one of those


1003
00:26:08,586 --> 00:26:10,336
low discrepancy sample points I


1004
00:26:10,336 --> 00:26:12,206
was just showing you and then we


1005
00:26:12,206 --> 00:26:13,726
apply a random delta for each


1006
00:26:13,726 --> 00:26:14,106
pixel.


1007
00:26:14,726 --> 00:26:18,426
Now, the effect of that is that


1008
00:26:18,466 --> 00:26:20,396
each pixel still runs through a


1009
00:26:20,396 --> 00:26:22,556
low discrepancy sequence, but


1010
00:26:22,556 --> 00:26:23,676
the exact positions of the


1011
00:26:23,676 --> 00:26:25,326
sample points are offset from


1012
00:26:25,326 --> 00:26:26,176
neighboring pixels on the


1013
00:26:26,176 --> 00:26:26,726
screen.


1014
00:26:27,206 --> 00:26:29,826
Now, there's a couple of


1015
00:26:29,826 --> 00:26:31,116
different ways to generate these


1016
00:26:31,116 --> 00:26:31,706
deltas.


1017
00:26:32,646 --> 00:26:34,826
One way is just to sample an RG


1018
00:26:34,826 --> 00:26:36,856
texture full of random numbers.


1019
00:26:37,386 --> 00:26:40,026
What we saw previously that


1020
00:26:40,026 --> 00:26:41,446
random numbers aren't always a


1021
00:26:41,446 --> 00:26:42,796
great choice for Ray Tracing.


1022
00:26:43,376 --> 00:26:44,796
And an alternative that works


1023
00:26:44,856 --> 00:26:45,836
really well for Ambient


1024
00:26:45,836 --> 00:26:47,266
Occlusion is blue noise.


1025
00:26:47,376 --> 00:26:49,966
So, you can see on the right


1026
00:26:50,026 --> 00:26:51,906
there that the randomness is the


1027
00:26:51,906 --> 00:26:53,366
blue noise texture, it's


1028
00:26:53,396 --> 00:26:55,436
distributed far more evenly and


1029
00:26:55,576 --> 00:26:56,936
that's great for image quality.


1030
00:26:56,936 --> 00:26:58,726
Particularly when we're limited


1031
00:26:58,836 --> 00:26:59,856
to just a couple of rays per


1032
00:26:59,856 --> 00:27:00,096
pixel.


1033
00:27:00,096 --> 00:27:03,886
So, let's look at the effect of


1034
00:27:03,886 --> 00:27:05,416
all of this on the Ambient


1035
00:27:05,416 --> 00:27:06,396
Occlusion result that we were


1036
00:27:06,396 --> 00:27:07,136
trying to generate.


1037
00:27:07,886 --> 00:27:09,896
So, here's what we started with.


1038
00:27:11,036 --> 00:27:12,066
This is using hemisphere


1039
00:27:12,066 --> 00:27:14,186
sampling and random deltas for


1040
00:27:14,186 --> 00:27:14,786
all pixels.


1041
00:27:15,396 --> 00:27:18,546
And this is what we get with


1042
00:27:18,546 --> 00:27:20,196
cosine sampling and the blue


1043
00:27:20,196 --> 00:27:21,136
noise that I was telling you


1044
00:27:21,136 --> 00:27:21,446
about.


1045
00:27:21,446 --> 00:27:23,506
So, I'll flip between these


1046
00:27:23,506 --> 00:27:24,396
images so you can see.


1047
00:27:25,816 --> 00:27:27,146
Now, both of these images are


1048
00:27:27,146 --> 00:27:28,846
generated using just two rays


1049
00:27:28,846 --> 00:27:29,346
per pixel.


1050
00:27:29,406 --> 00:27:31,896
But you can see by being


1051
00:27:31,946 --> 00:27:33,576
selective about how we use those


1052
00:27:33,576 --> 00:27:35,836
rays, the amount of noise is


1053
00:27:35,836 --> 00:27:37,246
significantly reduced.


1054
00:27:37,246 --> 00:27:38,396
And we've managed to capture


1055
00:27:38,396 --> 00:27:39,856
much more of the fine surface


1056
00:27:39,856 --> 00:27:40,266
detail.


1057
00:27:40,856 --> 00:27:43,456
And if we were to keep firing


1058
00:27:43,456 --> 00:27:45,316
rays, eventually the two


1059
00:27:45,316 --> 00:27:46,516
approaches would converge on


1060
00:27:46,516 --> 00:27:47,746
exactly the same image.


1061
00:27:48,136 --> 00:27:49,846
But using importance sampling


1062
00:27:49,846 --> 00:27:51,616
gets us there much faster.


1063
00:27:53,516 --> 00:27:55,386
So that's Shadows and Ambient


1064
00:27:55,386 --> 00:27:55,846
Occlusion.


1065
00:27:56,386 --> 00:27:58,046
And for these effects we were


1066
00:27:58,046 --> 00:27:59,636
really only interested in


1067
00:27:59,636 --> 00:28:00,916
whether our rays hit something


1068
00:28:00,916 --> 00:28:01,976
or whether they missed.


1069
00:28:02,826 --> 00:28:04,866
Now, for many of the other


1070
00:28:04,866 --> 00:28:06,036
effects that we typically


1071
00:28:06,036 --> 00:28:07,756
associate with Ray Tracing, such


1072
00:28:07,756 --> 00:28:09,766
as Global Illumination, you need


1073
00:28:09,766 --> 00:28:10,676
to model your rays as they


1074
00:28:10,676 --> 00:28:11,856
bounce around the scene.


1075
00:28:11,856 --> 00:28:13,896
And to talk some more about that


1076
00:28:13,896 --> 00:28:14,876
I'll invite up my colleague


1077
00:28:14,876 --> 00:28:14,976
Matt.


1078
00:28:16,516 --> 00:28:23,346
[ Applause ]


1079
00:28:23,846 --> 00:28:25,916
>> Thanks Wayne.


1080
00:28:26,456 --> 00:28:28,846
So, we're going to cover a few


1081
00:28:28,846 --> 00:28:30,336
topics in this section, starting


1082
00:28:30,336 --> 00:28:31,486
with a brief overview of Global


1083
00:28:31,486 --> 00:28:32,046
Illumination.


1084
00:28:32,546 --> 00:28:34,126
Then, we'll go into some best


1085
00:28:34,126 --> 00:28:35,306
practices for memory and ray


1086
00:28:35,306 --> 00:28:35,796
management.


1087
00:28:36,426 --> 00:28:38,036
Finally, we'll cover some


1088
00:28:38,036 --> 00:28:39,206
strategies for debugging your


1089
00:28:39,206 --> 00:28:40,186
Ray Tracing application.


1090
00:28:41,486 --> 00:28:43,256
So, what is Global Illumination?


1091
00:28:44,866 --> 00:28:46,056
Conceptually it's pretty simple.


1092
00:28:46,626 --> 00:28:47,876
Light enters the scene and


1093
00:28:47,876 --> 00:28:48,786
directly illuminates the


1094
00:28:48,786 --> 00:28:49,926
surfaces that it hits.


1095
00:28:50,646 --> 00:28:51,846
And rasterization, that's


1096
00:28:51,876 --> 00:28:52,546
typically the end of the


1097
00:28:52,546 --> 00:28:53,476
rendering process.


1098
00:28:53,866 --> 00:28:55,066
But in the real world, those


1099
00:28:55,066 --> 00:28:56,416
objects absorb some of the light


1100
00:28:56,416 --> 00:28:58,026
and then the rays bounce off and


1101
00:28:58,026 --> 00:28:59,196
keep traveling around the scene.


1102
00:28:59,686 --> 00:29:00,896
And as they bounce around, some


1103
00:29:00,896 --> 00:29:01,926
interesting visual effects


1104
00:29:01,926 --> 00:29:02,366
emerge.


1105
00:29:03,656 --> 00:29:05,986
After light has bounced once we


1106
00:29:05,986 --> 00:29:06,876
start to see specular


1107
00:29:06,876 --> 00:29:07,786
reflections on the mirrored


1108
00:29:07,786 --> 00:29:09,456
surfaces like the ball and wall


1109
00:29:09,456 --> 00:29:09,896
to the right.


1110
00:29:10,446 --> 00:29:12,916
You can also see that objects


1111
00:29:12,916 --> 00:29:14,166
and shadows get brighter as they


1112
00:29:14,166 --> 00:29:14,916
pick up light that's been


1113
00:29:14,916 --> 00:29:16,366
reflected off nearby surfaces.


1114
00:29:16,886 --> 00:29:19,406
After the light has bounced


1115
00:29:19,406 --> 00:29:20,286
twice, we start to see


1116
00:29:20,286 --> 00:29:21,476
reflections between mirrored


1117
00:29:21,476 --> 00:29:23,906
surfaces and eventually, some


1118
00:29:23,906 --> 00:29:25,176
rays have refracted all the way


1119
00:29:25,176 --> 00:29:26,946
through transparent objects, and


1120
00:29:26,946 --> 00:29:27,816
they're showing the surfaces


1121
00:29:27,816 --> 00:29:29,206
behind them giving us the glass


1122
00:29:29,206 --> 00:29:30,136
effect of the box.


1123
00:29:30,726 --> 00:29:32,956
Now, if we tried to model all


1124
00:29:32,956 --> 00:29:33,766
the light bouncing around the


1125
00:29:33,766 --> 00:29:35,746
scene only a small portion of it


1126
00:29:35,746 --> 00:29:36,946
would actually make it back to


1127
00:29:36,946 --> 00:29:38,066
the camera and that would be


1128
00:29:38,066 --> 00:29:38,706
pretty inefficient.


1129
00:29:38,986 --> 00:29:41,296
So instead, we'll work backwards


1130
00:29:41,446 --> 00:29:42,576
from the camera towards the


1131
00:29:42,576 --> 00:29:43,446
light source.


1132
00:29:44,376 --> 00:29:46,236
We cast rays from the camera


1133
00:29:46,236 --> 00:29:47,606
towards the pixels in our image.


1134
00:29:49,386 --> 00:29:51,316
The intersection points of those


1135
00:29:51,316 --> 00:29:52,666
rays tell us what objects are


1136
00:29:52,666 --> 00:29:53,036
visible.


1137
00:29:53,036 --> 00:29:54,376
But we'll need to figure out how


1138
00:29:54,376 --> 00:29:55,516
much light is reaching them in


1139
00:29:55,516 --> 00:29:56,416
order to figure out what their


1140
00:29:56,416 --> 00:29:57,666
color in the final image should


1141
00:29:57,666 --> 00:29:57,956
be.


1142
00:29:59,036 --> 00:30:00,396
Earlier, Wayne described how to


1143
00:30:00,396 --> 00:30:02,296
calculate soft shadows and here


1144
00:30:02,296 --> 00:30:03,156
we're going to be performing


1145
00:30:03,156 --> 00:30:04,616
exactly the same process.


1146
00:30:05,956 --> 00:30:07,136
We cast shadow rays from the


1147
00:30:07,136 --> 00:30:08,546
intersection points towards the


1148
00:30:08,546 --> 00:30:09,826
lights in the scene in order to


1149
00:30:09,826 --> 00:30:10,946
approximate how much light's


1150
00:30:10,946 --> 00:30:11,366
reaching them.


1151
00:30:12,606 --> 00:30:13,496
That's used as the light


1152
00:30:13,496 --> 00:30:14,706
contribution towards the final


1153
00:30:14,706 --> 00:30:15,026
image.


1154
00:30:15,526 --> 00:30:19,336
Next, from the intersection


1155
00:30:19,336 --> 00:30:21,166
points we cast secondary rays in


1156
00:30:21,166 --> 00:30:22,136
random directions.


1157
00:30:22,676 --> 00:30:24,226
We use Metal to figure out what


1158
00:30:24,306 --> 00:30:25,706
those rays hit and then cast


1159
00:30:25,706 --> 00:30:26,866
shadow rays to determine their


1160
00:30:26,866 --> 00:30:28,216
direct lighting and then use


1161
00:30:28,216 --> 00:30:29,396
that to add light to the final


1162
00:30:29,396 --> 00:30:29,726
image.


1163
00:30:30,366 --> 00:30:31,816
By repeating this process, we


1164
00:30:31,816 --> 00:30:32,866
can simulate light bouncing


1165
00:30:32,866 --> 00:30:34,056
around the room.


1166
00:30:34,486 --> 00:30:35,856
We described this extensively in


1167
00:30:35,856 --> 00:30:37,126
last year's talk, so I'll refer


1168
00:30:37,126 --> 00:30:38,206
you to that for more details on


1169
00:30:38,206 --> 00:30:39,476
how to go through this process.


1170
00:30:39,996 --> 00:30:42,586
Our pipeline for this will look


1171
00:30:42,586 --> 00:30:43,456
a little bit different than the


1172
00:30:43,456 --> 00:30:44,656
hybrid pipelines that we've seen


1173
00:30:44,656 --> 00:30:45,156
so far.


1174
00:30:46,316 --> 00:30:47,526
First, we set up rays and use


1175
00:30:47,526 --> 00:30:48,226
Metal to find their


1176
00:30:48,226 --> 00:30:51,496
intersections with the scene.


1177
00:30:51,966 --> 00:30:53,216
Then, we write a shader to


1178
00:30:53,216 --> 00:30:54,236
process the results of those


1179
00:30:54,236 --> 00:30:55,916
intersection tests to tell us


1180
00:30:55,916 --> 00:30:57,506
what surfaces we hit.


1181
00:30:58,956 --> 00:31:01,226
Then, we generate shadow rays


1182
00:31:01,226 --> 00:31:02,066
from those intersection


1183
00:31:02,066 --> 00:31:03,266
locations towards the lights in


1184
00:31:03,266 --> 00:31:03,636
the scene.


1185
00:31:04,136 --> 00:31:05,456
I'll write a shader to figure


1186
00:31:05,456 --> 00:31:06,516
out which of those rays hit the


1187
00:31:06,516 --> 00:31:07,806
light and then add their light


1188
00:31:07,806 --> 00:31:08,566
to the final image.


1189
00:31:10,016 --> 00:31:11,656
Finally, we use the hit surfaces


1190
00:31:11,656 --> 00:31:12,776
as the starting positions for


1191
00:31:12,776 --> 00:31:13,766
our next set of rays.


1192
00:31:14,326 --> 00:31:15,666
We repeat this process over and


1193
00:31:15,666 --> 00:31:16,686
over again until we've modeled


1194
00:31:16,686 --> 00:31:17,996
as many ray bounces as we like.


1195
00:31:18,626 --> 00:31:20,996
So that's how Global


1196
00:31:20,996 --> 00:31:22,156
Illumination works.


1197
00:31:22,826 --> 00:31:24,536
Now we'll discuss some best


1198
00:31:24,536 --> 00:31:25,606
practices that come up with


1199
00:31:25,606 --> 00:31:27,446
memory for this programing


1200
00:31:27,446 --> 00:31:27,736
model.


1201
00:31:28,976 --> 00:31:31,026
As any ray bounces around the


1202
00:31:31,026 --> 00:31:31,486
scene.


1203
00:31:31,836 --> 00:31:33,186
Its state changes depending on


1204
00:31:33,186 --> 00:31:34,106
its interactions with the


1205
00:31:34,106 --> 00:31:35,106
objects that it hits.


1206
00:31:35,766 --> 00:31:37,276
For instance, if a ray hits a


1207
00:31:37,276 --> 00:31:38,906
red material that surface


1208
00:31:38,906 --> 00:31:40,496
absorbs everything but the red


1209
00:31:40,496 --> 00:31:41,266
component of the light.


1210
00:31:41,836 --> 00:31:42,986
So, the secondary rays that


1211
00:31:42,986 --> 00:31:44,616
reflect off of that surface will


1212
00:31:44,616 --> 00:31:45,636
only carry red light.


1213
00:31:46,146 --> 00:31:47,586
So, we'll have to keep track of


1214
00:31:47,586 --> 00:31:48,736
that information in order to


1215
00:31:48,736 --> 00:31:50,056
pass it to the next iteration of


1216
00:31:50,056 --> 00:31:50,666
our pipeline.


1217
00:31:51,366 --> 00:31:51,996
That means we'll have to


1218
00:31:51,996 --> 00:31:53,346
allocate a bunch of resources to


1219
00:31:53,346 --> 00:31:54,816
keep track of ray and scene


1220
00:31:54,816 --> 00:31:55,516
properties.


1221
00:31:56,136 --> 00:31:57,646
To the right, I've listed a few


1222
00:31:57,646 --> 00:31:59,446
examples of scene properties you


1223
00:31:59,446 --> 00:32:02,636
may want to keep track of.


1224
00:32:03,146 --> 00:32:04,116
With all these new buffers


1225
00:32:04,116 --> 00:32:05,626
relocated we're going to be


1226
00:32:05,626 --> 00:32:06,676
using a lot of memory.


1227
00:32:07,186 --> 00:32:08,836
For a 4K image, the ray buffer


1228
00:32:08,836 --> 00:32:11,096
alone would be 250 MB.


1229
00:32:11,416 --> 00:32:12,576
In one of our demos, we're using


1230
00:32:12,576 --> 00:32:13,906
almost 80 bytes per ray.


1231
00:32:14,536 --> 00:32:15,756
And this approach can quickly


1232
00:32:15,756 --> 00:32:16,836
exceed the amount of available


1233
00:32:16,836 --> 00:32:17,586
GPU memory.


1234
00:32:19,396 --> 00:32:20,946
One solution to this is just to


1235
00:32:20,946 --> 00:32:22,476
batch up your rays into smaller


1236
00:32:22,476 --> 00:32:23,266
groups or tiles.


1237
00:32:23,926 --> 00:32:25,066
And by restricting the number of


1238
00:32:25,066 --> 00:32:25,816
rays that you're launching


1239
00:32:25,816 --> 00:32:26,916
simultaneously you can


1240
00:32:26,916 --> 00:32:28,156
drastically reduce the memory


1241
00:32:28,156 --> 00:32:29,396
footprint of your resources.


1242
00:32:29,846 --> 00:32:32,336
Because the data in these


1243
00:32:32,336 --> 00:32:33,396
buffers is going to be passed


1244
00:32:33,496 --> 00:32:35,316
between pipeline iterations,


1245
00:32:36,256 --> 00:32:37,546
storing that data out and then


1246
00:32:37,546 --> 00:32:38,736
reading it in, in the next pass


1247
00:32:38,736 --> 00:32:39,906
is going to be a major limiting


1248
00:32:39,906 --> 00:32:40,276
factor.


1249
00:32:40,906 --> 00:32:42,956
For 4K image we're using over 8


1250
00:32:42,956 --> 00:32:43,756
million rays.


1251
00:32:44,276 --> 00:32:45,486
And for that number of rays,


1252
00:32:45,486 --> 00:32:46,626
we're reading and writing almost


1253
00:32:46,626 --> 00:32:50,006
5 gigabytes of data per pass.


1254
00:32:50,286 --> 00:32:51,466
There's no one solution to every


1255
00:32:51,466 --> 00:32:52,736
bandwidth problem, but we can


1256
00:32:52,736 --> 00:32:53,796
give you some best practices


1257
00:32:53,796 --> 00:32:54,936
that worked well for us.


1258
00:32:55,206 --> 00:32:57,066
First, don't index into your


1259
00:32:57,066 --> 00:32:57,946
data buffers randomly.


1260
00:32:58,996 --> 00:33:00,606
It's much more efficient if you


1261
00:33:00,606 --> 00:33:02,196
can index by thread ID, so the


1262
00:33:02,196 --> 00:33:03,636
compiler can coalesce all of the


1263
00:33:03,636 --> 00:33:05,456
loads and stores since the


1264
00:33:05,456 --> 00:33:06,746
memory the threads are accessing


1265
00:33:06,746 --> 00:33:07,936
will be in adjacent buffer


1266
00:33:07,936 --> 00:33:08,576
positions.


1267
00:33:09,796 --> 00:33:10,966
This is really going to improve


1268
00:33:10,966 --> 00:33:11,946
your cache coherency.


1269
00:33:13,146 --> 00:33:14,756
Next, for variables where you


1270
00:33:14,756 --> 00:33:15,786
don't need full precision,


1271
00:33:16,376 --> 00:33:17,726
consider using smaller data


1272
00:33:17,726 --> 00:33:18,586
types where possible.


1273
00:33:19,316 --> 00:33:20,736
Try to use half instead of float


1274
00:33:20,736 --> 00:33:22,196
data types for ray and scene and


1275
00:33:22,196 --> 00:33:23,366
material properties if you can.


1276
00:33:24,806 --> 00:33:26,566
Finally, split up structs if


1277
00:33:26,566 --> 00:33:27,836
possible, to avoid loading or


1278
00:33:27,836 --> 00:33:28,996
storing data you're not going to


1279
00:33:28,996 --> 00:33:29,446
use.


1280
00:33:29,696 --> 00:33:31,506
For example, we have a struct


1281
00:33:31,506 --> 00:33:32,586
that contains material


1282
00:33:32,586 --> 00:33:33,206
properties.


1283
00:33:33,776 --> 00:33:35,026
We get a nice performance boost


1284
00:33:35,026 --> 00:33:35,706
by stripping out the


1285
00:33:35,706 --> 00:33:37,316
transparency variables because


1286
00:33:37,316 --> 00:33:38,926
not every ray hits a transparent


1287
00:33:38,926 --> 00:33:39,446
surface.


1288
00:33:39,446 --> 00:33:40,626
And we didn't want those rays to


1289
00:33:40,626 --> 00:33:41,756
have to pay the penalty for


1290
00:33:41,756 --> 00:33:42,806
reading and writing that data.


1291
00:33:43,626 --> 00:33:44,356
We're going to see a more


1292
00:33:44,356 --> 00:33:45,716
concrete example of this later


1293
00:33:45,716 --> 00:33:46,916
in the GPU debugging section.


1294
00:33:46,916 --> 00:33:51,476
It might be counter intuitive,


1295
00:33:51,576 --> 00:33:52,586
but it may be more efficient to


1296
00:33:52,586 --> 00:33:53,886
allocate your own buffers to


1297
00:33:53,886 --> 00:33:55,996
store origin and direction data


1298
00:33:56,356 --> 00:33:57,586
rather than reusing the Metal


1299
00:33:57,586 --> 00:33:58,506
ray buffer structs.


1300
00:33:59,816 --> 00:34:00,996
This is because the Metal ray


1301
00:34:00,996 --> 00:34:02,566
buffers may contain extra data


1302
00:34:02,566 --> 00:34:03,636
numbers that you don't want to


1303
00:34:03,636 --> 00:34:05,516
have to load and store for every


1304
00:34:05,516 --> 00:34:06,806
shader that may access the ray.


1305
00:34:09,576 --> 00:34:12,096
To maximize your GPU usage, you


1306
00:34:12,096 --> 00:34:12,985
need to be mindful of your


1307
00:34:12,985 --> 00:34:13,856
shader occupancy.


1308
00:34:14,545 --> 00:34:16,306
Occupancy is a huge topic, so we


1309
00:34:16,306 --> 00:34:17,565
won't go into it in depth here.


1310
00:34:18,266 --> 00:34:19,525
But if you are getting occupancy


1311
00:34:19,525 --> 00:34:20,746
problems the easiest way to


1312
00:34:20,746 --> 00:34:22,156
improve it is to reduce your


1313
00:34:22,156 --> 00:34:22,896
register pressure.


1314
00:34:24,246 --> 00:34:25,735
So, be conscious of the number


1315
00:34:25,735 --> 00:34:27,255
of simultaneously live variables


1316
00:34:27,255 --> 00:34:28,096
that you have in your shader.


1317
00:34:28,876 --> 00:34:30,326
Be careful with loop counters,


1318
00:34:30,326 --> 00:34:32,505
function calls, and don't hold


1319
00:34:32,505 --> 00:34:33,626
on to full structs if you can


1320
00:34:33,626 --> 00:34:34,585
avoid it.


1321
00:34:35,156 --> 00:34:38,766
When we process ray intersection


1322
00:34:38,766 --> 00:34:40,485
points we need to evaluate the


1323
00:34:40,485 --> 00:34:41,826
surface properties of whatever


1324
00:34:41,826 --> 00:34:42,866
object a ray hits.


1325
00:34:43,116 --> 00:34:44,755
And graphics applications


1326
00:34:44,755 --> 00:34:45,686
typically store a lot of the


1327
00:34:45,686 --> 00:34:47,335
material properties in textures.


1328
00:34:47,976 --> 00:34:49,456
The problem here is that because


1329
00:34:49,456 --> 00:34:51,446
a shader may need access to any


1330
00:34:51,446 --> 00:34:52,346
texture that an object


1331
00:34:52,346 --> 00:34:54,936
references, and we don't know in


1332
00:34:54,936 --> 00:34:56,696
advance what object a ray is


1333
00:34:56,696 --> 00:34:58,246
going to hit, we may potential


1334
00:34:58,246 --> 00:35:00,296
he need access to every -- every


1335
00:35:00,296 --> 00:35:01,246
texture that's in the scene.


1336
00:35:02,006 --> 00:35:03,026
And this can get out of hand


1337
00:35:03,026 --> 00:35:03,356
quickly.


1338
00:35:03,846 --> 00:35:05,386
For instance, the commonly used


1339
00:35:05,386 --> 00:35:07,406
Sponza Atrium scene has 76


1340
00:35:07,406 --> 00:35:09,236
textures, which is over double


1341
00:35:09,306 --> 00:35:10,426
our available number of bind


1342
00:35:10,426 --> 00:35:10,746
slots.


1343
00:35:11,376 --> 00:35:12,666
So, we'll pretty quickly run out


1344
00:35:12,666 --> 00:35:13,866
of binding locations.


1345
00:35:15,756 --> 00:35:17,796
One way to address this is by


1346
00:35:17,796 --> 00:35:19,566
using Metal Argument Buffers.


1347
00:35:19,906 --> 00:35:20,766
A Metal Argument Buffer


1348
00:35:20,766 --> 00:35:22,566
represents a group of resources


1349
00:35:22,566 --> 00:35:23,526
that can be collectively


1350
00:35:23,526 --> 00:35:24,946
assigned as a single argument to


1351
00:35:24,946 --> 00:35:25,316
a shader.


1352
00:35:26,466 --> 00:35:27,786
We gave a talk on this at WWDC


1353
00:35:27,786 --> 00:35:29,006
two years ago.


1354
00:35:29,276 --> 00:35:30,786
So, I'll refer you to that for


1355
00:35:30,786 --> 00:35:33,106
more details on how to use them.


1356
00:35:33,546 --> 00:35:34,926
Assuming we have one texture per


1357
00:35:34,926 --> 00:35:36,706
primitive, our argument buffer


1358
00:35:36,706 --> 00:35:38,166
will be a struct that contains a


1359
00:35:38,166 --> 00:35:39,006
reference to a texture.


1360
00:35:40,376 --> 00:35:41,596
Here, we've set up a struct that


1361
00:35:41,596 --> 00:35:43,196
we called material that contains


1362
00:35:43,196 --> 00:35:44,536
a texture reference and any


1363
00:35:44,536 --> 00:35:45,576
other information we'd like to


1364
00:35:45,576 --> 00:35:46,206
access.


1365
00:35:47,566 --> 00:35:48,896
Next, we bind our argument


1366
00:35:48,896 --> 00:35:49,916
buffer to a compute kernel.


1367
00:35:50,206 --> 00:35:51,846
It will appear as an array of


1368
00:35:51,846 --> 00:35:52,726
material structs.


1369
00:35:54,506 --> 00:35:55,646
We read from our intersection


1370
00:35:55,646 --> 00:35:56,676
buffer to find out what


1371
00:35:56,676 --> 00:35:59,206
primitive the ray hit and then


1372
00:35:59,206 --> 00:36:00,596
we index into our argument


1373
00:36:00,596 --> 00:36:01,936
buffer using that index.


1374
00:36:02,626 --> 00:36:04,126
That lets us access a unique


1375
00:36:04,126 --> 00:36:04,976
texture for every primitive.


1376
00:36:08,646 --> 00:36:10,106
That covers our memory topics.


1377
00:36:11,186 --> 00:36:12,336
Now we'll discuss managing the


1378
00:36:12,336 --> 00:36:13,436
lifetime of your rays.


1379
00:36:14,516 --> 00:36:16,066
As your ray bounces around the


1380
00:36:16,066 --> 00:36:17,716
scene it can stop contributing


1381
00:36:17,716 --> 00:36:19,026
to the final image for a variety


1382
00:36:19,026 --> 00:36:19,646
of reasons.


1383
00:36:20,156 --> 00:36:21,546
First, it may leave the scene


1384
00:36:21,546 --> 00:36:22,036
entirely.


1385
00:36:22,736 --> 00:36:23,936
Unlike the real world, your


1386
00:36:23,936 --> 00:36:25,156
scene takes up a finite amount


1387
00:36:25,156 --> 00:36:26,956
of space, and if the ray exits


1388
00:36:26,956 --> 00:36:28,096
it there's no way for it to make


1389
00:36:28,096 --> 00:36:28,866
its way back in.


1390
00:36:29,386 --> 00:36:31,386
If that happens, we typically


1391
00:36:31,386 --> 00:36:32,716
evaluate an environment map to


1392
00:36:32,716 --> 00:36:34,336
get a background color, but that


1393
00:36:34,336 --> 00:36:35,376
ray is effectively dead.


1394
00:36:36,806 --> 00:36:39,166
Second, as the ray bounces, the


1395
00:36:39,166 --> 00:36:40,136
light it carries will be


1396
00:36:40,136 --> 00:36:41,566
attenuated by the surfaces is


1397
00:36:41,566 --> 00:36:42,266
interacts with.


1398
00:36:42,936 --> 00:36:45,456
If it loses enough light it may


1399
00:36:45,456 --> 00:36:46,576
not be able to have a measurable


1400
00:36:46,576 --> 00:36:47,716
impact on the final image.


1401
00:36:48,686 --> 00:36:50,276
And finally, with transparent


1402
00:36:50,276 --> 00:36:51,516
surfaces, there are some rays


1403
00:36:51,516 --> 00:36:53,026
that can get trapped in


1404
00:36:53,026 --> 00:36:54,066
position, such that they can


1405
00:36:54,066 --> 00:36:55,166
never get back to the camera.


1406
00:36:55,786 --> 00:36:58,826
So how quickly to rays become


1407
00:36:58,826 --> 00:36:59,236
inactive?


1408
00:37:00,116 --> 00:37:01,136
Well, depending on the kind of


1409
00:37:01,136 --> 00:37:02,706
scene it can be quite rapid.


1410
00:37:03,396 --> 00:37:04,996
For example, this scene has an


1411
00:37:04,996 --> 00:37:06,626
open world and a lot of the rays


1412
00:37:06,626 --> 00:37:07,866
will exit quickly by hitting the


1413
00:37:07,866 --> 00:37:08,456
environment map.


1414
00:37:09,156 --> 00:37:10,156
On the right, we're showing a


1415
00:37:10,156 --> 00:37:11,696
simplified representation of a


1416
00:37:11,696 --> 00:37:13,666
fully active ray buffer as it


1417
00:37:13,666 --> 00:37:14,696
would exist for the first


1418
00:37:14,696 --> 00:37:15,956
iteration of our pipeline.


1419
00:37:16,346 --> 00:37:17,886
This is the step where we cast


1420
00:37:17,886 --> 00:37:19,246
rays from the camera towards the


1421
00:37:19,246 --> 00:37:19,546
scene.


1422
00:37:20,136 --> 00:37:23,096
Some of those rays will hit the


1423
00:37:23,096 --> 00:37:24,016
environment map and become


1424
00:37:24,016 --> 00:37:24,436
inactive.


1425
00:37:25,156 --> 00:37:26,336
Here, we've colored inactive


1426
00:37:26,336 --> 00:37:27,986
rays yellow and we've removed


1427
00:37:27,986 --> 00:37:28,826
them from the ray buffer.


1428
00:37:29,626 --> 00:37:31,626
After the first pass only 57


1429
00:37:31,626 --> 00:37:32,746
percent of our rays are still


1430
00:37:32,746 --> 00:37:33,046
active.


1431
00:37:34,526 --> 00:37:36,046
When we let the rays continue


1432
00:37:36,046 --> 00:37:37,276
traveling, some of the rays that


1433
00:37:37,276 --> 00:37:39,006
initially hit the ground bounce


1434
00:37:39,006 --> 00:37:40,076
up and hit the environment map.


1435
00:37:40,636 --> 00:37:41,916
Now we're down to 43 percent of


1436
00:37:41,916 --> 00:37:44,566
rays that -- left active.


1437
00:37:45,286 --> 00:37:46,796
Now, some of the rays travel all


1438
00:37:46,796 --> 00:37:47,826
the way through the transparent


1439
00:37:47,826 --> 00:37:49,126
objects and eventually exit the


1440
00:37:49,126 --> 00:37:49,536
scene.


1441
00:37:50,036 --> 00:37:50,956
We've only got about a third


1442
00:37:50,956 --> 00:37:51,556
remaining active.


1443
00:37:52,646 --> 00:37:53,816
And of course, the more we


1444
00:37:53,816 --> 00:37:55,016
iterate, the more rays become


1445
00:37:55,016 --> 00:37:55,386
inactive.


1446
00:37:56,086 --> 00:37:58,896
In this example we know a lot of


1447
00:37:58,896 --> 00:38:00,116
the rays in our ray buffer will


1448
00:38:00,116 --> 00:38:01,406
be inactive, and anytime we


1449
00:38:01,406 --> 00:38:02,466
spend processing them will be


1450
00:38:02,466 --> 00:38:02,886
wasted.


1451
00:38:03,376 --> 00:38:04,916
But because we don't know in


1452
00:38:04,916 --> 00:38:06,156
advance which rays are going to


1453
00:38:06,156 --> 00:38:07,896
be inactive, the Metal Ray


1454
00:38:07,896 --> 00:38:09,366
Intersector and all of the


1455
00:38:09,366 --> 00:38:10,896
shaders that process its results


1456
00:38:10,896 --> 00:38:12,126
are still going to have to be


1457
00:38:12,126 --> 00:38:13,276
run on all of them.


1458
00:38:13,696 --> 00:38:14,296
That means we'll have to


1459
00:38:14,296 --> 00:38:15,486
allocate thread group memory,


1460
00:38:15,626 --> 00:38:16,756
the compiler may be prefetching


1461
00:38:16,756 --> 00:38:18,176
data, and we may have to add


1462
00:38:18,176 --> 00:38:20,056
control flow statements to cull


1463
00:38:20,056 --> 00:38:21,146
inactive rays.


1464
00:38:22,026 --> 00:38:23,676
Our occupancy here stays the


1465
00:38:23,676 --> 00:38:25,676
same, but our thread groups have


1466
00:38:25,676 --> 00:38:27,076
become sparsely utilized.


1467
00:38:27,486 --> 00:38:28,756
And we're wasting all that


1468
00:38:28,756 --> 00:38:29,676
processor capacity.


1469
00:38:30,216 --> 00:38:33,386
Our solution to this is to the


1470
00:38:33,386 --> 00:38:34,736
compact the ray buffers.


1471
00:38:35,536 --> 00:38:37,396
For every pass we only add


1472
00:38:37,396 --> 00:38:39,256
active rays to the next passes


1473
00:38:39,256 --> 00:38:39,726
ray buffer.


1474
00:38:40,426 --> 00:38:41,856
This adds some overhead, but it


1475
00:38:41,856 --> 00:38:43,166
results in the cache lines and


1476
00:38:43,166 --> 00:38:44,136
thread groups being fully


1477
00:38:44,136 --> 00:38:45,926
utilized so there's less waste


1478
00:38:45,926 --> 00:38:47,566
of processing and less bandwidth


1479
00:38:47,566 --> 00:38:48,056
required.


1480
00:38:48,746 --> 00:38:50,446
It's also important to note that


1481
00:38:50,446 --> 00:38:51,666
this can be used for shadow rays


1482
00:38:51,666 --> 00:38:52,286
as well.


1483
00:38:52,756 --> 00:38:54,066
Some rays will hit surfaces that


1484
00:38:54,066 --> 00:38:55,186
are pointing away from a light


1485
00:38:55,436 --> 00:38:56,436
or they may hit the background.


1486
00:38:56,546 --> 00:38:57,406
So, we won't want to cache


1487
00:38:57,406 --> 00:38:58,776
shadow rays for them.


1488
00:38:59,936 --> 00:39:01,966
The downside is that because


1489
00:39:01,966 --> 00:39:03,196
we're shuffling ray positions


1490
00:39:03,196 --> 00:39:04,856
within the ray buffers, the


1491
00:39:04,856 --> 00:39:06,836
indices in our ray buffer no


1492
00:39:06,836 --> 00:39:08,206
longer map to constant pixel


1493
00:39:08,206 --> 00:39:08,846
locations.


1494
00:39:09,336 --> 00:39:10,256
So, we'll need to allocate a


1495
00:39:10,256 --> 00:39:11,546
buffer to start tracking pixel


1496
00:39:11,546 --> 00:39:12,876
coordinates along with each ray.


1497
00:39:12,876 --> 00:39:15,386
Even though we're using extra


1498
00:39:15,386 --> 00:39:17,026
buffers, we'll actually be using


1499
00:39:17,026 --> 00:39:18,616
much less memory if we factor in


1500
00:39:18,616 --> 00:39:19,726
all of the rays that we don't


1501
00:39:19,726 --> 00:39:20,636
have to process.


1502
00:39:21,886 --> 00:39:23,976
When we're compacting the rays,


1503
00:39:24,316 --> 00:39:25,846
we don't want two shaders to try


1504
00:39:25,846 --> 00:39:27,136
to add rays to the new ray


1505
00:39:27,136 --> 00:39:28,506
buffer at the same location.


1506
00:39:29,296 --> 00:39:30,476
Therefore, we need to produce a


1507
00:39:30,476 --> 00:39:32,126
unique index into the ray buffer


1508
00:39:32,126 --> 00:39:33,286
for every ray that remains


1509
00:39:33,286 --> 00:39:34,916
active between passes.


1510
00:39:35,996 --> 00:39:37,406
We use an atomic counter to do


1511
00:39:37,406 --> 00:39:37,756
this.


1512
00:39:38,536 --> 00:39:39,836
Here, the atomic integer


1513
00:39:39,946 --> 00:39:41,446
outgoingRayCount contains the


1514
00:39:41,446 --> 00:39:43,036
current number of rays in the


1515
00:39:43,036 --> 00:39:43,756
new ray buffer.


1516
00:39:45,376 --> 00:39:47,506
We use atomic fetch add explicit


1517
00:39:47,506 --> 00:39:48,836
to grab the current value of


1518
00:39:48,836 --> 00:39:50,786
outgoing ray count and increment


1519
00:39:51,396 --> 00:39:52,606
it by one.


1520
00:39:52,606 --> 00:39:54,156
Using that value as the index


1521
00:39:54,156 --> 00:39:55,306
into the outgoing ray buffer


1522
00:39:55,406 --> 00:39:56,376
ensures that we don't get


1523
00:39:56,376 --> 00:39:57,086
conflicts.


1524
00:39:57,556 --> 00:39:58,806
It has the added benefit of


1525
00:39:58,806 --> 00:39:59,936
leaving the number of rays that


1526
00:39:59,936 --> 00:40:02,516
remain active in outgoing ray


1527
00:40:03,416 --> 00:40:03,556
count.


1528
00:40:04,096 --> 00:40:05,446
Now, Ray Compaction doesn't help


1529
00:40:05,446 --> 00:40:06,666
you much if you can't restrict


1530
00:40:06,666 --> 00:40:07,426
the number of threads that


1531
00:40:07,426 --> 00:40:07,906
you're launching.


1532
00:40:08,076 --> 00:40:09,476
The outgoing ray count buffer we


1533
00:40:09,476 --> 00:40:11,046
just produced contains the total


1534
00:40:11,046 --> 00:40:12,806
number of active rays in our


1535
00:40:12,806 --> 00:40:13,686
outgoing ray buffer.


1536
00:40:14,836 --> 00:40:16,286
We can use that to fill out an


1537
00:40:16,356 --> 00:40:17,646
MTLDispatch ThreadGroups


1538
00:40:17,686 --> 00:40:19,026
IndirectArguments object.


1539
00:40:19,956 --> 00:40:21,266
That just specifies launch


1540
00:40:21,266 --> 00:40:22,476
dimensions to be used with the


1541
00:40:22,476 --> 00:40:23,026
dispatch.


1542
00:40:24,146 --> 00:40:25,836
Then, by using IndirectDispatch


1543
00:40:25,836 --> 00:40:27,056
with that indirectBuffer object


1544
00:40:27,496 --> 00:40:28,596
we can restrict the number of


1545
00:40:28,596 --> 00:40:29,666
threads that we're launching to


1546
00:40:29,666 --> 00:40:30,896
only process the rays that


1547
00:40:30,896 --> 00:40:31,416
remain active.


1548
00:40:31,416 --> 00:40:33,506
There's also a version of the


1549
00:40:33,506 --> 00:40:34,436
ray intersection function that


1550
00:40:34,466 --> 00:40:34,976
corresponds to this.


1551
00:40:35,066 --> 00:40:37,576
The important point here is that


1552
00:40:38,266 --> 00:40:40,966
we can pass our ray count via a


1553
00:40:40,966 --> 00:40:42,356
buffer, so we can feed the


1554
00:40:42,356 --> 00:40:43,626
result of our ray compaction


1555
00:40:43,626 --> 00:40:45,216
step in as the number of threads


1556
00:40:45,216 --> 00:40:45,796
to launch.


1557
00:40:47,596 --> 00:40:49,776
After Ray Compaction we get


1558
00:40:49,776 --> 00:40:51,326
about a 15 percent performance


1559
00:40:51,326 --> 00:40:52,216
gain in this scene.


1560
00:40:52,346 --> 00:40:54,096
But of course, your results will


1561
00:40:54,096 --> 00:40:55,616
depend on the complexity of the


1562
00:40:55,616 --> 00:40:56,876
scene you're using and the


1563
00:40:56,876 --> 00:40:57,926
number of ray bounces.


1564
00:40:58,486 --> 00:41:02,036
So that covers ray lifetime and


1565
00:41:02,036 --> 00:41:02,396
culling.


1566
00:41:03,696 --> 00:41:05,386
Now we're going to discuss


1567
00:41:05,386 --> 00:41:07,806
debugging your application with


1568
00:41:08,536 --> 00:41:08,706
Xcode.


1569
00:41:09,346 --> 00:41:10,496
Debugging on the GPU is


1570
00:41:10,496 --> 00:41:12,176
notoriously difficult process.


1571
00:41:12,756 --> 00:41:14,126
And this is especially true for


1572
00:41:14,126 --> 00:41:14,546
Ray Tracing.


1573
00:41:15,346 --> 00:41:16,436
Any change you make may get


1574
00:41:16,436 --> 00:41:18,016
invoked multiple times per ray


1575
00:41:18,016 --> 00:41:19,286
and you might have to write a


1576
00:41:19,286 --> 00:41:20,726
lot of code to dump out buffers


1577
00:41:20,726 --> 00:41:22,196
and textures for a bunch of


1578
00:41:22,196 --> 00:41:23,046
different stages of your


1579
00:41:23,046 --> 00:41:24,676
algorithm to get a clue about


1580
00:41:24,676 --> 00:41:25,916
where an error was introduced.


1581
00:41:26,736 --> 00:41:28,566
Xcode's frame capture tools are


1582
00:41:28,566 --> 00:41:30,226
amazing for debugging exactly


1583
00:41:30,226 --> 00:41:31,446
these kinds of issues.


1584
00:41:31,896 --> 00:41:32,966
It's incredibly powerful and a


1585
00:41:32,966 --> 00:41:33,766
real time saver.


1586
00:41:34,746 --> 00:41:36,356
So, I'm going to walk you


1587
00:41:36,356 --> 00:41:37,586
through debugging a real-world


1588
00:41:37,586 --> 00:41:38,856
issue that we hit when we


1589
00:41:38,856 --> 00:41:40,246
implemented super sampling in


1590
00:41:40,246 --> 00:41:40,976
our ray tracer.


1591
00:41:41,606 --> 00:41:43,256
We implemented the ability to


1592
00:41:43,256 --> 00:41:44,776
sample a single pixel multiple


1593
00:41:44,776 --> 00:41:46,336
times per frame and all of a


1594
00:41:46,336 --> 00:41:47,476
sudden, our ray tracer is


1595
00:41:47,476 --> 00:41:48,746
producing a blown-out image.


1596
00:41:50,096 --> 00:41:52,356
The first step is just to do a


1597
00:41:52,356 --> 00:41:53,386
frame capture as your


1598
00:41:53,386 --> 00:41:54,276
application is running.


1599
00:41:55,716 --> 00:41:56,756
This records the state of the


1600
00:41:56,756 --> 00:41:58,686
GPU for every API call and


1601
00:41:58,686 --> 00:41:59,686
shader over the course of a


1602
00:41:59,686 --> 00:42:00,046
frame.


1603
00:42:01,076 --> 00:42:03,106
By selecting any shader, we can


1604
00:42:03,106 --> 00:42:04,266
examine the resources that are


1605
00:42:04,266 --> 00:42:06,206
bound to it so we can really


1606
00:42:06,206 --> 00:42:07,716
quickly narrow down exactly what


1607
00:42:07,716 --> 00:42:09,176
shader's failing by just


1608
00:42:09,176 --> 00:42:10,376
selecting all of the shaders


1609
00:42:10,376 --> 00:42:11,346
that write to the frame buffer


1610
00:42:11,486 --> 00:42:12,636
and examining the frame buffer


1611
00:42:12,636 --> 00:42:13,546
contents directly.


1612
00:42:13,956 --> 00:42:15,556
So here we can see the first


1613
00:42:15,556 --> 00:42:16,316
image is pretty light.


1614
00:42:16,866 --> 00:42:18,006
The second image is pretty


1615
00:42:18,006 --> 00:42:18,486
washed out.


1616
00:42:18,486 --> 00:42:19,716
And the third is almost white.


1617
00:42:20,326 --> 00:42:23,186
But here we're going to select


1618
00:42:23,186 --> 00:42:24,166
the shader that outputs the


1619
00:42:24,166 --> 00:42:26,206
lightest image and we're going


1620
00:42:26,206 --> 00:42:27,526
to take a look at the two input


1621
00:42:27,526 --> 00:42:28,426
buffers that we used to


1622
00:42:28,466 --> 00:42:29,736
calculate the frame buffer.


1623
00:42:30,566 --> 00:42:31,826
And the first buffer just


1624
00:42:31,826 --> 00:42:32,956
contains the sum of all the


1625
00:42:32,956 --> 00:42:34,736
light a ray has accumulated.


1626
00:42:36,796 --> 00:42:38,346
The second buffer contains our


1627
00:42:38,346 --> 00:42:38,836
new variable.


1628
00:42:38,836 --> 00:42:40,456
And that's just the number of


1629
00:42:40,456 --> 00:42:41,506
times we've sampled a given


1630
00:42:41,506 --> 00:42:41,816
pixel.


1631
00:42:42,786 --> 00:42:43,916
Both of these buffers look like


1632
00:42:43,916 --> 00:42:45,386
they have valid data in them, so


1633
00:42:45,386 --> 00:42:46,406
we'll go directly to the shader


1634
00:42:46,406 --> 00:42:47,456
debugger to examine what our


1635
00:42:47,456 --> 00:42:48,476
shader is doing with this data.


1636
00:42:49,116 --> 00:42:51,846
Our color calculation is just


1637
00:42:51,846 --> 00:42:52,956
that some of the luminance for


1638
00:42:52,956 --> 00:42:54,076
all the rays that were launched


1639
00:42:54,076 --> 00:42:54,936
for a given pixel.


1640
00:42:55,546 --> 00:42:57,246
When we only had one ray per


1641
00:42:57,246 --> 00:42:58,676
pixel, this worked just fine.


1642
00:42:59,636 --> 00:43:00,586
But now, we're failing to


1643
00:43:00,586 --> 00:43:01,566
compensate for the fact that


1644
00:43:01,566 --> 00:43:02,896
we're sampling multiple times


1645
00:43:02,936 --> 00:43:03,346
per pixel.


1646
00:43:03,346 --> 00:43:05,576
So, we're going to change that


1647
00:43:05,576 --> 00:43:06,986
code in the shader debugger to


1648
00:43:07,126 --> 00:43:08,486
divide the total luminance by


1649
00:43:08,486 --> 00:43:09,746
the number of input samples.


1650
00:43:10,586 --> 00:43:12,146
We reevaluate directly in the


1651
00:43:12,146 --> 00:43:14,176
shader debugger and we can


1652
00:43:14,176 --> 00:43:15,266
instantly see that our output


1653
00:43:15,266 --> 00:43:16,226
image has been fixed.


1654
00:43:16,606 --> 00:43:19,836
It's just that easy.


1655
00:43:20,486 --> 00:43:21,666
Another issue we hit frequently


1656
00:43:21,666 --> 00:43:22,636
was trying to understand the


1657
00:43:22,636 --> 00:43:23,556
performance impact of our


1658
00:43:23,556 --> 00:43:24,246
changes.


1659
00:43:24,476 --> 00:43:26,776
Xcode frame captures tools make


1660
00:43:26,816 --> 00:43:27,886
this easy as well.


1661
00:43:29,136 --> 00:43:30,226
Here's an example of a struct


1662
00:43:30,226 --> 00:43:31,046
that tracks surface


1663
00:43:31,046 --> 00:43:32,366
characteristics across ray


1664
00:43:32,366 --> 00:43:33,066
bounces.


1665
00:43:33,826 --> 00:43:35,116
Not every surface in our scene


1666
00:43:35,116 --> 00:43:36,206
uses transparencies.


1667
00:43:36,206 --> 00:43:37,186
The final two values,


1668
00:43:37,246 --> 00:43:38,566
transmission and index of


1669
00:43:38,566 --> 00:43:40,206
refraction, won't be used for


1670
00:43:40,206 --> 00:43:40,986
some rays.


1671
00:43:41,566 --> 00:43:43,056
But, because we've packed all of


1672
00:43:43,056 --> 00:43:44,546
that data into a single struct,


1673
00:43:44,986 --> 00:43:46,406
rays that don't hit transparent


1674
00:43:46,406 --> 00:43:47,896
surfaces are still going to have


1675
00:43:47,896 --> 00:43:49,676
to pay the penalty for reading


1676
00:43:49,676 --> 00:43:50,976
and writing those fields out


1677
00:43:51,906 --> 00:43:53,376
between passes.


1678
00:43:53,876 --> 00:43:55,896
Here, we've refactored the index


1679
00:43:55,896 --> 00:43:57,096
of refraction variables into


1680
00:43:57,096 --> 00:43:57,746
their own struct.


1681
00:43:58,556 --> 00:44:00,036
By separating the structs only


1682
00:44:00,036 --> 00:44:01,166
rays that hit transparent


1683
00:44:01,166 --> 00:44:02,326
surfaces will have to touch the


1684
00:44:02,326 --> 00:44:03,756
refraction data.


1685
00:44:06,156 --> 00:44:07,636
But we can still do a bit


1686
00:44:07,636 --> 00:44:07,926
better.


1687
00:44:08,606 --> 00:44:09,626
Now we've changed all of our


1688
00:44:09,626 --> 00:44:11,306
variables to half data types to


1689
00:44:11,306 --> 00:44:12,346
save even more space.


1690
00:44:13,096 --> 00:44:14,226
We've reduced our memory usage


1691
00:44:14,226 --> 00:44:16,236
from 40 to 20 bytes, and rays


1692
00:44:16,236 --> 00:44:17,256
that don't hit transparent


1693
00:44:17,256 --> 00:44:18,776
objects will only need 12 bytes.


1694
00:44:19,326 --> 00:44:21,526
So how do we understand the


1695
00:44:21,526 --> 00:44:22,706
performance impact of this?


1696
00:44:23,386 --> 00:44:25,666
Here we grab GPU traces using


1697
00:44:25,666 --> 00:44:26,726
the frame capture tool both


1698
00:44:26,756 --> 00:44:28,306
before and after our change.


1699
00:44:29,216 --> 00:44:30,666
The most basic version of


1700
00:44:30,666 --> 00:44:31,946
performance analysis we can do


1701
00:44:31,946 --> 00:44:33,256
takes place at this phase.


1702
00:44:34,036 --> 00:44:35,536
By comparing the shader timings


1703
00:44:35,866 --> 00:44:37,056
in our before and after


1704
00:44:37,056 --> 00:44:38,976
captures, we can isolate shaders


1705
00:44:38,976 --> 00:44:40,076
whose performance has changed.


1706
00:44:40,796 --> 00:44:41,906
Here, we can see that the shader


1707
00:44:41,906 --> 00:44:43,026
that we've labeled sample


1708
00:44:43,026 --> 00:44:45,136
surface has gone from 5.5


1709
00:44:45,136 --> 00:44:46,756
milliseconds to 4 milliseconds.


1710
00:44:47,396 --> 00:44:48,536
That's almost a 30 percent


1711
00:44:48,536 --> 00:44:49,546
savings for one of our more


1712
00:44:49,546 --> 00:44:50,516
costly shaders.


1713
00:44:51,546 --> 00:44:53,726
If we want to quantify exactly


1714
00:44:53,726 --> 00:44:54,926
why we're getting a performance


1715
00:44:54,926 --> 00:44:56,836
gain, Xcode helpfully displays


1716
00:44:56,836 --> 00:44:57,756
the results of all the


1717
00:44:57,756 --> 00:44:58,756
performance counters that it


1718
00:44:58,756 --> 00:44:59,846
inserts when it does a frame


1719
00:44:59,846 --> 00:45:00,146
capture.


1720
00:45:00,526 --> 00:45:02,176
Because we're interested in how


1721
00:45:02,176 --> 00:45:03,626
we've affected our memory usage,


1722
00:45:04,386 --> 00:45:05,246
we can take a look at the


1723
00:45:05,246 --> 00:45:07,266
texture unit statistics and we


1724
00:45:07,266 --> 00:45:08,496
see that our average texture


1725
00:45:08,496 --> 00:45:10,096
unit stall time has gone down


1726
00:45:10,096 --> 00:45:11,836
from 70 percent to 54 percent.


1727
00:45:12,476 --> 00:45:13,686
And we've reduced our L2


1728
00:45:13,686 --> 00:45:16,686
throughput by almost two-thirds.


1729
00:45:17,506 --> 00:45:18,986
Even more helpfully Xcode will


1730
00:45:18,986 --> 00:45:20,336
do some analysis of its own and


1731
00:45:20,336 --> 00:45:21,576
report potential problems to


1732
00:45:21,576 --> 00:45:21,726
you.


1733
00:45:22,246 --> 00:45:23,846
Here, it's telling us that our


1734
00:45:23,846 --> 00:45:25,086
original version had some real


1735
00:45:25,086 --> 00:45:26,366
problems with memory and that


1736
00:45:26,366 --> 00:45:27,476
our new version's performing


1737
00:45:27,476 --> 00:45:29,806
much better.


1738
00:45:30,456 --> 00:45:31,526
One more tip that you may find


1739
00:45:31,526 --> 00:45:33,106
useful, is that the compute


1740
00:45:33,106 --> 00:45:34,116
pipeline state had some


1741
00:45:34,116 --> 00:45:35,376
interesting telemetry as well.


1742
00:45:36,346 --> 00:45:36,616
Look at


1743
00:45:36,616 --> 00:45:37,966
MaxTotalThreadsForThreadgroup.


1744
00:45:38,356 --> 00:45:39,746
This is an indication of the


1745
00:45:39,746 --> 00:45:40,876
occupancy of a shader.


1746
00:45:41,576 --> 00:45:42,866
You should target 1024 as the


1747
00:45:42,866 --> 00:45:44,346
maximum and anything less means


1748
00:45:44,346 --> 00:45:45,386
that there may be an occupancy


1749
00:45:45,386 --> 00:45:46,426
issue that you can fix.


1750
00:45:46,926 --> 00:45:50,166
So that's debugging in Xcode.


1751
00:45:50,706 --> 00:45:51,996
It makes developing Ray Tracing


1752
00:45:51,996 --> 00:45:52,896
and Global Illumination


1753
00:45:52,896 --> 00:45:54,296
algorithms on the Mac platform


1754
00:45:54,296 --> 00:45:55,116
incredibly easy.


1755
00:45:55,876 --> 00:45:56,986
And now, here's Wayne to give


1756
00:45:56,986 --> 00:45:57,966
you a live demo of all of this.


1757
00:45:58,516 --> 00:46:01,056
[ Applause ]


1758
00:46:01,556 --> 00:46:03,206
>> Thanks Matt.


1759
00:46:04,386 --> 00:46:06,086
So, you may recognize this scene


1760
00:46:06,176 --> 00:46:07,736
from our platform State of the


1761
00:46:07,736 --> 00:46:09,636
Union session earlier this week.


1762
00:46:10,826 --> 00:46:12,546
To render it here, I'm using a


1763
00:46:12,546 --> 00:46:14,176
MacBook Pro along with four


1764
00:46:14,176 --> 00:46:14,606
external GPUs.


1765
00:46:14,606 --> 00:46:17,986
And everything you can see on


1766
00:46:18,016 --> 00:46:19,386
the screen there is being ray


1767
00:46:19,386 --> 00:46:20,546
traced in real time.


1768
00:46:21,106 --> 00:46:22,696
So, I can just take hold of the


1769
00:46:22,696 --> 00:46:23,706
camera and move around the


1770
00:46:23,706 --> 00:46:23,976
scene.


1771
00:46:25,216 --> 00:46:26,936
So, let's start over here.


1772
00:46:26,936 --> 00:46:29,306
You can see these great shadows


1773
00:46:29,306 --> 00:46:30,076
that we're getting with Ray


1774
00:46:30,076 --> 00:46:30,616
Tracing.


1775
00:46:30,826 --> 00:46:32,386
They're hard at the contact


1776
00:46:32,386 --> 00:46:33,836
points and they become softer


1777
00:46:33,836 --> 00:46:35,356
and softer as the distance to


1778
00:46:35,356 --> 00:46:36,326
the ground increases.


1779
00:46:37,736 --> 00:46:40,186
And remember, for these shadows


1780
00:46:40,186 --> 00:46:41,666
we're firing just one ray per


1781
00:46:41,666 --> 00:46:43,236
pixel and then we're using the


1782
00:46:43,236 --> 00:46:44,576
Denoiser that Sean was telling


1783
00:46:44,576 --> 00:46:45,786
us about to get this great


1784
00:46:45,826 --> 00:46:46,506
filtered result.


1785
00:46:47,126 --> 00:46:49,176
And this is all calculated


1786
00:46:49,176 --> 00:46:49,816
dynamically.


1787
00:46:49,816 --> 00:46:51,136
So, I can just take hold of the


1788
00:46:51,136 --> 00:46:52,966
light and move it around.


1789
00:46:54,066 --> 00:46:56,096
And I can see the effect of that


1790
00:46:56,096 --> 00:46:57,026
pretty much immediately.


1791
00:46:57,596 --> 00:47:00,256
There's a really great effect


1792
00:47:00,256 --> 00:47:01,056
going on here too.


1793
00:47:01,056 --> 00:47:02,636
If we fly over and look in the


1794
00:47:02,636 --> 00:47:04,346
window of the tram here, you can


1795
00:47:04,346 --> 00:47:05,856
actually see the reflections of


1796
00:47:05,856 --> 00:47:07,606
our shadows, and again, you can


1797
00:47:07,606 --> 00:47:09,126
see the shadow moving around as


1798
00:47:09,126 --> 00:47:10,826
I take control of the light.


1799
00:47:13,226 --> 00:47:15,326
And if we head over to this part


1800
00:47:15,326 --> 00:47:16,296
of the scene now, there's a


1801
00:47:16,296 --> 00:47:18,036
really great reflection effect


1802
00:47:18,076 --> 00:47:18,656
going on here.


1803
00:47:19,306 --> 00:47:21,866
So, if we look at the left most


1804
00:47:21,866 --> 00:47:24,276
tram you can see the reflection


1805
00:47:24,276 --> 00:47:25,446
of the tram behind this.


1806
00:47:26,296 --> 00:47:28,106
But you can also see reflections


1807
00:47:28,196 --> 00:47:29,636
in the windshield of the tram


1808
00:47:29,636 --> 00:47:30,276
behind us.


1809
00:47:30,396 --> 00:47:31,846
So, there's reflections within


1810
00:47:31,846 --> 00:47:33,856
reflections going on here and we


1811
00:47:33,856 --> 00:47:35,136
have to simulate a couple of ray


1812
00:47:35,136 --> 00:47:36,896
bounces per pixel to achieve


1813
00:47:37,106 --> 00:47:38,006
that effect.


1814
00:47:39,856 --> 00:47:41,226
So, I'm going to zoom out here a


1815
00:47:41,226 --> 00:47:41,606
bit now.


1816
00:47:41,886 --> 00:47:43,896
And of course, in this scene


1817
00:47:43,896 --> 00:47:45,676
it's not just the camera and the


1818
00:47:45,676 --> 00:47:46,526
lights that can move.


1819
00:47:47,486 --> 00:47:48,636
Sean was telling us about


1820
00:47:48,636 --> 00:47:50,086
Metal's Two-Level Acceleration


1821
00:47:50,086 --> 00:47:50,806
structures earlier.


1822
00:47:51,156 --> 00:47:52,556
And we're using those here to


1823
00:47:52,676 --> 00:47:53,926
enable the trams to move around


1824
00:47:53,926 --> 00:47:54,226
the scene.


1825
00:47:54,846 --> 00:47:57,966
What I really want to show you


1826
00:47:57,966 --> 00:47:59,576
now though is this fantastic


1827
00:47:59,576 --> 00:48:01,076
lighting effect we have going on


1828
00:48:01,116 --> 00:48:01,656
up on the roof.


1829
00:48:01,656 --> 00:48:05,266
So, if we focus on the wall on


1830
00:48:05,266 --> 00:48:07,006
the right there you can see that


1831
00:48:07,006 --> 00:48:08,486
currently it's being lit


1832
00:48:08,626 --> 00:48:10,206
primarily by direct sunlight.


1833
00:48:10,866 --> 00:48:13,266
But as I take control of the sun


1834
00:48:13,396 --> 00:48:15,636
and I rotate it around you can


1835
00:48:15,636 --> 00:48:16,996
see the wall falls into shadow


1836
00:48:16,996 --> 00:48:18,756
and now it's being lit by this


1837
00:48:18,846 --> 00:48:20,606
really great indirect


1838
00:48:20,606 --> 00:48:21,206
illumination.


1839
00:48:22,176 --> 00:48:24,336
So, what's going on here is


1840
00:48:24,866 --> 00:48:26,116
sunlight is hitting the roof on


1841
00:48:26,116 --> 00:48:28,246
the left and it's bouncing and


1842
00:48:28,246 --> 00:48:29,246
illuminating the wall on the


1843
00:48:29,246 --> 00:48:29,576
right.


1844
00:48:29,576 --> 00:48:30,756
Giving us this great color


1845
00:48:30,756 --> 00:48:31,476
bleeding effect.


1846
00:48:31,956 --> 00:48:35,226
And if I continue to rotate the


1847
00:48:35,226 --> 00:48:36,556
sun you can see these really


1848
00:48:36,556 --> 00:48:38,026
dramatic shadows start to come


1849
00:48:38,026 --> 00:48:39,626
in and they travel across the


1850
00:48:39,626 --> 00:48:40,356
surface of the roof there.


1851
00:48:41,016 --> 00:48:43,506
If I spin the camera around a


1852
00:48:43,506 --> 00:48:44,516
bit you can really see the


1853
00:48:44,516 --> 00:48:45,956
reflections as well hitting the


1854
00:48:45,956 --> 00:48:47,366
roof on the left.


1855
00:48:47,976 --> 00:48:49,246
So, this is -- I really like


1856
00:48:49,246 --> 00:48:49,796
this shot.


1857
00:48:49,796 --> 00:48:51,636
There's a lot of Ray Tracing


1858
00:48:51,636 --> 00:48:53,056
effects all going on at the same


1859
00:48:53,056 --> 00:48:53,706
time here.


1860
00:48:53,706 --> 00:48:54,686
We have the indirect


1861
00:48:54,686 --> 00:48:55,766
illumination, we have the


1862
00:48:55,766 --> 00:48:56,696
shadows, we have the


1863
00:48:56,696 --> 00:48:57,426
reflections.


1864
00:48:58,126 --> 00:48:59,516
And it's all being ray traced in


1865
00:48:59,516 --> 00:49:01,666
real time with Metal and multi


1866
00:49:01,666 --> 00:49:01,976
GPU.


1867
00:49:02,976 --> 00:49:04,176
So, I'm going to switch back to


1868
00:49:04,176 --> 00:49:05,516
the keynote now and it's this


1869
00:49:05,516 --> 00:49:07,206
multi GPU aspect that I'd like


1870
00:49:07,206 --> 00:49:08,396
to talk a bit more about.


1871
00:49:09,516 --> 00:49:16,516
[ Applause ]


1872
00:49:17,016 --> 00:49:18,146
So, for the demo that we just


1873
00:49:18,146 --> 00:49:20,666
saw, the way that we implemented


1874
00:49:21,006 --> 00:49:23,066
multi GPU was by dividing the


1875
00:49:23,066 --> 00:49:25,546
screen into a set of small tiles


1876
00:49:26,536 --> 00:49:27,676
and then we mapped these tiles


1877
00:49:27,676 --> 00:49:29,036
onto the different GPUs.


1878
00:49:29,636 --> 00:49:32,396
Now in the visualization here


1879
00:49:32,396 --> 00:49:33,826
I'm using different colors to


1880
00:49:33,826 --> 00:49:35,066
show you how the tiles are


1881
00:49:35,066 --> 00:49:35,716
distributed.


1882
00:49:36,256 --> 00:49:38,166
So, one GPU renders the tiles in


1883
00:49:38,166 --> 00:49:38,716
red.


1884
00:49:39,316 --> 00:49:40,176
Another does the tiles in


1885
00:49:40,176 --> 00:49:40,696
yellow, and so on.


1886
00:49:40,696 --> 00:49:43,286
And after all GPUs are finished,


1887
00:49:43,286 --> 00:49:45,906
we just composite those results


1888
00:49:45,906 --> 00:49:47,396
together to form our final


1889
00:49:47,396 --> 00:49:47,766
image.


1890
00:49:47,766 --> 00:49:50,716
So, if we take a step back and


1891
00:49:50,716 --> 00:49:53,186
look at what we have here


1892
00:49:53,226 --> 00:49:54,546
there's two things that jump


1893
00:49:54,546 --> 00:49:54,826
out.


1894
00:49:54,826 --> 00:49:57,806
So firstly, in the image on the


1895
00:49:57,806 --> 00:49:59,126
left, so the way that we're


1896
00:49:59,126 --> 00:50:00,006
assigning tiles to GPUs, it


1897
00:50:00,006 --> 00:50:00,716
looks a bit strange.


1898
00:50:01,086 --> 00:50:03,766
So why are we doing it like


1899
00:50:03,766 --> 00:50:04,156
that?


1900
00:50:05,066 --> 00:50:08,136
And secondly, for those small


1901
00:50:08,136 --> 00:50:11,056
tiles the implication of that is


1902
00:50:11,056 --> 00:50:12,736
that each GPU is going to render


1903
00:50:12,736 --> 00:50:14,436
a block of pixels there and then


1904
00:50:14,436 --> 00:50:15,336
a block of pixels somewhere


1905
00:50:15,336 --> 00:50:15,546
else.


1906
00:50:16,476 --> 00:50:17,646
And that just feels like it's


1907
00:50:17,646 --> 00:50:19,246
going to be bad for things like


1908
00:50:19,246 --> 00:50:21,336
ray coherency, cache hit ratios.


1909
00:50:21,336 --> 00:50:22,126
All that kind of stuff.


1910
00:50:23,116 --> 00:50:25,036
So, let's deal with these in


1911
00:50:27,016 --> 00:50:27,126
turn.


1912
00:50:27,326 --> 00:50:30,226
So, imagine we have four GPUs.


1913
00:50:30,226 --> 00:50:31,986
The simple way to do multi GPU


1914
00:50:31,986 --> 00:50:34,046
here is just to split the screen


1915
00:50:34,046 --> 00:50:34,886
into quadrants.


1916
00:50:35,826 --> 00:50:38,156
Now the issue with that is that


1917
00:50:38,156 --> 00:50:39,506
some parts of a scene will be


1918
00:50:39,506 --> 00:50:40,816
much easier to render than


1919
00:50:40,816 --> 00:50:41,106
others.


1920
00:50:41,986 --> 00:50:43,896
So, if we assume that the street


1921
00:50:43,896 --> 00:50:45,226
and the building on the left


1922
00:50:45,226 --> 00:50:47,026
there are much easier to render


1923
00:50:47,026 --> 00:50:48,266
than the tram on the right.


1924
00:50:49,316 --> 00:50:50,946
It stands to reason that the red


1925
00:50:50,946 --> 00:50:52,316
and yellow GPUs will finish


1926
00:50:52,316 --> 00:50:54,046
before the green and purple


1927
00:50:54,046 --> 00:50:54,226
GPUs.


1928
00:50:54,226 --> 00:50:57,926
Now we can fix this just by


1929
00:50:57,926 --> 00:50:59,116
splitting the screen into


1930
00:50:59,116 --> 00:50:59,926
smaller tiles.


1931
00:50:59,926 --> 00:51:02,866
Then we can split each of those


1932
00:51:02,866 --> 00:51:05,286
into smaller tiles and so on.


1933
00:51:05,436 --> 00:51:06,946
Until we reach some minimum tile


1934
00:51:06,996 --> 00:51:07,326
size.


1935
00:51:07,946 --> 00:51:10,836
Now this has the effect of


1936
00:51:10,836 --> 00:51:13,706
distributing work really evenly


1937
00:51:13,706 --> 00:51:14,196
across the GPUs.


1938
00:51:14,926 --> 00:51:16,456
So, if one part of the screen is


1939
00:51:16,456 --> 00:51:17,566
particularly difficult to


1940
00:51:17,566 --> 00:51:19,276
render, it just doesn't matter,


1941
00:51:19,626 --> 00:51:21,586
because every GPU will be


1942
00:51:21,586 --> 00:51:24,026
assigned tiles from that part of


1943
00:51:25,056 --> 00:51:25,506
the screen.


1944
00:51:25,956 --> 00:51:27,406
Now in practice, this regular


1945
00:51:27,406 --> 00:51:29,126
tiling pattern that you see here


1946
00:51:29,126 --> 00:51:30,616
probably isn't the way to go.


1947
00:51:31,166 --> 00:51:32,506
Because you can get cases where


1948
00:51:32,506 --> 00:51:33,886
the tiling aligns with the


1949
00:51:33,886 --> 00:51:34,936
geometry in your scene.


1950
00:51:36,396 --> 00:51:37,606
And so, we randomize a bit.


1951
00:51:38,186 --> 00:51:39,936
And I'll give a few more details


1952
00:51:39,936 --> 00:51:40,726
on how we're doing that in a


1953
00:51:40,726 --> 00:51:41,126
second.


1954
00:51:41,626 --> 00:51:44,606
And one of the really


1955
00:51:44,606 --> 00:51:45,826
interesting things about this


1956
00:51:45,826 --> 00:51:47,956
approach is that the mapping of


1957
00:51:47,956 --> 00:51:50,106
tiles to GPUs, it does not


1958
00:51:50,106 --> 00:51:50,616
change.


1959
00:51:51,886 --> 00:51:53,716
So, the same GPU will process


1960
00:51:53,716 --> 00:51:55,586
the same tiles every frame.


1961
00:51:56,316 --> 00:51:57,566
And this is great.


1962
00:51:57,626 --> 00:51:59,106
So, you can just calculate that


1963
00:51:59,106 --> 00:52:00,666
mapping when your application


1964
00:52:00,666 --> 00:52:02,666
initializes or when you resize


1965
00:52:02,666 --> 00:52:04,066
the window and that's it.


1966
00:52:04,636 --> 00:52:05,906
You don't need to think about


1967
00:52:05,906 --> 00:52:07,946
multi GPU load balancing anymore


1968
00:52:07,946 --> 00:52:09,056
and there's nothing to monitor.


1969
00:52:09,056 --> 00:52:10,626
Nothing to recalculate in your


1970
00:52:10,626 --> 00:52:12,226
application's main loop.


1971
00:52:14,176 --> 00:52:17,366
So, if we know that small tiles


1972
00:52:17,616 --> 00:52:19,126
distribute the work more evenly,


1973
00:52:19,576 --> 00:52:20,626
why not just take it to the


1974
00:52:20,626 --> 00:52:22,306
extreme and make them a pixel.


1975
00:52:22,946 --> 00:52:25,956
So, the problem with that is


1976
00:52:25,956 --> 00:52:27,446
that we need to give each GPU


1977
00:52:27,766 --> 00:52:29,356
nice coherent blocks of pixels


1978
00:52:29,356 --> 00:52:30,076
to be working on.


1979
00:52:31,326 --> 00:52:33,476
So, the tradeoff there between


1980
00:52:33,476 --> 00:52:35,276
balancing the load evenly and


1981
00:52:35,276 --> 00:52:36,786
making sure that each GPU can


1982
00:52:36,786 --> 00:52:38,166
run as efficiently as possible.


1983
00:52:38,746 --> 00:52:41,606
So, to better understand that


1984
00:52:41,606 --> 00:52:43,276
tradeoff we did a simple


1985
00:52:43,276 --> 00:52:43,866
experiment.


1986
00:52:44,446 --> 00:52:46,756
We took one of the new Mac Pros


1987
00:52:46,756 --> 00:52:49,336
with a pair of the Vega II Duo


1988
00:52:49,336 --> 00:52:51,066
GPUs, so that's four GPUs in


1989
00:52:51,066 --> 00:52:53,386
total, and we tried rendering


1990
00:52:53,386 --> 00:52:54,496
the same scene with various


1991
00:52:54,496 --> 00:52:56,146
tiles sizes to see how that


1992
00:52:56,146 --> 00:52:57,256
effected performance.


1993
00:52:57,476 --> 00:53:00,826
Now of course, your mileage may


1994
00:53:00,826 --> 00:53:03,756
vary here, but what we found is


1995
00:53:03,756 --> 00:53:05,056
that the performance window is


1996
00:53:05,056 --> 00:53:06,116
actually really wide.


1997
00:53:07,076 --> 00:53:09,566
So, efficiency drops off if you


1998
00:53:09,566 --> 00:53:11,486
make your tiles very small or if


1999
00:53:11,486 --> 00:53:12,856
you make them very, very large.


2000
00:53:13,766 --> 00:53:15,446
But anywhere in the middle keeps


2001
00:53:15,446 --> 00:53:16,626
us pretty close to peak


2002
00:53:16,626 --> 00:53:17,246
performance.


2003
00:53:20,936 --> 00:53:22,386
So now we have our tile size


2004
00:53:22,386 --> 00:53:23,966
pinned down, what we need to do


2005
00:53:23,966 --> 00:53:25,686
next is assign them to the


2006
00:53:25,686 --> 00:53:27,486
various GPUs.


2007
00:53:28,196 --> 00:53:30,186
Now to do this, we start by


2008
00:53:30,186 --> 00:53:31,936
generating a random number for


2009
00:53:31,936 --> 00:53:34,236
each tile and then we compare


2010
00:53:34,236 --> 00:53:36,006
those random numbers to a set of


2011
00:53:36,006 --> 00:53:36,736
thresholds.


2012
00:53:38,036 --> 00:53:39,406
And whichever range the random


2013
00:53:39,406 --> 00:53:41,106
number lands in, that gives us


2014
00:53:41,106 --> 00:53:43,066
the GPU to use for that tile.


2015
00:53:43,506 --> 00:53:46,606
So as an example, here, if the


2016
00:53:46,606 --> 00:53:49,026
random number is .4, we assign


2017
00:53:49,026 --> 00:53:49,786
it to GPU 1.


2018
00:53:50,796 --> 00:53:53,736
If it's .55, it goes on GPU 2.


2019
00:53:54,146 --> 00:53:54,886
And so on.


2020
00:53:56,236 --> 00:53:58,186
Now, once we've done this for


2021
00:53:58,186 --> 00:54:00,406
every tile the output is a list


2022
00:54:00,406 --> 00:54:01,876
of tiles that we need each GPU


2023
00:54:01,876 --> 00:54:02,266
to render.


2024
00:54:03,016 --> 00:54:06,676
As you can see down the bottom


2025
00:54:07,226 --> 00:54:08,146
there the ranges that we're


2026
00:54:08,146 --> 00:54:10,216
using for each GPU are equal.


2027
00:54:11,476 --> 00:54:13,616
So, when assigning tiles to GPUs


2028
00:54:13,716 --> 00:54:15,016
they are all equally likely to


2029
00:54:15,016 --> 00:54:15,486
be chosen.


2030
00:54:16,146 --> 00:54:19,346
But in practice, you almost


2031
00:54:19,346 --> 00:54:20,936
certainly don't want this.


2032
00:54:20,936 --> 00:54:23,346
For example, you might need to


2033
00:54:23,346 --> 00:54:25,536
reserve capacity on one of your


2034
00:54:25,536 --> 00:54:27,286
GPUs for non-ray tracing tasks


2035
00:54:27,806 --> 00:54:29,736
such as denoising or tone


2036
00:54:31,206 --> 00:54:31,366
mapping.


2037
00:54:31,916 --> 00:54:33,536
Or you might be using GPUs with


2038
00:54:33,536 --> 00:54:34,536
different performance.


2039
00:54:34,906 --> 00:54:35,866
In which case you'll want to


2040
00:54:35,866 --> 00:54:37,246
send more tiles to the more


2041
00:54:37,246 --> 00:54:37,976
powerful GPUs.


2042
00:54:39,846 --> 00:54:41,096
And you can account for this


2043
00:54:41,346 --> 00:54:43,226
really easily by just adjusting


2044
00:54:43,226 --> 00:54:43,676
the ranges.


2045
00:54:44,996 --> 00:54:46,416
So now if we go ahead and


2046
00:54:46,416 --> 00:54:47,906
reassign the same tiles we used


2047
00:54:47,906 --> 00:54:49,946
before, you can see here that


2048
00:54:49,946 --> 00:54:51,886
now GPU 2 takes on a much


2049
00:54:51,886 --> 00:54:52,886
greater share of the work.


2050
00:54:52,886 --> 00:54:57,966
Now, for the actual implantation


2051
00:54:57,966 --> 00:54:59,696
of this there was a lot of


2052
00:54:59,696 --> 00:55:01,296
really useful information in our


2053
00:55:01,296 --> 00:55:02,696
Metal for Pro Apps session


2054
00:55:02,696 --> 00:55:03,466
earlier this week.


2055
00:55:03,766 --> 00:55:05,256
So, I won't go over that again


2056
00:55:05,256 --> 00:55:05,496
here.


2057
00:55:06,086 --> 00:55:08,356
But it is definitely useful to


2058
00:55:08,356 --> 00:55:10,016
highlight just a couple of areas


2059
00:55:10,106 --> 00:55:11,016
that can have a really big


2060
00:55:11,016 --> 00:55:12,286
impact on performance.


2061
00:55:12,846 --> 00:55:16,616
So firstly, you'll probably want


2062
00:55:16,616 --> 00:55:17,976
to composite your tiles together


2063
00:55:17,976 --> 00:55:19,436
on the GPU that's driving the


2064
00:55:19,436 --> 00:55:19,896
display.


2065
00:55:21,216 --> 00:55:22,886
So, it's important to find out


2066
00:55:22,886 --> 00:55:25,056
which GPU that is and then work


2067
00:55:25,056 --> 00:55:27,086
backwards to figure out how to


2068
00:55:27,086 --> 00:55:28,416
get your data there efficiently.


2069
00:55:28,936 --> 00:55:31,326
So, if the GPUs are in the same


2070
00:55:31,326 --> 00:55:33,176
peer group then you can copy


2071
00:55:33,176 --> 00:55:34,916
between them directly using our


2072
00:55:34,916 --> 00:55:36,196
new peer group APIs.


2073
00:55:37,186 --> 00:55:38,646
Otherwise you'll need to go by


2074
00:55:38,646 --> 00:55:39,216
the CPU.


2075
00:55:41,926 --> 00:55:44,476
Now secondly, it can often take


2076
00:55:44,476 --> 00:55:46,056
a few milliseconds to copy data


2077
00:55:46,056 --> 00:55:48,156
between GPUs and we definitely


2078
00:55:48,276 --> 00:55:50,016
don't want to block waiting for


2079
00:55:50,016 --> 00:55:51,126
those transfers to complete.


2080
00:55:52,356 --> 00:55:54,526
So, to give you an example of


2081
00:55:54,526 --> 00:55:56,426
how we're dealing with that we


2082
00:55:56,426 --> 00:55:58,256
have two GPUs here and we're


2083
00:55:58,256 --> 00:55:59,466
using the tiling scheme that I


2084
00:55:59,466 --> 00:56:01,136
was just talking about to spread


2085
00:56:01,136 --> 00:56:02,786
the rendering across the two


2086
00:56:02,786 --> 00:56:02,956
GPUs.


2087
00:56:04,666 --> 00:56:06,876
Now in GPU 0 at the top there we


2088
00:56:06,876 --> 00:56:08,066
have two queues.


2089
00:56:08,306 --> 00:56:10,066
One is just flat out doing


2090
00:56:10,066 --> 00:56:11,146
back-to-back Ray Tracing.


2091
00:56:11,876 --> 00:56:13,116
And then we have a second queue


2092
00:56:13,606 --> 00:56:15,076
that copies the completed tiles


2093
00:56:15,076 --> 00:56:16,976
over to GPU 1 asynchronously.


2094
00:56:20,266 --> 00:56:21,956
Now, we'll assume that GPU 1 at


2095
00:56:21,956 --> 00:56:23,166
the bottom there is the one


2096
00:56:23,166 --> 00:56:24,206
that's driving our display.


2097
00:56:24,896 --> 00:56:26,246
And here things are a bit


2098
00:56:26,246 --> 00:56:26,596
different.


2099
00:56:27,086 --> 00:56:30,626
This GPU is also Ray Tracing


2100
00:56:30,746 --> 00:56:32,996
part of frame 0, but we can't go


2101
00:56:32,996 --> 00:56:34,596
ahead and present that frame


2102
00:56:35,076 --> 00:56:36,746
until the rest of our tiles have


2103
00:56:36,746 --> 00:56:37,936
been copied over from the other


2104
00:56:37,936 --> 00:56:38,476
GPU.


2105
00:56:39,596 --> 00:56:42,076
So rather than wait, we just


2106
00:56:42,076 --> 00:56:43,226
start work on the next frame.


2107
00:56:44,716 --> 00:56:46,126
And then a bit later on when our


2108
00:56:46,126 --> 00:56:47,996
tiles arrive from the other GPU,


2109
00:56:48,836 --> 00:56:50,186
that's when we go ahead and


2110
00:56:50,186 --> 00:56:51,386
composite everything together.


2111
00:56:52,716 --> 00:56:53,906
So, I'll show you that one more


2112
00:56:53,906 --> 00:56:54,286
time here.


2113
00:56:54,286 --> 00:56:57,396
So, you can see that we end up


2114
00:56:57,396 --> 00:56:59,316
in this steady state where we


2115
00:56:59,316 --> 00:57:01,146
render frame N and then we


2116
00:57:01,146 --> 00:57:02,756
composite frame N minus 1.


2117
00:57:04,376 --> 00:57:06,326
So essentially, what we're doing


2118
00:57:06,326 --> 00:57:07,656
here is latency hiding.


2119
00:57:08,796 --> 00:57:10,186
And this together with the


2120
00:57:10,186 --> 00:57:11,626
tiling scheme I was showing you


2121
00:57:11,626 --> 00:57:13,196
to load balance between the


2122
00:57:13,596 --> 00:57:15,236
GPUs, this is enabling us to


2123
00:57:15,236 --> 00:57:16,796
achieve really great performance


2124
00:57:16,796 --> 00:57:18,526
for our Ray Tracing workloads on


2125
00:57:18,526 --> 00:57:19,886
our multi GPU systems.


2126
00:57:20,396 --> 00:57:23,186
And with that, we come to the


2127
00:57:23,186 --> 00:57:23,796
end of the talk.


2128
00:57:24,926 --> 00:57:26,896
We began with a quick refresher


2129
00:57:26,896 --> 00:57:28,286
of how Ray Tracing works in


2130
00:57:28,286 --> 00:57:30,696
Metal and then we focused on a


2131
00:57:30,756 --> 00:57:31,696
few features of the


2132
00:57:31,696 --> 00:57:33,536
MPSRayIntersector that are there


2133
00:57:33,616 --> 00:57:34,846
to really help with dynamic


2134
00:57:34,846 --> 00:57:35,376
scenes.


2135
00:57:35,796 --> 00:57:36,886
So that's the Two-Level


2136
00:57:36,886 --> 00:57:38,886
Acceleration Structures along


2137
00:57:38,886 --> 00:57:40,226
with our GPU Accelerated


2138
00:57:40,226 --> 00:57:41,766
Rebuilds and Refitting.


2139
00:57:42,376 --> 00:57:45,216
We also introduced the new Metal


2140
00:57:45,216 --> 00:57:45,656
Denoiser.


2141
00:57:45,786 --> 00:57:48,026
And then we talked through a few


2142
00:57:48,026 --> 00:57:49,716
Ray Tracing use cases such as


2143
00:57:49,716 --> 00:57:51,826
Shadows, Ambient Occlusion, and


2144
00:57:51,826 --> 00:57:52,716
Global Illumination.


2145
00:57:53,716 --> 00:57:55,806
When then showed you how to


2146
00:57:55,806 --> 00:57:57,736
debug and profile Ray Tracing


2147
00:57:57,736 --> 00:57:58,866
workloads using Xcode.


2148
00:57:58,866 --> 00:58:00,856
And then, we finished by talking


2149
00:58:00,856 --> 00:58:02,946
about how to take advantage of


2150
00:58:02,946 --> 00:58:05,086
multiple GPUs in your Ray


2151
00:58:05,086 --> 00:58:06,136
Tracing applications.


2152
00:58:06,166 --> 00:58:08,026
Now, for more information be


2153
00:58:08,026 --> 00:58:08,606
sure to visit


2154
00:58:08,606 --> 00:58:10,996
developer.apple.com and there


2155
00:58:10,996 --> 00:58:12,666
you'll also find a new sample


2156
00:58:12,666 --> 00:58:13,646
demonstrating some of the


2157
00:58:13,646 --> 00:58:14,826
features that we've talked about


2158
00:58:14,826 --> 00:58:15,046
today.


2159
00:58:16,066 --> 00:58:17,926
If you're new to Ray Tracing be


2160
00:58:18,226 --> 00:58:19,506
sure to check out our talk from


2161
00:58:19,506 --> 00:58:20,236
last year.


2162
00:58:20,586 --> 00:58:21,926
And finally, we have our lab


2163
00:58:21,926 --> 00:58:23,336
session coming up next at 12.


2164
00:58:23,446 --> 00:58:24,886
So, I hope you can join us for


2165
00:58:24,886 --> 00:58:24,976
that.


2166
00:58:26,366 --> 00:58:27,456
So, thank you all for coming and


2167
00:58:27,456 --> 00:58:28,796
I'll see you in the lab shortly.


2168
00:58:29,016 --> 00:58:31,000
[ Applause ]

