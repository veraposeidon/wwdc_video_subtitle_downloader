1
00:00:00,506 --> 00:00:04,500
[ Music ]


2
00:00:13,131 --> 00:00:15,131
[Applause]


3
00:00:15,246 --> 00:00:15,906
>> Good Morning.


4
00:00:16,856 --> 00:00:18,716
Welcome to What's New in Swift.


5
00:00:19,786 --> 00:00:21,086
Today we're going to talk about


6
00:00:21,146 --> 00:00:23,186
two important and exciting Swift


7
00:00:23,186 --> 00:00:23,856
releases.


8
00:00:24,276 --> 00:00:26,056
Swift 5, which was recently


9
00:00:26,056 --> 00:00:28,876
released in March, and Swift 5.1


10
00:00:29,036 --> 00:00:30,546
which is available now as a


11
00:00:30,546 --> 00:00:32,906
developer preview in Xcode 11.


12
00:00:34,196 --> 00:00:36,326
Combined together, these two


13
00:00:36,326 --> 00:00:38,436
releases further unleash the


14
00:00:38,436 --> 00:00:41,156
potential of Swift as a language


15
00:00:41,216 --> 00:00:42,986
and technology that both Apple


16
00:00:43,276 --> 00:00:45,616
and all of you can build upon.


17
00:00:46,666 --> 00:00:49,326
And that comes in the form of


18
00:00:49,326 --> 00:00:51,406
really powerhouse story with


19
00:00:51,406 --> 00:00:54,666
Swift and APIs.


20
00:00:55,756 --> 00:00:58,136
With a shared Swift runtime for


21
00:00:58,206 --> 00:00:59,876
third-party apps now shipped in


22
00:00:59,876 --> 00:01:02,356
Apple's operating system, and


23
00:01:02,356 --> 00:01:03,726
binary frameworks written in


24
00:01:03,726 --> 00:01:05,716
Swift that can now be deployed,


25
00:01:06,326 --> 00:01:08,416
we see the appearance of marquee


26
00:01:08,616 --> 00:01:10,476
Swift-only frameworks from


27
00:01:10,476 --> 00:01:10,856
Apple.


28
00:01:11,926 --> 00:01:14,136
Further, the integrated support


29
00:01:14,486 --> 00:01:15,826
of the Swift Package Manager


30
00:01:15,826 --> 00:01:17,296
within Xcode brings Swift


31
00:01:17,296 --> 00:01:19,256
packages directly into the core


32
00:01:19,256 --> 00:01:21,516
workflows for app development.


33
00:01:22,166 --> 00:01:23,496
And the Swift language itself


34
00:01:23,496 --> 00:01:25,066
has grown new affordances for


35
00:01:25,066 --> 00:01:27,886
building beautiful and rich APIs


36
00:01:28,396 --> 00:01:30,016
and capabilities for expressing


37
00:01:30,016 --> 00:01:31,216
API evolution.


38
00:01:31,716 --> 00:01:33,096
It's a really, really exciting


39
00:01:33,096 --> 00:01:35,846
time for the language and in the


40
00:01:35,846 --> 00:01:36,306
story.


41
00:01:36,966 --> 00:01:38,716
So let's kick things off by


42
00:01:38,716 --> 00:01:40,436
talking more about binary


43
00:01:40,506 --> 00:01:42,296
frameworks, in particular, dig


44
00:01:42,296 --> 00:01:43,806
into some of the core


45
00:01:43,806 --> 00:01:45,666
ingredients that made that


46
00:01:45,666 --> 00:01:46,176
happen.


47
00:01:46,846 --> 00:01:48,536
And those ingredients are ABI


48
00:01:48,536 --> 00:01:50,256
and module stability.


49
00:01:51,516 --> 00:01:54,276
ABI stands for Application


50
00:01:54,436 --> 00:01:56,496
Binary Interface and it's the


51
00:01:56,496 --> 00:01:57,966
rules that governs the nuts and


52
00:01:57,966 --> 00:01:59,906
bolts of how compiled code can


53
00:01:59,956 --> 00:02:01,766
interact together at runtime.


54
00:02:02,576 --> 00:02:04,636
So details like a function call.


55
00:02:04,916 --> 00:02:06,796
How does it actually work?


56
00:02:07,416 --> 00:02:08,836
How are the values in the


57
00:02:08,836 --> 00:02:11,586
arguments passed off from caller


58
00:02:11,996 --> 00:02:12,636
to callee?


59
00:02:13,086 --> 00:02:14,386
What is the available metadata?


60
00:02:14,386 --> 00:02:15,506
How is it laid out in memory?


61
00:02:15,626 --> 00:02:16,766
All of these details are


62
00:02:16,766 --> 00:02:18,506
necessary for compiled code to


63
00:02:18,506 --> 00:02:19,436
interact together.


64
00:02:19,766 --> 00:02:21,526
So to kind of illustrate this


65
00:02:21,526 --> 00:02:23,326
idea, imagine you have a program


66
00:02:23,326 --> 00:02:24,116
written in Swift.


67
00:02:24,236 --> 00:02:25,626
It's an app, could be command


68
00:02:25,626 --> 00:02:26,926
line tool, it doesn't really


69
00:02:26,926 --> 00:02:27,246
matter.


70
00:02:27,246 --> 00:02:28,876
It's just some executable.


71
00:02:29,706 --> 00:02:31,416
And it uses a framework that is


72
00:02:31,416 --> 00:02:33,756
also written in Swift, and all


73
00:02:33,756 --> 00:02:35,066
of this, you know, compiled code


74
00:02:35,066 --> 00:02:36,866
is running together within a


75
00:02:36,866 --> 00:02:37,786
running process.


76
00:02:37,876 --> 00:02:40,926
So the executable is using APIs


77
00:02:41,116 --> 00:02:42,146
from the framework and they have


78
00:02:42,186 --> 00:02:43,386
to be able to talk to each other


79
00:02:43,696 --> 00:02:44,456
at runtime.


80
00:02:45,246 --> 00:02:46,966
Well, in order for this to work,


81
00:02:46,966 --> 00:02:48,186
they have to have a compatible


82
00:02:48,186 --> 00:02:49,896
ABI, like these two, you know,


83
00:02:49,896 --> 00:02:50,926
pieces are compiled


84
00:02:51,006 --> 00:02:52,696
independently but that compiled


85
00:02:52,736 --> 00:02:53,856
code needs to work together.


86
00:02:54,436 --> 00:02:56,296
Before ABI stability, the only


87
00:02:56,296 --> 00:02:58,876
guarantee we had is that these


88
00:02:59,066 --> 00:03:00,546
would have a compatible ABI if


89
00:03:00,546 --> 00:03:02,406
they were built with the same


90
00:03:02,406 --> 00:03:02,966
compiler.


91
00:03:03,056 --> 00:03:04,826
And this was the case because we


92
00:03:04,826 --> 00:03:06,616
were really evolving the core


93
00:03:06,616 --> 00:03:08,176
fundamentals of Swift, making


94
00:03:08,176 --> 00:03:09,746
sure all the building blocks


95
00:03:09,746 --> 00:03:10,996
that we wanted to have in place


96
00:03:11,416 --> 00:03:13,096
to build upon in the future were


97
00:03:13,096 --> 00:03:14,106
in the right place.


98
00:03:14,766 --> 00:03:16,226
Well, in Swift 5, we've


99
00:03:16,226 --> 00:03:18,286
crystallized those details and


100
00:03:18,386 --> 00:03:20,436
Swift now has ABI stability,


101
00:03:20,436 --> 00:03:22,286
meaning these two components no


102
00:03:22,286 --> 00:03:23,796
longer need to be built with the


103
00:03:23,796 --> 00:03:25,826
same compiler as long as they're


104
00:03:25,826 --> 00:03:27,166
built with the Swift 5 compiler


105
00:03:27,626 --> 00:03:28,106
or later.


106
00:03:28,676 --> 00:03:31,386
The second important ingredient


107
00:03:31,386 --> 00:03:33,346
is module stability and this is


108
00:03:33,346 --> 00:03:35,146
a compiled time concept.


109
00:03:35,146 --> 00:03:36,996
So if you take a Swift framework


110
00:03:37,156 --> 00:03:38,966
using of all the APIs in that


111
00:03:38,966 --> 00:03:40,516
framework, those are part of a


112
00:03:40,516 --> 00:03:42,496
shared namespace called a


113
00:03:42,496 --> 00:03:43,076
module.


114
00:03:43,466 --> 00:03:45,396
And when the Swift compiler is


115
00:03:45,396 --> 00:03:48,296
used to build that framework, it


116
00:03:48,296 --> 00:03:50,786
produces a manifest of all the


117
00:03:50,786 --> 00:03:53,716
APIs in that framework that can


118
00:03:53,716 --> 00:03:55,756
be then consumed by clients of


119
00:03:55,756 --> 00:03:56,326
that framework.


120
00:03:56,636 --> 00:03:57,826
And that manifest is called a


121
00:03:57,826 --> 00:03:58,776
Swift module file.


122
00:03:59,196 --> 00:04:00,666
So if we return back to this


123
00:04:00,666 --> 00:04:02,586
example, imagine where-- you


124
00:04:02,586 --> 00:04:03,346
know, we're compiling the


125
00:04:03,386 --> 00:04:04,716
program so we have, you know, a


126
00:04:04,716 --> 00:04:06,396
source file, it references the


127
00:04:06,466 --> 00:04:08,206
framework, and what happens is


128
00:04:08,206 --> 00:04:09,216
the compiler goes and reads


129
00:04:09,256 --> 00:04:10,756
Swift module file, gets the


130
00:04:10,756 --> 00:04:11,416
available APIs.


131
00:04:11,416 --> 00:04:14,246
But the details in this module


132
00:04:14,246 --> 00:04:17,326
file are really rich and in many


133
00:04:17,326 --> 00:04:18,766
ways very tightly coupled to the


134
00:04:18,766 --> 00:04:19,826
compiler itself.


135
00:04:19,826 --> 00:04:21,716
So we had the same problem as


136
00:04:21,716 --> 00:04:22,746
with ABI stability.


137
00:04:22,746 --> 00:04:24,016
The only thing that worked is


138
00:04:24,016 --> 00:04:25,266
that these two pieces had to


139
00:04:25,266 --> 00:04:27,446
compile with the same compiler.


140
00:04:28,026 --> 00:04:31,236
On Swift 5.1, we've introduced a


141
00:04:31,236 --> 00:04:33,446
new complementary manifest.


142
00:04:33,936 --> 00:04:35,506
It's called a Swift module


143
00:04:35,506 --> 00:04:36,396
interface file.


144
00:04:36,996 --> 00:04:38,766
And it can be used by frameworks


145
00:04:39,186 --> 00:04:40,906
to provide a stable interface


146
00:04:41,356 --> 00:04:42,896
that clients can consume.


147
00:04:43,666 --> 00:04:45,736
It's a-- If you, you know, crack


148
00:04:45,736 --> 00:04:47,246
it open, it looks like Swift


149
00:04:47,296 --> 00:04:47,816
source code.


150
00:04:47,866 --> 00:04:49,196
So it's also built on the notion


151
00:04:49,196 --> 00:04:50,836
of source stability that we've


152
00:04:50,836 --> 00:04:52,446
had in Swift for quite some


153
00:04:52,446 --> 00:04:52,776
time.


154
00:04:53,086 --> 00:04:54,946
So with these two ingredients,


155
00:04:55,186 --> 00:04:57,626
you get Swift frameworks that


156
00:04:57,626 --> 00:04:59,776
can be deployed and shared with


157
00:04:59,776 --> 00:05:00,296
others.


158
00:05:01,516 --> 00:05:06,546
[Applause]


159
00:05:07,046 --> 00:05:08,096
Now there's a lot of really


160
00:05:08,096 --> 00:05:09,576
interesting details about ABI


161
00:05:09,576 --> 00:05:10,786
stability, was something that


162
00:05:10,786 --> 00:05:12,346
was in the works for quite some


163
00:05:12,946 --> 00:05:13,216
time.


164
00:05:13,216 --> 00:05:14,386
If you're interested in finding


165
00:05:14,386 --> 00:05:15,896
out a lot more details and we're


166
00:05:15,896 --> 00:05:16,946
going to talk about today,


167
00:05:16,946 --> 00:05:19,326
swift.org is a great resource.


168
00:05:19,326 --> 00:05:22,236
This is the homepage of Swift


169
00:05:22,236 --> 00:05:23,056
open source project.


170
00:05:23,056 --> 00:05:24,136
And there's a couple of really


171
00:05:24,136 --> 00:05:25,766
great blog posts about ABI


172
00:05:25,816 --> 00:05:26,276
stability.


173
00:05:27,816 --> 00:05:29,286
Also, if you're interested in


174
00:05:29,286 --> 00:05:31,156
putting binary frameworks to


175
00:05:31,576 --> 00:05:33,576
use, you know, for your own use


176
00:05:33,576 --> 00:05:34,416
like, you know, sharing with


177
00:05:34,416 --> 00:05:35,866
others, there's a great talk


178
00:05:35,866 --> 00:05:37,176
later this week called Binary


179
00:05:37,176 --> 00:05:38,976
Frameworks in Swift.


180
00:05:39,276 --> 00:05:40,256
And it talks about some of the


181
00:05:40,256 --> 00:05:41,666
considerations you should have


182
00:05:41,996 --> 00:05:43,566
when sharing frameworks with


183
00:05:43,566 --> 00:05:44,036
others.


184
00:05:45,316 --> 00:05:46,476
Now binary frameworks are just


185
00:05:46,476 --> 00:05:48,286
one part of that API story,


186
00:05:48,286 --> 00:05:50,296
another big piece are Swift


187
00:05:50,566 --> 00:05:51,116
packages.


188
00:05:51,946 --> 00:05:53,336
And with the integration of the


189
00:05:53,336 --> 00:05:55,216
Swift Package Manager now into


190
00:05:55,626 --> 00:05:56,646
Xcode, they're part of the core


191
00:05:56,646 --> 00:05:58,816
workflows of building apps.


192
00:05:59,666 --> 00:06:00,826
Two great talks this week about


193
00:06:00,826 --> 00:06:02,326
both creating and adopting


194
00:06:02,326 --> 00:06:04,206
packages within Xcode.


195
00:06:04,296 --> 00:06:06,356
And so the combination of binary


196
00:06:06,356 --> 00:06:07,766
frameworks and Swift packages


197
00:06:07,766 --> 00:06:09,346
provides a really rich set of


198
00:06:09,346 --> 00:06:12,276
options for sharing APIs with


199
00:06:12,276 --> 00:06:12,766
others.


200
00:06:14,556 --> 00:06:15,966
So let's shift gears and talk


201
00:06:15,966 --> 00:06:17,386
about performance.


202
00:06:18,066 --> 00:06:20,386
Swift language was built to be a


203
00:06:20,386 --> 00:06:22,326
modern, safe, but very


204
00:06:22,326 --> 00:06:24,216
performant programming language.


205
00:06:24,856 --> 00:06:25,856
And there are some key


206
00:06:25,856 --> 00:06:27,106
performance benefits that came


207
00:06:27,106 --> 00:06:28,376
out of ABI stability.


208
00:06:29,706 --> 00:06:30,976
One of them comes down to having


209
00:06:30,976 --> 00:06:32,696
that shared Swift runtime for


210
00:06:32,696 --> 00:06:34,676
apps in the OS, and this came


211
00:06:34,676 --> 00:06:37,206
out in March and so for macOS,


212
00:06:37,206 --> 00:06:38,676
iOS, tvOS, watchOS and now


213
00:06:38,756 --> 00:06:41,086
iPadOS, as of these releases,


214
00:06:41,406 --> 00:06:42,666
there's a shared Swift runtime


215
00:06:42,666 --> 00:06:45,176
in US that, well, third-party


216
00:06:45,176 --> 00:06:46,046
apps, first-party apps,


217
00:06:46,046 --> 00:06:47,936
everything in the system uses.


218
00:06:48,526 --> 00:06:51,546
So what-- how does this actually


219
00:06:51,546 --> 00:06:53,296
work, when does this come into


220
00:06:54,096 --> 00:06:54,196
play?


221
00:06:54,406 --> 00:06:56,376
If your app is built with Swift


222
00:06:56,376 --> 00:06:58,656
5 or later, it will always use


223
00:06:58,716 --> 00:07:00,496
the shared runtime in the OS


224
00:07:00,916 --> 00:07:02,486
when it is present.


225
00:07:03,636 --> 00:07:05,336
However, you may still be


226
00:07:05,336 --> 00:07:06,826
building your app to deploy back


227
00:07:06,826 --> 00:07:08,496
to an earlier OS release that


228
00:07:08,496 --> 00:07:09,546
doesn't have that runtime.


229
00:07:10,886 --> 00:07:12,396
In that case, Xcode will


230
00:07:12,396 --> 00:07:13,976
continue to bundle a copy of the


231
00:07:13,976 --> 00:07:15,986
runtime in your app so it can


232
00:07:15,986 --> 00:07:17,466
continue to run on those older


233
00:07:17,466 --> 00:07:18,596
OS releases.


234
00:07:19,796 --> 00:07:22,406
But, we will always prefer to


235
00:07:22,406 --> 00:07:24,166
use a copy that's in the OS


236
00:07:24,166 --> 00:07:25,986
itself, so that, you know, that


237
00:07:25,986 --> 00:07:27,956
copy in the app will be inert


238
00:07:28,566 --> 00:07:29,806
when running on newer system.


239
00:07:30,536 --> 00:07:33,976
And as an optimization, the iOS


240
00:07:34,156 --> 00:07:36,556
App Store will send out that


241
00:07:36,716 --> 00:07:37,906
copy, the runtime from your app


242
00:07:38,356 --> 00:07:39,766
when downloading into a device


243
00:07:39,976 --> 00:07:41,926
that has the runtime in the OS.


244
00:07:41,926 --> 00:07:43,756
So your users don't have to pay


245
00:07:43,756 --> 00:07:44,966
that download cost.


246
00:07:45,606 --> 00:07:48,566
So that's a really important


247
00:07:48,566 --> 00:07:51,286
code size benefit, but the real


248
00:07:51,286 --> 00:07:52,796
win about having that runtime in


249
00:07:52,796 --> 00:07:54,526
the OS is now it can be


250
00:07:54,586 --> 00:07:56,476
optimized as part of the


251
00:07:56,476 --> 00:07:58,126
operating system itself.


252
00:07:58,126 --> 00:07:59,586
And then those benefits can then


253
00:07:59,586 --> 00:08:01,136
be imparted onto apps


254
00:08:01,216 --> 00:08:01,676
themselves.


255
00:08:03,226 --> 00:08:04,986
And one important benefit is


256
00:08:04,986 --> 00:08:06,096
launch time.


257
00:08:06,336 --> 00:08:08,506
So let's rewind back in time, a


258
00:08:08,506 --> 00:08:10,926
year ago, we talked about Swift


259
00:08:10,926 --> 00:08:11,496
4.2.


260
00:08:12,996 --> 00:08:14,926
And if you take an Objective C


261
00:08:14,926 --> 00:08:17,506
app, it does nothing, it just


262
00:08:17,506 --> 00:08:19,166
starts up, does nothing at all


263
00:08:19,716 --> 00:08:21,346
and a Swift app that's, you


264
00:08:21,346 --> 00:08:22,526
know, similarly has no function,


265
00:08:22,526 --> 00:08:23,386
it just starts up.


266
00:08:23,796 --> 00:08:25,446
There's about a 5% overhead of


267
00:08:25,446 --> 00:08:27,326
using Swift because of the work


268
00:08:27,356 --> 00:08:29,256
needed to, you know, handle that


269
00:08:29,256 --> 00:08:30,116
embedded runtime.


270
00:08:30,306 --> 00:08:32,546
But when your app is recompiled


271
00:08:32,546 --> 00:08:34,265
with Swift 5 compiler and runs


272
00:08:34,265 --> 00:08:35,506
on an OS with that shared


273
00:08:35,506 --> 00:08:37,466
runtime, that overhead


274
00:08:38,035 --> 00:08:38,686
disappears.


275
00:08:39,515 --> 00:08:43,216
[Applause]


276
00:08:43,716 --> 00:08:44,536
This is really, really


277
00:08:44,536 --> 00:08:45,676
important.


278
00:08:45,676 --> 00:08:47,006
I mean, that latency is the


279
00:08:47,006 --> 00:08:48,886
difference between users wanting


280
00:08:48,886 --> 00:08:50,156
to-- you know, the moment they


281
00:08:50,156 --> 00:08:51,196
want to start using your app,


282
00:08:51,626 --> 00:08:52,996
and them starting experiencing


283
00:08:53,796 --> 00:08:53,866
it.


284
00:08:54,996 --> 00:08:56,856
Another important area that


285
00:08:56,856 --> 00:08:58,476
we've optimized is further


286
00:08:58,476 --> 00:09:01,396
tuning the committed, you know,


287
00:09:01,396 --> 00:09:02,686
code from the compilers.


288
00:09:02,686 --> 00:09:03,676
It reduces-- further reduce the


289
00:09:03,676 --> 00:09:06,026
code size of Swift applications.


290
00:09:06,026 --> 00:09:07,776
And this really has been like


291
00:09:07,776 --> 00:09:09,356
fine tuning, like looking at


292
00:09:09,386 --> 00:09:11,126
specific patterns in Swift


293
00:09:11,126 --> 00:09:13,086
applications like chess, how our


294
00:09:13,086 --> 00:09:14,306
dictionary literals like


295
00:09:14,306 --> 00:09:15,556
represented, you know, when


296
00:09:15,556 --> 00:09:16,656
their code generated and so


297
00:09:16,656 --> 00:09:18,516
forth, and just trying to make


298
00:09:18,516 --> 00:09:19,696
sure that, you know, the output


299
00:09:19,696 --> 00:09:22,346
of the compiler is optimized for


300
00:09:22,346 --> 00:09:23,406
those use cases.


301
00:09:23,786 --> 00:09:24,756
And so with an assortment of


302
00:09:24,756 --> 00:09:26,776
optimizations we see up to a 10%


303
00:09:26,776 --> 00:09:29,546
reduction in code size when--


304
00:09:29,546 --> 00:09:30,956
well, with the Swift 5.1


305
00:09:30,956 --> 00:09:31,506
compiler.


306
00:09:31,846 --> 00:09:32,846
And if you have optimized your


307
00:09:32,846 --> 00:09:35,936
size, it's about a 15% reduction


308
00:09:35,936 --> 00:09:36,566
code size.


309
00:09:36,976 --> 00:09:39,086
So some pretty significant ones.


310
00:09:40,076 --> 00:09:42,786
We've also continued to refine,


311
00:09:42,786 --> 00:09:44,136
you know, the performance of


312
00:09:44,136 --> 00:09:44,536
bridging.


313
00:09:45,156 --> 00:09:46,246
And by bridging I'm talking


314
00:09:46,246 --> 00:09:47,856
about the bridging between Swift


315
00:09:48,296 --> 00:09:49,046
and Objective-C.


316
00:09:49,046 --> 00:09:49,956
There's a really deep


317
00:09:49,956 --> 00:09:51,776
inoperability between those two


318
00:09:51,776 --> 00:09:52,456
languages.


319
00:09:54,556 --> 00:09:56,666
So both Swift and Objective-C


320
00:09:56,666 --> 00:09:58,396
have what we call common


321
00:09:58,446 --> 00:10:00,206
currency types, that are used


322
00:10:00,256 --> 00:10:01,786
throughout the API space.


323
00:10:02,326 --> 00:10:04,206
Things like String and NSString,


324
00:10:04,556 --> 00:10:06,356
Dictionary and NSDictionary.


325
00:10:06,356 --> 00:10:08,516
And the inoperability between


326
00:10:08,516 --> 00:10:10,296
those currency types is pretty


327
00:10:10,296 --> 00:10:11,136
fundamental as part of the


328
00:10:11,136 --> 00:10:12,796
inoperability between Swift and


329
00:10:12,796 --> 00:10:13,706
Objective-C.


330
00:10:14,246 --> 00:10:15,646
Objective-C APIs that use their


331
00:10:15,646 --> 00:10:16,886
currency types are re-mapped


332
00:10:16,886 --> 00:10:18,486
into Swift using Swift's


333
00:10:18,486 --> 00:10:19,326
currency types.


334
00:10:19,506 --> 00:10:21,166
Now this is a compiler-- this is


335
00:10:21,166 --> 00:10:23,006
a combination of compiler work


336
00:10:23,566 --> 00:10:24,696
but also there's a runtime


337
00:10:24,696 --> 00:10:26,116
aspect when you pass a value of


338
00:10:26,116 --> 00:10:28,696
one type off for another across


339
00:10:28,726 --> 00:10:29,956
these API boundaries.


340
00:10:31,026 --> 00:10:32,076
This is the part that we have


341
00:10:32,076 --> 00:10:33,626
further attuned as part of Swift


342
00:10:33,676 --> 00:10:35,246
being now part of the operating


343
00:10:35,246 --> 00:10:35,756
system.


344
00:10:36,676 --> 00:10:39,106
For example, bridging between


345
00:10:39,106 --> 00:10:40,256
NSDictionary and Dictionary is


346
00:10:40,256 --> 00:10:42,156
now 1.6 times faster.


347
00:10:43,186 --> 00:10:44,966
And if you're passing a Swift


348
00:10:44,966 --> 00:10:47,416
string off to Objective-C and it


349
00:10:47,416 --> 00:10:49,346
bridges over as an NSString and


350
00:10:49,346 --> 00:10:50,206
it's used, you know, from the


351
00:10:50,206 --> 00:10:52,676
Objective-C side, its operations


352
00:10:52,706 --> 00:10:55,566
can be up to 15 times faster.


353
00:10:56,516 --> 00:11:01,096
[ Applause ]


354
00:11:01,596 --> 00:11:03,116
And all these like little bit--


355
00:11:03,116 --> 00:11:04,666
all these benefits really do add


356
00:11:04,666 --> 00:11:05,896
up because these are types that


357
00:11:05,896 --> 00:11:07,286
are used, you know, throughout


358
00:11:07,286 --> 00:11:08,436
the API ecosystem.


359
00:11:09,076 --> 00:11:12,326
Now speaking of strings, we


360
00:11:12,326 --> 00:11:13,986
continue to refine their core


361
00:11:13,986 --> 00:11:15,316
representation and we made a


362
00:11:15,316 --> 00:11:17,546
major change to the string type


363
00:11:17,976 --> 00:11:18,826
in Swift 5.


364
00:11:19,786 --> 00:11:20,856
And this was an under-the-hood


365
00:11:20,856 --> 00:11:21,896
change where we change the


366
00:11:21,896 --> 00:11:23,346
unicode representation of


367
00:11:23,346 --> 00:11:29,326
strings from UTF-16 to UTF-8.


368
00:11:30,206 --> 00:11:31,866
Now this is completely


369
00:11:31,866 --> 00:11:33,416
performance motivated.


370
00:11:34,296 --> 00:11:35,416
There's a lot of rich detail


371
00:11:35,416 --> 00:11:36,226
about this change.


372
00:11:36,226 --> 00:11:37,206
If you're interested in finding


373
00:11:37,206 --> 00:11:38,506
out a lot more than what I'm


374
00:11:38,506 --> 00:11:40,406
about to say, swift.org, there's


375
00:11:40,406 --> 00:11:41,566
a blog post that goes into the


376
00:11:41,566 --> 00:11:42,896
actual technical changes and


377
00:11:42,896 --> 00:11:43,666
what motivate it.


378
00:11:44,196 --> 00:11:44,946
Well, I'll highlight a few


379
00:11:44,946 --> 00:11:45,766
important things.


380
00:11:46,816 --> 00:11:49,556
First, we created Swift as a


381
00:11:49,556 --> 00:11:50,936
language you could reach for,


382
00:11:50,936 --> 00:11:52,996
for C-like performance.


383
00:11:54,256 --> 00:11:55,536
But a key aspect of that is that


384
00:11:55,536 --> 00:11:56,846
we want Swift to have great


385
00:11:56,846 --> 00:11:58,716
inoperability with an existing


386
00:11:58,716 --> 00:12:00,266
ecosystem of C APIs.


387
00:12:00,266 --> 00:12:02,286
And when Swift strings were


388
00:12:02,286 --> 00:12:05,016
using the UTF-16, when you pass


389
00:12:05,016 --> 00:12:08,866
a string off to a C API, there--


390
00:12:09,186 --> 00:12:10,936
unbeknownst to maybe to you, you


391
00:12:10,936 --> 00:12:12,796
had to do-- there was an


392
00:12:12,796 --> 00:12:14,556
allocation and a copy and a


393
00:12:14,556 --> 00:12:15,776
transcoding just to put it in a


394
00:12:15,776 --> 00:12:16,996
compatible format that can be


395
00:12:17,046 --> 00:12:17,746
passed up to six.


396
00:12:17,746 --> 00:12:18,916
So this is like a lot of


397
00:12:18,916 --> 00:12:19,366
overhead.


398
00:12:20,176 --> 00:12:22,346
By moving to UTF-8, we can just


399
00:12:22,346 --> 00:12:23,436
now pull a pass off a


400
00:12:23,436 --> 00:12:25,396
null-terminated UTF-8 string to


401
00:12:25,396 --> 00:12:26,036
C APIs.


402
00:12:26,396 --> 00:12:28,896
No allocations, no copies, zero


403
00:12:28,896 --> 00:12:29,276
overhead.


404
00:12:30,886 --> 00:12:32,666
We've also been able to expand


405
00:12:32,666 --> 00:12:33,736
out the optimizations of the


406
00:12:33,736 --> 00:12:34,816
string type itself.


407
00:12:35,576 --> 00:12:37,396
So string has a small string


408
00:12:37,396 --> 00:12:39,376
optimization where if the number


409
00:12:39,376 --> 00:12:40,436
of characters in the string are


410
00:12:40,436 --> 00:12:41,796
about like 15 characters or


411
00:12:41,796 --> 00:12:43,646
less, we don't need a separate


412
00:12:43,646 --> 00:12:44,746
allocation to care-- you know,


413
00:12:44,746 --> 00:12:45,816
to have that, that payload of


414
00:12:45,816 --> 00:12:47,016
characters, we can just pack it


415
00:12:47,016 --> 00:12:48,156
right into the string value


416
00:12:48,156 --> 00:12:48,546
itself.


417
00:12:48,706 --> 00:12:49,726
So this is a real win.


418
00:12:49,836 --> 00:12:51,566
With Swift 5, we'd be able to


419
00:12:51,566 --> 00:12:53,026
expand this optimization out to


420
00:12:53,026 --> 00:12:54,216
include, you know, essentially


421
00:12:54,216 --> 00:12:55,716
all unicode characters not just,


422
00:12:55,716 --> 00:12:57,806
you know, ASCII, which means it


423
00:12:57,806 --> 00:12:59,776
now applies to languages with


424
00:12:59,776 --> 00:13:00,946
non-Roman characters.


425
00:13:01,506 --> 00:13:03,596
And we've done this while


426
00:13:03,596 --> 00:13:06,236
maintaining great inoperability


427
00:13:06,456 --> 00:13:08,036
between NSStrings and String at


428
00:13:08,036 --> 00:13:08,876
a performance level.


429
00:13:10,216 --> 00:13:11,456
But the really exciting to hear


430
00:13:11,456 --> 00:13:13,446
is this is really all about


431
00:13:13,446 --> 00:13:13,906
performance.


432
00:13:13,906 --> 00:13:14,966
I've said it several times.


433
00:13:16,056 --> 00:13:17,486
A great example that benchmarks


434
00:13:17,556 --> 00:13:18,916
this is SwiftNIO.


435
00:13:18,916 --> 00:13:20,266
For those of you who are not


436
00:13:20,266 --> 00:13:21,756
familiar with it, SwiftNIO comes


437
00:13:21,756 --> 00:13:23,086
from the Swift on server world


438
00:13:23,566 --> 00:13:25,556
and it is a cross-platform


439
00:13:25,556 --> 00:13:26,786
framework for building network


440
00:13:26,836 --> 00:13:27,976
protocols and services.


441
00:13:28,246 --> 00:13:29,966
And it's really been tuned for


442
00:13:29,966 --> 00:13:30,486
speed.


443
00:13:31,676 --> 00:13:35,156
And by switching to UTF-8, we


444
00:13:35,226 --> 00:13:37,776
see a 20% increase in the


445
00:13:37,776 --> 00:13:39,646
throughput of a web server built


446
00:13:39,646 --> 00:13:40,266
on SwiftNIO.


447
00:13:40,266 --> 00:13:41,236
So this is just like, you know,


448
00:13:41,666 --> 00:13:43,446
just a benchmark of textual text


449
00:13:43,446 --> 00:13:44,136
processing.


450
00:13:44,736 --> 00:13:46,726
And this really resonates with


451
00:13:46,726 --> 00:13:47,926
we want string to be a type that


452
00:13:47,926 --> 00:13:51,406
you can use for high performance


453
00:13:51,566 --> 00:13:54,216
intensive string operations but


454
00:13:54,216 --> 00:13:56,326
also just it's user friendly and


455
00:13:56,386 --> 00:13:59,906
easy to use.


456
00:14:00,366 --> 00:14:01,576
And before I hand the stage off


457
00:14:01,696 --> 00:14:03,266
to Anna, who will talk about


458
00:14:03,266 --> 00:14:04,636
mainly the language changes in


459
00:14:04,636 --> 00:14:06,536
Swift 5 and Swift 5.1, I want to


460
00:14:06,536 --> 00:14:07,636
talk about some of the core tool


461
00:14:07,636 --> 00:14:09,556
and improvements and part of


462
00:14:09,556 --> 00:14:11,946
those being a key aspect of the


463
00:14:11,946 --> 00:14:12,846
open source project.


464
00:14:14,416 --> 00:14:16,766
Now Swift being open source is


465
00:14:16,766 --> 00:14:18,936
more than just the day to day,


466
00:14:18,936 --> 00:14:20,096
you know, engineering work on a


467
00:14:20,096 --> 00:14:20,556
project.


468
00:14:20,886 --> 00:14:22,216
It's about Swift being part of a


469
00:14:22,216 --> 00:14:23,926
much broader and diverse


470
00:14:23,986 --> 00:14:25,886
ecosystem of software.


471
00:14:26,536 --> 00:14:28,816
So for example, the Swift


472
00:14:28,816 --> 00:14:30,566
community came together and


473
00:14:30,566 --> 00:14:32,746
created official Docker images


474
00:14:32,926 --> 00:14:34,346
for Swift that are hosted on


475
00:14:34,496 --> 00:14:35,786
Docker Hub.


476
00:14:36,446 --> 00:14:37,546
And if you have Docker installed


477
00:14:37,546 --> 00:14:38,636
on your Mac, which is a few


478
00:14:38,636 --> 00:14:40,606
keystrokes, you can have-- you


479
00:14:40,606 --> 00:14:42,016
can pull down a Docker, this


480
00:14:42,016 --> 00:14:43,406
Docker image and have, you know,


481
00:14:43,406 --> 00:14:45,066
working Docker Linux container


482
00:14:45,466 --> 00:14:46,896
on your Mac that includes a


483
00:14:46,896 --> 00:14:48,866
compiler and the package


484
00:14:48,866 --> 00:14:50,356
manager, everything you need to


485
00:14:50,356 --> 00:14:50,866
get going.


486
00:14:51,366 --> 00:14:52,566
And this was done because


487
00:14:52,626 --> 00:14:53,986
containers are viewed as an


488
00:14:53,986 --> 00:14:56,306
intrinsic part of building


489
00:14:56,406 --> 00:14:58,396
services today.


490
00:14:59,736 --> 00:15:01,816
Another important technology


491
00:15:01,816 --> 00:15:03,006
that is open source is


492
00:15:03,006 --> 00:15:03,516
SourceKit.


493
00:15:03,936 --> 00:15:05,536
And it's a semantic code engine


494
00:15:05,656 --> 00:15:07,286
behind Xcode's features like


495
00:15:07,426 --> 00:15:08,426
code completion,


496
00:15:08,426 --> 00:15:10,496
jump-to-definition, refactoring,


497
00:15:10,936 --> 00:15:11,376
and more.


498
00:15:12,116 --> 00:15:13,066
And it's something that we


499
00:15:13,066 --> 00:15:14,406
continue to refine.


500
00:15:14,406 --> 00:15:15,546
We want to make the results of


501
00:15:15,546 --> 00:15:17,276
code completion, so forth, much


502
00:15:17,276 --> 00:15:17,826
better.


503
00:15:19,186 --> 00:15:20,496
So something we continually to,


504
00:15:20,496 --> 00:15:21,406
you know, iterate upon.


505
00:15:22,266 --> 00:15:23,886
But also we want to make it


506
00:15:23,886 --> 00:15:25,466
reliable and robust.


507
00:15:27,296 --> 00:15:28,556
One of the efforts that we did,


508
00:15:28,556 --> 00:15:29,546
part of the open source project


509
00:15:29,546 --> 00:15:31,006
this year was build a new stress


510
00:15:31,006 --> 00:15:32,526
tester tool for SourceKit.


511
00:15:33,676 --> 00:15:35,946
What it does is it just pummels


512
00:15:36,126 --> 00:15:37,696
SourceKit with all the queries


513
00:15:37,696 --> 00:15:40,086
the IDE could issue to flush out


514
00:15:40,136 --> 00:15:42,296
issues with SourceKit.


515
00:15:42,856 --> 00:15:43,816
So things like crashes,


516
00:15:43,816 --> 00:15:44,756
assertions, it creates


517
00:15:44,796 --> 00:15:46,476
reproducible test cases for us.


518
00:15:46,896 --> 00:15:48,836
And there's something very Meta


519
00:15:48,836 --> 00:15:49,106
here.


520
00:15:50,466 --> 00:15:52,086
We believe in building the first


521
00:15:52,086 --> 00:15:55,096
in class tools with Swift for


522
00:15:55,096 --> 00:15:56,996
all of you and investing in


523
00:15:56,996 --> 00:15:58,396
tools as part of our own


524
00:15:58,396 --> 00:15:59,386
workflows is like, you know,


525
00:15:59,386 --> 00:16:01,146
we're eating our own philosophy


526
00:16:01,786 --> 00:16:04,386
and efforts like this are now a


527
00:16:04,486 --> 00:16:06,686
core part of, you know, our day


528
00:16:06,686 --> 00:16:07,996
to day engineering with the


529
00:16:08,546 --> 00:16:08,766
project.


530
00:16:10,906 --> 00:16:12,986
And I like to talk about a


531
00:16:12,986 --> 00:16:14,626
future looking investment with


532
00:16:14,626 --> 00:16:16,046
SourceKit, and that's in


533
00:16:16,046 --> 00:16:17,246
adopting the language server


534
00:16:17,246 --> 00:16:17,676
protocol.


535
00:16:18,386 --> 00:16:20,446
So take this example slide


536
00:16:20,446 --> 00:16:20,896
before.


537
00:16:21,576 --> 00:16:23,546
You could take Xcode and really


538
00:16:23,546 --> 00:16:24,896
generalize this picture, be


539
00:16:24,896 --> 00:16:27,146
about really any kind of editor


540
00:16:27,146 --> 00:16:27,636
or tool.


541
00:16:27,636 --> 00:16:29,086
I mean SourceKit is open source.


542
00:16:29,406 --> 00:16:30,776
It's designed to be used as a


543
00:16:30,776 --> 00:16:32,606
reusable component for building


544
00:16:32,606 --> 00:16:33,116
tools.


545
00:16:34,196 --> 00:16:37,386
So this could work, right, but


546
00:16:37,386 --> 00:16:39,636
this is really kind of an old


547
00:16:39,636 --> 00:16:40,016
model.


548
00:16:40,236 --> 00:16:41,646
You imagine that there's a wide


549
00:16:41,646 --> 00:16:43,996
range of tools and editors and


550
00:16:43,996 --> 00:16:45,806
IDs out there and they want to


551
00:16:45,806 --> 00:16:47,046
wire up to a variety of


552
00:16:47,046 --> 00:16:48,056
different, you know, language


553
00:16:48,056 --> 00:16:48,816
services.


554
00:16:49,246 --> 00:16:50,316
And so while they could directly


555
00:16:50,316 --> 00:16:51,526
wire up logic to talk to


556
00:16:51,526 --> 00:16:53,466
SourceKit, this is all very ad


557
00:16:53,466 --> 00:16:53,836
hoc.


558
00:16:53,836 --> 00:16:54,926
You have to have each editor


559
00:16:54,926 --> 00:16:57,096
wire up its own support and they


560
00:16:57,096 --> 00:16:58,136
have to understand the SourceKit


561
00:16:58,136 --> 00:16:58,926
and then they have to understand


562
00:16:58,926 --> 00:17:00,056
all the other services they want


563
00:17:00,056 --> 00:17:00,526
to connect to.


564
00:17:00,526 --> 00:17:02,446
So this isn't a very scalable


565
00:17:02,446 --> 00:17:02,776
model.


566
00:17:03,296 --> 00:17:04,576
But like most problems in


567
00:17:04,576 --> 00:17:05,626
computer science, you can solve


568
00:17:05,626 --> 00:17:06,486
everything with a layer of


569
00:17:06,486 --> 00:17:08,546
indirection, (except


570
00:17:08,546 --> 00:17:11,776
performance), and an industry


571
00:17:11,776 --> 00:17:12,886
standard solution called the


572
00:17:12,886 --> 00:17:14,465
Language Service Protocol has


573
00:17:14,465 --> 00:17:15,596
emerged or LSP.


574
00:17:15,596 --> 00:17:18,056
And the idea is, is that if the


575
00:17:18,056 --> 00:17:20,205
editors speak LSP, which is a


576
00:17:20,205 --> 00:17:22,056
standard set of queries and the


577
00:17:22,056 --> 00:17:23,846
services, you know, can speak it


578
00:17:23,846 --> 00:17:25,286
back, you can just mash, make


579
00:17:25,286 --> 00:17:26,056
them up together.


580
00:17:27,576 --> 00:17:28,976
This is an active effort that's


581
00:17:28,976 --> 00:17:31,136
underway, also an open source,


582
00:17:31,376 --> 00:17:32,236
you can check it out.


583
00:17:32,846 --> 00:17:34,446
But to give you a taste of


584
00:17:34,446 --> 00:17:36,806
what's there, this animation


585
00:17:36,806 --> 00:17:39,146
shows code completion support


586
00:17:39,146 --> 00:17:41,596
working in them using SourceKit


587
00:17:41,596 --> 00:17:44,296
LSP and there's also support for


588
00:17:44,296 --> 00:17:45,536
various other editors.


589
00:17:45,536 --> 00:17:47,256
You can find instructions on the


590
00:17:47,256 --> 00:17:48,006
GitHub page.


591
00:17:49,516 --> 00:17:54,616
[ Applause ]


592
00:17:55,116 --> 00:17:56,476
It's investments like this that


593
00:17:56,476 --> 00:17:57,906
are really exciting for us,


594
00:17:57,906 --> 00:17:59,416
because Swift is really-- it's a


595
00:17:59,416 --> 00:18:00,976
language that we built for


596
00:18:00,976 --> 00:18:02,936
general, you know, computing,


597
00:18:03,076 --> 00:18:03,326
right?


598
00:18:03,326 --> 00:18:05,166
It has an immense amount of


599
00:18:05,216 --> 00:18:07,616
potential and this is really


600
00:18:07,616 --> 00:18:10,036
about making Swift really thrive


601
00:18:10,036 --> 00:18:11,636
in a diverse software ecosystem.


602
00:18:12,126 --> 00:18:13,766
With that I'd like to hand the


603
00:18:13,766 --> 00:18:15,146
stage off to my colleague Anna


604
00:18:15,146 --> 00:18:16,496
Zaks [phonetic], who will talk


605
00:18:16,496 --> 00:18:18,146
about the language changes in


606
00:18:18,146 --> 00:18:18,516
Swift.


607
00:18:19,516 --> 00:18:24,056
[ Applause ]


608
00:18:24,556 --> 00:18:25,146
>> Thank you, Ted.


609
00:18:25,756 --> 00:18:26,526
Ted talked about the


610
00:18:26,526 --> 00:18:27,996
improvements to the project and


611
00:18:27,996 --> 00:18:28,586
the compiler.


612
00:18:28,956 --> 00:18:30,366
Now let me tell you about


613
00:18:30,526 --> 00:18:32,136
improvements we've made to the


614
00:18:32,136 --> 00:18:33,516
Swift language and the standard


615
00:18:33,516 --> 00:18:35,176
library in Swift 5 and Swift


616
00:18:35,176 --> 00:18:36,006
5.1.


617
00:18:37,126 --> 00:18:38,836
Many of these features continued


618
00:18:38,836 --> 00:18:40,416
refining the core parts of the


619
00:18:40,416 --> 00:18:41,576
language and the library.


620
00:18:42,256 --> 00:18:43,956
Also, aligned with Apple


621
00:18:43,956 --> 00:18:45,556
shipping several major Swift


622
00:18:45,556 --> 00:18:47,086
frameworks this year, we've


623
00:18:47,086 --> 00:18:48,626
added features that support


624
00:18:48,626 --> 00:18:50,386
creation of better Swift APIs.


625
00:18:51,356 --> 00:18:52,876
As many of you know, Swift


626
00:18:52,876 --> 00:18:54,556
language goes through open


627
00:18:54,556 --> 00:18:55,516
evolution process.


628
00:18:56,006 --> 00:18:57,676
And these SE numbers you see on


629
00:18:57,676 --> 00:18:59,716
the slide correspond to the


630
00:18:59,716 --> 00:19:01,006
feature documents that you can


631
00:19:01,006 --> 00:19:02,396
find on the Swift evolution


632
00:19:02,396 --> 00:19:02,916
website.


633
00:19:03,926 --> 00:19:05,146
It's a great resource if you


634
00:19:05,146 --> 00:19:06,346
want to learn more about these


635
00:19:06,346 --> 00:19:06,786
features.


636
00:19:07,306 --> 00:19:08,486
But now, let me give you a


637
00:19:08,486 --> 00:19:11,096
glimpse into some of them.


638
00:19:11,256 --> 00:19:12,726
We'll start with a few examples


639
00:19:12,726 --> 00:19:14,376
that I just fill in the missing


640
00:19:14,376 --> 00:19:14,726
blocks.


641
00:19:15,296 --> 00:19:18,046
Many of you love the simplicity


642
00:19:18,046 --> 00:19:19,546
of single expression closure


643
00:19:19,546 --> 00:19:20,026
syntax.


644
00:19:20,606 --> 00:19:22,036
So they need to write a return


645
00:19:22,216 --> 00:19:24,226
in single expression, functions,


646
00:19:24,226 --> 00:19:27,066
methods, and subscripts might


647
00:19:27,156 --> 00:19:28,896
feel like unnecessary burden.


648
00:19:29,216 --> 00:19:31,456
Well now, you can use the simple


649
00:19:31,456 --> 00:19:32,676
syntax everywhere.


650
00:19:33,516 --> 00:19:38,476
[ Applause ]


651
00:19:38,976 --> 00:19:40,466
Another [inaudible] was fixed by


652
00:19:40,466 --> 00:19:41,876
an open source contributor,


653
00:19:42,156 --> 00:19:43,416
Alejandro Alonso.


654
00:19:43,766 --> 00:19:45,716
And what's amazing, he is just


655
00:19:45,716 --> 00:19:46,856
finishing high school.


656
00:19:47,766 --> 00:19:49,146
Consider this struct that


657
00:19:49,146 --> 00:19:50,806
conveniently defines default


658
00:19:50,806 --> 00:19:51,906
values for both of its


659
00:19:51,906 --> 00:19:52,436
properties.


660
00:19:53,396 --> 00:19:54,896
Previously, you could call an


661
00:19:54,896 --> 00:19:56,546
initializer and pass it no


662
00:19:56,546 --> 00:19:57,146
arguments.


663
00:19:57,806 --> 00:19:58,776
You could also call an


664
00:19:58,776 --> 00:20:00,216
initializer and pass it all


665
00:20:00,216 --> 00:20:02,326
arguments, but you could not


666
00:20:02,356 --> 00:20:04,196
call an initializer and pass it


667
00:20:04,196 --> 00:20:05,406
only some of the arguments.


668
00:20:06,266 --> 00:20:08,236
As of Swift 5, this problem is


669
00:20:08,236 --> 00:20:08,626
fixed.


670
00:20:09,506 --> 00:20:11,106
Everything works as you expect


671
00:20:11,606 --> 00:20:15,736
[applause].


672
00:20:16,236 --> 00:20:18,286
And the compiler generates


673
00:20:18,506 --> 00:20:19,766
initializers for all of these


674
00:20:19,766 --> 00:20:20,156
cases.


675
00:20:21,116 --> 00:20:23,176
Another imported area is high


676
00:20:23,176 --> 00:20:24,206
performance computing.


677
00:20:25,106 --> 00:20:26,896
In Swift 5 the standard library


678
00:20:26,896 --> 00:20:29,006
added support for SIMD, Single


679
00:20:29,006 --> 00:20:30,396
Instruction Multiple Data


680
00:20:30,496 --> 00:20:31,576
instructions and types.


681
00:20:32,496 --> 00:20:33,986
These are often used for writing


682
00:20:33,986 --> 00:20:36,056
low level performance sensitive


683
00:20:36,056 --> 00:20:38,116
code for graphics, such as image


684
00:20:38,116 --> 00:20:39,766
processing or AR.


685
00:20:40,276 --> 00:20:41,706
In fact, the new RealityKit


686
00:20:41,706 --> 00:20:43,036
library we're shipping this year


687
00:20:43,276 --> 00:20:44,496
is using these types.


688
00:20:45,226 --> 00:20:47,716
The new SIMD types represent


689
00:20:47,916 --> 00:20:49,486
fixed size SIMD vectors.


690
00:20:50,136 --> 00:20:51,786
And as you expect, you can use


691
00:20:51,786 --> 00:20:53,566
the standard library integer and


692
00:20:53,606 --> 00:20:55,756
floating-point types as elements


693
00:20:55,756 --> 00:20:55,966
here.


694
00:20:56,916 --> 00:20:58,396
Let me give you a taste of what


695
00:20:58,396 --> 00:21:01,916
you can do with these types.


696
00:21:02,096 --> 00:21:03,876
You can initialize SIMD vector


697
00:21:03,876 --> 00:21:04,786
from array literals.


698
00:21:05,626 --> 00:21:07,676
Here we have array of size four,


699
00:21:08,156 --> 00:21:09,386
actually two arrays of size


700
00:21:09,386 --> 00:21:09,696
four.


701
00:21:09,696 --> 00:21:11,816
And the new dot operators allow


702
00:21:11,816 --> 00:21:14,046
you to perform pointwise


703
00:21:14,096 --> 00:21:16,096
operations on these vectors,


704
00:21:16,706 --> 00:21:17,946
such as equality and


705
00:21:17,946 --> 00:21:18,676
comparisons.


706
00:21:19,296 --> 00:21:20,906
For example here, we are


707
00:21:20,906 --> 00:21:23,636
checking if x is greater than y


708
00:21:23,936 --> 00:21:24,616
pointwise.


709
00:21:25,406 --> 00:21:27,136
And the result tells us that x


710
00:21:27,136 --> 00:21:29,076
is greater than y only at the


711
00:21:29,076 --> 00:21:30,076
last two points.


712
00:21:30,676 --> 00:21:33,076
The result is stored in another


713
00:21:33,076 --> 00:21:36,136
type called SIMDMask and the dot


714
00:21:36,136 --> 00:21:37,906
operators on the SIMDMask type


715
00:21:37,906 --> 00:21:40,096
allow you to manipulate these


716
00:21:40,496 --> 00:21:42,036
resulting masks further.


717
00:21:42,246 --> 00:21:43,226
For example here, we are


718
00:21:43,226 --> 00:21:44,356
negating the result of the


719
00:21:44,356 --> 00:21:45,466
previous computation.


720
00:21:48,376 --> 00:21:50,456
Swift 5 also gives you more


721
00:21:50,456 --> 00:21:52,206
expressivity for manipulating


722
00:21:53,426 --> 00:21:53,576
text.


723
00:21:53,806 --> 00:21:55,246
String interpolation has been


724
00:21:55,246 --> 00:21:56,946
redesigned in Swift 5.


725
00:21:57,506 --> 00:22:00,346
The new design is up to 1.7


726
00:22:00,346 --> 00:22:03,376
times faster and further, you


727
00:22:03,376 --> 00:22:05,256
can customize the built


728
00:22:05,256 --> 00:22:07,116
interpolation by providing your


729
00:22:07,116 --> 00:22:08,676
own helpers and you can


730
00:22:08,676 --> 00:22:10,956
initialize your own types with


731
00:22:10,956 --> 00:22:12,946
interpolated strings, giving


732
00:22:12,946 --> 00:22:14,356
string interpolation cost and


733
00:22:14,356 --> 00:22:14,786
meanings.


734
00:22:15,886 --> 00:22:17,576
Swift can support the string


735
00:22:17,576 --> 00:22:18,726
interpolation from the very


736
00:22:18,726 --> 00:22:19,116
beginning.


737
00:22:19,466 --> 00:22:20,666
If you write the backslash


738
00:22:21,016 --> 00:22:22,266
followed by some parenthesized


739
00:22:22,266 --> 00:22:23,566
quote inside of a string


740
00:22:23,566 --> 00:22:25,166
literal, the compiler will


741
00:22:25,166 --> 00:22:26,636
execute the code and insert the


742
00:22:26,636 --> 00:22:28,476
string and insert the value into


743
00:22:28,476 --> 00:22:28,916
the string.


744
00:22:28,916 --> 00:22:31,246
This has always worked but there


745
00:22:31,246 --> 00:22:32,546
were some limitations as well.


746
00:22:33,556 --> 00:22:35,736
For example, using an


747
00:22:35,736 --> 00:22:37,816
interpolated string enclosed to


748
00:22:37,816 --> 00:22:40,056
NSLocalizedString does not work.


749
00:22:41,236 --> 00:22:43,346
The interpolation happens before


750
00:22:43,346 --> 00:22:44,276
the translation.


751
00:22:44,946 --> 00:22:46,986
And for example here, the string


752
00:22:46,986 --> 00:22:48,996
file does not contain a


753
00:22:48,996 --> 00:22:51,246
translation of this string with


754
00:22:51,296 --> 00:22:52,896
every single integer inserted


755
00:22:52,896 --> 00:22:53,306
into it.


756
00:22:53,726 --> 00:22:57,636
So, you have 10 apples will not


757
00:22:57,636 --> 00:22:58,466
get translated.


758
00:22:59,576 --> 00:23:01,016
Instead what you need to do is


759
00:23:01,016 --> 00:23:02,586
first construct the


760
00:23:02,636 --> 00:23:03,416
formatString.


761
00:23:05,146 --> 00:23:07,166
Next, localize it.


762
00:23:08,176 --> 00:23:10,046
And only after that, insert the


763
00:23:10,046 --> 00:23:11,716
value into the localized string.


764
00:23:12,836 --> 00:23:14,376
This is the right way to do


765
00:23:14,376 --> 00:23:16,726
string localization with UIKit


766
00:23:16,726 --> 00:23:17,406
and AppKit.


767
00:23:18,456 --> 00:23:20,476
But the new string interpolation


768
00:23:20,476 --> 00:23:22,236
design lets us take it another


769
00:23:22,236 --> 00:23:24,526
step forward and design really


770
00:23:24,526 --> 00:23:26,946
expressive APIs like text from


771
00:23:26,946 --> 00:23:28,036
the SwiftUI framework.


772
00:23:28,706 --> 00:23:30,666
Text is used to represent label


773
00:23:30,666 --> 00:23:32,906
in SwiftUI and we want that


774
00:23:32,906 --> 00:23:33,506
localized.


775
00:23:34,616 --> 00:23:35,606
Let's see how that works.


776
00:23:36,336 --> 00:23:39,096
Here we are passing an


777
00:23:39,096 --> 00:23:40,256
interpolated string to the


778
00:23:40,256 --> 00:23:41,526
initializer of text.


779
00:23:42,506 --> 00:23:44,126
And the trick here is that the


780
00:23:44,126 --> 00:23:46,656
text initializer does not take a


781
00:23:46,656 --> 00:23:48,046
string type as its input.


782
00:23:48,616 --> 00:23:50,026
It takes another type called


783
00:23:50,146 --> 00:23:52,456
LocalizedStringKey that is


784
00:23:52,456 --> 00:23:54,166
defined inside of a SwiftUI


785
00:23:54,166 --> 00:23:54,616
framework.


786
00:23:54,726 --> 00:23:56,916
Because of this, the Swift


787
00:23:56,946 --> 00:23:58,316
compiler uses the cost and


788
00:23:58,316 --> 00:24:00,186
conformance to the expressible


789
00:24:00,186 --> 00:24:02,026
by string interpolation protocol


790
00:24:02,236 --> 00:24:03,876
to process this interpolation.


791
00:24:04,896 --> 00:24:06,496
Once it knows which conformance


792
00:24:06,496 --> 00:24:08,656
to use, the compiler translates


793
00:24:08,656 --> 00:24:10,606
this string interpolation with


794
00:24:10,606 --> 00:24:12,156
this autogenerated code.


795
00:24:13,306 --> 00:24:14,746
Let step three to understand


796
00:24:14,746 --> 00:24:15,276
what it does.


797
00:24:16,166 --> 00:24:18,546
First, Swift creates an instance


798
00:24:18,596 --> 00:24:21,296
for a builder specifically for


799
00:24:21,296 --> 00:24:23,076
the LocalizedStringKey.


800
00:24:23,566 --> 00:24:25,396
This instance will contain two


801
00:24:25,396 --> 00:24:27,876
things, formatKey and an


802
00:24:27,876 --> 00:24:29,276
argument array separately.


803
00:24:30,756 --> 00:24:33,216
Next we build up the string by


804
00:24:33,716 --> 00:24:35,566
processing the segments of the


805
00:24:35,566 --> 00:24:36,336
interpolation.


806
00:24:37,076 --> 00:24:38,666
First, we have a string literal


807
00:24:38,786 --> 00:24:40,036
and we add it to the formatKey.


808
00:24:41,296 --> 00:24:43,506
Second, on processing quantity,


809
00:24:43,646 --> 00:24:45,856
restore the format specifier in


810
00:24:45,856 --> 00:24:48,256
the formatKey and the value


811
00:24:48,256 --> 00:24:49,596
inside of the arguments array


812
00:24:49,636 --> 00:24:50,186
separately.


813
00:24:51,666 --> 00:24:53,356
Last, we add another literal to


814
00:24:53,356 --> 00:24:54,046
the formatKey.


815
00:24:55,346 --> 00:24:57,466
And finally, the initializer for


816
00:24:57,466 --> 00:24:58,626
the LocalizedStringKey is


817
00:24:58,626 --> 00:24:58,946
called.


818
00:24:58,946 --> 00:25:00,806
At this point you have enough


819
00:25:00,806 --> 00:25:02,826
information to properly localize


820
00:25:02,826 --> 00:25:03,306
the string.


821
00:25:05,356 --> 00:25:06,856
So, SwiftUI can use this


822
00:25:06,856 --> 00:25:08,326
language feature to localize the


823
00:25:08,386 --> 00:25:11,236
text, and the user can read the


824
00:25:11,236 --> 00:25:11,776
message.


825
00:25:12,076 --> 00:25:12,646
Pretty cool.


826
00:25:13,516 --> 00:25:19,036
[ Applause ]


827
00:25:19,536 --> 00:25:21,266
This example only scratches the


828
00:25:21,266 --> 00:25:22,796
surface of what you can do with


829
00:25:22,796 --> 00:25:23,886
string interpolation.


830
00:25:24,296 --> 00:25:26,196
And if you're as excited as us


831
00:25:26,196 --> 00:25:27,886
about this new feature, a good


832
00:25:27,916 --> 00:25:29,456
place to get started is reading


833
00:25:29,456 --> 00:25:30,646
documentation for the


834
00:25:30,646 --> 00:25:32,426
ExpressibleByStringInterpolation


835
00:25:32,426 --> 00:25:33,056
protocol.


836
00:25:35,166 --> 00:25:36,926
Now, let's talk about focus.


837
00:25:37,506 --> 00:25:39,896
Part of API design is deciding


838
00:25:39,896 --> 00:25:42,806
what to exclude from your API.


839
00:25:42,876 --> 00:25:44,766
And in Swift 5.1, we've


840
00:25:44,866 --> 00:25:46,256
specifically made improvements


841
00:25:46,256 --> 00:25:47,466
around returned types.


842
00:25:47,986 --> 00:25:50,146
While it's important that the


843
00:25:50,146 --> 00:25:51,636
returned type represents


844
00:25:51,636 --> 00:25:53,166
capabilities of the type that


845
00:25:53,166 --> 00:25:54,956
the user of your API should


846
00:25:54,956 --> 00:25:57,416
reason about, sometimes we want


847
00:25:57,416 --> 00:25:59,246
to abstract what we return.


848
00:26:00,246 --> 00:26:01,906
A function could return multiple


849
00:26:01,906 --> 00:26:05,066
times at runtime, or maybe it


850
00:26:05,066 --> 00:26:06,736
always returns the same type,


851
00:26:07,366 --> 00:26:08,716
but that type might leak


852
00:26:08,716 --> 00:26:11,296
implementation detail about your


853
00:26:11,296 --> 00:26:11,426
API,


854
00:26:12,456 --> 00:26:14,446
exposing something that the user


855
00:26:14,446 --> 00:26:15,806
of your API should not reason


856
00:26:15,806 --> 00:26:16,186
about.


857
00:26:17,026 --> 00:26:18,456
Let's take a look at the options


858
00:26:18,666 --> 00:26:20,326
that Swift provides for these


859
00:26:20,326 --> 00:26:20,766
cases.


860
00:26:22,226 --> 00:26:23,846
We'll use the simple shape API


861
00:26:24,176 --> 00:26:25,106
in our examples.


862
00:26:25,626 --> 00:26:27,116
Here as you'd expect we have a


863
00:26:27,116 --> 00:26:29,626
shape protocol and we have types


864
00:26:29,626 --> 00:26:31,696
that define basic shapes like


865
00:26:31,696 --> 00:26:34,616
circle, oval, and square.


866
00:26:35,736 --> 00:26:37,226
Further we have structs that


867
00:26:37,226 --> 00:26:40,136
manipulate shapes creating their


868
00:26:40,136 --> 00:26:42,256
union and transforming them.


869
00:26:42,916 --> 00:26:44,476
Consider this face shape


870
00:26:44,476 --> 00:26:45,076
example.


871
00:26:45,796 --> 00:26:47,906
Note that this API returns


872
00:26:47,946 --> 00:26:50,206
different types depending on the


873
00:26:50,296 --> 00:26:53,016
type of your shape-- face but


874
00:26:53,216 --> 00:26:55,166
all of them conform to the shape


875
00:26:55,166 --> 00:26:55,686
protocol.


876
00:26:55,996 --> 00:26:57,806
So it's a great place to use the


877
00:26:57,876 --> 00:26:59,246
protocol type as our returned


878
00:26:59,246 --> 00:26:59,466
type.


879
00:27:00,086 --> 00:27:02,726
Now, what about this example


880
00:27:02,916 --> 00:27:05,126
where we're constructing an


881
00:27:05,216 --> 00:27:07,696
eight-pointed star by creating a


882
00:27:07,696 --> 00:27:09,566
union of a square and the


883
00:27:09,566 --> 00:27:10,596
transformed square?


884
00:27:11,866 --> 00:27:13,476
Declaring the concrete return


885
00:27:13,476 --> 00:27:15,376
type here, will leak most of the


886
00:27:15,376 --> 00:27:16,696
implementation details to the


887
00:27:16,696 --> 00:27:19,726
client and expose-- exposing


888
00:27:19,726 --> 00:27:21,546
this unnecessary detail will


889
00:27:21,546 --> 00:27:23,706
make the API hard to reason


890
00:27:23,706 --> 00:27:24,106
about.


891
00:27:25,626 --> 00:27:27,406
However, using a protocol type


892
00:27:27,406 --> 00:27:29,216
shape here is also not so great.


893
00:27:29,606 --> 00:27:30,236
Let's see why.


894
00:27:31,706 --> 00:27:33,226
When the protocol type is


895
00:27:33,226 --> 00:27:34,856
returned, there is no guarantee


896
00:27:34,856 --> 00:27:36,516
that the same type will be


897
00:27:36,516 --> 00:27:38,046
returned from every call to the


898
00:27:38,046 --> 00:27:40,606
API, which, in addition to the


899
00:27:40,606 --> 00:27:42,486
Swift generic's model, brings us


900
00:27:42,486 --> 00:27:44,086
these fundamental limitations.


901
00:27:44,806 --> 00:27:46,906
If you have two values of


902
00:27:46,906 --> 00:27:49,046
eight-pointed star, return from


903
00:27:49,046 --> 00:27:51,336
the same API but two different


904
00:27:51,336 --> 00:27:53,526
calls to this API, they might


905
00:27:53,526 --> 00:27:54,976
not have the same type so you


906
00:27:54,976 --> 00:27:56,236
cannot compare them for


907
00:27:56,236 --> 00:27:56,766
equality.


908
00:27:57,636 --> 00:27:59,296
The returned type cannot have


909
00:27:59,296 --> 00:28:01,766
any associated types nor it can


910
00:28:01,766 --> 00:28:03,096
have requirements that involve


911
00:28:03,096 --> 00:28:03,486
self.


912
00:28:04,526 --> 00:28:06,606
Further, losing this type


913
00:28:06,606 --> 00:28:07,926
identity may prevent some


914
00:28:07,926 --> 00:28:08,976
compiler optimizations.


915
00:28:11,496 --> 00:28:14,216
Swift 5.1 introduces another


916
00:28:14,216 --> 00:28:16,666
concept called opaque results


917
00:28:16,716 --> 00:28:17,126
types.


918
00:28:17,706 --> 00:28:19,476
It's a great feat for APIs that


919
00:28:19,476 --> 00:28:21,476
are known to return the same


920
00:28:21,476 --> 00:28:24,406
concrete type, but might want to


921
00:28:24,406 --> 00:28:26,396
hide them, this type from their


922
00:28:26,396 --> 00:28:26,816
users.


923
00:28:27,876 --> 00:28:29,126
And opaque result type is


924
00:28:29,126 --> 00:28:31,576
spelled some shape and it


925
00:28:31,576 --> 00:28:33,736
conveys that a specific shape


926
00:28:33,736 --> 00:28:35,266
type is returned from this API.


927
00:28:36,936 --> 00:28:38,996
This guarantee of type identity


928
00:28:39,316 --> 00:28:40,536
also allows us to perform


929
00:28:40,536 --> 00:28:42,326
stronger type checking inside of


930
00:28:42,326 --> 00:28:43,586
the body of the API.


931
00:28:44,516 --> 00:28:46,296
So, if you have several return


932
00:28:46,296 --> 00:28:48,046
statements that return different


933
00:28:48,046 --> 00:28:50,946
types, the compiler will cache


934
00:28:51,256 --> 00:28:52,796
that and remind you to fix the


935
00:28:52,796 --> 00:28:53,246
problem.


936
00:28:54,606 --> 00:28:55,996
Opaque result types are


937
00:28:55,996 --> 00:28:58,476
available in Swift 5.1 and you


938
00:28:58,476 --> 00:28:59,846
can read more about them in our


939
00:28:59,846 --> 00:29:00,626
documentation.


940
00:29:01,806 --> 00:29:03,296
Note that this feature requires


941
00:29:03,296 --> 00:29:04,336
new Swift runtime.


942
00:29:05,086 --> 00:29:06,626
So it will only work on newer


943
00:29:06,626 --> 00:29:07,366
Swift OS.


944
00:29:08,356 --> 00:29:09,796
If you had caught that backward


945
00:29:09,796 --> 00:29:11,636
deploy, you can use this feature


946
00:29:11,636 --> 00:29:13,686
but you need to guard their uses


947
00:29:13,986 --> 00:29:15,656
with static availability checks.


948
00:29:17,816 --> 00:29:19,766
Now let's talk about code reuse,


949
00:29:19,866 --> 00:29:21,126
and the new feature called


950
00:29:21,216 --> 00:29:22,306
property wrappers.


951
00:29:23,636 --> 00:29:25,296
Custom patterns for accessing


952
00:29:25,296 --> 00:29:26,306
properties are common.


953
00:29:26,856 --> 00:29:28,816
Some of you-- Some of these


954
00:29:28,816 --> 00:29:30,246
patterns have first class


955
00:29:30,246 --> 00:29:32,426
language support, such as lazy,


956
00:29:32,866 --> 00:29:34,206
but you are also probably


957
00:29:34,206 --> 00:29:35,466
writing your own custom


958
00:29:35,466 --> 00:29:35,826
wrappers.


959
00:29:36,716 --> 00:29:39,066
Maybe you have some storage that


960
00:29:39,106 --> 00:29:41,406
access a thread local


961
00:29:41,406 --> 00:29:42,396
[inaudible].


962
00:29:42,396 --> 00:29:43,686
Maybe you have computed


963
00:29:43,686 --> 00:29:45,046
properties to store your user


964
00:29:45,046 --> 00:29:45,536
defaults.


965
00:29:46,956 --> 00:29:48,666
We write custom getters and


966
00:29:48,666 --> 00:29:50,476
setters all the time, but


967
00:29:50,476 --> 00:29:52,146
sometimes that code is repeated.


968
00:29:53,106 --> 00:29:54,636
For example here, I have two


969
00:29:54,636 --> 00:29:57,046
properties that specify my user


970
00:29:57,046 --> 00:29:57,506
default.


971
00:29:58,436 --> 00:29:59,696
But most of this code is just


972
00:29:59,696 --> 00:30:02,206
copy and pasted.


973
00:30:02,336 --> 00:30:03,856
With property wrappers, we can


974
00:30:03,856 --> 00:30:06,756
declare one type that specifies


975
00:30:06,756 --> 00:30:07,896
the access pattern.


976
00:30:09,446 --> 00:30:10,816
Let's call it user default.


977
00:30:12,186 --> 00:30:13,846
Further, we tell the compiler


978
00:30:13,846 --> 00:30:15,416
that this type is special.


979
00:30:16,256 --> 00:30:18,246
Its primary purpose is to wrap a


980
00:30:18,246 --> 00:30:20,776
property, specify its access


981
00:30:20,826 --> 00:30:21,236
pattern.


982
00:30:22,486 --> 00:30:24,646
What that gives us is this type


983
00:30:24,646 --> 00:30:26,056
will allow us to use a custom


984
00:30:26,106 --> 00:30:28,796
attribute to declare properties


985
00:30:28,796 --> 00:30:30,786
that use-- user default access


986
00:30:30,786 --> 00:30:31,126
pattern.


987
00:30:32,486 --> 00:30:33,556
Let's take a closer look.


988
00:30:33,806 --> 00:30:35,326
With the property wrappers in


989
00:30:35,326 --> 00:30:38,746
place, we can rewrite that two


990
00:30:38,746 --> 00:30:40,116
user default properties from


991
00:30:40,116 --> 00:30:41,096
before was this code.


992
00:30:41,216 --> 00:30:43,626
There is no repetition here.


993
00:30:43,626 --> 00:30:44,886
It's very clean.


994
00:30:45,386 --> 00:30:47,196
All I needed to do is add the


995
00:30:47,196 --> 00:30:50,546
custom attributes, and also know


996
00:30:50,546 --> 00:30:52,236
that these properties still are


997
00:30:52,236 --> 00:30:53,436
declared a type Bool.


998
00:30:53,716 --> 00:30:55,296
So you can use them as if they


999
00:30:55,296 --> 00:30:56,826
were simple Boolean values.


1000
00:30:58,516 --> 00:31:04,276
[ Applause ]


1001
00:31:04,776 --> 00:31:06,236
Property wrappers allow us to


1002
00:31:06,236 --> 00:31:08,096
define custom access patterns


1003
00:31:08,486 --> 00:31:09,856
and a property can opt into


1004
00:31:09,856 --> 00:31:11,776
using them by just adding a


1005
00:31:11,776 --> 00:31:13,086
custom attributes to its


1006
00:31:13,086 --> 00:31:13,726
declaration.


1007
00:31:16,136 --> 00:31:18,046
We reach for specific tools to


1008
00:31:18,046 --> 00:31:19,396
solve specific problems.


1009
00:31:19,926 --> 00:31:21,796
They each are useful in their


1010
00:31:21,796 --> 00:31:22,486
own domains.


1011
00:31:23,526 --> 00:31:25,776
Similarly, DSLs play an


1012
00:31:25,776 --> 00:31:26,956
important role in programmer's


1013
00:31:26,956 --> 00:31:27,256
lives.


1014
00:31:27,936 --> 00:31:29,536
We use them to query databases


1015
00:31:30,006 --> 00:31:31,646
and build graphs.


1016
00:31:31,646 --> 00:31:33,256
We love the declarative style


1017
00:31:33,546 --> 00:31:35,116
that allows us to simply and


1018
00:31:35,116 --> 00:31:38,166
concisely declare our layout for


1019
00:31:38,166 --> 00:31:39,126
our web pages.


1020
00:31:40,016 --> 00:31:41,686
However, they are also


1021
00:31:41,686 --> 00:31:42,146
different.


1022
00:31:43,176 --> 00:31:44,626
Every time we use one as a


1023
00:31:44,626 --> 00:31:46,806
contact Switch, each language


1024
00:31:46,806 --> 00:31:48,276
comes with its own syntax and


1025
00:31:48,426 --> 00:31:48,966
semantics.


1026
00:31:50,166 --> 00:31:51,546
They each have unique powerful


1027
00:31:51,546 --> 00:31:52,746
tools that support them.


1028
00:31:53,456 --> 00:31:55,576
It's very easy if an HTML tag is


1029
00:31:55,576 --> 00:31:57,496
missing, if you're inside of an


1030
00:31:57,496 --> 00:31:58,806
HTML editor.


1031
00:31:59,916 --> 00:32:01,426
However, because syntax and


1032
00:32:01,456 --> 00:32:03,436
semantics are tuned to specific


1033
00:32:03,506 --> 00:32:05,986
purposes, the tools that support


1034
00:32:05,986 --> 00:32:07,386
them are also often domain


1035
00:32:07,386 --> 00:32:08,036
specific.


1036
00:32:09,196 --> 00:32:10,946
So when we need to integrate


1037
00:32:10,946 --> 00:32:12,636
these DSLs into our projects,


1038
00:32:13,496 --> 00:32:14,776
the options are not so great.


1039
00:32:16,066 --> 00:32:17,586
In some cases, we add custom


1040
00:32:17,586 --> 00:32:20,336
build phases but often we reach


1041
00:32:20,336 --> 00:32:21,336
out to this solution.


1042
00:32:22,456 --> 00:32:23,826
I'm sure it looks familiar.


1043
00:32:23,826 --> 00:32:25,296
It's a string literal that


1044
00:32:25,296 --> 00:32:26,376
represents HTML.


1045
00:32:27,666 --> 00:32:28,946
We gained integration but we


1046
00:32:28,946 --> 00:32:29,936
lost tool support.


1047
00:32:30,566 --> 00:32:32,726
The compiler code completion see


1048
00:32:32,726 --> 00:32:33,606
this as a string.


1049
00:32:34,476 --> 00:32:35,866
There is no type checking here.


1050
00:32:36,186 --> 00:32:37,776
It's a blob of text to the Swift


1051
00:32:37,776 --> 00:32:38,176
compiler.


1052
00:32:39,046 --> 00:32:40,526
So silly mistakes like


1053
00:32:40,526 --> 00:32:42,836
forgetting a closing tag go


1054
00:32:42,836 --> 00:32:44,286
unnoticed until runtime.


1055
00:32:45,306 --> 00:32:47,316
We want the power of these DSLs


1056
00:32:47,736 --> 00:32:49,146
but we also want them to


1057
00:32:49,276 --> 00:32:50,926
integrate well in our language


1058
00:32:51,026 --> 00:32:51,526
and tools.


1059
00:32:53,316 --> 00:32:55,466
In Swift 5.1, we are bringing


1060
00:32:55,466 --> 00:32:57,626
the power to define embedded


1061
00:32:57,626 --> 00:32:58,766
DSLs into Swift.


1062
00:32:59,516 --> 00:33:06,516
[ Applause ]


1063
00:33:07,016 --> 00:33:08,256
Let's take a look at this code


1064
00:33:08,256 --> 00:33:10,116
that defines an HTML object.


1065
00:33:10,656 --> 00:33:12,476
One of my colleagues prototype


1066
00:33:12,476 --> 00:33:15,636
support for the HTML DSL, just


1067
00:33:15,636 --> 00:33:17,906
for fun, in a few hours, using


1068
00:33:17,906 --> 00:33:19,236
this new Swift feature.


1069
00:33:20,056 --> 00:33:21,706
As you can see here, this code


1070
00:33:21,706 --> 00:33:23,796
looks like Swift, but your eyes


1071
00:33:23,796 --> 00:33:25,496
are drawn to the HTML elements


1072
00:33:25,496 --> 00:33:26,276
is defining.


1073
00:33:26,536 --> 00:33:29,886
Here you can see the familiar


1074
00:33:29,886 --> 00:33:32,186
Swift concepts like closures and


1075
00:33:32,186 --> 00:33:32,646
method calls.


1076
00:33:33,076 --> 00:33:34,596
We are using the variables from


1077
00:33:34,596 --> 00:33:35,956
our Swift program.


1078
00:33:36,756 --> 00:33:38,496
The tools will ensure there are


1079
00:33:38,496 --> 00:33:40,366
no unbalanced text and provide


1080
00:33:40,366 --> 00:33:41,536
syntax highlights and


1081
00:33:41,536 --> 00:33:42,816
refactoring actions.


1082
00:33:43,946 --> 00:33:45,666
Our vision is that not only


1083
00:33:45,666 --> 00:33:47,126
you'll be able to declare a list


1084
00:33:47,126 --> 00:33:49,366
of elements, but you could use


1085
00:33:49,426 --> 00:33:51,506
Swift control statements like


1086
00:33:51,506 --> 00:33:54,116
this, right here in this DSL.


1087
00:33:56,306 --> 00:33:56,456
OK.


1088
00:33:58,516 --> 00:34:02,316
[ Applause ]


1089
00:34:02,816 --> 00:34:04,386
Let's take a look at how this is


1090
00:34:04,386 --> 00:34:05,706
implemented under the hood.


1091
00:34:06,256 --> 00:34:07,926
The DSL implementer added a


1092
00:34:07,986 --> 00:34:10,116
function to construct each HTML


1093
00:34:10,206 --> 00:34:10,565
element.


1094
00:34:11,545 --> 00:34:12,676
These functions, they're


1095
00:34:12,676 --> 00:34:13,356
closures.


1096
00:34:14,216 --> 00:34:16,626
And the interesting part here is


1097
00:34:16,626 --> 00:34:18,216
that these closures are special.


1098
00:34:18,815 --> 00:34:20,106
They all have this custom


1099
00:34:20,106 --> 00:34:22,806
attribute, @HTMLBuilder, that


1100
00:34:22,806 --> 00:34:24,656
tells the compiler to use the


1101
00:34:24,656 --> 00:34:27,025
HTML builder type to process


1102
00:34:27,096 --> 00:34:27,896
these closures.


1103
00:34:29,576 --> 00:34:30,826
Let's see how disclosure


1104
00:34:30,826 --> 00:34:32,706
containing DSL code gets


1105
00:34:32,706 --> 00:34:34,246
translated into a normal Swift


1106
00:34:34,286 --> 00:34:34,716
closure.


1107
00:34:36,056 --> 00:34:37,896
What is this DSL closure doing?


1108
00:34:38,386 --> 00:34:40,016
Well, it's producing a batch of


1109
00:34:40,016 --> 00:34:40,446
values.


1110
00:34:41,386 --> 00:34:42,806
However, those values are not


1111
00:34:42,806 --> 00:34:43,976
used and there is no return


1112
00:34:43,976 --> 00:34:45,716
statement here either.


1113
00:34:46,456 --> 00:34:48,126
To make this work, the compiler


1114
00:34:48,126 --> 00:34:51,286
translates this code by first


1115
00:34:51,896 --> 00:34:53,646
collecting the unused values,


1116
00:34:54,266 --> 00:34:57,196
and second, calling into the


1117
00:34:57,196 --> 00:34:59,036
builder functions to combine


1118
00:34:59,036 --> 00:34:59,226
them.


1119
00:35:00,686 --> 00:35:02,196
These functions are provided by


1120
00:35:02,196 --> 00:35:05,046
the HTML builder type that you,


1121
00:35:05,046 --> 00:35:08,076
the DSL author, write and it can


1122
00:35:08,146 --> 00:35:10,396
construct any object that is


1123
00:35:10,396 --> 00:35:11,576
suitable for your DSL.


1124
00:35:12,236 --> 00:35:14,196
Here we are building HTML, so it


1125
00:35:14,196 --> 00:35:15,676
builds HTML objects.


1126
00:35:17,976 --> 00:35:19,756
We are very excited about this


1127
00:35:19,756 --> 00:35:21,336
feature and we use it to power


1128
00:35:21,566 --> 00:35:23,796
the declarative syntax that you


1129
00:35:23,796 --> 00:35:25,606
will use with the new SwiftUI


1130
00:35:25,836 --> 00:35:26,286
framework.


1131
00:35:27,516 --> 00:35:33,266
[ Applause ]


1132
00:35:33,766 --> 00:35:35,366
Here is an example of that


1133
00:35:35,366 --> 00:35:37,616
[inaudible] in SwiftUI using its


1134
00:35:37,616 --> 00:35:39,896
own custom Swift DSL.


1135
00:35:41,196 --> 00:35:42,706
This feature is available in


1136
00:35:42,706 --> 00:35:44,596
beta 1, and we'd like to see how


1137
00:35:44,596 --> 00:35:46,146
it will benefit you and what


1138
00:35:46,146 --> 00:35:47,846
cool DSLs you'll build with it.


1139
00:35:48,886 --> 00:35:50,226
We are discussing the details


1140
00:35:50,226 --> 00:35:51,596
behind this feature on the Swift


1141
00:35:51,596 --> 00:35:52,526
forums right now.


1142
00:35:53,336 --> 00:35:54,356
So if you're interested in


1143
00:35:54,356 --> 00:35:55,776
shaping the future of this


1144
00:35:55,776 --> 00:35:57,416
feature or other Swift features,


1145
00:35:57,886 --> 00:35:59,306
we welcome you to participate.


1146
00:36:01,596 --> 00:36:03,216
To conclude, many of the


1147
00:36:03,216 --> 00:36:05,106
improvements I talked about come


1148
00:36:05,106 --> 00:36:06,996
together in the new Swift


1149
00:36:06,996 --> 00:36:08,136
frameworks we are shipping this


1150
00:36:08,136 --> 00:36:08,436
year.


1151
00:36:09,276 --> 00:36:11,186
And we are excited to see how


1152
00:36:11,186 --> 00:36:13,286
they will benefit you, to make


1153
00:36:13,286 --> 00:36:15,276
your APIs expressive, clear and


1154
00:36:15,276 --> 00:36:15,946
easy to use.


1155
00:36:16,776 --> 00:36:18,626
Our colleagues will give a talk


1156
00:36:18,626 --> 00:36:20,906
on modern Swift API design where


1157
00:36:20,906 --> 00:36:22,466
they will share with you some of


1158
00:36:22,466 --> 00:36:24,206
the lessons learned when using


1159
00:36:24,206 --> 00:36:26,076
these features building Apple


1160
00:36:26,076 --> 00:36:26,646
frameworks.


1161
00:36:27,446 --> 00:36:29,356
But this is it from us, enjoy


1162
00:36:29,356 --> 00:36:30,016
the conference.


1163
00:36:30,316 --> 00:36:30,816
Thank you.


1164
00:36:31,516 --> 00:36:36,500
[ Applause ]

