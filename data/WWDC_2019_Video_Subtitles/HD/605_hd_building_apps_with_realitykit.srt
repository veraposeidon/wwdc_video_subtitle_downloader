1
00:00:00,506 --> 00:00:04,500
[ Music ]


2
00:00:09,016 --> 00:00:10,236
[ Applause ]


3
00:00:10,236 --> 00:00:13,766
>> Hello everyone.


4
00:00:13,766 --> 00:00:14,886
I'm Ross. I'm an engineer on the


5
00:00:14,886 --> 00:00:16,666
RealityKit team at Apple and


6
00:00:16,666 --> 00:00:18,106
welcome to Building Apps with


7
00:00:18,106 --> 00:00:18,686
RealityKit.


8
00:00:19,766 --> 00:00:22,316
So this session is intended as a


9
00:00:22,316 --> 00:00:23,076
follow up.


10
00:00:23,076 --> 00:00:24,786
So you might want to check out


11
00:00:24,786 --> 00:00:26,506
Intro to RealityKit and Reality


12
00:00:26,506 --> 00:00:27,206
Composer Session.


13
00:00:27,686 --> 00:00:28,596
Today we're going into the


14
00:00:28,596 --> 00:00:30,216
applied usage of RealityKit.


15
00:00:30,216 --> 00:00:31,136
And we'll walk you through


16
00:00:31,136 --> 00:00:32,226
building an augmented reality


17
00:00:32,226 --> 00:00:33,686
app and how you can leverage


18
00:00:33,686 --> 00:00:34,646
many of the frameworks key


19
00:00:34,646 --> 00:00:35,156
features.


20
00:00:35,706 --> 00:00:36,856
Before we dive in let's do a


21
00:00:36,856 --> 00:00:38,186
quick recap of what RealityKit


22
00:00:38,186 --> 00:00:38,386
is.


23
00:00:39,056 --> 00:00:40,916
So RealityKit is Apple's new


24
00:00:40,916 --> 00:00:43,986
framework for building AR Apps.


25
00:00:44,076 --> 00:00:46,296
Trying to make it as simple and


26
00:00:46,296 --> 00:00:47,596
intuitive as possible for any


27
00:00:47,596 --> 00:00:48,066
developer.


28
00:00:48,726 --> 00:00:49,566
It's been built from the ground


29
00:00:49,566 --> 00:00:50,636
up to work with AR.


30
00:00:50,636 --> 00:00:52,096
And it allows you to seamlessly


31
00:00:52,096 --> 00:00:53,466
blend rendered content with a


32
00:00:53,466 --> 00:00:54,436
real world environment.


33
00:00:54,436 --> 00:00:57,126
Its Swift API is simple yet


34
00:00:57,126 --> 00:00:58,536
powerful and lets you do a lot


35
00:00:58,536 --> 00:00:59,716
with only a few lines of code.


36
00:01:00,586 --> 00:01:01,696
All right, let's build an app.


37
00:01:02,956 --> 00:01:03,826
The app we're going to be


38
00:01:03,826 --> 00:01:05,066
building today is called "Memory


39
00:01:05,066 --> 00:01:05,556
Cards."


40
00:01:05,816 --> 00:01:06,766
And as the name cleverly


41
00:01:06,766 --> 00:01:08,256
implies, it's a card matching


42
00:01:08,256 --> 00:01:08,476
game.


43
00:01:09,736 --> 00:01:10,806
To play you tap on a card to


44
00:01:10,806 --> 00:01:12,086
select it and its image is


45
00:01:12,086 --> 00:01:12,476
revealed.


46
00:01:12,986 --> 00:01:14,946
Select another card to reveal it


47
00:01:14,946 --> 00:01:16,276
and if the pair is a match the


48
00:01:16,276 --> 00:01:17,006
cards are removed.


49
00:01:17,726 --> 00:01:19,106
If they don't match both cards


50
00:01:19,106 --> 00:01:20,506
are hidden and you're free to


51
00:01:20,506 --> 00:01:21,226
select another pair.


52
00:01:21,926 --> 00:01:23,636
This simple game will allow us


53
00:01:23,636 --> 00:01:24,726
to highlight and discuss a lot of


54
00:01:24,726 --> 00:01:26,016
useful RealityKit features.


55
00:01:26,016 --> 00:01:28,186
So we're going to build Memory


56
00:01:28,186 --> 00:01:29,306
Cards in four stages.


57
00:01:30,156 --> 00:01:30,876
First we're going to put


58
00:01:30,876 --> 00:01:33,226
together a prototype that will


59
00:01:33,226 --> 00:01:34,796
place our content in AR and


60
00:01:34,796 --> 00:01:35,556
allow for some simple


61
00:01:35,556 --> 00:01:35,976
interaction.


62
00:01:37,596 --> 00:01:38,896
Next we'll add some polish with


63
00:01:38,896 --> 00:01:40,306
some fancy art assets, improve


64
00:01:40,306 --> 00:01:41,476
performance and AR rendering


65
00:01:41,476 --> 00:01:41,916
tricks.


66
00:01:43,176 --> 00:01:44,326
Then we'll leverage the entity


67
00:01:44,326 --> 00:01:46,406
component system to track custom


68
00:01:46,406 --> 00:01:47,186
state information.


69
00:01:48,596 --> 00:01:49,706
And finally we'll show you how


70
00:01:49,706 --> 00:01:50,706
to use RealityKit's built in


71
00:01:50,706 --> 00:01:51,736
network support by adding


72
00:01:51,736 --> 00:01:53,576
multiplayer to our game.


73
00:01:55,396 --> 00:01:55,976
All right.


74
00:01:56,166 --> 00:01:56,966
Let's get started with our


75
00:01:56,966 --> 00:01:57,226
prototype.


76
00:01:57,886 --> 00:01:59,856
So as mentioned in the intro


77
00:01:59,856 --> 00:02:01,346
session there are four objects


78
00:02:01,346 --> 00:02:02,906
that you'll need to use in every


79
00:02:02,996 --> 00:02:07,446
RealityKit app -- an ARView, the


80
00:02:07,446 --> 00:02:11,636
Scene, Anchors, and Entities.


81
00:02:12,206 --> 00:02:15,056
ARView is your window into the


82
00:02:15,056 --> 00:02:15,736
world of AR.


83
00:02:16,146 --> 00:02:17,346
And in your entry point for


84
00:02:17,346 --> 00:02:17,946
RealityKit.


85
00:02:18,606 --> 00:02:19,896
It's a view and it goes into


86
00:02:19,896 --> 00:02:21,136
your apps View hierarchy.


87
00:02:21,696 --> 00:02:24,106
The scene holds up with a


88
00:02:24,106 --> 00:02:25,086
virtual content that makes up


89
00:02:25,086 --> 00:02:26,816
your app and is owned by ARView.


90
00:02:29,506 --> 00:02:31,146
In RealityKit, Anchors describe


91
00:02:31,146 --> 00:02:32,486
how objects relate to the real


92
00:02:32,486 --> 00:02:32,846
world.


93
00:02:33,156 --> 00:02:34,116
And you'll need them to be able


94
00:02:34,316 --> 00:02:35,716
to place your virtual content.


95
00:02:36,326 --> 00:02:37,766
To place an anchor you add it to


96
00:02:37,766 --> 00:02:39,076
the scene and when the


97
00:02:39,076 --> 00:02:40,406
appropriate target is found the


98
00:02:40,406 --> 00:02:41,986
anchor is automatically placed


99
00:02:42,056 --> 00:02:42,546
in the world.


100
00:02:43,436 --> 00:02:44,636
For Memory Cards we'll use an


101
00:02:44,636 --> 00:02:45,656
anchor to place our game board


102
00:02:45,656 --> 00:02:46,886
on a horizontal surface.


103
00:02:47,836 --> 00:02:49,606
And entities are used to


104
00:02:49,606 --> 00:02:50,916
represent your virtual content


105
00:02:51,136 --> 00:02:52,096
and are the building blocks that


106
00:02:52,096 --> 00:02:52,676
make up your scene.


107
00:02:53,196 --> 00:02:54,876
In Memory Cards each of the


108
00:02:54,876 --> 00:02:56,196
cards will be represented by an


109
00:02:56,196 --> 00:02:56,586
entity.


110
00:02:57,186 --> 00:02:58,716
Since your game has 16 cards


111
00:02:58,716 --> 00:03:00,206
we'll need 16 entities.


112
00:03:01,656 --> 00:03:02,996
So now that we've covered the


113
00:03:02,996 --> 00:03:03,926
important elements that we'll


114
00:03:03,926 --> 00:03:05,656
need in our app let's talk about


115
00:03:05,656 --> 00:03:07,216
how we'll create our anchor so


116
00:03:07,216 --> 00:03:08,846
we can place our virtual game


117
00:03:08,846 --> 00:03:11,126
board in the real world.


118
00:03:12,216 --> 00:03:13,266
RealityKit anchoring is built on


119
00:03:13,266 --> 00:03:14,466
top of and integrated with


120
00:03:14,496 --> 00:03:14,976
ARkit.


121
00:03:14,976 --> 00:03:16,696
But then you leverage it's full


122
00:03:16,696 --> 00:03:17,246
feature set.


123
00:03:18,516 --> 00:03:20,366
To define Anchor content you


124
00:03:20,366 --> 00:03:21,446
create an anchor entity.


125
00:03:22,146 --> 00:03:23,416
To clear the type of anchoring


126
00:03:23,416 --> 00:03:25,616
you'd like to use and then add


127
00:03:25,616 --> 00:03:27,076
the anchor entity to your scene.


128
00:03:27,556 --> 00:03:30,236
Once the appropriate target is


129
00:03:30,236 --> 00:03:32,256
detected by ARkit, the anchor


130
00:03:32,256 --> 00:03:33,426
entity will automatically track


131
00:03:33,426 --> 00:03:34,986
it and making your virtual


132
00:03:34,986 --> 00:03:35,956
content feel like it's been


133
00:03:35,956 --> 00:03:37,266
placed in the real world as your


134
00:03:37,266 --> 00:03:38,586
device moves.


135
00:03:40,266 --> 00:03:41,276
Also as mentioned in the intro


136
00:03:41,276 --> 00:03:43,016
session, RealityKit supports all


137
00:03:43,016 --> 00:03:44,026
of the anchor types available


138
00:03:44,026 --> 00:03:45,206
with ARkit, allowing me to


139
00:03:45,206 --> 00:03:46,516
anchor things like planes,


140
00:03:46,856 --> 00:03:49,696
faces, images, objects, and new


141
00:03:49,696 --> 00:03:51,836
for ARkit 3, body anchors.


142
00:03:53,376 --> 00:03:54,816
For Memory Cards we just need a


143
00:03:54,816 --> 00:03:56,276
single anchor to place our game


144
00:03:56,276 --> 00:03:56,516
board.


145
00:03:57,686 --> 00:03:58,706
We like to place it on a


146
00:03:58,706 --> 00:04:00,006
horizontal surface with enough


147
00:04:00,006 --> 00:04:01,236
space to fit all the cards,


148
00:04:01,236 --> 00:04:03,286
about 20 centimeters squared.


149
00:04:04,346 --> 00:04:05,416
And that anchor will represent


150
00:04:05,416 --> 00:04:07,176
our game board in the world and


151
00:04:07,176 --> 00:04:08,506
we'll place our content around


152
00:04:08,506 --> 00:04:08,626
it.


153
00:04:09,416 --> 00:04:10,186
Let's write some code to do


154
00:04:10,186 --> 00:04:10,526
this.


155
00:04:11,706 --> 00:04:12,386
So here we have the view


156
00:04:12,386 --> 00:04:13,586
controller for our Memory Cards


157
00:04:13,586 --> 00:04:14,076
prototype.


158
00:04:14,586 --> 00:04:15,996
We have an ARView in place in


159
00:04:15,996 --> 00:04:17,426
the View hierarchy and we're


160
00:04:17,426 --> 00:04:18,706
ready to find our anchor and


161
00:04:18,706 --> 00:04:19,946
create out virtual content,


162
00:04:20,636 --> 00:04:22,156
which we'll be doing in the


163
00:04:22,156 --> 00:04:23,606
viewDidLoad method.


164
00:04:25,366 --> 00:04:26,946
To define our anchor we create


165
00:04:26,946 --> 00:04:28,856
an anchor entity and using this


166
00:04:28,856 --> 00:04:30,266
convenience initializer we can


167
00:04:30,266 --> 00:04:31,856
specify the type of plane we'd


168
00:04:31,856 --> 00:04:32,526
like it to anchor to.


169
00:04:32,526 --> 00:04:33,946
In this case the horizontal


170
00:04:33,946 --> 00:04:34,216
plane.


171
00:04:35,336 --> 00:04:36,546
And we can optionally pass in


172
00:04:36,546 --> 00:04:38,476
the minimum area we require, 20


173
00:04:38,476 --> 00:04:39,326
centimeters squared.


174
00:04:40,246 --> 00:04:41,496
RealityKit's units are in meters


175
00:04:41,786 --> 00:04:44,166
so I get 20 centimeters by 20


176
00:04:44,166 --> 00:04:46,316
centimeters, we pass in 0.2 by


177
00:04:46,316 --> 00:04:47,626
0.2.


178
00:04:48,086 --> 00:04:48,936
Then we just add our anchor to


179
00:04:48,936 --> 00:04:50,316
the scene and as soon as


180
00:04:50,316 --> 00:04:51,566
RealityKit finds a horizontal


181
00:04:51,566 --> 00:04:52,786
plane of at least 20 centimeters


182
00:04:52,786 --> 00:04:54,656
squared, any virtual content we


183
00:04:54,656 --> 00:04:55,756
attach to this anchor will


184
00:04:55,756 --> 00:04:56,306
appear in AR.


185
00:04:56,946 --> 00:04:59,356
Now that we have our anchor set


186
00:04:59,356 --> 00:05:00,236
up let's add some virtual


187
00:05:00,236 --> 00:05:00,686
content.


188
00:05:01,346 --> 00:05:02,246
First we need to load in the


189
00:05:02,246 --> 00:05:02,576
model.


190
00:05:03,326 --> 00:05:04,586
RealityKit natively supports


191
00:05:04,586 --> 00:05:06,386
assets in USDZ in the new


192
00:05:06,516 --> 00:05:07,696
Reality File formats.


193
00:05:08,766 --> 00:05:09,326
Loading can be done


194
00:05:09,326 --> 00:05:10,866
synchronously or asynchronously.


195
00:05:11,036 --> 00:05:11,856
For now we'll start with


196
00:05:11,856 --> 00:05:13,176
synchronous loading but we'll


197
00:05:13,176 --> 00:05:16,456
touch more on this later.


198
00:05:16,456 --> 00:05:18,236
When you load a USDZ or reality


199
00:05:18,236 --> 00:05:19,586
file asset, RealityKit


200
00:05:19,586 --> 00:05:20,956
automatically imports its entity


201
00:05:20,956 --> 00:05:23,126
hierarchy, and meshes used by


202
00:05:23,126 --> 00:05:25,806
the asset, its materials, and


203
00:05:25,806 --> 00:05:27,536
any animations it may have as


204
00:05:27,536 --> 00:05:27,726
well.


205
00:05:29,886 --> 00:05:30,796
Let's load in our basic card


206
00:05:30,796 --> 00:05:31,396
assets.


207
00:05:31,966 --> 00:05:34,396
To load a model you just need to


208
00:05:34,396 --> 00:05:36,026
go entities load model method


209
00:05:36,216 --> 00:05:37,196
with the name of the asset.


210
00:05:37,866 --> 00:05:38,816
There's not need to specify the


211
00:05:38,816 --> 00:05:40,466
file extension if the asset is


212
00:05:40,466 --> 00:05:41,146
in your app bundle.


213
00:05:42,426 --> 00:05:43,556
If RealityKit is able to load


214
00:05:43,556 --> 00:05:44,766
the asset, it will automatically


215
00:05:44,766 --> 00:05:46,066
create a ready to use entity for


216
00:05:46,066 --> 00:05:47,326
you to use however you want.


217
00:05:47,986 --> 00:05:49,146
Here we're loading on the eight


218
00:05:49,146 --> 00:05:50,666
base card models and storing


219
00:05:50,666 --> 00:05:51,316
them in an array.


220
00:05:51,926 --> 00:05:54,736
So Memory Card has 16 total


221
00:05:54,736 --> 00:05:55,376
cards.


222
00:05:56,366 --> 00:05:57,876
There are eight card types, each


223
00:05:57,876 --> 00:05:58,586
with a different image.


224
00:05:58,916 --> 00:06:00,666
And then there are two instances


225
00:06:00,666 --> 00:06:02,476
of each type to create our eight


226
00:06:02,606 --> 00:06:03,536
matching pairs.


227
00:06:04,436 --> 00:06:05,496
So we've got our eight type


228
00:06:05,526 --> 00:06:06,796
models loaded, but how do we get


229
00:06:06,796 --> 00:06:07,346
the other eight?


230
00:06:08,496 --> 00:06:10,466
Now we could call entities load


231
00:06:10,466 --> 00:06:12,196
model method again, but any


232
00:06:12,196 --> 00:06:13,476
setup we perform on our cards


233
00:06:13,476 --> 00:06:14,846
will need to be done for each of


234
00:06:14,846 --> 00:06:15,306
these as well.


235
00:06:16,746 --> 00:06:17,826
RealityKit provides and easier


236
00:06:17,826 --> 00:06:19,616
solution with entity cloning.


237
00:06:20,206 --> 00:06:22,646
To create a clone you call


238
00:06:22,646 --> 00:06:23,616
entities clone method.


239
00:06:24,966 --> 00:06:26,146
And cloning creates an identical


240
00:06:26,146 --> 00:06:27,646
copy of the original entity.


241
00:06:28,996 --> 00:06:29,976
It references all the same


242
00:06:29,976 --> 00:06:32,576
assets used by the original, and


243
00:06:32,576 --> 00:06:33,486
cloning can also be done


244
00:06:33,626 --> 00:06:35,236
recursively, which will clone


245
00:06:35,236 --> 00:06:36,176
all of entities children as


246
00:06:36,176 --> 00:06:37,996
well, which really comes in


247
00:06:37,996 --> 00:06:39,076
handy when you're composing


248
00:06:39,136 --> 00:06:40,686
complex scenes with deep


249
00:06:40,686 --> 00:06:41,366
hierarchies.


250
00:06:41,996 --> 00:06:44,146
It's also important to note that


251
00:06:44,146 --> 00:06:45,876
clone entities are copies of the


252
00:06:45,876 --> 00:06:48,386
originals, not instances.


253
00:06:48,386 --> 00:06:49,906
So if you make a change to the


254
00:06:49,906 --> 00:06:51,246
original entity, say by removing


255
00:06:51,246 --> 00:06:53,106
a child, that change will not be


256
00:06:53,106 --> 00:06:54,226
reflective in any of its all


257
00:06:54,226 --> 00:06:55,366
ready existing clones.


258
00:06:56,466 --> 00:06:57,866
Let's use cloning to create our


259
00:06:57,866 --> 00:06:58,506
card pairs.


260
00:06:59,086 --> 00:07:01,836
So here we're cloning the two


261
00:07:01,836 --> 00:07:03,236
instances of each card type we


262
00:07:03,236 --> 00:07:04,676
need and storing them in a


263
00:07:04,676 --> 00:07:06,266
separate array, which we'll use


264
00:07:06,266 --> 00:07:07,096
to build our game board.


265
00:07:08,406 --> 00:07:09,696
We could use the original card


266
00:07:09,696 --> 00:07:10,626
templates and then just clone


267
00:07:10,626 --> 00:07:12,206
one new instance, but by keeping


268
00:07:12,206 --> 00:07:13,286
the card template separate we


269
00:07:13,286 --> 00:07:14,456
can easily refer back to them to


270
00:07:14,456 --> 00:07:15,616
recreate the game board later


271
00:07:15,856 --> 00:07:16,746
without having to load them all


272
00:07:16,746 --> 00:07:17,796
again from scratch.


273
00:07:19,916 --> 00:07:21,426
Now that you have all 16 cards


274
00:07:21,426 --> 00:07:22,806
ready to go we need to place


275
00:07:22,806 --> 00:07:23,596
them in our game board.


276
00:07:24,336 --> 00:07:25,396
The anchor will be at the center


277
00:07:25,396 --> 00:07:26,576
of the play area and we'll


278
00:07:26,576 --> 00:07:27,706
arrange the cards in a


279
00:07:27,826 --> 00:07:30,266
four-by-four grid around them.


280
00:07:30,706 --> 00:07:31,916
Then all we need to do is add


281
00:07:31,916 --> 00:07:33,056
each card to the anchor and


282
00:07:33,056 --> 00:07:34,386
they'll be displayed in our ARC.


283
00:07:35,026 --> 00:07:38,036
So to do this we calculate the


284
00:07:38,036 --> 00:07:39,426
position of each card using its


285
00:07:39,426 --> 00:07:41,286
index and the array and then set


286
00:07:41,286 --> 00:07:42,496
it on it's position property.


287
00:07:43,226 --> 00:07:45,336
This will position it relative


288
00:07:45,336 --> 00:07:47,066
to its parent, the anchor, when


289
00:07:47,096 --> 00:07:48,156
we add each card to it.


290
00:07:48,816 --> 00:07:51,376
And that's all we need to do to


291
00:07:51,376 --> 00:07:52,906
get our cards laid out and


292
00:07:52,956 --> 00:07:54,066
rendering in AR.


293
00:07:54,736 --> 00:07:56,366
So we got our cards placing in a


294
00:07:56,366 --> 00:07:58,006
surface in AR, but we can't do


295
00:07:58,006 --> 00:07:59,186
anything with them yet, so let's


296
00:07:59,186 --> 00:07:59,976
add some interaction.


297
00:08:00,656 --> 00:08:02,946
We want the cards to flip when


298
00:08:02,946 --> 00:08:03,636
we tap on them.


299
00:08:03,706 --> 00:08:05,106
But to be able to do that we


300
00:08:05,106 --> 00:08:06,466
need to translate that tap on


301
00:08:06,466 --> 00:08:08,126
our devices screen into the


302
00:08:08,126 --> 00:08:09,836
world of AR so we can figure out


303
00:08:09,876 --> 00:08:11,486
what we're actually tapping on.


304
00:08:12,316 --> 00:08:13,156
And RealityKit provides a


305
00:08:13,156 --> 00:08:14,606
solution to this with hit


306
00:08:14,606 --> 00:08:14,966
testing.


307
00:08:16,386 --> 00:08:18,116
Hit testing works by turning a


308
00:08:18,116 --> 00:08:19,556
2D point that was tapped on your


309
00:08:19,556 --> 00:08:21,526
device's screen into a ray in


310
00:08:21,526 --> 00:08:22,396
our virtual scene.


311
00:08:23,236 --> 00:08:24,826
That ray is then cast into the


312
00:08:24,826 --> 00:08:26,556
scene and RealityKit finds all


313
00:08:26,556 --> 00:08:27,276
of the objects that are


314
00:08:27,276 --> 00:08:28,786
intersected by the ray.


315
00:08:29,286 --> 00:08:31,086
Any entities that were


316
00:08:31,086 --> 00:08:32,385
intersected by the ray are


317
00:08:32,385 --> 00:08:34,256
returned and you now know what


318
00:08:34,256 --> 00:08:35,606
objects lie under the tap.


319
00:08:37,145 --> 00:08:38,405
ARView provides the methods for


320
00:08:38,405 --> 00:08:38,986
hit testing.


321
00:08:39,285 --> 00:08:40,535
Entity at point returns the


322
00:08:40,535 --> 00:08:42,106
entity closest to the camera for


323
00:08:42,106 --> 00:08:44,066
the given point and entities at


324
00:08:44,066 --> 00:08:45,516
point returns all the entities


325
00:08:45,516 --> 00:08:47,006
that are intersected by the ray


326
00:08:47,136 --> 00:08:48,146
caster that given point.


327
00:08:48,616 --> 00:08:51,196
And we can easily integrate this


328
00:08:51,196 --> 00:08:52,216
into our Memory Cards app.


329
00:08:53,076 --> 00:08:54,746
Here we have a method responding


330
00:08:54,786 --> 00:08:56,496
to a tap gesture recognizer.


331
00:08:57,116 --> 00:08:58,556
We get the tap location in the


332
00:08:58,556 --> 00:09:00,206
ARView and then pass it into


333
00:09:00,206 --> 00:09:01,806
entity at, which we're using


334
00:09:01,806 --> 00:09:03,456
because we only want the entity


335
00:09:03,566 --> 00:09:04,626
closest to our device.


336
00:09:05,596 --> 00:09:06,876
If there's an entity under that


337
00:09:06,876 --> 00:09:09,636
tap location, dis call, we'll


338
00:09:09,636 --> 00:09:10,896
return it, and we could then


339
00:09:10,896 --> 00:09:12,616
perform our interaction on it.


340
00:09:13,436 --> 00:09:14,506
However, there's still one more


341
00:09:14,506 --> 00:09:15,586
thing we need to do for hit


342
00:09:15,586 --> 00:09:16,966
testing to work.


343
00:09:18,646 --> 00:09:20,026
For entities to be hit testable


344
00:09:20,086 --> 00:09:21,086
they need a collision type


345
00:09:21,086 --> 00:09:21,426
shape.


346
00:09:22,926 --> 00:09:24,636
Collision shape is simplified


347
00:09:24,636 --> 00:09:26,356
geometry, typically a box.


348
00:09:27,086 --> 00:09:28,346
They're easy to find and they


349
00:09:28,346 --> 00:09:30,236
allow for efficient intersection


350
00:09:30,236 --> 00:09:31,736
and collision calculations.


351
00:09:32,426 --> 00:09:34,326
And importantly without a


352
00:09:34,326 --> 00:09:36,086
collision shape, entities are


353
00:09:36,086 --> 00:09:37,296
not hit testable.


354
00:09:37,516 --> 00:09:39,086
So let's add them to our cards.


355
00:09:39,826 --> 00:09:42,066
So this is the same code we saw


356
00:09:42,066 --> 00:09:43,426
before for leading our models


357
00:09:43,426 --> 00:09:44,766
and creating our card templates.


358
00:09:45,336 --> 00:09:47,836
We'll make a small change here


359
00:09:47,836 --> 00:09:50,216
to add entities generate


360
00:09:50,276 --> 00:09:51,236
collision shapes method.


361
00:09:52,086 --> 00:09:53,446
This will automatically generate


362
00:09:53,676 --> 00:09:55,346
simple box collision shapes for


363
00:09:55,346 --> 00:09:57,506
an entity using the entities


364
00:09:57,506 --> 00:09:58,476
visual bounds.


365
00:09:59,016 --> 00:10:00,516
As you can see, much like with


366
00:10:00,516 --> 00:10:01,886
cloning, this can be performed


367
00:10:01,966 --> 00:10:03,646
recursively creating collision


368
00:10:03,646 --> 00:10:05,086
shapes for all the children of


369
00:10:05,086 --> 00:10:06,176
an entity as well.


370
00:10:07,206 --> 00:10:08,126
And speaking of cloning,


371
00:10:08,446 --> 00:10:09,686
collision shapes are included in


372
00:10:09,686 --> 00:10:10,986
the data that gets copied when


373
00:10:10,986 --> 00:10:11,886
an entity is cloned.


374
00:10:12,656 --> 00:10:13,806
Since we're all ready cloning


375
00:10:13,806 --> 00:10:14,696
the card templates to build our


376
00:10:14,696 --> 00:10:15,586
game board, they'll be


377
00:10:15,586 --> 00:10:17,496
automatically included with


378
00:10:17,496 --> 00:10:18,446
these collision shapes as well.


379
00:10:18,656 --> 00:10:21,346
Now that we can figure out what


380
00:10:21,346 --> 00:10:22,806
entities we're interacting with,


381
00:10:22,976 --> 00:10:24,196
let's add an animation that will


382
00:10:24,196 --> 00:10:25,266
play when we tap on a card.


383
00:10:26,056 --> 00:10:27,396
RealityKit supports two kinds of


384
00:10:27,396 --> 00:10:27,946
animation.


385
00:10:28,156 --> 00:10:29,926
The first is transform


386
00:10:29,926 --> 00:10:30,356
animation.


387
00:10:30,356 --> 00:10:31,776
It let's you animate the


388
00:10:32,016 --> 00:10:36,446
position, rotation, and scale of


389
00:10:36,446 --> 00:10:37,566
entities in code.


390
00:10:38,186 --> 00:10:40,686
And the second is asset


391
00:10:40,686 --> 00:10:41,966
animation, which plays the


392
00:10:41,966 --> 00:10:43,226
animations that are baked into


393
00:10:43,226 --> 00:10:44,716
your assets that are loaded in


394
00:10:44,716 --> 00:10:46,896
from USDZs or reality files.


395
00:10:47,526 --> 00:10:49,506
And RealityKit also provides


396
00:10:49,506 --> 00:10:50,856
completion handlers for use with


397
00:10:50,856 --> 00:10:52,376
both kinds of animation, letting


398
00:10:52,376 --> 00:10:53,446
you know when the animation


399
00:10:53,446 --> 00:10:54,006
finishes.


400
00:10:55,166 --> 00:10:57,566
Once our card assets don't have


401
00:10:57,566 --> 00:10:59,236
a baked in animation, so to flip


402
00:10:59,236 --> 00:11:00,186
them we're going to use a


403
00:11:00,186 --> 00:11:01,786
transform animation on our card


404
00:11:01,786 --> 00:11:02,136
entities.


405
00:11:05,206 --> 00:11:06,506
Transform animations can make


406
00:11:06,506 --> 00:11:07,696
use of a variety of timing


407
00:11:07,696 --> 00:11:09,046
functions that can control the


408
00:11:09,046 --> 00:11:09,986
speed of which the animation is


409
00:11:09,986 --> 00:11:10,316
played.


410
00:11:11,306 --> 00:11:12,536
There's linear, which plays the


411
00:11:12,536 --> 00:11:13,776
animation at a constant rate


412
00:11:13,996 --> 00:11:15,306
with instantaneous acceleration


413
00:11:15,306 --> 00:11:16,386
and deceleration.


414
00:11:16,686 --> 00:11:19,116
There's the ease in, which


415
00:11:19,116 --> 00:11:20,536
gradually ramps up the animation


416
00:11:20,576 --> 00:11:21,626
speed over its duration.


417
00:11:22,296 --> 00:11:24,696
Ease out is the opposite of ease


418
00:11:24,696 --> 00:11:25,816
in, which slows the animation


419
00:11:25,816 --> 00:11:27,126
down until its complete.


420
00:11:27,796 --> 00:11:30,436
And the ease in and ease out


421
00:11:30,686 --> 00:11:32,056
combines both, ramping the


422
00:11:32,056 --> 00:11:33,056
animations to be up until the


423
00:11:33,056 --> 00:11:34,586
halfway point and then slowing


424
00:11:34,586 --> 00:11:35,976
it down until its complete.


425
00:11:36,546 --> 00:11:38,836
And there's also a cubic Bezier


426
00:11:38,836 --> 00:11:40,436
option for customization of your


427
00:11:40,436 --> 00:11:41,126
timing function.


428
00:11:41,636 --> 00:11:43,346
Let's create an animation for


429
00:11:43,346 --> 00:11:43,886
our card flip.


430
00:11:44,556 --> 00:11:46,966
So we're going to start by


431
00:11:47,076 --> 00:11:48,606
copying our card's current


432
00:11:48,606 --> 00:11:49,276
transform.


433
00:11:49,936 --> 00:11:51,376
This ensures that we preserve


434
00:11:51,376 --> 00:11:52,596
the current scale and


435
00:11:52,596 --> 00:11:54,196
translation of the entity, which


436
00:11:54,296 --> 00:11:55,246
right here we don't want to


437
00:11:55,246 --> 00:11:55,636
change.


438
00:11:57,456 --> 00:11:59,346
Next we'll set the transform to


439
00:11:59,346 --> 00:12:01,566
a 180-degree rotation around the


440
00:12:01,566 --> 00:12:03,616
x-axis using a quaternion.


441
00:12:03,966 --> 00:12:05,596
This will flip the card so its


442
00:12:05,596 --> 00:12:06,576
image is facing up.


443
00:12:06,656 --> 00:12:09,506
Now we can start the animation


444
00:12:09,506 --> 00:12:09,976
itself.


445
00:12:10,606 --> 00:12:12,216
Transform animation is applied


446
00:12:12,216 --> 00:12:13,786
using entities "move to" method.


447
00:12:15,136 --> 00:12:16,096
RealityKit will smooth the


448
00:12:16,096 --> 00:12:17,176
animated entity between its


449
00:12:17,176 --> 00:12:18,386
current transform and the one


450
00:12:18,386 --> 00:12:19,466
you provide in this method.


451
00:12:19,986 --> 00:12:20,946
Using the requested timing


452
00:12:20,946 --> 00:12:22,556
function, in this case "ease in


453
00:12:22,556 --> 00:12:24,226
and out" over the given length


454
00:12:24,226 --> 00:12:24,566
of time.


455
00:12:25,626 --> 00:12:27,406
This gives us the animation we


456
00:12:27,406 --> 00:12:28,926
need to flip the card face up.


457
00:12:29,386 --> 00:12:32,646
And entities move method return


458
00:12:32,646 --> 00:12:33,576
in animation with playback


459
00:12:33,576 --> 00:12:34,676
controller that allows you to


460
00:12:34,676 --> 00:12:36,156
pause, resume, or stop the


461
00:12:36,156 --> 00:12:37,886
animation, or to receive


462
00:12:37,886 --> 00:12:39,006
notification when the animation


463
00:12:39,006 --> 00:12:40,426
completes like we're doing here.


464
00:12:41,026 --> 00:12:43,806
Then to flip the card back to


465
00:12:43,806 --> 00:12:45,236
being face down, we just need to


466
00:12:45,236 --> 00:12:46,976
make one small tweak setting the


467
00:12:46,976 --> 00:12:48,666
rotation of our transform back


468
00:12:48,666 --> 00:12:49,096
to zero.


469
00:12:49,296 --> 00:12:50,786
When we call move this


470
00:12:50,786 --> 00:12:51,986
transform, the card will flip


471
00:12:51,986 --> 00:12:53,356
back to being face down.


472
00:12:55,406 --> 00:12:56,756
So now we can show the app with


473
00:12:56,756 --> 00:12:58,056
interaction enabled, using hit


474
00:12:58,056 --> 00:12:59,396
testing to detect what objects


475
00:12:59,396 --> 00:13:01,266
the user is selecting and


476
00:13:01,266 --> 00:13:02,696
transform animation to hide the


477
00:13:02,696 --> 00:13:02,976
cards.


478
00:13:06,046 --> 00:13:07,056
Now that we've got the basics


479
00:13:07,056 --> 00:13:08,326
working, let's polish things up


480
00:13:08,326 --> 00:13:10,146
a bit with some detail work.


481
00:13:10,716 --> 00:13:12,976
We've got our simple card models


482
00:13:12,976 --> 00:13:14,966
loaded and placed in AR, but 2D


483
00:13:14,966 --> 00:13:16,596
images on cards is not very


484
00:13:16,596 --> 00:13:17,076
exciting.


485
00:13:18,056 --> 00:13:19,176
Thankfully our art team has also


486
00:13:19,176 --> 00:13:20,366
created a bunch of high quality


487
00:13:20,366 --> 00:13:21,866
models, so let's add them into


488
00:13:21,866 --> 00:13:23,136
the mix to help our app be a bit


489
00:13:23,136 --> 00:13:24,096
more three-dimensional.


490
00:13:24,656 --> 00:13:27,156
We could load these new assets


491
00:13:27,156 --> 00:13:28,696
the same way we did before with


492
00:13:28,696 --> 00:13:30,166
the synchronous entity.load


493
00:13:30,166 --> 00:13:30,556
method.


494
00:13:31,076 --> 00:13:32,436
However, these models are a lot


495
00:13:32,436 --> 00:13:34,396
more detailed than the simple


496
00:13:34,396 --> 00:13:35,226
card assets.


497
00:13:35,226 --> 00:13:36,756
And the larger assets will take


498
00:13:36,756 --> 00:13:37,446
longer to load.


499
00:13:37,926 --> 00:13:40,096
Loading them will be quick, but


500
00:13:40,096 --> 00:13:41,446
the app will be blocked while


501
00:13:41,446 --> 00:13:41,946
they're loading.


502
00:13:42,926 --> 00:13:44,226
And if you're loading a lot of


503
00:13:44,226 --> 00:13:45,186
assets that can add up to


504
00:13:45,186 --> 00:13:46,766
noticeable delays where nothing


505
00:13:46,766 --> 00:13:47,316
is happening.


506
00:13:48,136 --> 00:13:48,876
Is there anything we can do to


507
00:13:48,876 --> 00:13:49,436
make this better?


508
00:13:50,726 --> 00:13:51,806
Thankfully as we mentioned it


509
00:13:51,806 --> 00:13:53,106
earlier, RealityKit offers both


510
00:13:53,106 --> 00:13:54,446
synchronous and asynchronous


511
00:13:54,446 --> 00:13:54,786
loading.


512
00:13:55,576 --> 00:13:56,446
We can load models


513
00:13:56,446 --> 00:13:57,666
asynchronously by calling


514
00:13:57,666 --> 00:13:59,906
entities load model async


515
00:14:00,736 --> 00:14:00,896
method.


516
00:14:01,046 --> 00:14:02,106
With asynchronous loading,


517
00:14:02,556 --> 00:14:03,396
assets are loaded in the


518
00:14:03,396 --> 00:14:05,836
background and this unlocks the


519
00:14:05,836 --> 00:14:07,076
app and allows it to continue


520
00:14:07,116 --> 00:14:08,506
uninterrupted, which makes your


521
00:14:08,506 --> 00:14:10,266
app responsive and allows ARkit


522
00:14:10,266 --> 00:14:14,216
to continue observing the world.


523
00:14:14,536 --> 00:14:16,266
When asynchronous loading is


524
00:14:16,266 --> 00:14:17,676
complete you'll receive a call


525
00:14:17,676 --> 00:14:18,566
back and then it can use your


526
00:14:18,566 --> 00:14:20,436
assets just as you would with


527
00:14:20,436 --> 00:14:21,136
synchronous loading.


528
00:14:21,946 --> 00:14:23,486
And additionally you can also


529
00:14:23,486 --> 00:14:24,636
combine load requests and


530
00:14:24,636 --> 00:14:26,446
execute them simultaneously and


531
00:14:26,726 --> 00:14:28,056
receive notification when all


532
00:14:28,056 --> 00:14:29,136
assets have finished loading.


533
00:14:29,306 --> 00:14:30,186
So you don't need to load your


534
00:14:30,186 --> 00:14:31,326
content piecemeal.


535
00:14:32,136 --> 00:14:33,186
Let's write some code to load


536
00:14:33,186 --> 00:14:34,796
our new models asynchronously.


537
00:14:36,056 --> 00:14:37,426
So we'll start by loading a


538
00:14:37,516 --> 00:14:39,046
single model asynchronously.


539
00:14:39,846 --> 00:14:41,516
Entities load model async method


540
00:14:41,686 --> 00:14:43,176
takes on the name of the asset


541
00:14:43,436 --> 00:14:44,386
just like its synchronous


542
00:14:44,416 --> 00:14:44,966
counterpart.


543
00:14:45,656 --> 00:14:48,276
It returns a load request to


544
00:14:48,276 --> 00:14:49,316
receive notification when the


545
00:14:49,316 --> 00:14:51,396
model has finished loading and


546
00:14:51,396 --> 00:14:52,016
can be used.


547
00:14:52,596 --> 00:14:54,546
We call the sync method with a


548
00:14:54,546 --> 00:14:56,056
closure that will be executed


549
00:14:56,056 --> 00:14:57,266
when the asset is ready.


550
00:14:58,246 --> 00:15:00,456
The load request uses API


551
00:15:00,456 --> 00:15:01,536
introduced with a new Swift


552
00:15:01,536 --> 00:15:02,416
framework Combine.


553
00:15:02,816 --> 00:15:03,696
So I recommend checking out the


554
00:15:03,696 --> 00:15:05,216
session Introducing Combine and


555
00:15:05,216 --> 00:15:06,346
Advances in Foundation.


556
00:15:06,346 --> 00:15:08,656
And that's all you need to do to


557
00:15:08,656 --> 00:15:09,696
be able to load your content


558
00:15:09,696 --> 00:15:10,356
asynchronously.


559
00:15:10,706 --> 00:15:11,856
No you could load all of your


560
00:15:11,856 --> 00:15:13,416
assets individually like this,


561
00:15:13,856 --> 00:15:14,966
but you can also combine


562
00:15:14,966 --> 00:15:16,716
multiple load requests into one.


563
00:15:19,046 --> 00:15:19,896
We can do this by simply


564
00:15:19,956 --> 00:15:21,146
appending another load request


565
00:15:21,276 --> 00:15:22,126
on to the first one.


566
00:15:22,676 --> 00:15:25,316
We then call collect to combine


567
00:15:25,316 --> 00:15:26,326
our to load requests.


568
00:15:26,876 --> 00:15:28,876
And then we call sink.


569
00:15:29,036 --> 00:15:30,506
And our closure will be executed


570
00:15:30,506 --> 00:15:31,956
when both models have finished


571
00:15:31,956 --> 00:15:33,466
loading, packaged into the


572
00:15:33,466 --> 00:15:34,946
models of array parameter for


573
00:15:34,946 --> 00:15:35,896
easy processing.


574
00:15:38,256 --> 00:15:39,396
And we can extend this as far as


575
00:15:39,396 --> 00:15:39,766
we want.


576
00:15:40,356 --> 00:15:41,676
Here we're collecting all eight


577
00:15:41,676 --> 00:15:43,046
of our detailed card models into


578
00:15:43,046 --> 00:15:44,426
a single load request.


579
00:15:45,916 --> 00:15:46,816
Our sink closure will be


580
00:15:46,816 --> 00:15:48,146
executed when all eight have


581
00:15:48,396 --> 00:15:49,026
finished loading.


582
00:15:49,656 --> 00:15:50,756
Combine and load requests makes


583
00:15:50,756 --> 00:15:51,976
managing your content much


584
00:15:51,976 --> 00:15:52,346
easier.


585
00:15:55,106 --> 00:15:55,866
Let's show how synchronous


586
00:15:55,866 --> 00:15:56,516
loading compares with


587
00:15:56,516 --> 00:15:57,266
asynchronous loading.


588
00:15:57,266 --> 00:15:59,546
On the left our app is using


589
00:15:59,546 --> 00:16:00,466
synchronous loading and on the


590
00:16:00,466 --> 00:16:01,566
right asynchronous.


591
00:16:01,566 --> 00:16:03,306
As soon as the synchronous app


592
00:16:03,306 --> 00:16:04,836
starts loading everything comes


593
00:16:04,836 --> 00:16:06,596
to a stop as the app is blocked


594
00:16:06,596 --> 00:16:07,556
until loading is complete.


595
00:16:08,216 --> 00:16:09,806
By contrast the asynchronous app


596
00:16:09,806 --> 00:16:11,076
continues to be responsive


597
00:16:11,386 --> 00:16:12,506
allowing it to respond to user


598
00:16:12,506 --> 00:16:14,766
input, update the camera, and


599
00:16:14,766 --> 00:16:15,706
you continue to observe the


600
00:16:15,706 --> 00:16:18,006
world in front of the camera.


601
00:16:18,196 --> 00:16:19,046
Loading takes about the same


602
00:16:19,046 --> 00:16:20,836
amount of time for both, however


603
00:16:20,836 --> 00:16:22,256
the device using async loading


604
00:16:22,256 --> 00:16:23,286
is able to place its content


605
00:16:23,606 --> 00:16:24,746
first because its able to


606
00:16:24,746 --> 00:16:26,076
continue observing the world


607
00:16:26,356 --> 00:16:26,986
during loading.


608
00:16:27,186 --> 00:16:27,956
While the device using


609
00:16:27,956 --> 00:16:29,636
asynchronous loading is not


610
00:16:29,876 --> 00:16:31,706
making it a much better fit for


611
00:16:31,706 --> 00:16:33,256
use with AR.


612
00:16:35,006 --> 00:16:35,626
So now we have out detailed


613
00:16:35,626 --> 00:16:36,396
models loading in without


614
00:16:36,396 --> 00:16:37,506
freezing the app.


615
00:16:37,826 --> 00:16:39,526
However an astute observer may


616
00:16:39,526 --> 00:16:40,446
notice that we can see the new


617
00:16:40,446 --> 00:16:41,756
models while the cards are faced


618
00:16:41,756 --> 00:16:42,076
down.


619
00:16:43,356 --> 00:16:44,366
We could simply hide the models


620
00:16:44,366 --> 00:16:45,436
while the cards are face down,


621
00:16:45,436 --> 00:16:46,356
but nothing would stop the user


622
00:16:46,356 --> 00:16:47,626
from bending over and looking at


623
00:16:47,626 --> 00:16:48,996
the underside of the cards and


624
00:16:48,996 --> 00:16:49,876
seeing which ones match up


625
00:16:50,126 --> 00:16:52,606
without having to flip them.


626
00:16:52,716 --> 00:16:54,386
So RealityKit provides a super


627
00:16:54,386 --> 00:16:55,426
useful way to fix this,


628
00:16:55,616 --> 00:16:56,696
occlusion materials.


629
00:16:57,396 --> 00:16:58,496
Occlusion materials are


630
00:16:58,496 --> 00:17:00,056
invisible, but when applied to


631
00:17:00,056 --> 00:17:01,516
geometry in a scene they hide


632
00:17:01,516 --> 00:17:03,136
virtual content behind them


633
00:17:03,886 --> 00:17:04,925
revealing the video pass


634
00:17:04,925 --> 00:17:05,146
through.


635
00:17:05,685 --> 00:17:06,836
Here you can see we've added


636
00:17:06,836 --> 00:17:07,896
some occlusion geometry to our


637
00:17:07,896 --> 00:17:09,086
scene, along with some


638
00:17:09,086 --> 00:17:10,256
additional highlighting to show


639
00:17:10,256 --> 00:17:11,705
the shape of an otherwise


640
00:17:11,796 --> 00:17:12,675
invisible object.


641
00:17:13,476 --> 00:17:15,356
As in animates up and down parts


642
00:17:15,356 --> 00:17:16,566
of the robot it intersects are


643
00:17:16,656 --> 00:17:18,175
hidden and lets the real world


644
00:17:18,445 --> 00:17:19,455
behind it show through.


645
00:17:20,616 --> 00:17:21,576
Occlusion materials are great


646
00:17:21,576 --> 00:17:22,796
for simulating real world


647
00:17:22,796 --> 00:17:24,215
objects that would block virtual


648
00:17:24,215 --> 00:17:26,086
objects from being seen like a


649
00:17:26,086 --> 00:17:26,856
table or wall.


650
00:17:27,276 --> 00:17:28,296
So let's make use of it in our


651
00:17:28,996 --> 00:17:29,066
app.


652
00:17:30,076 --> 00:17:31,346
Let's start by adding an


653
00:17:31,346 --> 00:17:32,686
occlusion plane under our game


654
00:17:32,686 --> 00:17:32,956
board.


655
00:17:33,526 --> 00:17:34,756
We'll create a plane mesh half a


656
00:17:34,756 --> 00:17:35,926
meter wide and half a meter


657
00:17:35,926 --> 00:17:36,216
deep.


658
00:17:37,476 --> 00:17:38,436
We'll then create our occlusion


659
00:17:38,436 --> 00:17:41,346
material and then create a model


660
00:17:41,346 --> 00:17:42,786
entity using it and our plane


661
00:17:42,786 --> 00:17:43,176
mesh.


662
00:17:43,876 --> 00:17:45,276
We'll position it slightly below


663
00:17:45,276 --> 00:17:46,206
the game board so that it


664
00:17:46,206 --> 00:17:47,676
doesn't intersect the bottom of


665
00:17:47,676 --> 00:17:48,166
our models.


666
00:17:49,106 --> 00:17:50,196
And then we just add it to our


667
00:17:50,196 --> 00:17:51,736
anchor to place the occlusion


668
00:17:51,786 --> 00:17:52,856
plane in our scene.


669
00:17:54,366 --> 00:17:56,006
Here we can see the occlusion


670
00:17:56,006 --> 00:17:56,876
plane in action.


671
00:17:57,106 --> 00:17:58,306
At first glance this seems to do


672
00:17:58,306 --> 00:17:59,166
a great job of solving the


673
00:17:59,166 --> 00:18:00,456
problem, however when we start


674
00:18:00,456 --> 00:18:02,046
to move the device down we can


675
00:18:02,046 --> 00:18:03,676
see the edge of the occlusion


676
00:18:03,676 --> 00:18:04,896
plane and see our virtual


677
00:18:04,896 --> 00:18:06,076
content rendering inside the


678
00:18:06,076 --> 00:18:06,456
table.


679
00:18:06,456 --> 00:18:08,016
So this plane works great when


680
00:18:08,016 --> 00:18:09,396
we're above the game board but


681
00:18:09,396 --> 00:18:10,406
we need occlusion that will work


682
00:18:10,406 --> 00:18:13,476
for an angle in this case.


683
00:18:13,646 --> 00:18:14,976
Solution is using occlusion


684
00:18:14,976 --> 00:18:16,206
box instead of an occlusion


685
00:18:16,206 --> 00:18:16,466
plane.


686
00:18:16,986 --> 00:18:20,016
So we'll generate a box, make


687
00:18:20,016 --> 00:18:20,846
use of the same occlusion


688
00:18:20,846 --> 00:18:23,036
material, and then create a


689
00:18:23,036 --> 00:18:24,566
model entity using the box in


690
00:18:24,566 --> 00:18:25,336
place of the plane.


691
00:18:26,806 --> 00:18:28,256
Generated geometric objects have


692
00:18:28,256 --> 00:18:30,106
their origins in the center so


693
00:18:30,106 --> 00:18:31,176
we need to bump it down by


694
00:18:31,176 --> 00:18:31,716
half a size and then just a


695
00:18:31,716 --> 00:18:32,806
little bit more so that the top


696
00:18:32,806 --> 00:18:34,096
of the box will rest just below


697
00:18:34,096 --> 00:18:35,006
the bottom of the game board.


698
00:18:36,376 --> 00:18:38,246
And then once again we just add


699
00:18:38,246 --> 00:18:39,266
it to our anchor to place the


700
00:18:39,266 --> 00:18:42,496
occlusion box in our scene.


701
00:18:43,136 --> 00:18:44,696
Initially it looks the same as


702
00:18:44,696 --> 00:18:46,656
the occlusion plane until we


703
00:18:46,656 --> 00:18:48,096
start to move our device down


704
00:18:48,736 --> 00:18:50,716
and we can see, or rather can't


705
00:18:50,716 --> 00:18:52,096
see our virtual content.


706
00:18:52,746 --> 00:18:54,026
Our occlusion box is preventing


707
00:18:54,026 --> 00:18:55,396
content from rendering inside


708
00:18:55,396 --> 00:18:57,046
the table simulating the real


709
00:18:57,046 --> 00:18:58,486
world object in our virtual


710
00:18:58,486 --> 00:18:58,856
scene.


711
00:19:00,226 --> 00:19:01,266
So now we have an app where we


712
00:19:01,266 --> 00:19:02,386
can place our virtual cards in


713
00:19:02,386 --> 00:19:03,716
the real world and interact with


714
00:19:03,716 --> 00:19:03,896
them.


715
00:19:03,896 --> 00:19:05,246
We're loading assets


716
00:19:05,246 --> 00:19:06,366
asynchronously and we're


717
00:19:06,366 --> 00:19:07,736
simulating our virtual content


718
00:19:07,736 --> 00:19:08,916
being hidden by real world


719
00:19:08,916 --> 00:19:10,376
objects using occlusion


720
00:19:10,376 --> 00:19:10,906
geometry.


721
00:19:11,566 --> 00:19:13,116
Now I'd like to invite my


722
00:19:13,116 --> 00:19:14,236
colleague Courtland up to talk


723
00:19:14,236 --> 00:19:15,336
about tracking game state.


724
00:19:15,706 --> 00:19:16,036
Courtland.


725
00:19:17,016 --> 00:19:21,500
[ Applause ]


726
00:19:25,236 --> 00:19:25,816
>> Thank you Ross.


727
00:19:26,476 --> 00:19:27,776
Hello. I'm Courtland, an


728
00:19:27,776 --> 00:19:29,296
engineer on the RealityKit team


729
00:19:29,296 --> 00:19:29,666
at Apple.


730
00:19:30,396 --> 00:19:31,766
We've just seen how to prototype


731
00:19:31,766 --> 00:19:33,756
a functioning AR game, add


732
00:19:33,756 --> 00:19:35,616
interaction, and integrate final


733
00:19:35,616 --> 00:19:36,006
artwork.


734
00:19:36,876 --> 00:19:38,056
Now I'd like to show you how to


735
00:19:38,056 --> 00:19:39,396
best track your state with


736
00:19:39,396 --> 00:19:40,796
custom components and entities


737
00:19:41,146 --> 00:19:42,416
and finally how to add


738
00:19:42,416 --> 00:19:42,916
mutli-player.


739
00:19:43,896 --> 00:19:45,446
Let's start with tracking state.


740
00:19:46,606 --> 00:19:48,106
As we covered in the intro


741
00:19:48,106 --> 00:19:49,936
session, RealityKit uses the


742
00:19:49,936 --> 00:19:51,296
entity component design pattern


743
00:19:51,446 --> 00:19:52,666
to build objects within the


744
00:19:52,666 --> 00:19:53,306
virtual world.


745
00:19:53,476 --> 00:19:56,326
An entity itself is comprised of


746
00:19:56,326 --> 00:19:57,676
pieces called "components."


747
00:19:58,616 --> 00:20:00,396
These components define specific


748
00:20:00,396 --> 00:20:02,536
behaviors and data that can be


749
00:20:02,536 --> 00:20:03,856
added to individual entities.


750
00:20:04,846 --> 00:20:06,546
Using entities and components


751
00:20:06,546 --> 00:20:08,286
allows for reuse of code and is


752
00:20:08,286 --> 00:20:09,126
flexible to use.


753
00:20:09,786 --> 00:20:10,956
Let's take a look at how we can


754
00:20:10,956 --> 00:20:11,806
apply components.


755
00:20:12,356 --> 00:20:14,986
We're using RealityKit's model


756
00:20:14,986 --> 00:20:16,646
entity to represent our cards.


757
00:20:17,096 --> 00:20:18,226
It provides us with a set of


758
00:20:18,226 --> 00:20:19,806
components, which are useful for


759
00:20:19,806 --> 00:20:21,626
representing most common virtual


760
00:20:21,626 --> 00:20:22,196
objects.


761
00:20:22,946 --> 00:20:24,306
We've made use of the model


762
00:20:24,306 --> 00:20:25,796
component for visual appearance


763
00:20:25,796 --> 00:20:27,776
and the collision component for


764
00:20:27,776 --> 00:20:28,276
hit testing.


765
00:20:29,436 --> 00:20:30,936
Model entity also contains a


766
00:20:30,936 --> 00:20:32,626
physics component, allowing the


767
00:20:32,626 --> 00:20:34,326
entity to move and interact with


768
00:20:34,326 --> 00:20:35,736
other objects in a physically


769
00:20:35,816 --> 00:20:37,496
realistic way, though we haven't


770
00:20:37,496 --> 00:20:38,246
made use of it here.


771
00:20:39,836 --> 00:20:40,996
RealityKit enable you to


772
00:20:40,996 --> 00:20:42,006
customize an entity.


773
00:20:42,626 --> 00:20:43,866
By using an entity component


774
00:20:43,866 --> 00:20:45,206
design you can include the


775
00:20:45,206 --> 00:20:47,116
behaviors you want, exclude the


776
00:20:47,116 --> 00:20:49,296
ones you don't need, and add new


777
00:20:49,296 --> 00:20:50,166
behaviors of your own.


778
00:20:51,196 --> 00:20:52,926
Let's customize this entity for


779
00:20:53,636 --> 00:20:54,826
our cards.


780
00:20:54,966 --> 00:20:56,486
Model entity has most of what we


781
00:20:56,486 --> 00:20:56,746
need.


782
00:20:57,476 --> 00:20:58,996
We'll remove physics since we're


783
00:20:58,996 --> 00:20:59,506
not using it.


784
00:21:00,746 --> 00:21:01,986
We want to store whether the


785
00:21:01,986 --> 00:21:03,716
card is hidden or revealed and


786
00:21:03,826 --> 00:21:06,076
the kind of card which we'll use


787
00:21:06,116 --> 00:21:07,296
to determine if two cards are


788
00:21:07,296 --> 00:21:07,616
matching.


789
00:21:08,736 --> 00:21:10,286
To do this we need to create a


790
00:21:10,286 --> 00:21:12,226
new card component type with


791
00:21:12,226 --> 00:21:13,296
these properties, which we'll


792
00:21:13,296 --> 00:21:13,956
add to the entity.


793
00:21:15,266 --> 00:21:16,906
So what exactly is a component?


794
00:21:17,626 --> 00:21:20,196
A RealityKit component is a


795
00:21:20,196 --> 00:21:21,656
Swift struct that contains your


796
00:21:21,656 --> 00:21:22,046
properties.


797
00:21:23,046 --> 00:21:24,366
It conforms to the component


798
00:21:24,366 --> 00:21:26,056
protocol, which allows us to


799
00:21:26,056 --> 00:21:27,086
attach it to an entity.


800
00:21:28,466 --> 00:21:30,376
It's also a good idea to conform


801
00:21:30,376 --> 00:21:31,616
to Codable, as we'll see in the


802
00:21:31,616 --> 00:21:32,556
multi-player segment.


803
00:21:33,496 --> 00:21:34,066
So let's make one.


804
00:21:35,076 --> 00:21:37,506
We start by declaring our struct


805
00:21:37,866 --> 00:21:38,936
called CardComponent.


806
00:21:39,966 --> 00:21:41,046
We adopt the component in


807
00:21:41,046 --> 00:21:42,036
Codable protocols.


808
00:21:44,066 --> 00:21:45,086
Next we'll add our two


809
00:21:45,086 --> 00:21:46,626
properties -- a boolean called


810
00:21:46,626 --> 00:21:48,066
"revealed" to represent whether


811
00:21:48,066 --> 00:21:49,226
the card's contents are hidden


812
00:21:49,226 --> 00:21:51,006
or revealed and a string "kind,"


813
00:21:51,496 --> 00:21:52,516
which we can use to match the


814
00:21:52,516 --> 00:21:52,946
two cards.


815
00:21:53,726 --> 00:21:54,476
That's all for the type.


816
00:21:55,396 --> 00:21:56,476
We'll start with one of the card


817
00:21:56,476 --> 00:21:57,826
models Ross loaded earlier.


818
00:21:58,446 --> 00:22:01,106
For demonstration purposes I'll


819
00:22:01,106 --> 00:22:02,226
show how to remove a physics


820
00:22:02,256 --> 00:22:02,936
body component.


821
00:22:03,696 --> 00:22:05,036
The model entity provides a


822
00:22:05,036 --> 00:22:06,346
physics body property, which


823
00:22:06,346 --> 00:22:07,156
makes this easy.


824
00:22:08,016 --> 00:22:10,586
We just assign nil and we're


825
00:22:11,696 --> 00:22:11,806
done.


826
00:22:12,026 --> 00:22:12,666
Now we'll load the card


827
00:22:12,666 --> 00:22:13,986
component by assigning to the


828
00:22:13,986 --> 00:22:16,336
components array indexed by the


829
00:22:16,336 --> 00:22:17,236
type of component.


830
00:22:18,246 --> 00:22:19,376
This will add the component, if


831
00:22:19,376 --> 00:22:21,006
it doesn't all ready exist, on


832
00:22:21,816 --> 00:22:23,046
the entity.


833
00:22:23,246 --> 00:22:24,446
Changing the kind property is


834
00:22:24,446 --> 00:22:24,756
similar.


835
00:22:25,726 --> 00:22:27,016
Indexed into the entities


836
00:22:27,016 --> 00:22:28,666
components array, and assigned


837
00:22:28,666 --> 00:22:29,476
to the kind property.


838
00:22:30,406 --> 00:22:31,766
Since not every entity contains


839
00:22:31,766 --> 00:22:33,506
a card component, the accesser


840
00:22:33,506 --> 00:22:36,216
returns an optional value.


841
00:22:37,266 --> 00:22:38,846
For common configuration of


842
00:22:38,876 --> 00:22:40,056
components used throughout your


843
00:22:40,056 --> 00:22:41,566
game, we can take it a step


844
00:22:41,566 --> 00:22:42,736
further and create our own


845
00:22:42,806 --> 00:22:43,476
custom entity.


846
00:22:44,466 --> 00:22:45,746
RealityKit comes with a number


847
00:22:45,746 --> 00:22:47,346
of entity configurations such as


848
00:22:47,346 --> 00:22:48,946
directional light and model


849
00:22:48,946 --> 00:22:49,306
entity.


850
00:22:49,816 --> 00:22:50,766
And you can make your own very


851
00:22:50,766 --> 00:22:51,166
easily.


852
00:22:51,926 --> 00:22:53,156
We're using cards everywhere in


853
00:22:53,156 --> 00:22:55,336
our game, so this makes an ideal


854
00:22:55,336 --> 00:22:56,546
candidate to turn into an


855
00:22:56,546 --> 00:22:56,866
entity.


856
00:22:58,006 --> 00:22:59,386
We'll get compile times, static


857
00:22:59,386 --> 00:23:00,836
typing and code completion for


858
00:23:00,836 --> 00:23:01,496
these objects.


859
00:23:01,996 --> 00:23:03,346
This is also where we can add


860
00:23:03,346 --> 00:23:04,836
methods to encapsulate


861
00:23:04,836 --> 00:23:05,366
functionality.


862
00:23:06,726 --> 00:23:08,126
This is especially useful when


863
00:23:08,126 --> 00:23:08,976
you're changing multiple


864
00:23:08,976 --> 00:23:11,106
components at the same time such


865
00:23:11,106 --> 00:23:12,156
as setting the state of the card


866
00:23:12,156 --> 00:23:14,146
to revealed at the same time as


867
00:23:14,146 --> 00:23:16,326
flipping it over.


868
00:23:16,576 --> 00:23:18,006
Creating new entity is just a


869
00:23:18,006 --> 00:23:18,486
few steps.


870
00:23:19,736 --> 00:23:21,266
First we needed a new class to


871
00:23:21,296 --> 00:23:24,196
represent our entity.


872
00:23:24,406 --> 00:23:25,906
Then we added any RealityKit


873
00:23:25,906 --> 00:23:27,566
components we need.


874
00:23:28,696 --> 00:23:30,416
Next we'll add any custom


875
00:23:30,416 --> 00:23:31,016
components.


876
00:23:31,226 --> 00:23:32,136
We solved the physics body


877
00:23:32,136 --> 00:23:33,316
property on model entity


878
00:23:33,316 --> 00:23:34,816
earlier, which provide a


879
00:23:34,816 --> 00:23:36,356
convenient syntax for accessing


880
00:23:36,356 --> 00:23:37,496
the physical body component.


881
00:23:38,066 --> 00:23:39,966
We'll do the same for our card.


882
00:23:40,976 --> 00:23:42,516
Last we extend it with methods


883
00:23:43,646 --> 00:23:45,366
reveal and hide.


884
00:23:46,466 --> 00:23:49,246
So we create our card entity


885
00:23:49,246 --> 00:23:51,136
class derive from entity.


886
00:23:52,666 --> 00:23:54,086
Next include the RealityKit


887
00:23:54,086 --> 00:23:54,726
components.


888
00:23:55,356 --> 00:23:57,136
We're adding the HasModel and


889
00:23:57,136 --> 00:23:58,386
HasCollision protocols.


890
00:23:59,146 --> 00:24:00,606
These protocols give us access


891
00:24:00,646 --> 00:24:01,766
to the model and collision


892
00:24:01,766 --> 00:24:04,056
components via properties and


893
00:24:04,056 --> 00:24:05,186
any methods that they provide


894
00:24:05,466 --> 00:24:06,536
such as generate collision


895
00:24:06,536 --> 00:24:06,996
shapes.


896
00:24:07,496 --> 00:24:10,356
Last we add a card property,


897
00:24:10,816 --> 00:24:11,936
which returns a CardComponent.


898
00:24:12,626 --> 00:24:13,976
Since all cards need a card


899
00:24:13,976 --> 00:24:15,066
component we'll make it


900
00:24:15,066 --> 00:24:15,636
non-optional.


901
00:24:16,276 --> 00:24:19,246
The getter will retrieve our


902
00:24:19,246 --> 00:24:20,096
CardComponent from the


903
00:24:20,096 --> 00:24:20,706
components array.


904
00:24:21,686 --> 00:24:22,736
We use the nil coalescing


905
00:24:22,736 --> 00:24:24,466
operator to return a default


906
00:24:24,466 --> 00:24:25,506
value if we didn't all ready


907
00:24:25,506 --> 00:24:25,996
have a card.


908
00:24:27,236 --> 00:24:28,986
The setter copies new value into


909
00:24:28,986 --> 00:24:29,626
the components array.


910
00:24:29,626 --> 00:24:32,776
Now that we have our class we


911
00:24:32,776 --> 00:24:33,566
extend it with methods.


912
00:24:34,276 --> 00:24:37,926
I've included the reveal method


913
00:24:38,086 --> 00:24:39,466
to show us how easy it is to


914
00:24:39,466 --> 00:24:40,596
coordinate multiple updates.


915
00:24:41,756 --> 00:24:43,366
We first update the card's state


916
00:24:43,456 --> 00:24:44,646
to indicate that it's revealed.


917
00:24:45,596 --> 00:24:46,986
We'll do this immediately rather


918
00:24:46,986 --> 00:24:48,196
than at the end of the animation


919
00:24:48,576 --> 00:24:49,936
in case you tap it again while


920
00:24:49,936 --> 00:24:50,626
it's still animating.


921
00:24:51,886 --> 00:24:53,596
Next we use the same code that


922
00:24:53,596 --> 00:24:55,016
Ross showed us earlier to


923
00:24:55,016 --> 00:24:56,126
animate the card flipping over.


924
00:24:57,006 --> 00:24:58,406
And that's it.


925
00:24:58,506 --> 00:24:59,426
Hide method would do the


926
00:24:59,426 --> 00:24:59,816
opposite.


927
00:25:00,436 --> 00:25:02,016
Set reveal to false and turn the


928
00:25:02,016 --> 00:25:03,066
card to be facing down.


929
00:25:04,106 --> 00:25:05,356
Let's see what this is like to


930
00:25:05,356 --> 00:25:05,756
use now.


931
00:25:07,156 --> 00:25:08,266
We'll go back to the onTap


932
00:25:08,266 --> 00:25:08,676
handler.


933
00:25:09,866 --> 00:25:11,636
We call the same ARView entity


934
00:25:11,636 --> 00:25:13,756
at method, but this time cast


935
00:25:13,756 --> 00:25:15,206
its result to a card entity.


936
00:25:16,136 --> 00:25:17,236
Though we only have cards in our


937
00:25:17,236 --> 00:25:18,896
game, your app might have other


938
00:25:18,896 --> 00:25:19,676
types of entities.


939
00:25:20,926 --> 00:25:22,596
Casting to card entity lets us


940
00:25:22,856 --> 00:25:24,466
perform actions specific to the


941
00:25:24,466 --> 00:25:24,716
card.


942
00:25:26,186 --> 00:25:27,546
With a new card entity and


943
00:25:27,546 --> 00:25:29,106
component, we can just ask the


944
00:25:29,106 --> 00:25:30,346
card if it's revealed.


945
00:25:30,346 --> 00:25:32,366
If it is currently revealed


946
00:25:32,846 --> 00:25:34,136
we'll hide it.


947
00:25:34,256 --> 00:25:35,786
Otherwise we'll reveal it.


948
00:25:36,886 --> 00:25:37,926
With hide and reveal


949
00:25:37,926 --> 00:25:39,226
encapsulated as methods on the


950
00:25:39,226 --> 00:25:40,726
entity, we don't need to be


951
00:25:40,726 --> 00:25:42,076
concerned with the specifics of


952
00:25:42,076 --> 00:25:43,606
hiding and revealing cards here.


953
00:25:44,226 --> 00:25:46,726
We've cleaned things up


954
00:25:46,726 --> 00:25:48,136
considerably by adding a custom


955
00:25:48,136 --> 00:25:50,056
component in entity and made one


956
00:25:50,056 --> 00:25:51,126
important functional change


957
00:25:51,126 --> 00:25:51,336
here.


958
00:25:52,426 --> 00:25:53,686
We now know that a card is


959
00:25:53,686 --> 00:25:55,536
revealed and can tap on it again


960
00:25:55,536 --> 00:25:57,186
to hide it in case it wasn't the


961
00:25:57,186 --> 00:25:57,996
card you remembered.


962
00:25:58,686 --> 00:26:00,906
Now that we've modeled our state


963
00:26:00,906 --> 00:26:02,386
as components and entities, it's


964
00:26:02,386 --> 00:26:04,186
time to take the game to the


965
00:26:04,186 --> 00:26:04,786
next level.


966
00:26:05,316 --> 00:26:06,326
What's something easy we can


967
00:26:06,326 --> 00:26:06,506
add?


968
00:26:11,086 --> 00:26:12,436
Just add multiplayer right?


969
00:26:15,636 --> 00:26:17,706
AR games are fun and playing


970
00:26:17,706 --> 00:26:18,896
with friends makes them even


971
00:26:18,896 --> 00:26:19,286
more fun.


972
00:26:20,666 --> 00:26:21,986
Multiplayer can turn a simple


973
00:26:21,986 --> 00:26:23,386
card matching game into a real


974
00:26:23,386 --> 00:26:25,766
competition, however making a


975
00:26:25,766 --> 00:26:27,576
multiplayer AR game comes with a


976
00:26:27,576 --> 00:26:28,986
few additional challenges that


977
00:26:28,986 --> 00:26:30,476
we don't encounter with non-AR


978
00:26:30,476 --> 00:26:30,886
games.


979
00:26:32,076 --> 00:26:33,356
When they place virtual objects


980
00:26:33,356 --> 00:26:35,056
in the real world, we want them


981
00:26:35,056 --> 00:26:36,516
to be in the same location for


982
00:26:36,516 --> 00:26:37,316
everyone playing the game.


983
00:26:37,316 --> 00:26:39,966
And because everyone is in the


984
00:26:39,966 --> 00:26:41,496
same place, we want updates


985
00:26:41,536 --> 00:26:43,286
between devices to be fast, to


986
00:26:43,286 --> 00:26:44,856
maintain the shared illusion of


987
00:26:44,856 --> 00:26:45,236
reality.


988
00:26:46,376 --> 00:26:47,506
To enable this we built


989
00:26:47,506 --> 00:26:49,276
RealityKit from the ground up to


990
00:26:49,276 --> 00:26:50,446
support multiplayer AR.


991
00:26:51,386 --> 00:26:52,226
Combined with ARKit's


992
00:26:52,226 --> 00:26:53,826
Collaborative Session, also


993
00:26:53,826 --> 00:26:55,576
introduced this year, this gives


994
00:26:55,576 --> 00:26:57,146
you the tools you need to add


995
00:26:57,146 --> 00:26:59,036
multi users support to your AR


996
00:26:59,036 --> 00:26:59,506
experiences.


997
00:27:00,916 --> 00:27:02,146
So let's take a look at what


998
00:27:02,146 --> 00:27:04,816
multiplayer means for our game.


999
00:27:04,956 --> 00:27:05,976
Both players will play


1000
00:27:05,976 --> 00:27:07,986
simultaneously and can turn over


1001
00:27:07,986 --> 00:27:09,156
cards at any time.


1002
00:27:10,486 --> 00:27:11,596
Everyone can see the reveal of


1003
00:27:11,596 --> 00:27:11,986
cards.


1004
00:27:12,146 --> 00:27:13,896
So you can gain an advantage if


1005
00:27:13,896 --> 00:27:15,096
you're paying attention to what


1006
00:27:15,096 --> 00:27:16,346
the other player is doing.


1007
00:27:16,346 --> 00:27:18,726
We'll also add a small white


1008
00:27:18,726 --> 00:27:20,366
circle to indicate to the player


1009
00:27:20,636 --> 00:27:21,976
which card they turned over.


1010
00:27:25,176 --> 00:27:26,616
Let's take a look at multiplayer


1011
00:27:26,816 --> 00:27:27,456
in RealityKit.


1012
00:27:28,236 --> 00:27:29,786
RealityKit provides automatic


1013
00:27:29,916 --> 00:27:30,836
scene synchronization.


1014
00:27:31,676 --> 00:27:33,276
Changes made automatically


1015
00:27:33,276 --> 00:27:35,206
update on all devices.


1016
00:27:36,576 --> 00:27:38,136
Leverages, device discovery, and


1017
00:27:38,136 --> 00:27:39,346
connection for multi peer


1018
00:27:39,346 --> 00:27:39,836
connectivity.


1019
00:27:40,856 --> 00:27:42,316
This makes it simple to find and


1020
00:27:42,316 --> 00:27:43,406
connect to nearby devices


1021
00:27:44,096 --> 00:27:45,756
without maintaining servers or


1022
00:27:45,756 --> 00:27:46,846
even connecting to the same


1023
00:27:46,846 --> 00:27:47,476
Wi-Fi network.


1024
00:27:48,016 --> 00:27:49,966
It provides an easy to use


1025
00:27:49,966 --> 00:27:51,406
ownership model allowing you to


1026
00:27:51,406 --> 00:27:52,826
control which peers are allowed


1027
00:27:52,826 --> 00:27:54,376
to change which entities.


1028
00:27:55,006 --> 00:27:57,986
And provides low latency even on


1029
00:27:57,986 --> 00:27:59,466
busy Wi-Fi networks, which is


1030
00:27:59,466 --> 00:28:00,956
essential for convincing AR


1031
00:28:00,956 --> 00:28:01,496
experiences.


1032
00:28:04,256 --> 00:28:05,826
Let's go through the steps for


1033
00:28:05,826 --> 00:28:07,246
adopting multiplayer for our


1034
00:28:07,246 --> 00:28:07,356
game.


1035
00:28:08,386 --> 00:28:09,786
First we need to designate a


1036
00:28:09,786 --> 00:28:10,156
host.


1037
00:28:10,526 --> 00:28:11,406
We'll place the game board.


1038
00:28:12,696 --> 00:28:13,826
We'll ask the user to select


1039
00:28:13,826 --> 00:28:15,756
this at the game's main menu.


1040
00:28:16,686 --> 00:28:18,486
Then we connect the sessions so


1041
00:28:18,486 --> 00:28:20,116
that they can communicate with


1042
00:28:20,116 --> 00:28:20,426
each other.


1043
00:28:21,686 --> 00:28:23,776
We'll also enable ARkit's


1044
00:28:23,776 --> 00:28:25,326
Collaborative Session, which


1045
00:28:25,326 --> 00:28:26,386
enables our peers to create a


1046
00:28:26,386 --> 00:28:27,726
shared map of the environment.


1047
00:28:28,826 --> 00:28:30,136
And we'll create a synchronized


1048
00:28:30,136 --> 00:28:31,966
anchor, which attaches our game


1049
00:28:31,966 --> 00:28:33,786
board to a specific world


1050
00:28:33,786 --> 00:28:35,566
location and coordinated between


1051
00:28:35,566 --> 00:28:35,956
peers.


1052
00:28:36,786 --> 00:28:38,476
And last, we use ownership to


1053
00:28:38,476 --> 00:28:39,676
make changes to the game board


1054
00:28:40,076 --> 00:28:41,366
such as flipping over the cards


1055
00:28:41,656 --> 00:28:42,316
and removing them.


1056
00:28:43,126 --> 00:28:45,166
We've asked the user to choose


1057
00:28:45,166 --> 00:28:46,356
"host" or "join" from the main


1058
00:28:46,356 --> 00:28:46,676
menu.


1059
00:28:47,406 --> 00:28:48,586
Now we need to establish a


1060
00:28:48,586 --> 00:28:49,056
connection.


1061
00:28:50,286 --> 00:28:51,506
We use the multi peer


1062
00:28:51,506 --> 00:28:53,936
connectivity framework to get


1063
00:28:53,936 --> 00:28:54,396
connected.


1064
00:28:54,396 --> 00:28:56,356
We won't go into all of the


1065
00:28:56,356 --> 00:28:57,416
detail of multi peer


1066
00:28:57,416 --> 00:28:58,946
connectivity here, but if you


1067
00:28:58,946 --> 00:28:59,996
want to know more check out the


1068
00:28:59,996 --> 00:29:02,246
2014 session, Cross Platform


1069
00:29:02,306 --> 00:29:03,006
Nearby Networking.


1070
00:29:04,186 --> 00:29:06,466
First create an MCPeerID and


1071
00:29:06,466 --> 00:29:06,876
MCSession.


1072
00:29:07,976 --> 00:29:09,426
Be sure to enable encryption as


1073
00:29:09,426 --> 00:29:10,556
it's required for use with


1074
00:29:10,556 --> 00:29:11,116
RealityKit.


1075
00:29:14,036 --> 00:29:14,966
We'll check the user's role


1076
00:29:14,966 --> 00:29:15,696
before proceeding.


1077
00:29:16,426 --> 00:29:17,586
If they choose host we'll


1078
00:29:17,586 --> 00:29:19,266
advertise the session using


1079
00:29:19,316 --> 00:29:21,166
MCNearbyServiceAdvertiser.


1080
00:29:21,906 --> 00:29:23,046
This broadcast that we have an


1081
00:29:23,046 --> 00:29:23,766
available session.


1082
00:29:24,416 --> 00:29:26,316
The client creates an


1083
00:29:26,396 --> 00:29:28,366
MCNearbyServiceBrowser to start


1084
00:29:28,366 --> 00:29:29,066
looking for sessions.


1085
00:29:29,936 --> 00:29:30,786
And now that we have an


1086
00:29:30,836 --> 00:29:32,796
MCSession we need to instruct


1087
00:29:32,796 --> 00:29:33,836
RealityKit to use it for


1088
00:29:33,836 --> 00:29:34,586
synchronization.


1089
00:29:35,406 --> 00:29:36,766
We do this by creating a multi


1090
00:29:36,806 --> 00:29:38,706
peer connectivity service, which


1091
00:29:38,706 --> 00:29:40,496
is a RealityKit class that wraps


1092
00:29:40,546 --> 00:29:42,126
the MCSession and makes it


1093
00:29:42,126 --> 00:29:43,086
usable for scene


1094
00:29:43,086 --> 00:29:43,726
synchronization.


1095
00:29:44,626 --> 00:29:45,966
We'll create this and assign it


1096
00:29:45,966 --> 00:29:47,316
to the synchronization service


1097
00:29:47,416 --> 00:29:50,136
property on the scene.


1098
00:29:50,316 --> 00:29:51,246
Now we have two devices


1099
00:29:51,246 --> 00:29:52,566
connected and synching their


1100
00:29:52,566 --> 00:29:52,836
scene.


1101
00:29:53,786 --> 00:29:55,246
However, they don't yet know


1102
00:29:55,246 --> 00:29:56,426
where they are in the physical


1103
00:29:56,426 --> 00:29:57,896
world relative to each other.


1104
00:29:59,076 --> 00:30:00,056
Let's take advantage of the


1105
00:30:00,056 --> 00:30:01,466
collaborative session introduced


1106
00:30:01,466 --> 00:30:03,226
in ARKit 3, which is natively


1107
00:30:03,226 --> 00:30:03,976
supported by RealityKit.


1108
00:30:05,486 --> 00:30:06,786
Collaborative session lets us


1109
00:30:06,786 --> 00:30:07,966
build the world more quickly and


1110
00:30:08,266 --> 00:30:09,776
lets multiple users share the


1111
00:30:09,776 --> 00:30:10,956
same in world experience.


1112
00:30:10,956 --> 00:30:13,646
Since we want collaborative


1113
00:30:13,646 --> 00:30:15,006
mapping we need to turn it on.


1114
00:30:15,646 --> 00:30:16,656
We'll do this at the end of


1115
00:30:16,656 --> 00:30:17,236
viewDidLoad.


1116
00:30:18,226 --> 00:30:19,976
We create a new world tracking


1117
00:30:19,976 --> 00:30:20,756
configuration.


1118
00:30:21,876 --> 00:30:24,016
Set is collaboration enabled to


1119
00:30:25,066 --> 00:30:27,166
true, instruct AR Session to run


1120
00:30:27,166 --> 00:30:27,916
our configuration.


1121
00:30:29,176 --> 00:30:30,736
Now that we have collaborative


1122
00:30:30,736 --> 00:30:32,346
session enabled we can create a


1123
00:30:32,346 --> 00:30:33,856
synchronized anchor.


1124
00:30:34,616 --> 00:30:36,436
Previously we created an anchor


1125
00:30:36,436 --> 00:30:38,266
entity requesting any horizontal


1126
00:30:38,266 --> 00:30:39,536
plane that's at least 20


1127
00:30:39,536 --> 00:30:40,536
centimeters on a side.


1128
00:30:41,386 --> 00:30:42,556
With multiple players we want to


1129
00:30:42,556 --> 00:30:43,586
make sure the board is in a good


1130
00:30:43,626 --> 00:30:44,876
place for two players to walk


1131
00:30:44,876 --> 00:30:45,206
around.


1132
00:30:45,676 --> 00:30:46,996
To ensure this we'll ask the


1133
00:30:46,996 --> 00:30:47,886
host to place the board.


1134
00:30:48,676 --> 00:30:49,926
And since we want the same world


1135
00:30:49,926 --> 00:30:51,636
position on both peers, we'll


1136
00:30:51,636 --> 00:30:53,086
ask ARkit to synchronize this


1137
00:30:53,086 --> 00:30:53,376
anchor.


1138
00:30:54,396 --> 00:30:54,976
How do we do this?


1139
00:30:58,416 --> 00:31:00,516
On the host, we'll use the same


1140
00:31:00,516 --> 00:31:02,066
onTap handler as before.


1141
00:31:03,106 --> 00:31:04,186
We want to pick a spot that's


1142
00:31:04,186 --> 00:31:04,816
good for everybody.


1143
00:31:05,076 --> 00:31:06,486
So we'll raycast into the real


1144
00:31:06,526 --> 00:31:06,736
world.


1145
00:31:07,926 --> 00:31:09,416
This is similar to the hit test


1146
00:31:09,416 --> 00:31:11,296
Ross showed us earlier, however


1147
00:31:11,496 --> 00:31:12,546
this one is run against an


1148
00:31:12,546 --> 00:31:14,006
estimation of the real world


1149
00:31:14,456 --> 00:31:15,696
rather than virtual objects.


1150
00:31:16,236 --> 00:31:17,926
Our game board needs to go on a


1151
00:31:17,926 --> 00:31:19,726
flat surface, so we're asking


1152
00:31:19,726 --> 00:31:20,916
for a horizontal plane.


1153
00:31:21,576 --> 00:31:24,226
If it finds a horizontal plane


1154
00:31:24,696 --> 00:31:25,976
we'll take the world transform


1155
00:31:25,976 --> 00:31:27,176
and use it to create an AR


1156
00:31:27,176 --> 00:31:27,516
anchor.


1157
00:31:28,206 --> 00:31:30,146
This is an ARkit anchor, which


1158
00:31:30,146 --> 00:31:31,296
we add to the AR session


1159
00:31:31,436 --> 00:31:32,286
provided by the view.


1160
00:31:33,126 --> 00:31:34,516
And this creates a synchronized


1161
00:31:34,516 --> 00:31:36,796
anchor whose real world position


1162
00:31:36,796 --> 00:31:38,266
will be coordinated by ARkit.


1163
00:31:39,696 --> 00:31:41,416
Using that AR anchor we'll


1164
00:31:41,416 --> 00:31:42,356
create a RealityKit anchor


1165
00:31:42,356 --> 00:31:42,736
entity.


1166
00:31:43,426 --> 00:31:44,936
This is our bridge between ARkit


1167
00:31:45,106 --> 00:31:47,026
and RealityKit and allows us to


1168
00:31:47,026 --> 00:31:47,706
attach our card.


1169
00:31:47,706 --> 00:31:50,086
And then we have the game board,


1170
00:31:50,236 --> 00:31:51,276
as Ross showed us earlier.


1171
00:31:52,326 --> 00:31:53,506
Only the host needs to build the


1172
00:31:53,506 --> 00:31:54,326
randomized board.


1173
00:31:55,146 --> 00:31:56,116
Everyone else receives it


1174
00:31:56,116 --> 00:31:57,606
automatically via network


1175
00:31:57,606 --> 00:31:58,266
synchronization.


1176
00:31:59,526 --> 00:32:00,636
The models we loaded aren't


1177
00:32:00,636 --> 00:32:01,716
synchronized as part of the


1178
00:32:01,716 --> 00:32:02,996
scene because that would be


1179
00:32:02,996 --> 00:32:03,506
loads of data.


1180
00:32:04,446 --> 00:32:05,666
Remember when Ross showed us how


1181
00:32:05,666 --> 00:32:07,286
to load the card templates?


1182
00:32:07,606 --> 00:32:08,696
Make sure we still do this on


1183
00:32:08,696 --> 00:32:09,296
all appearance.


1184
00:32:10,046 --> 00:32:11,166
And that's enough to get our


1185
00:32:11,166 --> 00:32:12,396
game running.


1186
00:32:15,206 --> 00:32:16,676
On the left we can see that the


1187
00:32:16,676 --> 00:32:17,766
host has placed the board and


1188
00:32:18,056 --> 00:32:18,986
the client can see it.


1189
00:32:19,476 --> 00:32:20,676
It's in the same real world


1190
00:32:20,676 --> 00:32:21,106
location.


1191
00:32:22,076 --> 00:32:23,386
Watch as the host flips over one


1192
00:32:23,386 --> 00:32:24,846
of the objects and then another.


1193
00:32:25,456 --> 00:32:26,536
OK, not a match.


1194
00:32:27,206 --> 00:32:28,226
Notice how it's automatically


1195
00:32:28,226 --> 00:32:29,656
reflected on the client and how


1196
00:32:29,656 --> 00:32:30,856
smooth the animation is.


1197
00:32:31,526 --> 00:32:32,366
No network program here


1198
00:32:32,366 --> 00:32:32,796
required.


1199
00:32:33,776 --> 00:32:34,766
Now watch as the client flips


1200
00:32:34,766 --> 00:32:35,836
over one of the cards.


1201
00:32:36,396 --> 00:32:38,626
it flips over in their screen


1202
00:32:39,076 --> 00:32:40,266
but not on the hosts.


1203
00:32:40,776 --> 00:32:41,926
To explain what's happening I


1204
00:32:41,926 --> 00:32:43,066
need to introduce you to


1205
00:32:43,066 --> 00:32:43,476
ownership.


1206
00:32:44,046 --> 00:32:45,696
What is ownership?


1207
00:32:46,596 --> 00:32:47,976
It's the right to modify an


1208
00:32:47,976 --> 00:32:48,386
entity.


1209
00:32:49,636 --> 00:32:51,496
In a shared session an entity


1210
00:32:51,496 --> 00:32:53,536
has one owner at a time, which


1211
00:32:53,536 --> 00:32:54,816
defaults to whomever created the


1212
00:32:54,816 --> 00:32:55,256
entity.


1213
00:32:56,056 --> 00:32:58,246
In our case that's the host.


1214
00:33:00,226 --> 00:33:02,276
Ownership is transferable, which


1215
00:33:02,276 --> 00:33:03,086
is how you can allow other


1216
00:33:03,176 --> 00:33:04,216
players to make changes.


1217
00:33:05,006 --> 00:33:06,266
And ownership transfer is


1218
00:33:06,266 --> 00:33:08,486
configurable so you can decide


1219
00:33:08,486 --> 00:33:09,196
which entities can be


1220
00:33:09,196 --> 00:33:10,836
transferred and at what times.


1221
00:33:11,926 --> 00:33:13,416
To illustrate ownership let's


1222
00:33:13,416 --> 00:33:14,486
look at what's happening in our


1223
00:33:14,486 --> 00:33:14,686
game.


1224
00:33:17,006 --> 00:33:18,096
The host creates the cards,


1225
00:33:18,546 --> 00:33:19,546
which means it owns them.


1226
00:33:20,126 --> 00:33:22,106
And the cards automatically show


1227
00:33:22,106 --> 00:33:22,866
up on the client.


1228
00:33:23,426 --> 00:33:25,506
When the owner of an entity


1229
00:33:25,506 --> 00:33:27,146
makes the change, such as


1230
00:33:27,146 --> 00:33:29,306
flipping it over, this change is


1231
00:33:29,306 --> 00:33:30,786
sent to the client and reflected


1232
00:33:30,786 --> 00:33:31,316
in their scene.


1233
00:33:32,486 --> 00:33:33,666
Since RealityKit has been built


1234
00:33:33,666 --> 00:33:34,696
from the ground up for


1235
00:33:34,696 --> 00:33:36,036
multiplayer, we're only


1236
00:33:36,106 --> 00:33:37,326
synchronizing the instruction to


1237
00:33:37,326 --> 00:33:38,736
animate, rather than to


1238
00:33:38,736 --> 00:33:39,906
transform every frame.


1239
00:33:40,506 --> 00:33:41,876
This is why it looks so smooth


1240
00:33:41,876 --> 00:33:42,406
on the client.


1241
00:33:43,126 --> 00:33:45,156
Now the client flips over our


1242
00:33:45,156 --> 00:33:45,476
card.


1243
00:33:46,506 --> 00:33:47,756
Since the client does not own


1244
00:33:47,756 --> 00:33:49,756
the entity, the change will not


1245
00:33:49,756 --> 00:33:50,466
get sent to peers.


1246
00:33:51,616 --> 00:33:52,596
While it's still allowed to make


1247
00:33:52,626 --> 00:33:53,956
the changes locally, they're


1248
00:33:53,956 --> 00:33:55,696
likely to get overwritten the


1249
00:33:55,696 --> 00:33:56,706
next time the owner sends an


1250
00:33:56,706 --> 00:33:57,076
update.


1251
00:33:58,096 --> 00:33:59,456
This presents a dilemma because


1252
00:33:59,456 --> 00:34:00,586
we do want to make changes to


1253
00:34:00,586 --> 00:34:00,956
the card.


1254
00:34:01,696 --> 00:34:03,036
So let's go back a step before


1255
00:34:03,036 --> 00:34:04,406
the client had turned over the


1256
00:34:04,406 --> 00:34:04,746
robot.


1257
00:34:05,956 --> 00:34:06,796
So I mentioned earlier,


1258
00:34:07,716 --> 00:34:08,766
ownership can be transferred.


1259
00:34:09,476 --> 00:34:11,315
Any peer can request ownership


1260
00:34:11,315 --> 00:34:11,896
of an entity.


1261
00:34:12,726 --> 00:34:13,815
Let's have the client request


1262
00:34:13,815 --> 00:34:15,275
ownership of a yellow robot


1263
00:34:15,626 --> 00:34:16,806
before making its changes.


1264
00:34:18,106 --> 00:34:19,456
It sends a request to the host


1265
00:34:19,806 --> 00:34:20,726
asking for ownership.


1266
00:34:21,826 --> 00:34:23,036
The entities owner decides


1267
00:34:23,036 --> 00:34:24,166
whether to allow the transfer.


1268
00:34:24,755 --> 00:34:26,076
It may decline if a different


1269
00:34:26,076 --> 00:34:28,186
peer requested ownership or if


1270
00:34:28,186 --> 00:34:29,446
the object's transfer mode was


1271
00:34:29,446 --> 00:34:29,826
changed.


1272
00:34:30,835 --> 00:34:32,565
Since from the default state the


1273
00:34:32,565 --> 00:34:34,496
host accepts the request and


1274
00:34:34,496 --> 00:34:35,846
ownership is transferred to the


1275
00:34:35,846 --> 00:34:36,176
client.


1276
00:34:37,286 --> 00:34:38,856
The client is now free to make


1277
00:34:38,856 --> 00:34:39,726
changes to the card.


1278
00:34:40,505 --> 00:34:42,136
We can reveal the card and the


1279
00:34:42,136 --> 00:34:43,766
changes will be reflected on the


1280
00:34:43,766 --> 00:34:44,186
host.


1281
00:34:45,206 --> 00:34:46,446
And we've made this simple to


1282
00:34:46,446 --> 00:34:46,716
use.


1283
00:34:47,255 --> 00:34:50,306
The client starts by requesting


1284
00:34:50,306 --> 00:34:51,496
ownership of the entity.


1285
00:34:52,485 --> 00:34:53,766
If we all ready own the object


1286
00:34:54,076 --> 00:34:54,516
that's fine.


1287
00:34:55,176 --> 00:34:56,246
The request will be granted


1288
00:34:56,246 --> 00:34:57,586
without doing any additional


1289
00:34:58,166 --> 00:34:58,266
work.


1290
00:34:59,236 --> 00:35:00,106
When the ownership request


1291
00:35:00,106 --> 00:35:01,586
returns we'll be informed


1292
00:35:01,586 --> 00:35:02,926
whether the ownership was


1293
00:35:02,926 --> 00:35:03,266
granted.


1294
00:35:04,046 --> 00:35:05,846
If it was, we'll call reveal on


1295
00:35:05,846 --> 00:35:06,966
the card to flip it over.


1296
00:35:07,996 --> 00:35:09,156
However, if the request was


1297
00:35:09,196 --> 00:35:10,676
denied, for example someone else


1298
00:35:10,676 --> 00:35:12,166
turned it over, we'll give the


1299
00:35:12,166 --> 00:35:13,646
user the opportunity to select a


1300
00:35:13,646 --> 00:35:14,176
different card.


1301
00:35:15,246 --> 00:35:16,246
And that's all we need to flip


1302
00:35:16,246 --> 00:35:17,746
over the card and see it on both


1303
00:35:17,746 --> 00:35:18,096
peers.


1304
00:35:18,676 --> 00:35:19,706
But we want to go one step


1305
00:35:19,766 --> 00:35:20,006
further.


1306
00:35:21,006 --> 00:35:22,466
While the card is revealed, we


1307
00:35:22,466 --> 00:35:24,236
want to keep ownership of it.


1308
00:35:24,966 --> 00:35:26,666
We want to deny any requests to


1309
00:35:26,666 --> 00:35:28,196
take ownership while we have it


1310
00:35:28,196 --> 00:35:28,606
revealed.


1311
00:35:29,576 --> 00:35:30,776
We'll go back to our reveal


1312
00:35:30,776 --> 00:35:30,956
method.


1313
00:35:33,066 --> 00:35:34,656
Here's where we previously set


1314
00:35:34,826 --> 00:35:36,116
the revealed property to true.


1315
00:35:37,166 --> 00:35:38,436
Because we adopted the codable


1316
00:35:38,436 --> 00:35:40,856
protocol on card component, this


1317
00:35:40,926 --> 00:35:42,286
automatically updates on other


1318
00:35:42,286 --> 00:35:42,686
peers.


1319
00:35:42,936 --> 00:35:43,896
There's nothing else to do.


1320
00:35:44,546 --> 00:35:46,726
And after we change the cards


1321
00:35:46,726 --> 00:35:48,916
revealed property to true, set


1322
00:35:48,916 --> 00:35:49,996
the ownership transfer mode to


1323
00:35:49,996 --> 00:35:50,316
manual.


1324
00:35:51,036 --> 00:35:52,936
This automatically denies any


1325
00:35:52,936 --> 00:35:56,226
requests to transfer the entity.


1326
00:35:56,486 --> 00:35:57,756
When we flip the object back to


1327
00:35:57,756 --> 00:35:59,096
hidden we'll want to start


1328
00:35:59,096 --> 00:36:00,286
accepting requests for


1329
00:36:00,286 --> 00:36:00,656
ownership.


1330
00:36:02,036 --> 00:36:03,046
This is what the hide method


1331
00:36:03,046 --> 00:36:03,566
might look like.


1332
00:36:04,856 --> 00:36:05,846
After changing revealed to


1333
00:36:05,896 --> 00:36:07,776
false, we changed the ownership


1334
00:36:07,776 --> 00:36:09,476
transfer mode to auto accept.


1335
00:36:10,286 --> 00:36:11,776
This will instruct RealityKit to


1336
00:36:11,776 --> 00:36:13,126
accept transfer requests for


1337
00:36:13,126 --> 00:36:14,806
this entity automatically.


1338
00:36:16,096 --> 00:36:17,056
One thing that's worth pointing


1339
00:36:17,056 --> 00:36:19,166
out -- the host isn't special


1340
00:36:19,296 --> 00:36:20,196
when it comes to ownership


1341
00:36:21,036 --> 00:36:22,786
because it placed the board, it


1342
00:36:22,926 --> 00:36:24,506
initially owned all the cards,


1343
00:36:25,096 --> 00:36:26,756
but otherwise behaves like any


1344
00:36:26,756 --> 00:36:28,086
other peer.


1345
00:36:28,406 --> 00:36:29,676
Once an object is transferred,


1346
00:36:29,886 --> 00:36:30,946
if the host wants to turn it


1347
00:36:30,946 --> 00:36:32,836
over it needs to request it too.


1348
00:36:34,006 --> 00:36:34,756
You can use the ownership


1349
00:36:34,756 --> 00:36:36,046
transfer mode to change this


1350
00:36:36,046 --> 00:36:37,306
behavior to suit your app.


1351
00:36:38,336 --> 00:36:39,636
And there's one last detail for


1352
00:36:40,336 --> 00:36:41,136
our app.


1353
00:36:41,396 --> 00:36:42,326
When you play with two or more


1354
00:36:42,326 --> 00:36:43,596
players you'll notice that the


1355
00:36:43,596 --> 00:36:44,406
board can get a little


1356
00:36:44,406 --> 00:36:44,976
confusing.


1357
00:36:45,516 --> 00:36:47,096
It could be hard to know what


1358
00:36:47,096 --> 00:36:48,296
piece you've selected and which


1359
00:36:48,296 --> 00:36:49,586
ones were selected by others.


1360
00:36:50,246 --> 00:36:51,636
We'd like to add a transparent


1361
00:36:51,636 --> 00:36:53,026
disk to display our selection.


1362
00:36:53,936 --> 00:36:55,946
As we've seen, everything gets


1363
00:36:55,946 --> 00:36:56,296
shared.


1364
00:36:56,596 --> 00:36:57,846
So that will show for everyone


1365
00:36:57,846 --> 00:36:59,076
and defeat its purpose.


1366
00:37:00,426 --> 00:37:02,256
Fortunately, RealityKit supports


1367
00:37:02,256 --> 00:37:03,366
local-only entities.


1368
00:37:04,206 --> 00:37:05,636
This is ideal for displaying


1369
00:37:05,636 --> 00:37:07,086
selection indicators or hidden


1370
00:37:07,086 --> 00:37:08,576
information like your hand in


1371
00:37:08,576 --> 00:37:08,916
poker.


1372
00:37:09,876 --> 00:37:11,226
And we do this by removing the


1373
00:37:11,226 --> 00:37:12,926
synchronization component and


1374
00:37:12,926 --> 00:37:14,566
otherwise handling the entity


1375
00:37:14,566 --> 00:37:15,266
like any other.


1376
00:37:15,896 --> 00:37:19,166
If the entity has children, they


1377
00:37:19,166 --> 00:37:20,286
will be unshared as well.


1378
00:37:20,776 --> 00:37:21,866
This can be useful to make an


1379
00:37:21,866 --> 00:37:23,716
entire tree of entities local


1380
00:37:23,716 --> 00:37:23,996
only.


1381
00:37:25,316 --> 00:37:26,936
While I'm not showing it here,


1382
00:37:26,936 --> 00:37:28,346
I've created a selection entity


1383
00:37:28,346 --> 00:37:29,526
class that represents our


1384
00:37:29,526 --> 00:37:30,036
selection.


1385
00:37:30,736 --> 00:37:32,186
It's initializer adds a white


1386
00:37:32,466 --> 00:37:33,746
slightly transparent disk.


1387
00:37:35,046 --> 00:37:35,986
Let's take a look at adding it


1388
00:37:35,986 --> 00:37:37,356
to our reveal method from


1389
00:37:37,356 --> 00:37:37,536
earlier.


1390
00:37:38,176 --> 00:37:40,606
We create the entity and


1391
00:37:40,606 --> 00:37:41,996
position it slightly above the


1392
00:37:41,996 --> 00:37:42,316
card.


1393
00:37:43,516 --> 00:37:45,166
Then we assign nil to the


1394
00:37:45,166 --> 00:37:46,196
synchronization component.


1395
00:37:46,866 --> 00:37:48,176
This instructs RealityKit that


1396
00:37:48,176 --> 00:37:49,046
we do not want to share this


1397
00:37:49,046 --> 00:37:49,466
entity.


1398
00:37:50,226 --> 00:37:51,756
And we add the child normally to


1399
00:37:52,196 --> 00:37:53,106
enter the hierarchy.


1400
00:37:54,206 --> 00:37:55,416
Now that we've added it in


1401
00:37:55,416 --> 00:37:56,946
reveal, we need to remove it


1402
00:37:57,016 --> 00:37:57,806
when we hide the card.


1403
00:37:58,336 --> 00:38:00,686
Here's the hide method from


1404
00:38:01,356 --> 00:38:01,506
earlier.


1405
00:38:02,766 --> 00:38:04,026
After changing other properties,


1406
00:38:04,316 --> 00:38:05,486
we'll iterate over the children


1407
00:38:05,746 --> 00:38:06,416
with the for loop.


1408
00:38:07,256 --> 00:38:08,796
We can use the where clause to


1409
00:38:08,796 --> 00:38:10,086
look for entities of type


1410
00:38:10,186 --> 00:38:11,026
selection entity.


1411
00:38:12,206 --> 00:38:14,016
Once we find it we'll remove it


1412
00:38:14,016 --> 00:38:14,556
from its parent.


1413
00:38:15,416 --> 00:38:16,336
Since we know there can only be


1414
00:38:16,336 --> 00:38:17,896
one selection entity, we'll


1415
00:38:17,896 --> 00:38:18,606
break out of the loop.


1416
00:38:19,096 --> 00:38:21,126
And that's it.


1417
00:38:21,456 --> 00:38:22,266
We're handling ownership


1418
00:38:22,266 --> 00:38:23,926
correctly and adding or removing


1419
00:38:23,926 --> 00:38:25,656
a local entity for selection.


1420
00:38:25,966 --> 00:38:27,886
Our game now works correctly


1421
00:38:27,886 --> 00:38:28,816
across two devices.


1422
00:38:29,706 --> 00:38:30,966
And while we've demonstrated


1423
00:38:30,966 --> 00:38:31,846
using two devices for


1424
00:38:31,846 --> 00:38:33,446
simplicity, we can actually


1425
00:38:33,446 --> 00:38:35,676
support more devices without any


1426
00:38:35,676 --> 00:38:36,906
additional code.


1427
00:38:42,906 --> 00:38:43,996
Let's look back at what we've


1428
00:38:44,036 --> 00:38:44,316
learned.


1429
00:38:44,876 --> 00:38:46,236
Today we've shown you how


1430
00:38:46,236 --> 00:38:47,696
RealityKit makes building AR


1431
00:38:47,696 --> 00:38:49,236
Apps easy and fast.


1432
00:38:50,486 --> 00:38:51,506
We've covered how to place


1433
00:38:51,506 --> 00:38:53,656
content with anchoring, load


1434
00:38:53,656 --> 00:38:55,246
assets both synchronous and


1435
00:38:55,246 --> 00:38:57,446
asynchronously, integrate


1436
00:38:57,446 --> 00:38:59,176
interaction in hit testing,


1437
00:39:00,266 --> 00:39:01,346
create custom components in


1438
00:39:01,346 --> 00:39:03,196
entities, and how to add


1439
00:39:03,196 --> 00:39:04,916
multiplayer to augmented reality


1440
00:39:04,916 --> 00:39:05,506
experiences.


1441
00:39:06,506 --> 00:39:07,506
I hope that we've given you a


1442
00:39:07,506 --> 00:39:08,746
better understanding of what


1443
00:39:08,746 --> 00:39:10,236
RealityKit is and what it


1444
00:39:10,236 --> 00:39:10,626
provides.


1445
00:39:11,386 --> 00:39:12,846
We can't wait to see what you do


1446
00:39:12,846 --> 00:39:13,806
with it.


1447
00:39:14,616 --> 00:39:16,246
For more information and access


1448
00:39:16,296 --> 00:39:18,036
to this session video check out


1449
00:39:18,036 --> 00:39:18,966
this session webpage.


1450
00:39:19,916 --> 00:39:21,076
Also check out Introducing


1451
00:39:21,076 --> 00:39:22,686
RealityKit and Reality Composer


1452
00:39:22,956 --> 00:39:23,786
for more information on


1453
00:39:23,786 --> 00:39:25,526
RealityKit and don't miss


1454
00:39:25,526 --> 00:39:27,506
Introducing ARkit 3 to learn


1455
00:39:27,506 --> 00:39:28,816
more about collaborative session


1456
00:39:29,146 --> 00:39:30,116
and other new features.


1457
00:39:31,326 --> 00:39:32,276
And be sure to catch us in the


1458
00:39:32,276 --> 00:39:34,886
labs today at noon and tomorrow


1459
00:39:34,886 --> 00:39:35,506
at 3:00 PM.


1460
00:39:36,966 --> 00:39:38,266
Thanks everyone and please enjoy


1461
00:39:38,266 --> 00:39:38,976
the rest of the conference.


1462
00:39:39,516 --> 00:39:42,500
[ Applause ]

