1
00:00:00,506 --> 00:00:05,500
[ Music ]


2
00:00:12,496 --> 00:00:14,496
[ Applause ]


3
00:00:14,976 --> 00:00:16,666
>> Good morning, and thank you


4
00:00:16,666 --> 00:00:17,616
for coming to our session.


5
00:00:19,206 --> 00:00:21,996
At Apple, we build technologies.


6
00:00:22,936 --> 00:00:24,436
We build technologies so that


7
00:00:24,436 --> 00:00:26,236
you can make great apps with


8
00:00:26,236 --> 00:00:27,356
amazing experiences.


9
00:00:27,886 --> 00:00:30,916
And my favorite apps are the


10
00:00:30,916 --> 00:00:32,296
ones that seamlessly blend those


11
00:00:32,296 --> 00:00:34,096
technologies and really immerse


12
00:00:34,096 --> 00:00:35,166
us in the experience.


13
00:00:36,956 --> 00:00:39,496
Today we'd like to talk to you


14
00:00:39,496 --> 00:00:40,946
about two of these technologies:


15
00:00:41,446 --> 00:00:43,036
Core ML and ARKit.


16
00:00:43,586 --> 00:00:47,026
Both of these help our devices


17
00:00:47,116 --> 00:00:48,666
gain a level of understanding


18
00:00:48,666 --> 00:00:50,466
about the world around us.


19
00:00:51,696 --> 00:00:54,216
They help us blend the physical


20
00:00:54,216 --> 00:00:54,976
and virtual worlds.


21
00:00:57,216 --> 00:00:58,646
Today we're going to take you on


22
00:00:58,646 --> 00:00:59,926
a journey of building an app


23
00:00:59,926 --> 00:01:02,046
that does just that.


24
00:01:02,516 --> 00:01:04,245
Along the way, we're going to


25
00:01:04,245 --> 00:01:05,296
look at some challenges that we


26
00:01:05,296 --> 00:01:07,076
faced and how we overcame them,


27
00:01:07,636 --> 00:01:09,136
and we're going to look at some


28
00:01:09,136 --> 00:01:11,266
themes that arose from facing


29
00:01:11,266 --> 00:01:12,066
those challenges.


30
00:01:13,836 --> 00:01:17,596
The first, being the question,


31
00:01:17,676 --> 00:01:19,486
can machine learning help?


32
00:01:20,656 --> 00:01:23,016
Well, okay, if I said no, then


33
00:01:23,016 --> 00:01:23,886
this would be a pretty short


34
00:01:23,886 --> 00:01:24,166
session.


35
00:01:24,806 --> 00:01:27,286
But I can't just say a blanket


36
00:01:27,286 --> 00:01:29,946
yes, because the answer really


37
00:01:29,946 --> 00:01:31,996
depends on the type of problem


38
00:01:31,996 --> 00:01:33,396
you're trying to solve and the


39
00:01:33,396 --> 00:01:34,836
data you have to solve it,


40
00:01:36,276 --> 00:01:37,366
because machine learning is


41
00:01:37,366 --> 00:01:38,646
about understanding data.


42
00:01:38,646 --> 00:01:40,506
It's about understanding


43
00:01:40,596 --> 00:01:42,486
patterns in data, patterns in


44
00:01:42,486 --> 00:01:44,476
data that may be difficult to


45
00:01:44,476 --> 00:01:45,816
write down programmatically.


46
00:01:46,246 --> 00:01:48,876
And this data exists in your


47
00:01:49,556 --> 00:01:49,746
apps.


48
00:01:50,106 --> 00:01:51,576
Your users enter it every day.


49
00:01:52,236 --> 00:01:53,836
They use the keyboard and they


50
00:01:53,836 --> 00:01:55,246
enter text.


51
00:01:56,216 --> 00:01:57,706
They use the microphone and they


52
00:01:57,706 --> 00:01:58,536
record sound.


53
00:02:00,456 --> 00:02:01,976
They use the camera and they


54
00:02:01,976 --> 00:02:03,726
capture video and pictures.


55
00:02:04,246 --> 00:02:07,006
So when facing a problem, asking


56
00:02:07,006 --> 00:02:08,466
yourself, can machine learning


57
00:02:08,466 --> 00:02:10,265
help, is a good question to ask.


58
00:02:10,705 --> 00:02:12,536
Now, you need to take a close


59
00:02:12,536 --> 00:02:13,256
look at the problem you're


60
00:02:13,256 --> 00:02:15,016
trying to solve and the data you


61
00:02:15,016 --> 00:02:16,726
have available to solve it.


62
00:02:19,656 --> 00:02:20,986
The second theme that we're


63
00:02:20,986 --> 00:02:22,806
going to look at today is


64
00:02:22,806 --> 00:02:23,886
understanding the behavior of


65
00:02:23,886 --> 00:02:25,076
your model.


66
00:02:25,996 --> 00:02:28,276
These models are trained to


67
00:02:28,276 --> 00:02:30,326
expect certain inputs in certain


68
00:02:30,326 --> 00:02:33,376
formats and to provide outputs


69
00:02:33,426 --> 00:02:35,036
in certain formats.


70
00:02:35,616 --> 00:02:38,806
And so if your input is not in


71
00:02:38,806 --> 00:02:40,176
the format that's expected for


72
00:02:40,176 --> 00:02:42,856
the model, then the output is


73
00:02:42,856 --> 00:02:44,046
going to be unexpected as well.


74
00:02:44,046 --> 00:02:48,046
And speaking of outputs, if you


75
00:02:48,046 --> 00:02:49,026
don't understand what's being


76
00:02:49,026 --> 00:02:50,326
output from your model, it's


77
00:02:50,326 --> 00:02:51,736
going to be difficult to use it


78
00:02:52,176 --> 00:02:53,616
to make that magical experience


79
00:02:53,616 --> 00:02:54,886
in your app.


80
00:02:56,136 --> 00:02:57,396
We're going to look at a couple


81
00:02:57,396 --> 00:02:59,316
ways that you can visualize the


82
00:02:59,316 --> 00:03:01,186
inputs and the outputs of some


83
00:03:01,186 --> 00:03:01,726
models.


84
00:03:02,206 --> 00:03:04,836
But for now, on with our


85
00:03:04,836 --> 00:03:05,116
journey.


86
00:03:06,166 --> 00:03:07,666
We said that we're going to


87
00:03:07,666 --> 00:03:09,456
combine technologies to blend


88
00:03:09,456 --> 00:03:10,776
the physical and virtual worlds,


89
00:03:10,836 --> 00:03:12,786
and what better context to do


90
00:03:12,786 --> 00:03:14,606
this in than an app?


91
00:03:14,706 --> 00:03:16,986
We thought that it would be fun


92
00:03:17,276 --> 00:03:18,716
to build an educational game app


93
00:03:18,806 --> 00:03:20,526
for children to practice their


94
00:03:20,526 --> 00:03:23,376
math skills, like counting, or


95
00:03:23,376 --> 00:03:24,986
addition, or multiplication.


96
00:03:25,796 --> 00:03:28,306
And we know that children


97
00:03:28,306 --> 00:03:29,746
sometimes use dice to practice


98
00:03:29,746 --> 00:03:30,266
these skills.


99
00:03:30,906 --> 00:03:32,266
Now, we could've just put


100
00:03:32,616 --> 00:03:35,036
virtual dice in the app and let


101
00:03:35,036 --> 00:03:36,406
those roll around on the screen,


102
00:03:36,656 --> 00:03:37,806
but we thought, wouldn't it be a


103
00:03:37,806 --> 00:03:39,946
lot more fun if the children


104
00:03:39,946 --> 00:03:41,236
could play with physical dice


105
00:03:41,236 --> 00:03:42,856
and roll those on the table and


106
00:03:43,396 --> 00:03:45,086
then interact with our app?


107
00:03:46,336 --> 00:03:47,996
So that's what we did.


108
00:03:48,296 --> 00:03:50,586
And the first challenge that we


109
00:03:50,586 --> 00:03:54,396
ran into was, how do you get an


110
00:03:54,396 --> 00:03:55,646
app to recognize dice?


111
00:03:56,146 --> 00:03:58,676
Well, there's a couple


112
00:03:58,676 --> 00:03:59,306
approaches.


113
00:04:00,266 --> 00:04:01,906
Let's start programmatically.


114
00:04:02,526 --> 00:04:04,666
But this is going to be a little


115
00:04:05,046 --> 00:04:05,306
difficult.


116
00:04:06,616 --> 00:04:08,106
If we constrain our problem to


117
00:04:08,106 --> 00:04:10,256
only six-sided dice, we can


118
00:04:10,256 --> 00:04:11,446
start to look at the properties


119
00:04:11,446 --> 00:04:11,726
of a die.


120
00:04:12,536 --> 00:04:14,666
For instance, the die behind me,


121
00:04:14,666 --> 00:04:15,606
its color is gray.


122
00:04:16,935 --> 00:04:19,466
But not all dice are gray, so


123
00:04:19,466 --> 00:04:21,536
that's not necessarily helpful.


124
00:04:22,856 --> 00:04:24,926
If you look at it in a 2D plane,


125
00:04:25,476 --> 00:04:26,876
it's a hexagon shape and it has


126
00:04:26,986 --> 00:04:28,596
three skewed squares for sides.


127
00:04:30,206 --> 00:04:31,926
But those move and change as the


128
00:04:31,926 --> 00:04:33,176
die rolls around on the table.


129
00:04:33,836 --> 00:04:36,416
If we take a closer look at each


130
00:04:36,416 --> 00:04:38,396
side, there's a number of dots


131
00:04:38,396 --> 00:04:40,096
on them; but again, that's


132
00:04:40,256 --> 00:04:41,426
different depending on the side


133
00:04:41,426 --> 00:04:42,966
you're looking at and depending


134
00:04:42,966 --> 00:04:44,236
on your perspective of the die.


135
00:04:45,426 --> 00:04:47,066
So with all of these properties


136
00:04:47,346 --> 00:04:49,476
changing, it's going to be


137
00:04:49,476 --> 00:04:50,726
pretty difficult to write a


138
00:04:50,876 --> 00:04:52,476
program to recognize dice.


139
00:04:52,866 --> 00:04:56,106
So let's take a look at the


140
00:04:56,106 --> 00:04:56,976
machine learning approach.


141
00:05:00,536 --> 00:05:02,376
We could train an image


142
00:05:02,376 --> 00:05:04,216
classification model to


143
00:05:04,216 --> 00:05:06,146
recognize dice in an image.


144
00:05:06,706 --> 00:05:10,996
But we want to know how many


145
00:05:10,996 --> 00:05:12,766
dice are in an image -- not just


146
00:05:12,766 --> 00:05:14,346
the existence of dice in an


147
00:05:14,346 --> 00:05:14,706
image.


148
00:05:15,896 --> 00:05:17,356
So instead, we looked at using


149
00:05:17,356 --> 00:05:18,426
an object detection model.


150
00:05:18,986 --> 00:05:21,056
An object detection model will


151
00:05:21,056 --> 00:05:22,316
tell us if there's dice in an


152
00:05:22,316 --> 00:05:24,366
image, but it will also tell us


153
00:05:24,366 --> 00:05:26,076
where it is in the image; and if


154
00:05:26,076 --> 00:05:27,176
we know where the dice are in


155
00:05:27,176 --> 00:05:29,446
the image, then we can count


156
00:05:30,476 --> 00:05:30,606
them.


157
00:05:30,786 --> 00:05:32,596
To do this, we needed to get


158
00:05:32,596 --> 00:05:34,846
data, so we took a bunch of


159
00:05:34,846 --> 00:05:37,336
pictures of dice rolling around


160
00:05:37,606 --> 00:05:38,116
on the table.


161
00:05:38,606 --> 00:05:41,436
Next, we took those pictures and


162
00:05:41,436 --> 00:05:43,286
we annotated them with bounding


163
00:05:43,286 --> 00:05:44,886
boxes, indicating where the dice


164
00:05:44,886 --> 00:05:45,906
are in the images.


165
00:05:46,226 --> 00:05:49,486
After that, we used the new


166
00:05:49,486 --> 00:05:51,276
Create ML to train our custom


167
00:05:51,276 --> 00:05:52,246
object detection model.


168
00:05:54,716 --> 00:05:56,026
If you'd like to learn more


169
00:05:56,026 --> 00:05:57,966
about this training, please see


170
00:05:57,966 --> 00:05:59,046
the Create ML for Object


171
00:05:59,046 --> 00:05:59,936
Detection and Sound


172
00:05:59,936 --> 00:06:00,876
Classification session.


173
00:06:00,876 --> 00:06:04,806
Now I'd like to invite Scott up


174
00:06:04,806 --> 00:06:06,356
to show you this in action.


175
00:06:07,596 --> 00:06:07,896
Scott?


176
00:06:08,516 --> 00:06:13,036
[ Applause ]


177
00:06:13,536 --> 00:06:14,496
>> Good morning, everyone.


178
00:06:14,936 --> 00:06:15,176
>> Morning!


179
00:06:17,136 --> 00:06:18,246
>> As Brent discussed, we're


180
00:06:18,246 --> 00:06:19,916
going to be exploring adding the


181
00:06:19,916 --> 00:06:21,516
ability for our app to count


182
00:06:21,516 --> 00:06:23,006
dice using a machine learning


183
00:06:23,006 --> 00:06:24,006
technique called object


184
00:06:24,006 --> 00:06:24,446
detection.


185
00:06:25,066 --> 00:06:26,396
And I'm sure you're all eager to


186
00:06:26,396 --> 00:06:27,726
see it in action, so let's get


187
00:06:27,726 --> 00:06:29,000
right to it.


188
00:06:38,536 --> 00:06:40,736
So here, we have a very simple


189
00:06:40,946 --> 00:06:41,996
app that's wired with a live


190
00:06:41,996 --> 00:06:43,586
camera view, and we've added our


191
00:06:43,586 --> 00:06:44,866
object detector trained to


192
00:06:44,866 --> 00:06:46,516
detect dice so that we can count


193
00:06:46,516 --> 00:06:46,706
them.


194
00:06:47,196 --> 00:06:48,236
So let's see what happens when


195
00:06:48,236 --> 00:06:49,366
we add dice to the frame.


196
00:06:50,766 --> 00:06:55,896
One, two, three, and four.


197
00:06:56,056 --> 00:06:59,056
We can even take a roll for more


198
00:06:59,056 --> 00:06:59,366
fun.


199
00:07:00,066 --> 00:07:02,416
So this is great.


200
00:07:02,416 --> 00:07:04,446
Our app is able to count dice


201
00:07:04,786 --> 00:07:05,866
using object detection.


202
00:07:06,476 --> 00:07:07,836
But one of the themes that we


203
00:07:07,836 --> 00:07:09,066
want to discuss with you today


204
00:07:09,066 --> 00:07:10,476
is understanding your model's


205
00:07:10,506 --> 00:07:10,966
behavior.


206
00:07:11,416 --> 00:07:13,616
So let's actually take a look at


207
00:07:13,616 --> 00:07:15,286
a debug visualization of what


208
00:07:15,286 --> 00:07:16,436
the model is seeing.


209
00:07:17,006 --> 00:07:18,096
As you can see, we're drawing


210
00:07:18,096 --> 00:07:20,066
bounding boxes around each of


211
00:07:20,066 --> 00:07:21,926
the detected objects -- in this


212
00:07:21,926 --> 00:07:23,576
case, dice -- on the board.


213
00:07:23,576 --> 00:07:25,216
And if we move them around,


214
00:07:25,566 --> 00:07:28,396
those boxes will move as well.


215
00:07:28,606 --> 00:07:30,346
This is important to you because


216
00:07:30,346 --> 00:07:32,756
if you are training an object


217
00:07:32,756 --> 00:07:34,606
detector and you start playing


218
00:07:34,606 --> 00:07:35,946
around with it, and you don't


219
00:07:35,946 --> 00:07:37,416
notice certain boxes around


220
00:07:37,416 --> 00:07:38,556
objects that aren't what you're


221
00:07:38,556 --> 00:07:40,826
trying to detect, or you're not


222
00:07:40,886 --> 00:07:42,156
seeing boxes around the objects


223
00:07:42,156 --> 00:07:43,436
that you are trying to detect,


224
00:07:43,846 --> 00:07:45,276
this is probably the opportunity


225
00:07:45,276 --> 00:07:46,536
for you to go and collect more


226
00:07:46,536 --> 00:07:47,866
data in this kind of lighting.


227
00:07:48,376 --> 00:07:49,746
You may want to collect more


228
00:07:49,746 --> 00:07:50,726
data with different kinds of


229
00:07:50,726 --> 00:07:52,786
backgrounds, different lighting,


230
00:07:53,096 --> 00:07:54,276
with a different number of


231
00:07:54,276 --> 00:07:55,756
objects -- in this case, we have


232
00:07:55,836 --> 00:07:56,716
four, but you may want to


233
00:07:56,716 --> 00:07:58,486
collect with five, six, up to


234
00:07:58,486 --> 00:08:00,706
ten dice, or less, or even


235
00:08:00,706 --> 00:08:02,066
images without them to train it


236
00:08:02,066 --> 00:08:03,746
to not recognize other objects.


237
00:08:07,076 --> 00:08:09,116
Let's take a look at some code


238
00:08:09,116 --> 00:08:11,346
to do this.


239
00:08:11,506 --> 00:08:12,566
When you use your object


240
00:08:12,566 --> 00:08:13,536
detector that you've trained


241
00:08:13,536 --> 00:08:15,186
with Create ML, in the Vision


242
00:08:15,186 --> 00:08:16,796
framework, what you get back as


243
00:08:16,796 --> 00:08:18,056
a result is a list of VN


244
00:08:18,056 --> 00:08:19,586
recognized object observations.


245
00:08:20,316 --> 00:08:21,536
So here we have a function that


246
00:08:21,536 --> 00:08:22,846
handles those observations and


247
00:08:22,846 --> 00:08:23,946
does a couple things for us.


248
00:08:24,526 --> 00:08:25,746
The first one is the easiest:


249
00:08:26,286 --> 00:08:27,146
we're just counting dice.


250
00:08:27,606 --> 00:08:29,106
And this just is as simple as


251
00:08:29,106 --> 00:08:29,806
counting the number of


252
00:08:29,806 --> 00:08:31,076
observations because we have one


253
00:08:31,156 --> 00:08:31,766
per die.


254
00:08:32,326 --> 00:08:34,716
Next, we have a couple helper


255
00:08:34,716 --> 00:08:36,035
functions that help us draw


256
00:08:36,035 --> 00:08:37,566
these bounding boxes on screen


257
00:08:37,676 --> 00:08:39,666
based on these recognized object


258
00:08:39,666 --> 00:08:40,346
observations.


259
00:08:40,936 --> 00:08:43,145
We have a first function that


260
00:08:43,145 --> 00:08:44,636
matched the bounds you get from


261
00:08:44,636 --> 00:08:46,316
each recognized object


262
00:08:46,316 --> 00:08:47,826
observation, which come in


263
00:08:47,966 --> 00:08:50,186
normalized coordinates based on


264
00:08:50,186 --> 00:08:51,656
the input image you provide to


265
00:08:51,656 --> 00:08:53,936
Vision, so that function maps


266
00:08:54,006 --> 00:08:55,316
those back to our view


267
00:08:55,316 --> 00:08:56,496
controller's views coordinate


268
00:08:56,496 --> 00:08:57,366
system so that we can


269
00:08:57,366 --> 00:08:58,546
appropriately draw them on


270
00:08:58,606 --> 00:09:00,606
screen, overlaying them on top


271
00:09:00,606 --> 00:09:01,466
of the actual objects.


272
00:09:03,026 --> 00:09:04,376
Next we have a helper function


273
00:09:04,376 --> 00:09:06,836
that creates our beautiful


274
00:09:07,106 --> 00:09:08,416
rounded rectangles that we


275
00:09:08,416 --> 00:09:10,326
display on screen, which is a


276
00:09:10,396 --> 00:09:13,276
CALayer, and we add that CALayer


277
00:09:13,276 --> 00:09:15,256
to an overlay layer to be


278
00:09:15,256 --> 00:09:15,986
rendered on screen.


279
00:09:16,656 --> 00:09:17,886
All this code is available in


280
00:09:17,886 --> 00:09:19,276
the sample app associated with


281
00:09:19,276 --> 00:09:20,536
this session, which I encourage


282
00:09:20,536 --> 00:09:22,876
you to check out.


283
00:09:23,136 --> 00:09:25,246
So this is really promising: our


284
00:09:25,486 --> 00:09:27,566
app is able to count dice using


285
00:09:27,566 --> 00:09:28,296
object detection.


286
00:09:29,216 --> 00:09:30,716
But you may have already


287
00:09:30,716 --> 00:09:32,686
realized or thought about the


288
00:09:32,686 --> 00:09:34,236
fact that games typically don't


289
00:09:34,236 --> 00:09:35,886
rely on the count of dice; they


290
00:09:35,886 --> 00:09:37,196
typically rely on the values


291
00:09:37,236 --> 00:09:37,866
displayed on them.


292
00:09:38,796 --> 00:09:40,436
So we need to take this one step


293
00:09:40,486 --> 00:09:42,416
further and figure out how to


294
00:09:42,416 --> 00:09:43,706
recognize the values displayed


295
00:09:43,706 --> 00:09:45,586
on these dice.


296
00:09:45,796 --> 00:09:47,166
This is ultimately the goal that


297
00:09:47,166 --> 00:09:49,446
we want our app to have: we want


298
00:09:49,446 --> 00:09:50,376
it to be able to tell that the


299
00:09:50,376 --> 00:09:52,476
die on the right side is a 5 and


300
00:09:52,476 --> 00:09:55,156
the one on the left is a 1.


301
00:09:55,366 --> 00:09:57,166
Luckily for us, as Brent


302
00:09:57,166 --> 00:09:59,476
mentioned, object detectors can


303
00:09:59,576 --> 00:10:01,106
not only detect but classify


304
00:10:01,106 --> 00:10:02,626
objects, because they're built


305
00:10:02,626 --> 00:10:04,196
to be able to recognize all


306
00:10:04,196 --> 00:10:05,496
sorts of different objects and


307
00:10:05,496 --> 00:10:05,916
images.


308
00:10:06,666 --> 00:10:09,636
So we went ahead and updated all


309
00:10:09,636 --> 00:10:11,186
our training data to actually


310
00:10:11,186 --> 00:10:12,936
consider dice with different


311
00:10:12,936 --> 00:10:14,376
values to be of a different


312
00:10:14,376 --> 00:10:16,246
class, just like you can see on


313
00:10:16,246 --> 00:10:16,766
the screen.


314
00:10:18,796 --> 00:10:21,136
So this sounded really


315
00:10:21,136 --> 00:10:22,856
promising, and so we gave it a


316
00:10:22,856 --> 00:10:24,246
try in our app.


317
00:10:24,246 --> 00:10:26,286
Let's take a look at some of the


318
00:10:26,286 --> 00:10:27,516
examples that we ran into.


319
00:10:27,566 --> 00:10:30,406
In most cases, it worked


320
00:10:30,446 --> 00:10:31,126
perfectly fine.


321
00:10:31,416 --> 00:10:32,566
As you can see in the picture


322
00:10:32,866 --> 00:10:34,866
behind me, our object detector


323
00:10:34,866 --> 00:10:36,396
is able to correctly and


324
00:10:36,436 --> 00:10:38,036
accurately detect and classify


325
00:10:38,036 --> 00:10:39,026
the dice on the left of the


326
00:10:39,026 --> 00:10:42,446
screen; but if we focus in on


327
00:10:42,446 --> 00:10:44,506
the other side, we can see that


328
00:10:44,506 --> 00:10:45,846
our object detector is actually


329
00:10:45,846 --> 00:10:47,736
detecting the 6 and the 4 as one


330
00:10:47,766 --> 00:10:48,266
single die.


331
00:10:49,816 --> 00:10:50,766
And if we think a little bit


332
00:10:50,766 --> 00:10:52,986
about what's happening, it's


333
00:10:52,986 --> 00:10:54,616
clear that the model isn't able


334
00:10:54,616 --> 00:10:56,476
to tell those apart as two


335
00:10:56,476 --> 00:10:58,986
separate dice, and it really


336
00:10:58,986 --> 00:11:00,246
comes down to the fact that the


337
00:11:00,246 --> 00:11:01,966
4 is being occluded by the one


338
00:11:01,966 --> 00:11:02,346
in front.


339
00:11:03,646 --> 00:11:05,266
So after thinking about this a


340
00:11:05,266 --> 00:11:06,936
little bit, what we realized was


341
00:11:06,936 --> 00:11:09,356
that we really care about the


342
00:11:09,356 --> 00:11:11,296
tops of these dice, and those


343
00:11:11,296 --> 00:11:12,796
are always visible in our frame.


344
00:11:13,946 --> 00:11:15,916
So we went ahead and we helped


345
00:11:15,916 --> 00:11:17,396
our model a little bit.


346
00:11:17,846 --> 00:11:19,616
We updated all our training data


347
00:11:19,776 --> 00:11:21,436
to actually focus in on the tops


348
00:11:21,436 --> 00:11:21,896
of these dice.


349
00:11:22,566 --> 00:11:24,616
So now we're actually training


350
00:11:24,616 --> 00:11:26,256
an object detector, not to


351
00:11:26,256 --> 00:11:27,996
detect dice, but to detect tops


352
00:11:27,996 --> 00:11:28,316
of dice.


353
00:11:29,406 --> 00:11:30,506
So let's take a look at what


354
00:11:30,506 --> 00:11:31,326
happened when we did that.


355
00:11:31,756 --> 00:11:34,326
As you can see, our model was


356
00:11:34,326 --> 00:11:36,646
still able to correctly predict


357
00:11:36,766 --> 00:11:39,206
and classify the same dice as


358
00:11:39,206 --> 00:11:41,726
before, but now it's also able


359
00:11:41,726 --> 00:11:43,786
to correctly detect and identify


360
00:11:43,786 --> 00:11:44,516
the dice on the right.


361
00:11:47,476 --> 00:11:48,916
We wanted to share with you


362
00:11:48,916 --> 00:11:49,926
another anecdote today.


363
00:11:51,396 --> 00:11:53,396
At some point along our journey,


364
00:11:53,886 --> 00:11:55,946
we noticed this behavior, where


365
00:11:55,946 --> 00:11:57,466
our model was actually detecting


366
00:11:57,726 --> 00:11:58,896
the left side of the dice,


367
00:11:59,046 --> 00:11:59,666
consistently.


368
00:12:01,076 --> 00:12:02,146
This was very confusing at


369
00:12:02,146 --> 00:12:04,096
first, but if we actually rotate


370
00:12:04,096 --> 00:12:05,936
this image, we can understand


371
00:12:06,006 --> 00:12:07,106
how the model thought these were


372
00:12:07,106 --> 00:12:07,616
the tops.


373
00:12:08,496 --> 00:12:09,816
This was super easy to realize


374
00:12:10,056 --> 00:12:10,986
as soon as we looked at the


375
00:12:10,986 --> 00:12:12,356
input of our model.


376
00:12:13,146 --> 00:12:14,486
We were simply not handling the


377
00:12:14,486 --> 00:12:15,966
image orientation according to


378
00:12:15,966 --> 00:12:17,426
our device's orientation, which


379
00:12:17,426 --> 00:12:18,616
is a very common problem for


380
00:12:18,616 --> 00:12:20,266
Vision tasks.


381
00:12:20,266 --> 00:12:21,926
So the key lesson here is, if


382
00:12:21,926 --> 00:12:23,506
you notice odd behavior in your


383
00:12:23,506 --> 00:12:25,046
model's output, it doesn't hurt


384
00:12:25,046 --> 00:12:26,056
to take a look at the input.


385
00:12:26,896 --> 00:12:29,336
It may be as simple as rotating


386
00:12:29,336 --> 00:12:30,466
your image based on the


387
00:12:30,466 --> 00:12:33,276
orientation of the device.


388
00:12:33,446 --> 00:12:34,756
So let's see this new model in


389
00:12:34,796 --> 00:12:35,000
action.


390
00:12:43,696 --> 00:12:45,026
So here we have the same app,


391
00:12:45,686 --> 00:12:47,356
but we updated it to have our


392
00:12:47,546 --> 00:12:49,326
model that's able to detect and


393
00:12:49,356 --> 00:12:51,666
classify diced as well.


394
00:12:51,766 --> 00:12:52,816
For simplicity, I'm going to


395
00:12:52,816 --> 00:12:53,756
focus on three dice.


396
00:12:54,216 --> 00:12:56,286
We can see that our model is


397
00:12:56,716 --> 00:12:58,406
predicting 6, 5 and 2.


398
00:12:59,426 --> 00:12:59,976
So let's take a roll.


399
00:13:02,996 --> 00:13:04,476
Four, 6 and 5.


400
00:13:05,316 --> 00:13:06,566
Awesome. This is really


401
00:13:06,566 --> 00:13:06,936
promising.


402
00:13:07,516 --> 00:13:10,716
[ Applause ]


403
00:13:11,216 --> 00:13:12,076
So I want to bring your


404
00:13:12,076 --> 00:13:13,756
attention to a detail here that


405
00:13:13,806 --> 00:13:14,856
I think is very important.


406
00:13:15,606 --> 00:13:17,296
If I move the dice around, you


407
00:13:17,296 --> 00:13:18,656
can see that the list updates.


408
00:13:19,146 --> 00:13:20,816
We're actually displaying the


409
00:13:20,816 --> 00:13:22,566
list of values according to the


410
00:13:22,566 --> 00:13:24,146
order in which the dice are laid


411
00:13:24,146 --> 00:13:24,786
out on the table.


412
00:13:25,476 --> 00:13:26,916
This is a minor design detail,


413
00:13:27,396 --> 00:13:29,426
but it really brings consistency


414
00:13:29,426 --> 00:13:30,576
to the experience, because the


415
00:13:30,576 --> 00:13:32,166
user is seeing these dice laid


416
00:13:32,166 --> 00:13:33,266
out in that fashion on the


417
00:13:33,266 --> 00:13:33,586
table.


418
00:13:34,126 --> 00:13:36,196
So since we're blending the


419
00:13:36,196 --> 00:13:37,506
physical and virtual worlds,


420
00:13:38,186 --> 00:13:40,976
we're actually giving the user a


421
00:13:42,246 --> 00:13:43,876
very consistent display of the


422
00:13:43,876 --> 00:13:44,406
predictions.


423
00:13:45,536 --> 00:13:46,436
There's another thing we need to


424
00:13:46,436 --> 00:13:48,446
figure out: when does a roll


425
00:13:48,446 --> 00:13:48,696
end?


426
00:13:49,626 --> 00:13:51,466
Again, games typically don't


427
00:13:51,466 --> 00:13:53,936
rely on transient states of a


428
00:13:53,936 --> 00:13:55,516
roll; they rely on the result of


429
00:13:55,516 --> 00:13:55,636
a roll.


430
00:13:55,636 --> 00:13:57,086
When you play a game, you roll


431
00:13:57,086 --> 00:13:58,546
some dice, and based on the


432
00:13:58,546 --> 00:14:00,836
result of that, your pawn either


433
00:14:00,836 --> 00:14:02,696
moves or you make some decision.


434
00:14:02,776 --> 00:14:04,276
In this case, we may want to


435
00:14:04,366 --> 00:14:05,806
animate something or provide


436
00:14:05,876 --> 00:14:06,996
feedback to the user.


437
00:14:07,276 --> 00:14:08,386
And you may have noticed in the


438
00:14:08,386 --> 00:14:10,036
demos that I just showed, I


439
00:14:10,036 --> 00:14:11,516
didn't show the numbers until


440
00:14:11,516 --> 00:14:12,326
the roll had ended.


441
00:14:13,086 --> 00:14:14,726
So how do we do this?


442
00:14:15,656 --> 00:14:16,736
Well, first we need to ask our


443
00:14:16,736 --> 00:14:18,336
self, what do we observe?


444
00:14:19,906 --> 00:14:21,756
In this case, we notice that the


445
00:14:21,756 --> 00:14:23,816
dice stop moving and the values


446
00:14:23,816 --> 00:14:25,336
are stable between different


447
00:14:25,336 --> 00:14:26,026
camera frames.


448
00:14:27,196 --> 00:14:28,696
So can machine learning help us


449
00:14:28,696 --> 00:14:28,926
here?


450
00:14:29,966 --> 00:14:32,716
Perhaps we could build a


451
00:14:32,716 --> 00:14:34,056
sequential model that takes in


452
00:14:34,096 --> 00:14:36,026
frames and decides when the roll


453
00:14:36,026 --> 00:14:37,636
has ended, but we already have a


454
00:14:37,636 --> 00:14:38,886
model that has a really good


455
00:14:38,886 --> 00:14:40,126
understanding of dice on the


456
00:14:40,126 --> 00:14:40,416
table.


457
00:14:40,816 --> 00:14:42,466
So what we really need to do is


458
00:14:42,466 --> 00:14:43,496
interpret the output of our


459
00:14:43,496 --> 00:14:43,816
model.


460
00:14:46,256 --> 00:14:47,746
So let's take a look at how to


461
00:14:47,746 --> 00:14:50,386
do this in code.


462
00:14:50,586 --> 00:14:51,956
Here we have a function that


463
00:14:51,956 --> 00:14:54,046
takes in two lists of object


464
00:14:54,046 --> 00:14:55,416
observations: one from the


465
00:14:55,416 --> 00:14:56,906
current camera frame and one


466
00:14:56,966 --> 00:14:58,286
from the previous camera frame.


467
00:14:59,336 --> 00:15:00,276
So there's a few things we need


468
00:15:00,276 --> 00:15:01,746
to check in order to decide that


469
00:15:01,776 --> 00:15:02,526
the roll has ended.


470
00:15:03,476 --> 00:15:05,396
The first is, do we have as many


471
00:15:05,396 --> 00:15:06,946
dice now as we had before?


472
00:15:07,996 --> 00:15:10,046
If not, maybe one die has


473
00:15:10,046 --> 00:15:11,206
entered the camera frame, so we


474
00:15:11,206 --> 00:15:12,346
now have more than before.


475
00:15:12,836 --> 00:15:14,226
If we have less than before,


476
00:15:14,536 --> 00:15:15,796
maybe one of them is bouncing


477
00:15:15,796 --> 00:15:17,186
around so the detector isn't


478
00:15:17,186 --> 00:15:18,526
picking that up.


479
00:15:19,216 --> 00:15:21,246
So if we don't have as many now


480
00:15:21,376 --> 00:15:22,986
as before, the roll is still


481
00:15:23,016 --> 00:15:23,336
happening.


482
00:15:23,816 --> 00:15:26,036
Next we're going to compare each


483
00:15:26,036 --> 00:15:27,366
of the observations in the


484
00:15:27,366 --> 00:15:29,586
previous prediction and in the


485
00:15:29,586 --> 00:15:30,136
current one.


486
00:15:31,516 --> 00:15:32,876
If the values represented on top


487
00:15:32,876 --> 00:15:35,606
of the dice aren't the same, our


488
00:15:35,606 --> 00:15:37,306
roll has not ended yet.


489
00:15:38,036 --> 00:15:40,186
And we also check that the


490
00:15:40,186 --> 00:15:41,456
bounding boxes overlap between


491
00:15:41,456 --> 00:15:42,666
these predictions by more than


492
00:15:42,666 --> 00:15:43,366
85%.


493
00:15:44,296 --> 00:15:45,576
If the bounding boxes between


494
00:15:45,576 --> 00:15:46,776
the prediction we're looking at


495
00:15:46,776 --> 00:15:48,036
and the one we're comparing it


496
00:15:48,036 --> 00:15:49,736
with don't overlap, either we're


497
00:15:49,736 --> 00:15:50,666
looking at two completely


498
00:15:50,666 --> 00:15:54,086
different dice, or it's the same


499
00:15:54,086 --> 00:15:55,036
one that has moved by a


500
00:15:55,096 --> 00:15:55,846
significant amount.


501
00:15:57,106 --> 00:15:59,726
Finally, if we have as many


502
00:15:59,726 --> 00:16:01,306
matches now as we have dice on


503
00:16:01,306 --> 00:16:02,956
the table, the roll has ended.


504
00:16:03,466 --> 00:16:07,966
So now that our app can find,


505
00:16:08,126 --> 00:16:11,156
count, recognize dice on a table


506
00:16:11,196 --> 00:16:13,516
and figuring out the end of a


507
00:16:13,516 --> 00:16:15,486
roll, we have a foundation for


508
00:16:15,756 --> 00:16:16,576
building something more.


509
00:16:17,206 --> 00:16:18,246
And it's time to talk about the


510
00:16:18,246 --> 00:16:19,186
next steps of our journey.


511
00:16:19,976 --> 00:16:21,536
To do that, I'd like to welcome


512
00:16:21,536 --> 00:16:22,516
Brent back up to the stage.


513
00:16:23,516 --> 00:16:26,036
[ Applause ]


514
00:16:26,536 --> 00:16:27,036
>> Thank you, Scott.


515
00:16:29,406 --> 00:16:30,456
All right.


516
00:16:30,456 --> 00:16:33,436
As Scott said, our app can now


517
00:16:33,436 --> 00:16:34,816
recognize dice on the table.


518
00:16:35,906 --> 00:16:36,836
The next thing we need to look


519
00:16:36,836 --> 00:16:39,076
at is, how do we handle user


520
00:16:39,076 --> 00:16:39,426
input?


521
00:16:39,426 --> 00:16:42,706
We know that our users are going


522
00:16:42,706 --> 00:16:44,016
to be entering numbers into our


523
00:16:44,016 --> 00:16:45,046
app, because we're practicing


524
00:16:45,046 --> 00:16:45,776
math skills.


525
00:16:45,846 --> 00:16:48,716
And we could've just put a large


526
00:16:48,716 --> 00:16:50,146
number pad up on the screen and


527
00:16:50,146 --> 00:16:51,386
have them tap in the numbers,


528
00:16:51,716 --> 00:16:53,816
but we wanted to facilitate a


529
00:16:53,816 --> 00:16:55,656
more natural interaction with


530
00:16:55,656 --> 00:16:55,896
the app.


531
00:16:56,146 --> 00:16:58,226
And remember: we're working with


532
00:16:58,226 --> 00:17:00,116
children here, and children are


533
00:17:00,116 --> 00:17:01,386
also practicing writing their


534
00:17:01,386 --> 00:17:01,936
numbers.


535
00:17:02,596 --> 00:17:04,846
So we thought, why not just let


536
00:17:04,846 --> 00:17:06,435
them draw directly on the


537
00:17:06,435 --> 00:17:06,856
screen?


538
00:17:06,856 --> 00:17:10,516
Well, to do this, we're going to


539
00:17:10,516 --> 00:17:11,256
need our app to be able to


540
00:17:11,256 --> 00:17:12,806
recognize handwritten digits.


541
00:17:13,976 --> 00:17:15,506
Fortunately, machine learning is


542
00:17:15,506 --> 00:17:16,695
already doing a very good job at


543
00:17:16,695 --> 00:17:18,786
solving this problem; in fact,


544
00:17:19,106 --> 00:17:20,236
there's an entire dataset


545
00:17:20,236 --> 00:17:22,156
available to let you train your


546
00:17:22,156 --> 00:17:23,205
own models to recognize


547
00:17:23,266 --> 00:17:24,026
handwritten digits.


548
00:17:24,026 --> 00:17:25,086
It's called MNIST.


549
00:17:26,396 --> 00:17:28,185
Well, we did that, and we put


550
00:17:28,185 --> 00:17:29,726
that model on our new Core ML


551
00:17:29,726 --> 00:17:30,406
Models page.


552
00:17:31,576 --> 00:17:33,346
So let's take a look in code at


553
00:17:33,346 --> 00:17:34,436
how we'd use this model.


554
00:17:35,336 --> 00:17:36,396
We're going to use Vision and


555
00:17:36,396 --> 00:17:37,076
PencilKit here.


556
00:17:37,676 --> 00:17:40,696
We set up Vision to use our Core


557
00:17:40,696 --> 00:17:42,226
ML model; in this case,


558
00:17:42,226 --> 00:17:43,066
MNISTClassifier.


559
00:17:43,536 --> 00:17:47,756
Next, we get our image from the


560
00:17:47,756 --> 00:17:48,796
PencilKit canvas view.


561
00:17:48,966 --> 00:17:52,876
After that, we set up our Vision


562
00:17:52,876 --> 00:17:54,436
request handler to use that


563
00:17:54,436 --> 00:17:54,906
image.


564
00:17:56,356 --> 00:17:59,286
Then, we perform the request and


565
00:17:59,286 --> 00:18:00,076
we get the results.


566
00:18:00,076 --> 00:18:00,976
It's as easy as that.


567
00:18:03,576 --> 00:18:04,956
So we integrated this into our


568
00:18:04,956 --> 00:18:07,916
model, and it started working


569
00:18:08,076 --> 00:18:08,616
pretty well.


570
00:18:08,616 --> 00:18:10,716
We were recognizing quite a few


571
00:18:10,716 --> 00:18:11,596
handwritten digits.


572
00:18:14,276 --> 00:18:15,976
But as we started drawing some


573
00:18:15,976 --> 00:18:17,506
larger digits, we noticed


574
00:18:17,506 --> 00:18:19,856
something interesting: our model


575
00:18:19,856 --> 00:18:20,766
was sometimes getting the


576
00:18:20,766 --> 00:18:21,906
predictions incorrect.


577
00:18:22,696 --> 00:18:24,566
So what's happening?


578
00:18:24,946 --> 00:18:27,646
Well, to understand, we need to


579
00:18:27,646 --> 00:18:30,236
see what image is being input to


580
00:18:30,236 --> 00:18:30,706
our model.


581
00:18:30,706 --> 00:18:33,186
And we can do that in Xcode.


582
00:18:34,286 --> 00:18:36,626
So we set a break point where we


583
00:18:36,626 --> 00:18:38,096
get the image from PencilKit,


584
00:18:38,096 --> 00:18:40,886
and we use Xcode's quick view to


585
00:18:41,206 --> 00:18:42,406
actually look at what that image


586
00:18:42,406 --> 00:18:42,826
is.


587
00:18:42,956 --> 00:18:44,996
And when we did, we saw


588
00:18:44,996 --> 00:18:47,456
something interesting: our 7s


589
00:18:47,456 --> 00:18:49,766
from the example are not looking


590
00:18:49,766 --> 00:18:51,126
like 7s to the model.


591
00:18:51,786 --> 00:18:52,956
They're looking a lot more like


592
00:18:52,956 --> 00:18:53,446
1s.


593
00:18:54,006 --> 00:18:56,396
So what's happening here?


594
00:18:56,396 --> 00:19:00,066
We need to think about what the


595
00:19:00,066 --> 00:19:01,506
model's expecting for an input.


596
00:19:02,956 --> 00:19:05,506
This model is expecting a 28 by


597
00:19:05,506 --> 00:19:08,796
28 pixel image, but the image


598
00:19:08,796 --> 00:19:10,156
that we get drawn on the screen


599
00:19:10,156 --> 00:19:11,846
is much bigger than that.


600
00:19:13,096 --> 00:19:14,406
So to get the image in the right


601
00:19:14,456 --> 00:19:15,836
format, we have to downscale it.


602
00:19:16,656 --> 00:19:18,716
But as we downscaled it, we lost


603
00:19:18,716 --> 00:19:20,026
information about the strokes


604
00:19:20,026 --> 00:19:20,836
that were being drawn on the


605
00:19:20,836 --> 00:19:23,006
screen, and our 7s started


606
00:19:23,006 --> 00:19:24,316
looking a lot more like 1s.


607
00:19:24,716 --> 00:19:28,376
Once we knew that, the fix was


608
00:19:28,406 --> 00:19:29,786
pretty easy: we just needed to


609
00:19:29,786 --> 00:19:31,016
have a thicker stroke on the


610
00:19:31,016 --> 00:19:31,476
screen.


611
00:19:31,556 --> 00:19:35,046
And when we did that, after we


612
00:19:35,046 --> 00:19:37,006
downscaled, our images going to


613
00:19:37,006 --> 00:19:38,806
the model looked a lot more like


614
00:19:38,806 --> 00:19:39,776
what was being drawn on the


615
00:19:39,776 --> 00:19:41,766
screen, and the model started


616
00:19:41,766 --> 00:19:43,446
getting the predictions correct.


617
00:19:44,836 --> 00:19:46,386
PencilKit makes this really


618
00:19:46,386 --> 00:19:46,616
easy.


619
00:19:47,786 --> 00:19:49,746
Here we have allowsFingerDrawing


620
00:19:49,746 --> 00:19:51,436
set to true, since we're drawing


621
00:19:51,436 --> 00:19:52,726
on the screen with our fingers;


622
00:19:52,856 --> 00:19:56,826
and then, we set the tool to be


623
00:19:56,906 --> 00:19:57,556
something like a marker with a


624
00:19:57,556 --> 00:19:57,976
thicker stroke.


625
00:20:01,356 --> 00:20:01,976
All right.


626
00:20:01,976 --> 00:20:04,416
Our model is now predicting


627
00:20:05,426 --> 00:20:07,706
single digits really well, but


628
00:20:08,396 --> 00:20:09,906
we have another couple


629
00:20:09,906 --> 00:20:10,536
challenges.


630
00:20:11,396 --> 00:20:13,766
Some digits are written with


631
00:20:13,766 --> 00:20:14,976
multiple strokes.


632
00:20:15,506 --> 00:20:19,096
Our model takes a static image


633
00:20:19,176 --> 00:20:20,796
of a digit, not stroke


634
00:20:20,796 --> 00:20:21,926
information about that digit.


635
00:20:23,016 --> 00:20:24,466
So how do we know when to take


636
00:20:24,766 --> 00:20:26,126
what's being drawn on the screen


637
00:20:26,196 --> 00:20:28,416
and pass it to our model to get


638
00:20:29,126 --> 00:20:30,276
a prediction?


639
00:20:30,276 --> 00:20:33,816
Additionally, since we're adding


640
00:20:33,816 --> 00:20:35,246
dice or possibly multiplying


641
00:20:35,246 --> 00:20:36,576
dice, we may be working with


642
00:20:36,576 --> 00:20:37,566
numbers that have multiple


643
00:20:37,566 --> 00:20:39,896
digits, and our model is only


644
00:20:39,896 --> 00:20:41,116
trained to recognize single


645
00:20:41,116 --> 00:20:43,236
digits, not multiple digits.


646
00:20:44,096 --> 00:20:45,726
So how do we handle that?


647
00:20:46,496 --> 00:20:47,586
We could've used machine


648
00:20:47,586 --> 00:20:48,606
learning to solve these


649
00:20:48,606 --> 00:20:48,956
problems.


650
00:20:48,956 --> 00:20:50,456
We could've trained a model to


651
00:20:50,456 --> 00:20:51,796
recognize stroke information


652
00:20:51,796 --> 00:20:54,156
about digits, or we could've


653
00:20:54,156 --> 00:20:55,686
trained a model to recognize


654
00:20:55,686 --> 00:20:56,936
numbers with multiple digits,


655
00:20:56,986 --> 00:20:58,826
but we already know a lot of


656
00:20:58,826 --> 00:21:00,086
information about what's being


657
00:21:00,086 --> 00:21:00,876
drawn on the screen.


658
00:21:01,386 --> 00:21:03,236
So instead, we decided to solve


659
00:21:03,236 --> 00:21:04,576
this problem programmatically,


660
00:21:04,876 --> 00:21:05,896
and I'll show you how.


661
00:21:06,426 --> 00:21:08,676
Let's take this example.


662
00:21:09,736 --> 00:21:11,116
Someone draws the first stroke


663
00:21:11,116 --> 00:21:12,426
of a 1 on the screen.


664
00:21:12,426 --> 00:21:15,406
We take that, we pass it as an


665
00:21:15,406 --> 00:21:16,626
image to our model, and we get a


666
00:21:16,626 --> 00:21:17,796
prediction, and it's a 1.


667
00:21:19,246 --> 00:21:20,766
Next, they draw the second


668
00:21:20,766 --> 00:21:23,766
stroke of a 1, the base.


669
00:21:23,966 --> 00:21:25,616
We look to see if any of that


670
00:21:25,616 --> 00:21:27,676
stroke is overlapping any of the


671
00:21:27,676 --> 00:21:28,216
first stroke.


672
00:21:29,086 --> 00:21:30,836
Since it is, we know that it's


673
00:21:30,836 --> 00:21:32,976
the same number, so we get rid


674
00:21:32,976 --> 00:21:34,716
of the first prediction, we


675
00:21:34,716 --> 00:21:35,916
combine the first stroke with


676
00:21:35,916 --> 00:21:37,756
the second stroke into one


677
00:21:37,756 --> 00:21:39,296
image, and we pass that entire


678
00:21:39,296 --> 00:21:40,026
image to the model.


679
00:21:40,136 --> 00:21:41,916
And that gets predicted to be a


680
00:21:41,916 --> 00:21:42,156
1.


681
00:21:42,696 --> 00:21:45,536
Next, the user draws another


682
00:21:45,536 --> 00:21:46,326
stroke on the screen.


683
00:21:47,546 --> 00:21:49,176
We look at that third stroke and


684
00:21:49,176 --> 00:21:51,926
see if any of it overlaps either


685
00:21:51,926 --> 00:21:52,876
of the first two strokes.


686
00:21:53,746 --> 00:21:55,306
Since it doesn't, we know that


687
00:21:55,306 --> 00:21:56,906
it's a separate number, so we


688
00:21:56,906 --> 00:21:58,226
pass it separately to the model,


689
00:21:58,226 --> 00:22:02,356
and it gets predicted to be a 2.


690
00:22:02,596 --> 00:22:03,516
Now I'd like to invite Scott


691
00:22:03,516 --> 00:22:05,756
back up to show you this in the


692
00:22:05,826 --> 00:22:06,126
app.


693
00:22:06,126 --> 00:22:06,416
Scott?


694
00:22:07,516 --> 00:22:11,416
[ Applause ]


695
00:22:11,916 --> 00:22:12,316
>> Thanks, Brent.


696
00:22:13,136 --> 00:22:15,166
We now have an updated app that


697
00:22:15,266 --> 00:22:16,876
still has our object detector


698
00:22:16,876 --> 00:22:18,316
that's able to detect and


699
00:22:18,536 --> 00:22:20,716
classify dice and their values,


700
00:22:21,136 --> 00:22:22,536
but we've also added the ability


701
00:22:22,606 --> 00:22:23,856
to draw input just like Brent


702
00:22:23,856 --> 00:22:24,486
discussed with you.


703
00:22:25,716 --> 00:22:27,576
So I think it's time to do some


704
00:22:27,576 --> 00:22:27,726
math.


705
00:22:30,276 --> 00:22:31,796
Here, the user has the option to


706
00:22:31,796 --> 00:22:33,426
either add the values displayed


707
00:22:33,426 --> 00:22:34,986
on the dice or multiply them.


708
00:22:35,306 --> 00:22:36,726
And so to keep things simple,


709
00:22:36,726 --> 00:22:37,406
I'm going to start with


710
00:22:37,406 --> 00:22:37,816
addition.


711
00:22:38,426 --> 00:22:40,066
So let's see how input handling


712
00:22:40,066 --> 00:22:40,266
works.


713
00:22:44,896 --> 00:22:45,036
Yes.


714
00:22:46,516 --> 00:22:50,626
[ Applause ]


715
00:22:51,126 --> 00:22:53,516
So if we multiply these values,


716
00:22:53,516 --> 00:22:55,036
I'm pretty sure we get 24.


717
00:22:56,036 --> 00:22:56,876
Now, that's an interesting


718
00:22:56,876 --> 00:22:57,316
number.


719
00:22:57,826 --> 00:22:58,666
I want you to pay close


720
00:22:58,666 --> 00:23:00,146
attention to what happens when I


721
00:23:00,146 --> 00:23:01,226
draw the 4 on screen.


722
00:23:02,756 --> 00:23:04,236
If you think about a 4 that's


723
00:23:04,236 --> 00:23:06,076
drawn with two strokes, our


724
00:23:06,076 --> 00:23:07,086
model's going to have a pretty


725
00:23:07,086 --> 00:23:08,336
hard time figuring out that's a


726
00:23:08,456 --> 00:23:10,046
4 when it only sees the first


727
00:23:10,046 --> 00:23:11,746
stroke, so it may predict some


728
00:23:11,746 --> 00:23:13,396
other digit until I draw the


729
00:23:13,396 --> 00:23:13,966
second stroke.


730
00:23:15,066 --> 00:23:15,626
Let's have a look.


731
00:23:21,276 --> 00:23:22,646
Did you notice that the first


732
00:23:22,646 --> 00:23:24,046
stroke of my 4 was predicted as


733
00:23:24,046 --> 00:23:25,676
a 1, but as soon as I had the


734
00:23:25,726 --> 00:23:27,176
second stroke, that was a 4?


735
00:23:27,946 --> 00:23:30,646
There's one other answer that is


736
00:23:30,716 --> 00:23:33,026
always correct, and I just want


737
00:23:33,026 --> 00:23:34,376
to show you more 4s, so let's


738
00:23:34,546 --> 00:23:34,746
try it.


739
00:23:40,426 --> 00:23:43,846
Cool. So our app can recognize


740
00:23:43,846 --> 00:23:45,316
dice on the table, understand a


741
00:23:45,316 --> 00:23:47,576
roll, it can check our math, we


742
00:23:47,576 --> 00:23:50,806
can input that using drawing to


743
00:23:50,996 --> 00:23:52,716
draw the digits on screen, but


744
00:23:52,716 --> 00:23:53,896
we're talking about blending the


745
00:23:53,896 --> 00:23:55,246
physical and virtual worlds


746
00:23:55,246 --> 00:23:56,846
together, so we thought it would


747
00:23:56,846 --> 00:23:58,526
be a lot of fun and also very


748
00:23:58,526 --> 00:24:01,036
interactive if the kids playing


749
00:24:01,036 --> 00:24:02,606
with our game could input their


750
00:24:02,606 --> 00:24:04,116
answers in the form of voice.


751
00:24:04,786 --> 00:24:07,766
So let's take a look at that.


752
00:24:07,766 --> 00:24:09,416
Again, I'm going to add or


753
00:24:09,416 --> 00:24:10,756
multiply these two together and


754
00:24:10,756 --> 00:24:11,516
get 24.


755
00:24:11,926 --> 00:24:13,646
And let's do that using speech.


756
00:24:14,906 --> 00:24:16,096
Twenty-four.


757
00:24:17,616 --> 00:24:18,466
Cool.


758
00:24:21,276 --> 00:24:22,686
This is super easy to do using


759
00:24:22,686 --> 00:24:23,396
the speech framework.


760
00:24:23,966 --> 00:24:29,836
And new this year in speech, we


761
00:24:29,836 --> 00:24:32,166
have offline speech recognition.


762
00:24:33,096 --> 00:24:34,406
This means that speech


763
00:24:34,406 --> 00:24:35,756
recognition can work in your app


764
00:24:36,126 --> 00:24:37,566
even when your device is not


765
00:24:37,566 --> 00:24:38,516
connected to the internet.


766
00:24:39,566 --> 00:24:41,586
And if you really want your


767
00:24:41,586 --> 00:24:43,746
user's data to remain on their


768
00:24:43,746 --> 00:24:45,696
device, you can actually require


769
00:24:45,696 --> 00:24:47,236
speech recognition to happen on


770
00:24:47,236 --> 00:24:48,226
device by setting


771
00:24:48,506 --> 00:24:50,026
requiresOnDeviceRecognition to


772
00:24:50,026 --> 00:24:50,946
true on your speech recognizer.


773
00:24:54,406 --> 00:24:56,326
So now our app can understand a


774
00:24:56,326 --> 00:24:58,206
dice roll and handle input in


775
00:24:58,206 --> 00:25:00,716
various different ways, but we


776
00:25:00,716 --> 00:25:02,706
need to move on with our journey


777
00:25:02,796 --> 00:25:04,856
and finish this up.


778
00:25:05,116 --> 00:25:06,206
So I'd like to welcome Brent


779
00:25:06,206 --> 00:25:06,956
back up to the stage.


780
00:25:07,516 --> 00:25:10,536
[ Applause ]


781
00:25:11,036 --> 00:25:11,546
>> Thank you, Scott.


782
00:25:17,576 --> 00:25:21,566
As Scott mentioned, we have our


783
00:25:21,566 --> 00:25:24,616
app recognizing dice, and we


784
00:25:24,616 --> 00:25:26,696
know how to handle user input.


785
00:25:27,366 --> 00:25:29,156
But we said this was going to be


786
00:25:29,156 --> 00:25:29,896
a game, right?


787
00:25:30,626 --> 00:25:34,026
So let's make it that.


788
00:25:34,026 --> 00:25:36,066
Next we're going to integrate in


789
00:25:36,066 --> 00:25:38,196
ARKit and really finalize the


790
00:25:38,196 --> 00:25:39,116
whole experience.


791
00:25:39,666 --> 00:25:45,266
Of course, any game needs rules,


792
00:25:45,546 --> 00:25:48,566
so let's go over those first.


793
00:25:50,416 --> 00:25:52,706
Our game is played on a circular


794
00:25:52,706 --> 00:25:54,516
board with nine sections.


795
00:25:55,206 --> 00:25:58,026
Each player starts on section


796
00:25:58,026 --> 00:26:00,606
one, and the goal is to move


797
00:26:00,606 --> 00:26:02,486
clockwise around the board and


798
00:26:02,486 --> 00:26:04,666
land directly on section nine.


799
00:26:05,286 --> 00:26:09,536
A roll that's too small, and you


800
00:26:09,536 --> 00:26:11,226
don't go far enough.


801
00:26:12,656 --> 00:26:14,556
A roll that's too large, and


802
00:26:14,556 --> 00:26:16,396
you're going to overshoot your


803
00:26:18,596 --> 00:26:18,706
goal.


804
00:26:18,906 --> 00:26:20,256
During each player's turn, they


805
00:26:20,256 --> 00:26:22,616
roll the dice, and they have two


806
00:26:22,616 --> 00:26:25,496
options: they can take the sum


807
00:26:25,496 --> 00:26:27,516
of that dice and move that


808
00:26:27,516 --> 00:26:28,836
number in a clockwise direction,


809
00:26:29,666 --> 00:26:30,856
or they can take the difference


810
00:26:30,856 --> 00:26:33,006
of the dice and move that number


811
00:26:33,046 --> 00:26:33,926
in a clockwise direction.


812
00:26:35,166 --> 00:26:38,426
So Scott, you up for a game?


813
00:26:39,516 --> 00:26:43,500
[ Applause ]


814
00:26:50,356 --> 00:26:51,496
>> So we've now integrated our


815
00:26:51,496 --> 00:26:53,766
virtual board into our ARKit


816
00:26:53,806 --> 00:26:56,246
game that's also using Core ML


817
00:26:56,576 --> 00:26:57,366
to recognize dice.


818
00:26:58,036 --> 00:26:59,366
How about you start off, Brent?


819
00:26:59,666 --> 00:27:00,126
>> Sounds good.


820
00:27:01,306 --> 00:27:02,456
All right.


821
00:27:02,976 --> 00:27:06,356
The 5 -- I've got a 5 and a 2.


822
00:27:06,356 --> 00:27:07,046
All right.


823
00:27:07,046 --> 00:27:09,976
I think I'm going to add those.


824
00:27:15,376 --> 00:27:15,686
>> All right.


825
00:27:16,446 --> 00:27:17,656
Ooh, you got really close.


826
00:27:17,726 --> 00:27:17,976
>> Close.


827
00:27:22,056 --> 00:27:24,996
>> So we got 6 and 1; I can


828
00:27:24,996 --> 00:27:27,116
either subtract these and get 5


829
00:27:27,186 --> 00:27:29,436
or add them and join Brent on


830
00:27:29,436 --> 00:27:30,966
the 8 slot, so let's add these.


831
00:27:37,796 --> 00:27:38,276
>> All right.


832
00:27:38,516 --> 00:27:41,236
I don't think I'm going to be


833
00:27:41,236 --> 00:27:42,626
able to get a 1.


834
00:27:42,626 --> 00:27:42,806
Let's see.


835
00:27:47,776 --> 00:27:49,316
I think I'll subtract this time.


836
00:27:49,316 --> 00:27:49,826
Let me do a 2.


837
00:27:59,676 --> 00:28:01,446
>> Okay. So I got 6 and 1 again.


838
00:28:01,686 --> 00:28:02,746
This time I'm going to change it


839
00:28:02,746 --> 00:28:04,546
up and do a 5.


840
00:28:05,506 --> 00:28:07,746
And Brent really thinks -- yeah.


841
00:28:08,866 --> 00:28:10,066
Brent thinks I draw funny 5s.


842
00:28:10,926 --> 00:28:13,946
>> You know, this game could


843
00:28:13,946 --> 00:28:16,496
probably go on pretty long, but


844
00:28:16,986 --> 00:28:18,876
I think Scott might've mentioned


845
00:28:18,876 --> 00:28:20,786
something about a number always


846
00:28:20,786 --> 00:28:23,366
being correct, so let's see if


847
00:28:23,366 --> 00:28:23,926
this works in our game.


848
00:28:28,326 --> 00:28:29,646
>> Ah, you found the secret,


849
00:28:29,646 --> 00:28:29,966
Brent.


850
00:28:30,976 --> 00:28:31,536
Good job.


851
00:28:31,776 --> 00:28:31,976
>> Success.


852
00:28:32,516 --> 00:28:37,500
[ Applause ]


853
00:28:43,626 --> 00:28:44,086
All right.


854
00:28:44,736 --> 00:28:47,466
Today we looked at combining


855
00:28:47,516 --> 00:28:49,686
multiple technologies together


856
00:28:49,806 --> 00:28:51,376
to blend our physical and


857
00:28:51,376 --> 00:28:52,186
virtual worlds.


858
00:28:53,436 --> 00:28:54,686
We built an experience that goes


859
00:28:54,686 --> 00:28:56,566
beyond any single technology and


860
00:28:57,016 --> 00:28:58,646
it let us play this fun game in


861
00:28:58,646 --> 00:28:59,996
this enhanced new world.


862
00:29:01,366 --> 00:29:03,606
We used object detection to


863
00:29:03,606 --> 00:29:07,326
recognize dice on the table.


864
00:29:07,466 --> 00:29:09,476
We used image classification to


865
00:29:09,476 --> 00:29:11,246
recognize handwritten digits on


866
00:29:11,246 --> 00:29:11,706
the screen.


867
00:29:12,916 --> 00:29:14,556
We used speech recognition as


868
00:29:14,556 --> 00:29:15,606
another way to interact with our


869
00:29:15,606 --> 00:29:15,886
app.


870
00:29:16,266 --> 00:29:18,636
And we brought in ARKit to


871
00:29:18,636 --> 00:29:19,976
really finalize the whole


872
00:29:19,976 --> 00:29:20,666
experience.


873
00:29:22,376 --> 00:29:23,996
If you'd like more information,


874
00:29:24,766 --> 00:29:26,856
please see our session 228 on


875
00:29:26,856 --> 00:29:28,616
the developer website or come


876
00:29:28,676 --> 00:29:30,096
talk to us in the labs tomorrow.


877
00:29:30,716 --> 00:29:32,416
Thank you, and have a great rest


878
00:29:32,416 --> 00:29:32,756
of the show.


879
00:29:33,508 --> 00:29:35,508
[ Applause ]

