1
00:00:00,506 --> 00:00:04,516
[ Music ]


2
00:00:05,516 --> 00:00:07,546
[ Applause ]


3
00:00:08,045 --> 00:00:10,456
>> Hello and welcome to Advances


4
00:00:10,456 --> 00:00:11,786
in Networking Part 2.


5
00:00:12,356 --> 00:00:13,686
If you couldn't join us for Part


6
00:00:13,686 --> 00:00:15,056
1, it will be available for


7
00:00:15,056 --> 00:00:16,766
streaming soon on the app and on


8
00:00:16,766 --> 00:00:17,046
the web.


9
00:00:18,486 --> 00:00:19,806
I'm Eric Kinnear from Internet


10
00:00:19,806 --> 00:00:20,456
Technologies.


11
00:00:20,706 --> 00:00:21,866
I'll be joined today by my


12
00:00:21,866 --> 00:00:23,506
colleagues Tommy and Stuart.


13
00:00:23,986 --> 00:00:26,566
We've got a lot to cover in Part


14
00:00:26,566 --> 00:00:26,746
2.


15
00:00:27,226 --> 00:00:28,336
We're going to start by


16
00:00:28,336 --> 00:00:29,946
expanding the horizons of what


17
00:00:29,946 --> 00:00:31,036
you can do with Bonjour


18
00:00:31,036 --> 00:00:31,466
browsing.


19
00:00:32,235 --> 00:00:33,146
We'll talk about how you can


20
00:00:33,146 --> 00:00:35,236
achieve efficient and easy


21
00:00:35,236 --> 00:00:36,886
message transport by building


22
00:00:36,886 --> 00:00:37,726
framing protocols.


23
00:00:38,406 --> 00:00:39,556
We'll take a look at some new


24
00:00:39,726 --> 00:00:41,126
and improved metric collection.


25
00:00:41,356 --> 00:00:42,746
And we'll finish off with some


26
00:00:42,746 --> 00:00:44,286
status updates and some best


27
00:00:44,286 --> 00:00:45,866
practices to help networking in


28
00:00:45,866 --> 00:00:47,766
your app become the best it can


29
00:00:47,766 --> 00:00:47,986
be.


30
00:00:49,476 --> 00:00:50,846
Before we begin, a brief


31
00:00:50,846 --> 00:00:51,246
reminder.


32
00:00:52,646 --> 00:00:54,506
If you're using URLSession and


33
00:00:54,506 --> 00:00:55,876
Network.framework, you'll be


34
00:00:55,876 --> 00:00:56,786
able to take advantage of


35
00:00:56,876 --> 00:00:57,946
everything we're talking about


36
00:00:57,946 --> 00:00:58,166
today.


37
00:00:59,116 --> 00:01:00,826
If you're not, these are some


38
00:01:00,826 --> 00:01:02,146
additional reasons why you


39
00:01:02,146 --> 00:01:03,256
should switch to a more modern


40
00:01:03,256 --> 00:01:05,525
networking API.


41
00:01:05,786 --> 00:01:07,546
Let's jump right in with Bonjour


42
00:01:09,676 --> 00:01:09,876
browsing.


43
00:01:09,986 --> 00:01:11,666
Bonjour is how you advertise and


44
00:01:11,666 --> 00:01:12,876
discover services on the


45
00:01:12,876 --> 00:01:13,256
network.


46
00:01:13,656 --> 00:01:15,666
It's used anytime you print with


47
00:01:15,666 --> 00:01:17,886
AirPrint, connect to an


48
00:01:17,886 --> 00:01:19,906
airplane-enabled device, use


49
00:01:19,906 --> 00:01:21,356
HomeKit to automate your home,


50
00:01:21,776 --> 00:01:23,356
really anytime you are


51
00:01:23,356 --> 00:01:24,726
connecting to something without


52
00:01:24,726 --> 00:01:26,456
typing in an IP address or a


53
00:01:26,456 --> 00:01:26,946
host name.


54
00:01:27,766 --> 00:01:29,306
And as you know, Bonjour is


55
00:01:29,306 --> 00:01:30,426
available on all Apple


56
00:01:30,426 --> 00:01:30,976
platforms.


57
00:01:31,546 --> 00:01:33,156
And it's also available on


58
00:01:33,156 --> 00:01:36,226
Linux, Android, Chrome OS, it's


59
00:01:36,226 --> 00:01:37,566
how Chromecast does discovery.


60
00:01:38,486 --> 00:01:39,886
What you may not know is that


61
00:01:39,886 --> 00:01:41,476
Microsoft also quietly added


62
00:01:41,476 --> 00:01:43,346
Bonjour support to Windows 10


63
00:01:43,346 --> 00:01:44,426
back in 2015.


64
00:01:45,316 --> 00:01:46,076
And since then the


65
00:01:46,076 --> 00:01:47,216
implementation has matured.


66
00:01:48,066 --> 00:01:49,416
This means that Bonjour is now


67
00:01:49,416 --> 00:01:51,006
available on every major


68
00:01:51,006 --> 00:01:51,456
platform.


69
00:01:53,876 --> 00:01:55,866
Today, we've got some exciting


70
00:01:55,866 --> 00:01:56,866
enhancements to share in this


71
00:01:56,866 --> 00:01:57,196
area.


72
00:01:57,706 --> 00:01:59,416
Sometimes you're on one network


73
00:02:00,006 --> 00:02:00,846
and you'd like to discover


74
00:02:00,846 --> 00:02:02,336
services that are available on a


75
00:02:02,336 --> 00:02:03,016
different network.


76
00:02:03,606 --> 00:02:04,996
Say you've got a device and


77
00:02:04,996 --> 00:02:06,226
you'd like to print to a printer


78
00:02:06,726 --> 00:02:08,286
that's on a different subnet and


79
00:02:08,286 --> 00:02:09,356
multiple hops away.


80
00:02:10,196 --> 00:02:11,616
Right now, you would send


81
00:02:11,616 --> 00:02:13,286
multicast packets on your local


82
00:02:13,286 --> 00:02:14,546
network and you wouldn't hear


83
00:02:14,546 --> 00:02:15,436
anything back.


84
00:02:16,606 --> 00:02:18,026
A discovery proxy solves this


85
00:02:18,026 --> 00:02:18,386
problem.


86
00:02:19,356 --> 00:02:20,986
You can now send unicast packets


87
00:02:21,216 --> 00:02:22,486
over to the discovery proxy.


88
00:02:22,956 --> 00:02:24,176
It will send out the multicast


89
00:02:24,176 --> 00:02:25,386
packets on the destination


90
00:02:25,386 --> 00:02:27,556
subnet, receive the response and


91
00:02:27,556 --> 00:02:28,806
proxy the results back to you.


92
00:02:29,636 --> 00:02:30,956
Now you can connect directly to


93
00:02:30,956 --> 00:02:32,736
your printer and voila, we've


94
00:02:32,736 --> 00:02:34,976
got our document.


95
00:02:35,516 --> 00:02:37,946
[ Applause ]


96
00:02:38,446 --> 00:02:39,756
We're excited to announce that


97
00:02:39,756 --> 00:02:41,506
the code for this on the client


98
00:02:41,506 --> 00:02:42,776
side is included in your


99
00:02:42,776 --> 00:02:44,846
developer seed and a server


100
00:02:44,846 --> 00:02:46,446
implementation along with


101
00:02:46,446 --> 00:02:47,846
instruction for setting it up


102
00:02:48,106 --> 00:02:49,176
are available on GitHub.


103
00:02:49,786 --> 00:02:52,596
Let's take a look at what this


104
00:02:52,596 --> 00:02:53,346
means for your app.


105
00:02:54,686 --> 00:02:55,956
Previously, it's been the


106
00:02:55,956 --> 00:02:57,436
recommendation that when


107
00:02:57,436 --> 00:02:58,566
browsing you should specifying


108
00:02:58,566 --> 00:02:59,416
nil for a domain.


109
00:03:00,166 --> 00:03:01,236
And this continues to be the


110
00:03:01,236 --> 00:03:02,836
case and the right answer for


111
00:03:02,836 --> 00:03:03,986
almost every situation.


112
00:03:05,096 --> 00:03:06,156
In the past you may not have


113
00:03:06,156 --> 00:03:07,596
noticed much difference, but now


114
00:03:07,596 --> 00:03:08,546
this starts to have a bigger


115
00:03:08,546 --> 00:03:11,226
effect, specifying local will


116
00:03:11,226 --> 00:03:13,716
explicitly prevent discovery of


117
00:03:13,806 --> 00:03:15,896
any remote or proxied services.


118
00:03:16,716 --> 00:03:18,046
This is probably not what you


119
00:03:18,046 --> 00:03:18,316
want.


120
00:03:18,316 --> 00:03:19,856
So double check that your browse


121
00:03:19,856 --> 00:03:21,226
calls aren't inadvertently


122
00:03:21,226 --> 00:03:22,136
specifying a domain.


123
00:03:23,546 --> 00:03:24,316
And while you're browsing


124
00:03:24,316 --> 00:03:25,316
services while building your


125
00:03:25,746 --> 00:03:26,616
app, let's take a look at how


126
00:03:26,616 --> 00:03:27,486
some new features in


127
00:03:27,486 --> 00:03:29,366
Network.framework can make


128
00:03:29,486 --> 00:03:31,346
browsing for Bonjour even easier


129
00:03:31,596 --> 00:03:32,696
especially in Swift.


130
00:03:34,226 --> 00:03:35,536
Last year, we introduced


131
00:03:35,536 --> 00:03:37,276
NWListener and NWConnection


132
00:03:37,516 --> 00:03:38,586
along with Network.framework.


133
00:03:39,286 --> 00:03:40,876
For example, you can have an


134
00:03:40,876 --> 00:03:42,646
NWListener advertising a Bonjour


135
00:03:42,646 --> 00:03:44,186
service and you can have an


136
00:03:44,226 --> 00:03:45,886
NWConnection connects to a


137
00:03:45,886 --> 00:03:46,996
Bonjour service endpoint.


138
00:03:47,986 --> 00:03:49,056
But you had to use one of the


139
00:03:49,056 --> 00:03:50,666
other Bonjour browsing APIs to


140
00:03:50,666 --> 00:03:52,366
discover the available services.


141
00:03:53,006 --> 00:03:54,426
And once you found one, you had


142
00:03:54,426 --> 00:03:55,616
to do a bunch of work to convert


143
00:03:55,616 --> 00:03:56,696
it into an endpoint that you


144
00:03:56,696 --> 00:03:57,786
could use with your connection.


145
00:03:59,046 --> 00:04:00,596
Today, we are thrilled to


146
00:04:00,596 --> 00:04:02,246
announce native browsing support


147
00:04:02,466 --> 00:04:03,526
in Network.framework via the


148
00:04:03,526 --> 00:04:04,826
NWBrowser object.


149
00:04:06,016 --> 00:04:07,786
Browser joints connection and


150
00:04:07,786 --> 00:04:09,416
listener to cover the entire


151
00:04:09,416 --> 00:04:11,536
workflow from advertise to


152
00:04:11,536 --> 00:04:13,866
discover to connect, all using


153
00:04:13,866 --> 00:04:14,876
the Network.framework objects


154
00:04:14,906 --> 00:04:15,766
that you're already familiar


155
00:04:15,766 --> 00:04:15,966
with.


156
00:04:19,156 --> 00:04:20,916
Browser provides native service


157
00:04:20,916 --> 00:04:22,616
discovery in Network.framework


158
00:04:23,276 --> 00:04:25,386
using a modern dispatch-based


159
00:04:25,386 --> 00:04:27,176
API that's optimized to work


160
00:04:27,176 --> 00:04:28,686
incredibly well in Swift.


161
00:04:29,486 --> 00:04:30,796
It also includes optional


162
00:04:30,796 --> 00:04:32,596
support for TXT records.


163
00:04:33,426 --> 00:04:34,816
So if your application needs it,


164
00:04:34,996 --> 00:04:36,476
you can ensure that a TXT record


165
00:04:36,476 --> 00:04:37,936
is requested for every


166
00:04:37,936 --> 00:04:38,736
discovered endpoint.


167
00:04:39,226 --> 00:04:42,396
Let's take a look at how we use


168
00:04:42,396 --> 00:04:42,846
our browser.


169
00:04:43,866 --> 00:04:45,596
We can init it using a Bonjour


170
00:04:45,596 --> 00:04:46,946
service type that we'd like to


171
00:04:46,946 --> 00:04:48,696
discover and some NWParameters


172
00:04:48,696 --> 00:04:50,026
which is how you tell it what


173
00:04:50,026 --> 00:04:51,016
you'd like to-- how you'd like


174
00:04:51,016 --> 00:04:52,426
to browse, the same way you do


175
00:04:52,426 --> 00:04:53,396
all other Network.framework


176
00:04:53,396 --> 00:04:53,896
objects.


177
00:04:54,506 --> 00:04:55,596
Next, you can set a


178
00:04:55,596 --> 00:04:56,916
browseResultsChangedHandler


179
00:04:57,876 --> 00:04:59,286
which will be called to deliver


180
00:04:59,546 --> 00:05:00,806
the list of available endpoints


181
00:05:00,806 --> 00:05:01,546
that have been discovered.


182
00:05:02,306 --> 00:05:03,856
And finally, just like other


183
00:05:03,856 --> 00:05:05,206
Network.framework objects, you


184
00:05:05,206 --> 00:05:07,046
start the browser on a dispatch


185
00:05:07,046 --> 00:05:07,866
queue where you'd like to


186
00:05:07,866 --> 00:05:08,956
receive those callbacks.


187
00:05:09,486 --> 00:05:11,906
Let's take a closer look at the


188
00:05:11,906 --> 00:05:13,026
browseResultsChangedHandler.


189
00:05:13,946 --> 00:05:14,846
You have two options.


190
00:05:15,176 --> 00:05:17,026
First, you can provide a handler


191
00:05:17,366 --> 00:05:18,846
that receives the detailed list


192
00:05:18,846 --> 00:05:19,966
of all changes that have


193
00:05:19,966 --> 00:05:20,786
happened in that update.


194
00:05:21,436 --> 00:05:23,206
This aligns very closely with


195
00:05:23,206 --> 00:05:24,546
the lower level APIs and


196
00:05:24,546 --> 00:05:26,066
provides you full visibility


197
00:05:26,276 --> 00:05:27,496
into everything that changed.


198
00:05:28,056 --> 00:05:29,696
Endpoints can be added or


199
00:05:29,696 --> 00:05:31,686
removed and they can also have


200
00:05:31,686 --> 00:05:32,886
their inner details changed.


201
00:05:33,716 --> 00:05:34,926
Those changes are represented by


202
00:05:34,926 --> 00:05:35,546
flags.


203
00:05:36,436 --> 00:05:38,076
And in this case, we'll check


204
00:05:38,076 --> 00:05:39,696
for interfaces being added or


205
00:05:39,696 --> 00:05:40,906
removed as endpoints are


206
00:05:40,906 --> 00:05:42,026
discovered over additional


207
00:05:42,026 --> 00:05:42,586
interfaces.


208
00:05:43,136 --> 00:05:45,996
You can also choose to provide a


209
00:05:45,996 --> 00:05:47,916
handler that just looks at the


210
00:05:47,916 --> 00:05:49,916
latest list of results that have


211
00:05:49,956 --> 00:05:50,596
been discovered.


212
00:05:51,476 --> 00:05:52,786
Be careful if you do this


213
00:05:52,986 --> 00:05:53,916
because this handler will be


214
00:05:53,916 --> 00:05:55,636
called repeatedly as the list of


215
00:05:55,636 --> 00:05:57,076
available endpoints changes.


216
00:05:57,676 --> 00:05:58,516
So make sure that you're


217
00:05:58,516 --> 00:05:59,846
updating the state and the rest


218
00:05:59,846 --> 00:06:00,626
of your application


219
00:06:00,626 --> 00:06:01,246
appropriately.


220
00:06:05,096 --> 00:06:06,566
Let's see an example of the


221
00:06:06,566 --> 00:06:07,576
NWBrowser in action.


222
00:06:08,476 --> 00:06:09,976
We're going to make an app that


223
00:06:09,976 --> 00:06:12,126
provides a service discovery and


224
00:06:12,126 --> 00:06:13,756
secure connectivity between two


225
00:06:13,756 --> 00:06:14,246
devices.


226
00:06:15,206 --> 00:06:16,236
In our case we're going to make


227
00:06:16,236 --> 00:06:17,426
it a tic-tac-toe game.


228
00:06:17,856 --> 00:06:18,856
But you could use this for


229
00:06:18,856 --> 00:06:19,846
pretty much anything else.


230
00:06:21,136 --> 00:06:22,516
We're going to use an NWListener


231
00:06:22,516 --> 00:06:23,666
to advertise games to nearby


232
00:06:23,666 --> 00:06:25,246
players, we're going to use


233
00:06:25,246 --> 00:06:26,866
NWBrowser to browse for the


234
00:06:26,866 --> 00:06:28,746
games that are available nearby,


235
00:06:29,036 --> 00:06:30,346
and we're going to take one of


236
00:06:30,346 --> 00:06:31,416
those browse results once the


237
00:06:31,416 --> 00:06:32,616
user picks a game they'd like to


238
00:06:32,616 --> 00:06:32,856
join.


239
00:06:32,856 --> 00:06:34,486
And we're going to pass it an


240
00:06:34,486 --> 00:06:36,536
NWConnection to connect back to


241
00:06:36,536 --> 00:06:36,946
our listener.


242
00:06:36,946 --> 00:06:39,416
Let's take a look at this in


243
00:06:39,416 --> 00:06:39,976
Xcode.


244
00:06:47,416 --> 00:06:49,376
Here I've got my application and


245
00:06:49,376 --> 00:06:50,476
we've already written a bunch of


246
00:06:50,516 --> 00:06:52,716
code to handle doing some


247
00:06:52,716 --> 00:06:54,706
different views displaying a


248
00:06:54,706 --> 00:06:56,006
list of available games to the


249
00:06:56,006 --> 00:06:57,256
user, letting them host the


250
00:06:57,256 --> 00:06:58,366
game, stuff like that.


251
00:06:58,626 --> 00:06:59,866
So, here we can just focus on


252
00:06:59,866 --> 00:07:00,286
the browser.


253
00:07:00,856 --> 00:07:02,816
I've got a class called


254
00:07:02,886 --> 00:07:04,656
PeerBrowser, which I'm going to


255
00:07:04,656 --> 00:07:06,676
use to manage my NWBrowser and


256
00:07:06,676 --> 00:07:08,006
provide a PeerBrowserDelegate


257
00:07:08,006 --> 00:07:09,716
that will pass the list of


258
00:07:09,716 --> 00:07:11,406
discovered endpoints too so the


259
00:07:11,406 --> 00:07:12,846
UI can display them to the user.


260
00:07:14,536 --> 00:07:15,936
First, I need to add my


261
00:07:15,936 --> 00:07:17,656
NWBrowser as an instance


262
00:07:17,656 --> 00:07:18,806
property on the PeerBrowser.


263
00:07:21,216 --> 00:07:22,766
Next, we see that when the


264
00:07:22,766 --> 00:07:24,706
PeerBrowser is initted, it will


265
00:07:24,706 --> 00:07:26,166
immediately call startBrowsing.


266
00:07:27,126 --> 00:07:28,666
We need to fill that in.


267
00:07:29,916 --> 00:07:31,846
First, I'm going to create some


268
00:07:31,846 --> 00:07:33,576
NWParameters which is the same


269
00:07:33,576 --> 00:07:34,916
objects that you use with other


270
00:07:34,916 --> 00:07:36,206
Network.framework objects to


271
00:07:36,206 --> 00:07:37,296
describe how you'd like to


272
00:07:37,296 --> 00:07:38,126
interact with the network.


273
00:07:38,716 --> 00:07:39,636
In this case the default


274
00:07:39,636 --> 00:07:41,146
parameters are just fine but


275
00:07:41,376 --> 00:07:43,046
we'll set includePeerToPeer to


276
00:07:43,046 --> 00:07:45,276
true so that we can discover


277
00:07:45,276 --> 00:07:46,926
other available games even if


278
00:07:46,926 --> 00:07:48,406
the devices aren't on the same


279
00:07:48,406 --> 00:07:49,066
physical network.


280
00:07:52,576 --> 00:07:55,006
Next, we'll create our NWBrowser


281
00:07:56,236 --> 00:07:58,076
browsing for a service type of


282
00:07:58,126 --> 00:07:59,216
tictactoe.tcp.


283
00:07:59,216 --> 00:08:01,356
And we'll make sure to specify


284
00:08:01,356 --> 00:08:02,286
nil for the domain.


285
00:08:03,616 --> 00:08:04,856
We'll use the parameters that we


286
00:08:04,856 --> 00:08:06,536
created earlier and save it off


287
00:08:06,536 --> 00:08:07,296
into our peer browser.


288
00:08:07,806 --> 00:08:10,066
Next, we'll set a


289
00:08:10,066 --> 00:08:11,876
stateUpdateHandler just like we


290
00:08:11,876 --> 00:08:12,826
do with other Network.framework


291
00:08:12,826 --> 00:08:14,756
objects to receive updates about


292
00:08:14,756 --> 00:08:15,966
the state of our browser if


293
00:08:15,966 --> 00:08:17,366
there's any errors, how it's


294
00:08:17,366 --> 00:08:18,866
going, things like that, and


295
00:08:20,936 --> 00:08:21,996
then we'll set our


296
00:08:21,996 --> 00:08:23,166
browseResultsChangedHandler.


297
00:08:24,226 --> 00:08:25,096
Here it's really simple.


298
00:08:25,436 --> 00:08:26,946
We take the list of results, we


299
00:08:26,946 --> 00:08:28,216
pass them off to our delegate to


300
00:08:28,216 --> 00:08:29,776
be displayed in the UI, and we


301
00:08:29,776 --> 00:08:30,806
make sure that our delegate is


302
00:08:30,806 --> 00:08:32,826
coded in such a way that it


303
00:08:32,826 --> 00:08:34,275
refreshes the UI every time this


304
00:08:34,275 --> 00:08:35,275
happens so we can always


305
00:08:35,275 --> 00:08:36,885
represent the latest list of


306
00:08:36,885 --> 00:08:37,736
discovered endpoints.


307
00:08:41,556 --> 00:08:43,785
Finally, we start the browser on


308
00:08:43,785 --> 00:08:44,996
the main queue since that's


309
00:08:44,996 --> 00:08:45,876
where we'd like to receive our


310
00:08:45,876 --> 00:08:46,276
updates.


311
00:08:46,786 --> 00:08:49,696
And that's it.


312
00:08:50,236 --> 00:08:51,726
With just that code, we're able


313
00:08:51,726 --> 00:08:53,546
to bring up an NWBrowser, have


314
00:08:53,546 --> 00:08:54,996
it discover nearby games


315
00:08:55,256 --> 00:08:56,376
potentially over peer to peer


316
00:08:56,376 --> 00:08:58,076
links and display a list of


317
00:08:58,076 --> 00:08:59,626
available games to the user so


318
00:08:59,626 --> 00:09:00,456
they can choose which one to


319
00:09:00,456 --> 00:09:00,856
connect to.


320
00:09:00,856 --> 00:09:05,466
We'll talk a little bit later


321
00:09:05,466 --> 00:09:06,226
about our listener and


322
00:09:06,226 --> 00:09:07,796
connection, but all of this code


323
00:09:07,796 --> 00:09:08,846
is available for download as


324
00:09:08,846 --> 00:09:10,376
sample code off the website.


325
00:09:10,376 --> 00:09:12,266
And there's one thing I want to


326
00:09:12,266 --> 00:09:13,846
touch on before we try it out.


327
00:09:14,786 --> 00:09:16,966
We've got our NWParameters that


328
00:09:16,966 --> 00:09:17,886
we're going to use with our


329
00:09:17,886 --> 00:09:18,926
listeners and connections.


330
00:09:19,506 --> 00:09:20,536
And earlier I mentioned that we


331
00:09:20,536 --> 00:09:21,806
want to make sure that our


332
00:09:21,806 --> 00:09:23,416
connection between these devices


333
00:09:23,416 --> 00:09:24,866
is secure so that nobody else


334
00:09:24,866 --> 00:09:26,066
can see what moves we're making


335
00:09:26,246 --> 00:09:27,636
or worse, modify one of the


336
00:09:27,636 --> 00:09:28,296
player's moves.


337
00:09:29,586 --> 00:09:30,676
We're going to do that by


338
00:09:30,676 --> 00:09:31,736
defining an extension to


339
00:09:31,736 --> 00:09:34,526
NWParameters and creating a


340
00:09:34,526 --> 00:09:35,666
convenience initializer.


341
00:09:36,976 --> 00:09:38,386
It takes a passcode as a string.


342
00:09:39,396 --> 00:09:40,556
We're going to display to the


343
00:09:40,556 --> 00:09:42,836
host of the game a passcode and


344
00:09:42,896 --> 00:09:44,036
ask the person that wants to


345
00:09:44,036 --> 00:09:45,146
play with them to type in that


346
00:09:45,146 --> 00:09:46,976
passcode and then use that to


347
00:09:46,976 --> 00:09:48,436
derive a pre-shared key that we


348
00:09:48,436 --> 00:09:49,806
can use to secure the connection


349
00:09:50,056 --> 00:09:50,346
with TOS.


350
00:09:50,346 --> 00:09:53,556
In order to this, we need to


351
00:09:53,556 --> 00:09:55,956
create both TCP and TLS options


352
00:09:56,336 --> 00:09:57,236
in our initializer.


353
00:09:57,966 --> 00:09:59,666
Let's start with TLS.


354
00:10:01,726 --> 00:10:03,046
Here we defined a function that


355
00:10:03,046 --> 00:10:04,266
creates TLS options.


356
00:10:04,476 --> 00:10:06,126
We pass at the passcode and for


357
00:10:06,126 --> 00:10:07,076
now we start with just the


358
00:10:07,076 --> 00:10:08,226
default TLS options.


359
00:10:09,656 --> 00:10:11,786
Next, we use the new CryptoKit


360
00:10:11,786 --> 00:10:12,976
framework, which is available


361
00:10:12,976 --> 00:10:14,586
this year, to derive an


362
00:10:14,586 --> 00:10:16,676
authentication key and code from


363
00:10:17,806 --> 00:10:20,656
that passcode.


364
00:10:20,776 --> 00:10:22,326
We'll add that pre-shared key to


365
00:10:22,326 --> 00:10:24,066
our set protocol options and


366
00:10:24,266 --> 00:10:25,556
we'll also make sure to add a


367
00:10:25,556 --> 00:10:27,186
TLS cipher suite that supports


368
00:10:27,186 --> 00:10:28,236
the use of pre-shared keys.


369
00:10:28,816 --> 00:10:31,716
We can return our TLS options.


370
00:10:32,266 --> 00:10:34,386
And up here we're ready to go


371
00:10:34,386 --> 00:10:35,836
with our TCP options.


372
00:10:38,456 --> 00:10:40,146
We'll use a default TCP options


373
00:10:40,146 --> 00:10:41,276
for most things but we'll also


374
00:10:41,276 --> 00:10:41,966
enable keepalive.


375
00:10:43,186 --> 00:10:45,026
We then init our NWParameters


376
00:10:45,026 --> 00:10:46,276
with the TLS options that we


377
00:10:46,276 --> 00:10:47,966
just created down below, and


378
00:10:47,966 --> 00:10:50,426
those pretty much default TCP


379
00:10:51,206 --> 00:10:51,396
options.


380
00:10:51,516 --> 00:10:52,656
Finally, the last thing we want


381
00:10:52,656 --> 00:10:55,786
to do is set include peer to


382
00:10:55,786 --> 00:10:57,486
peer here so that our connection


383
00:10:57,486 --> 00:10:58,936
and our listener will also be


384
00:10:58,936 --> 00:11:00,006
able to connect to nearby


385
00:11:00,006 --> 00:11:01,406
devices even when they're not on


386
00:11:01,406 --> 00:11:01,976
the same network.


387
00:11:02,506 --> 00:11:07,546
So that's it, let's try it out.


388
00:11:07,756 --> 00:11:09,206
If I go over here, we can see


389
00:11:09,206 --> 00:11:10,276
that I've got two devices


390
00:11:10,586 --> 00:11:11,966
running the app and we've


391
00:11:11,966 --> 00:11:13,116
already got our UI there for


392
00:11:13,116 --> 00:11:13,856
hosting a game.


393
00:11:14,416 --> 00:11:15,656
And the browser has already


394
00:11:15,656 --> 00:11:17,236
started browsing and is


395
00:11:17,236 --> 00:11:18,476
displaying searching for games


396
00:11:18,476 --> 00:11:19,576
since we haven't found anything


397
00:11:20,146 --> 00:11:20,266
yet.


398
00:11:21,276 --> 00:11:23,106
If I come up and type in my name


399
00:11:24,376 --> 00:11:26,516
and tap host game, you can see


400
00:11:26,596 --> 00:11:28,316
I'm given the passcode and our


401
00:11:28,316 --> 00:11:29,726
browseResultsChangedHandler has


402
00:11:29,726 --> 00:11:31,396
been called with the list of


403
00:11:31,396 --> 00:11:32,786
discovered endpoints, in this


404
00:11:32,786 --> 00:11:34,296
case the game that I'm hosting,


405
00:11:34,516 --> 00:11:35,456
and we've displayed that for the


406
00:11:35,456 --> 00:11:35,806
user.


407
00:11:36,116 --> 00:11:36,716
It's that easy.


408
00:11:37,316 --> 00:11:41,526
If I tap on join game, I'm


409
00:11:41,526 --> 00:11:42,866
presented the opportunity to


410
00:11:42,866 --> 00:11:45,526
type in the passcode.


411
00:11:45,526 --> 00:11:47,386
And now when I confirm that,


412
00:11:47,806 --> 00:11:49,276
we'll see that we've created the


413
00:11:49,276 --> 00:11:51,166
pre-shared key, used it to


414
00:11:51,166 --> 00:11:52,276
connect back to the listener,


415
00:11:52,746 --> 00:11:54,366
and hopefully the game will flip


416
00:11:54,366 --> 00:11:55,216
around and ready to play.


417
00:11:56,656 --> 00:11:57,036
There we go.


418
00:11:58,516 --> 00:12:01,500
[ Applause ]


419
00:12:08,236 --> 00:12:09,756
So far, we've built the


420
00:12:09,756 --> 00:12:11,426
beginnings of our app and


421
00:12:11,426 --> 00:12:12,836
established connectivity between


422
00:12:12,836 --> 00:12:13,646
the two devices.


423
00:12:14,386 --> 00:12:15,846
We used an NWListener to


424
00:12:15,846 --> 00:12:17,276
advertise a Bonjour service of


425
00:12:17,316 --> 00:12:18,246
tictactoe.tcp.


426
00:12:18,246 --> 00:12:21,856
We used an NWBrowser to browse


427
00:12:21,856 --> 00:12:23,316
for available games and display


428
00:12:23,316 --> 00:12:24,016
those to the user.


429
00:12:24,456 --> 00:12:25,866
And we were able to take the


430
00:12:25,866 --> 00:12:27,236
result that we got back from the


431
00:12:27,236 --> 00:12:29,186
browser and pass it directly to


432
00:12:29,186 --> 00:12:30,956
our NWConnection to connect back


433
00:12:30,996 --> 00:12:32,346
to the listener and establish a


434
00:12:32,346 --> 00:12:33,926
secure connection between those


435
00:12:33,926 --> 00:12:34,546
two devices.


436
00:12:35,596 --> 00:12:36,816
Of course in order to play the


437
00:12:36,816 --> 00:12:38,336
game, the two devices actually


438
00:12:38,336 --> 00:12:39,446
have to be able to communicate


439
00:12:39,686 --> 00:12:41,686
to share the game state, tell


440
00:12:41,686 --> 00:12:42,666
each other about moves that the


441
00:12:42,666 --> 00:12:44,236
players making, and things like


442
00:12:44,236 --> 00:12:44,456
that.


443
00:12:45,276 --> 00:12:46,726
In order to that, I'd like to


444
00:12:46,726 --> 00:12:48,216
invite Tommy up to the stage to


445
00:12:48,216 --> 00:12:49,496
walk us through building custom


446
00:12:49,496 --> 00:12:50,466
framing protocols.


447
00:12:51,516 --> 00:12:56,316
[ Applause ]


448
00:12:56,816 --> 00:12:57,556
>> All right.


449
00:12:57,556 --> 00:12:58,786
Thank you, Eric.


450
00:12:59,796 --> 00:13:01,416
So today, I'd like to share with


451
00:13:01,466 --> 00:13:04,006
you an exciting new way that you


452
00:13:04,006 --> 00:13:05,846
can extend your network


453
00:13:05,846 --> 00:13:08,786
connections with custom protocol


454
00:13:08,786 --> 00:13:10,776
framing code that you write that


455
00:13:10,776 --> 00:13:12,916
runs on the same thread as the


456
00:13:12,916 --> 00:13:13,956
rest of the protocols in the


457
00:13:13,956 --> 00:13:15,706
networking stack.


458
00:13:16,116 --> 00:13:17,806
So, in order to finish the game


459
00:13:17,806 --> 00:13:19,666
that Eric just started, we need


460
00:13:19,666 --> 00:13:21,236
to define a way for the two


461
00:13:21,236 --> 00:13:22,776
games to send commands between


462
00:13:22,776 --> 00:13:23,236
each other.


463
00:13:23,856 --> 00:13:24,966
When one player wants to make a


464
00:13:24,966 --> 00:13:26,366
move, he needs to send a message


465
00:13:26,366 --> 00:13:27,066
to the other side.


466
00:13:28,206 --> 00:13:29,896
To do this we're going to need a


467
00:13:29,896 --> 00:13:30,386
protocol.


468
00:13:30,966 --> 00:13:33,546
So here's what our protocol is


469
00:13:33,546 --> 00:13:34,276
going to look like.


470
00:13:34,836 --> 00:13:37,686
It's a simple type-length-value


471
00:13:37,686 --> 00:13:38,996
or TLV protocol.


472
00:13:40,016 --> 00:13:42,196
So we have a 4-byte type which


473
00:13:42,196 --> 00:13:44,156
may be make a move.


474
00:13:44,936 --> 00:13:47,116
The player wants to put a given


475
00:13:47,116 --> 00:13:48,586
character at a given location on


476
00:13:48,586 --> 00:13:49,716
our tic-tac-toe board.


477
00:13:50,296 --> 00:13:52,796
We have a 4-byte length which


478
00:13:52,796 --> 00:13:54,026
indicates the length of the rest


479
00:13:54,026 --> 00:13:54,626
of the message.


480
00:13:55,166 --> 00:13:57,656
And then after that we have the


481
00:13:57,656 --> 00:13:58,726
body of the message.


482
00:13:59,086 --> 00:14:00,326
And in this case it could be


483
00:14:00,436 --> 00:14:03,066
place the monkey face at row 1


484
00:14:03,066 --> 00:14:03,696
column 2.


485
00:14:04,506 --> 00:14:05,456
And then it's going to repeat


486
00:14:05,456 --> 00:14:07,546
like that on TLS byte-stream.


487
00:14:10,196 --> 00:14:11,706
So you may have noticed that


488
00:14:11,956 --> 00:14:13,906
this protocol, even though we're


489
00:14:13,906 --> 00:14:15,736
running on top of a TLS


490
00:14:15,736 --> 00:14:17,456
byte-stream which itself is not


491
00:14:17,456 --> 00:14:20,206
structured is using structured


492
00:14:20,206 --> 00:14:20,946
messages.


493
00:14:21,556 --> 00:14:22,906
The application is not thinking


494
00:14:22,906 --> 00:14:25,026
in terms of byte-streams but


495
00:14:25,026 --> 00:14:26,916
well-delineated pieces of


496
00:14:26,916 --> 00:14:27,506
information.


497
00:14:28,696 --> 00:14:29,976
And almost all networking


498
00:14:29,976 --> 00:14:31,616
applications do this.


499
00:14:32,806 --> 00:14:34,666
They either have a header and a


500
00:14:34,666 --> 00:14:37,246
body or they have a delimiter


501
00:14:37,666 --> 00:14:38,906
that goes somewhere to define


502
00:14:38,906 --> 00:14:39,686
the boundaries of their


503
00:14:39,686 --> 00:14:40,336
messages.


504
00:14:41,756 --> 00:14:45,446
However, traditional transport


505
00:14:45,446 --> 00:14:47,266
networking APIs like sockets


506
00:14:47,536 --> 00:14:49,986
didn't give you a way to easily


507
00:14:49,986 --> 00:14:51,806
read out messages on a


508
00:14:51,806 --> 00:14:52,336
connection.


509
00:14:52,536 --> 00:14:53,586
You had to do that all yourself


510
00:14:53,586 --> 00:14:54,236
in the application.


511
00:14:55,166 --> 00:14:57,436
So, to take a look at how this


512
00:14:57,466 --> 00:14:59,646
problem plays out let's look at


513
00:14:59,646 --> 00:15:01,026
the relationship of your


514
00:15:01,026 --> 00:15:02,846
application to the rest of the


515
00:15:02,846 --> 00:15:03,526
networking stack.


516
00:15:03,666 --> 00:15:05,426
So up on top you have your


517
00:15:05,426 --> 00:15:06,006
application.


518
00:15:07,186 --> 00:15:08,746
And it is communicating with the


519
00:15:08,746 --> 00:15:10,586
networking stack via the API.


520
00:15:11,806 --> 00:15:13,846
So in Network.framework, we have


521
00:15:14,366 --> 00:15:18,086
running TLS and TCP all within


522
00:15:18,086 --> 00:15:20,306
one shared thread inside your


523
00:15:20,306 --> 00:15:20,936
application.


524
00:15:21,346 --> 00:15:22,486
This is the user space


525
00:15:22,486 --> 00:15:23,496
networking stack that we


526
00:15:23,496 --> 00:15:24,706
introduced last year.


527
00:15:25,786 --> 00:15:27,896
Let's zoom in to see how your


528
00:15:27,896 --> 00:15:30,266
application reads messages when


529
00:15:30,266 --> 00:15:33,196
it's on top of a byte-stream.


530
00:15:33,376 --> 00:15:34,916
So if you have a protocol like


531
00:15:34,916 --> 00:15:36,146
the one that we're using for


532
00:15:36,146 --> 00:15:38,106
tic-tac-toe, you may have a


533
00:15:38,216 --> 00:15:39,086
fixed-length header.


534
00:15:39,796 --> 00:15:41,056
And the simple thing you can do


535
00:15:41,056 --> 00:15:43,246
here is to read exactly the


536
00:15:43,246 --> 00:15:44,186
length of your header.


537
00:15:45,246 --> 00:15:46,336
Receive 8 bytes.


538
00:15:47,236 --> 00:15:48,286
So this is a fixed length.


539
00:15:48,286 --> 00:15:49,266
You know what's going to happen.


540
00:15:49,796 --> 00:15:51,456
And the stack will call you back


541
00:15:51,456 --> 00:15:52,716
when you have your full header.


542
00:15:53,396 --> 00:15:55,156
This allows you to determine the


543
00:15:55,156 --> 00:15:55,986
length of the rest of the


544
00:15:55,986 --> 00:15:56,436
message.


545
00:15:56,786 --> 00:15:58,776
So you can read exactly that and


546
00:15:58,776 --> 00:16:00,216
then go back and forth reading


547
00:16:00,216 --> 00:16:02,796
body, header, body, header,


548
00:16:02,986 --> 00:16:03,296
body.


549
00:16:03,826 --> 00:16:07,796
So this is great, but you may


550
00:16:07,796 --> 00:16:08,966
have noticed that we have


551
00:16:08,966 --> 00:16:10,816
multiple back and forths at


552
00:16:10,816 --> 00:16:12,696
least two for every single


553
00:16:12,696 --> 00:16:13,226
message.


554
00:16:13,776 --> 00:16:15,356
If you have a more complex


555
00:16:15,356 --> 00:16:16,896
protocol, maybe you have a


556
00:16:16,896 --> 00:16:18,936
variable-length header or you


557
00:16:18,936 --> 00:16:20,576
have a delimiter, this can


558
00:16:20,576 --> 00:16:22,226
become even more inefficient,


559
00:16:22,726 --> 00:16:23,876
even though it's simple for your


560
00:16:23,876 --> 00:16:25,786
application to write its logic.


561
00:16:27,056 --> 00:16:28,716
If you care about efficiency a


562
00:16:28,716 --> 00:16:30,206
lot, you have another option.


563
00:16:30,836 --> 00:16:32,366
You could receive as much as


564
00:16:32,366 --> 00:16:33,436
possible at one time.


565
00:16:34,176 --> 00:16:35,936
But now you have a bunch of


566
00:16:35,936 --> 00:16:36,906
other problems to deal with.


567
00:16:37,766 --> 00:16:39,506
Now, you need to handle the case


568
00:16:39,506 --> 00:16:40,716
in which you don't receive a


569
00:16:40,716 --> 00:16:42,046
complete message all in one


570
00:16:42,046 --> 00:16:42,396
chunk.


571
00:16:43,226 --> 00:16:44,476
Or maybe you receive multiple


572
00:16:44,476 --> 00:16:46,856
messages in one go, or maybe you


573
00:16:46,856 --> 00:16:48,976
receive only part of your


574
00:16:48,976 --> 00:16:50,466
header, you only have two or


575
00:16:50,466 --> 00:16:51,536
three bytes of your length


576
00:16:51,536 --> 00:16:51,936
field.


577
00:16:51,936 --> 00:16:53,186
You need to save it off,


578
00:16:53,186 --> 00:16:55,186
reconstruct the field and parse


579
00:16:55,186 --> 00:16:55,796
it out again.


580
00:16:56,926 --> 00:16:58,876
Getting this fully correct and


581
00:16:58,876 --> 00:17:00,356
handling every possible edge


582
00:17:00,356 --> 00:17:02,776
case can be really difficult.


583
00:17:03,186 --> 00:17:04,486
And it's common to have subtle


584
00:17:04,486 --> 00:17:06,256
bugs that only show up when your


585
00:17:06,256 --> 00:17:07,656
users actually use your


586
00:17:07,656 --> 00:17:08,685
application in the field.


587
00:17:10,756 --> 00:17:11,376
All right.


588
00:17:11,526 --> 00:17:12,816
So, it's a bit of a bleak


589
00:17:12,816 --> 00:17:14,106
picture at this point.


590
00:17:14,506 --> 00:17:16,386
How do we get the best of both


591
00:17:16,386 --> 00:17:16,695
worlds?


592
00:17:16,695 --> 00:17:18,786
How can we have a way to be both


593
00:17:18,786 --> 00:17:21,425
efficient and have simple code


594
00:17:21,425 --> 00:17:22,675
that's easily testable and


595
00:17:22,675 --> 00:17:23,256
composable?


596
00:17:24,056 --> 00:17:25,915
Well, I'm really excited to


597
00:17:25,915 --> 00:17:28,215
share that now in iOS 13 and


598
00:17:28,215 --> 00:17:29,986
macOS Catalina, you'll be able


599
00:17:29,986 --> 00:17:32,226
to write your own protocol code


600
00:17:32,756 --> 00:17:34,466
that runs on the same networking


601
00:17:34,466 --> 00:17:35,986
thread to handle this problem.


602
00:17:36,376 --> 00:17:38,116
So, this is an unprecedented


603
00:17:38,116 --> 00:17:39,916
step forward in the amount of


604
00:17:39,916 --> 00:17:41,446
flexibility that you have to


605
00:17:41,446 --> 00:17:43,796
define your messages within a


606
00:17:43,796 --> 00:17:44,976
transport networking API


607
00:17:44,976 --> 00:17:45,706
[applause].


608
00:17:45,706 --> 00:17:50,446
Thank you.


609
00:17:50,446 --> 00:17:51,386
And you get to do this all


610
00:17:51,386 --> 00:17:52,926
within NWConnection.


611
00:17:53,086 --> 00:17:54,546
And so, to the application on


612
00:17:54,546 --> 00:17:56,126
top, it's just as if you're


613
00:17:56,126 --> 00:17:57,596
reading and writing datagrams


614
00:17:57,596 --> 00:17:59,206
like a basic connection.


615
00:18:00,736 --> 00:18:02,356
So let's look at the world now.


616
00:18:03,066 --> 00:18:04,116
Still have your application.


617
00:18:04,166 --> 00:18:05,686
It's still sending and receiving


618
00:18:05,816 --> 00:18:07,456
but now you have your framing


619
00:18:07,456 --> 00:18:09,556
code that's running within the


620
00:18:09,556 --> 00:18:11,736
same thread as TLS and TCP.


621
00:18:12,216 --> 00:18:13,146
So you can now call


622
00:18:13,886 --> 00:18:14,846
receiveMessage.


623
00:18:15,226 --> 00:18:16,596
And it will get exactly one


624
00:18:16,596 --> 00:18:17,626
callback when you have a


625
00:18:17,976 --> 00:18:19,346
complete message that your


626
00:18:19,346 --> 00:18:20,966
application can fully process.


627
00:18:21,596 --> 00:18:22,656
You can do this over and over


628
00:18:22,656 --> 00:18:22,976
again.


629
00:18:23,266 --> 00:18:25,466
One call per message and really,


630
00:18:25,466 --> 00:18:27,246
really easy to debug and


631
00:18:27,246 --> 00:18:28,386
understand what's going on.


632
00:18:28,926 --> 00:18:31,696
So, this is great.


633
00:18:31,866 --> 00:18:33,966
And if your-- You may be asking


634
00:18:33,966 --> 00:18:35,916
right now what can I actually


635
00:18:35,916 --> 00:18:38,046
implement as one of these


636
00:18:38,046 --> 00:18:38,796
framing protocols?


637
00:18:38,796 --> 00:18:39,746
What are the restrictions?


638
00:18:39,856 --> 00:18:42,076
So, the good news is, is that


639
00:18:42,276 --> 00:18:43,786
pretty much anything that


640
00:18:43,786 --> 00:18:45,976
encapsulates or encodes


641
00:18:45,976 --> 00:18:47,636
application data to transform it


642
00:18:48,176 --> 00:18:49,986
can be written as a framing


643
00:18:49,986 --> 00:18:50,466
protocol.


644
00:18:51,146 --> 00:18:53,146
You can even send your own


645
00:18:53,146 --> 00:18:54,916
messages that do not correspond


646
00:18:55,026 --> 00:18:56,736
to application data, if you need


647
00:18:56,736 --> 00:18:58,886
to do a handshake or if you need


648
00:18:59,076 --> 00:19:00,336
to implement some sort of


649
00:19:00,376 --> 00:19:01,606
keepalive on the connection.


650
00:19:02,156 --> 00:19:04,436
And the protocols that you're


651
00:19:04,436 --> 00:19:06,026
implementing here can be


652
00:19:06,026 --> 00:19:09,026
standard IETF official protocols


653
00:19:09,616 --> 00:19:10,476
or they could be something


654
00:19:10,476 --> 00:19:12,016
custom just for your app like


655
00:19:12,066 --> 00:19:13,326
what we're going to be doing for


656
00:19:13,326 --> 00:19:14,226
a tic-tac-toe game.


657
00:19:15,096 --> 00:19:16,456
So if you want to build a


658
00:19:16,456 --> 00:19:17,776
protocol, you have two steps.


659
00:19:18,446 --> 00:19:21,116
First, you implement a reusable


660
00:19:21,116 --> 00:19:22,566
piece of code that defines your


661
00:19:22,566 --> 00:19:23,286
message framing.


662
00:19:23,836 --> 00:19:24,796
This is the protocol.


663
00:19:25,716 --> 00:19:28,486
And then you add that protocol


664
00:19:28,886 --> 00:19:30,776
into your connection's protocol


665
00:19:30,776 --> 00:19:32,416
stacks so that you can use it


666
00:19:32,416 --> 00:19:34,366
for connection establishment as


667
00:19:34,366 --> 00:19:36,086
well as sending and receiving


668
00:19:36,186 --> 00:19:36,626
message.


669
00:19:37,176 --> 00:19:38,196
All right.


670
00:19:38,416 --> 00:19:40,786
So let's go on to step 1.


671
00:19:41,016 --> 00:19:41,596
We're going to start


672
00:19:41,696 --> 00:19:43,446
implementing framing protocols.


673
00:19:44,786 --> 00:19:47,096
What you do here is create a


674
00:19:47,096 --> 00:19:48,926
class that conforms to


675
00:19:48,926 --> 00:19:51,066
ProtocolFramerImplementation.


676
00:19:51,896 --> 00:19:52,846
And there are many things you


677
00:19:52,846 --> 00:19:54,166
can do within this class.


678
00:19:55,136 --> 00:19:56,886
But the two most important


679
00:19:56,886 --> 00:19:58,216
things to remember are to


680
00:19:58,216 --> 00:20:00,456
handleOutput, to send messages;


681
00:20:00,786 --> 00:20:02,326
and to handleInput, to parse


682
00:20:02,326 --> 00:20:02,956
messages.


683
00:20:03,516 --> 00:20:04,926
If you can do these two things,


684
00:20:05,256 --> 00:20:06,546
hooray, you are a framer.


685
00:20:07,736 --> 00:20:08,806
Let's take a look at the code.


686
00:20:09,506 --> 00:20:11,636
So, here we have my protocol.


687
00:20:12,266 --> 00:20:13,486
It's going to conform to


688
00:20:13,486 --> 00:20:15,276
ProtocolFramerImplementation.


689
00:20:16,526 --> 00:20:17,356
And the first thing that I


690
00:20:17,356 --> 00:20:19,976
recommend you do is create a


691
00:20:20,096 --> 00:20:21,346
definition object.


692
00:20:21,446 --> 00:20:23,476
And this is a handle to your


693
00:20:23,476 --> 00:20:25,046
protocol that you can use


694
00:20:25,366 --> 00:20:26,476
throughout the rest of your app.


695
00:20:27,096 --> 00:20:28,826
It refers to your protocols you


696
00:20:28,826 --> 00:20:30,166
can add it into connections.


697
00:20:30,626 --> 00:20:34,106
Next you can handle a lot of the


698
00:20:34,106 --> 00:20:36,156
basic callback events.


699
00:20:36,626 --> 00:20:37,886
One of the most important ones


700
00:20:37,886 --> 00:20:39,226
here is start.


701
00:20:39,576 --> 00:20:41,576
Start will get called anytime


702
00:20:41,576 --> 00:20:43,436
your protocol is loaded into a


703
00:20:43,436 --> 00:20:45,366
connection as being used to


704
00:20:45,446 --> 00:20:46,286
bring it up.


705
00:20:47,036 --> 00:20:48,706
If you need to do a handshake to


706
00:20:48,706 --> 00:20:49,806
exchange something with the


707
00:20:49,806 --> 00:20:51,416
other side, you can implement it


708
00:20:51,416 --> 00:20:51,726
here.


709
00:20:52,626 --> 00:20:54,636
Or if like our tic-tac-toe game


710
00:20:54,636 --> 00:20:55,916
you have a very simple protocol,


711
00:20:56,016 --> 00:20:57,386
you don't need to do any setup,


712
00:20:57,726 --> 00:20:58,996
just mark the connection ready


713
00:20:59,076 --> 00:20:59,636
immediately.


714
00:21:00,896 --> 00:21:02,806
So once you've done this, you


715
00:21:02,806 --> 00:21:04,736
now have to handleOutput and


716
00:21:04,736 --> 00:21:05,356
handleInput.


717
00:21:05,686 --> 00:21:06,796
Let's dive into these.


718
00:21:09,196 --> 00:21:11,156
So here is what handleOutput


719
00:21:11,186 --> 00:21:11,666
looks like.


720
00:21:12,416 --> 00:21:13,316
You will get called with


721
00:21:13,316 --> 00:21:16,036
handleOutput every time the


722
00:21:16,036 --> 00:21:17,966
application sends a message.


723
00:21:18,546 --> 00:21:19,906
And you'll be given the message


724
00:21:19,906 --> 00:21:22,116
metadata with some custom values


725
00:21:22,116 --> 00:21:25,036
if you need them, along with the


726
00:21:25,036 --> 00:21:26,106
length of the message the


727
00:21:26,106 --> 00:21:27,356
application is trying to send.


728
00:21:27,986 --> 00:21:31,016
So, if you have a header body


729
00:21:31,016 --> 00:21:32,626
protocol, like what we're using,


730
00:21:33,686 --> 00:21:35,886
you can first create your header


731
00:21:35,886 --> 00:21:38,186
structure and try to serialize


732
00:21:38,186 --> 00:21:38,666
some data.


733
00:21:39,686 --> 00:21:41,266
So this can include your type


734
00:21:41,846 --> 00:21:42,836
that you get maybe from the


735
00:21:42,836 --> 00:21:44,666
message metadata along with the


736
00:21:44,666 --> 00:21:47,166
length that was passed to you


737
00:21:47,166 --> 00:21:48,036
into handleOutput.


738
00:21:48,476 --> 00:21:51,086
You combine these into data and


739
00:21:51,086 --> 00:21:52,466
then you call writeOutput.


740
00:21:52,896 --> 00:21:54,656
WriteOutput will queue your


741
00:21:54,656 --> 00:21:56,506
bytes on to the output stream,


742
00:21:56,876 --> 00:21:58,276
but they won't get sent quite


743
00:22:00,596 --> 00:22:00,706
yet.


744
00:22:00,986 --> 00:22:03,086
Next you need to write the body.


745
00:22:03,226 --> 00:22:04,876
And in this case we don't need


746
00:22:04,876 --> 00:22:06,356
to transform the application


747
00:22:06,356 --> 00:22:06,916
data at all.


748
00:22:07,316 --> 00:22:08,136
We can just call


749
00:22:08,326 --> 00:22:09,876
writeOutputNoCopy.


750
00:22:11,086 --> 00:22:13,236
This allows us to just take the


751
00:22:13,236 --> 00:22:14,546
direct application bytes and


752
00:22:14,546 --> 00:22:15,686
then queue them on the stream.


753
00:22:16,496 --> 00:22:17,476
When we return from


754
00:22:17,476 --> 00:22:20,116
handleOutput, all of the bytes


755
00:22:20,166 --> 00:22:21,536
will be sent out to connection.


756
00:22:22,016 --> 00:22:22,206
All right.


757
00:22:23,276 --> 00:22:25,176
So let's move on to handling


758
00:22:25,246 --> 00:22:25,636
input.


759
00:22:26,416 --> 00:22:28,606
Handling input is similar but a


760
00:22:28,606 --> 00:22:29,806
little bit more complicated.


761
00:22:30,856 --> 00:22:31,626
You'll be called with


762
00:22:31,626 --> 00:22:33,906
handleInput anytime your


763
00:22:33,906 --> 00:22:36,806
application has received new


764
00:22:36,806 --> 00:22:37,896
bytes on the connection.


765
00:22:38,506 --> 00:22:40,346
And if you're doing a header


766
00:22:40,496 --> 00:22:42,556
body type protocol, you have two


767
00:22:42,556 --> 00:22:42,956
jobs.


768
00:22:42,956 --> 00:22:45,206
You need to parse the header and


769
00:22:45,206 --> 00:22:46,306
then you need to parse the body.


770
00:22:46,966 --> 00:22:48,516
So, let's start with parsing the


771
00:22:48,516 --> 00:22:48,756
header.


772
00:22:49,376 --> 00:22:50,986
Here we have a fixed-length


773
00:22:50,986 --> 00:22:52,036
header for our protocol.


774
00:22:52,036 --> 00:22:53,236
We're going to have exactly 8


775
00:22:53,236 --> 00:22:53,726
bytes.


776
00:22:54,216 --> 00:22:55,526
And what we do is we call


777
00:22:55,606 --> 00:22:57,436
parseInput to start inspecting


778
00:22:57,436 --> 00:22:58,456
the stream of bytes that have


779
00:22:58,506 --> 00:22:59,486
come into the connection.


780
00:23:00,406 --> 00:23:01,446
And we can call it with a


781
00:23:01,446 --> 00:23:03,556
minimum and a maximum of 8 bytes


782
00:23:03,586 --> 00:23:05,026
because we want to look exactly


783
00:23:05,026 --> 00:23:05,826
at that 8-byte header.


784
00:23:06,456 --> 00:23:09,076
If this succeeds, you'll be


785
00:23:09,076 --> 00:23:10,796
called in the block and you'll


786
00:23:10,796 --> 00:23:12,066
be able to look at the actual


787
00:23:12,066 --> 00:23:13,826
buffer bytes, parse out your


788
00:23:13,826 --> 00:23:15,796
values, save them off into local


789
00:23:15,796 --> 00:23:17,576
variables if you need to.


790
00:23:18,156 --> 00:23:20,706
The return value to parse input


791
00:23:21,416 --> 00:23:22,786
indicates how many bytes you


792
00:23:22,786 --> 00:23:24,486
want to increment the input


793
00:23:24,486 --> 00:23:25,086
cursor by.


794
00:23:25,186 --> 00:23:26,896
You say, I am done handling


795
00:23:26,896 --> 00:23:27,846
these 8 bytes.


796
00:23:27,916 --> 00:23:29,046
We don't need to see them again.


797
00:23:29,046 --> 00:23:30,196
We don't need to deliver them to


798
00:23:30,196 --> 00:23:30,896
the application.


799
00:23:31,306 --> 00:23:34,936
Move on. Now you can handle the


800
00:23:34,936 --> 00:23:36,986
case in which not all 8 bytes


801
00:23:36,986 --> 00:23:37,806
were available yet.


802
00:23:38,296 --> 00:23:41,346
In this case, the parseInput


803
00:23:41,416 --> 00:23:43,416
function will fail and you can


804
00:23:43,506 --> 00:23:45,246
just wait for more bytes to


805
00:23:45,246 --> 00:23:45,936
become available.


806
00:23:46,726 --> 00:23:48,616
The return value from


807
00:23:48,616 --> 00:23:51,216
handleInput indicates the number


808
00:23:51,216 --> 00:23:52,786
of bytes that need to be present


809
00:23:52,786 --> 00:23:54,066
before you can successfully do


810
00:23:54,066 --> 00:23:54,546
more work.


811
00:23:54,976 --> 00:23:56,476
So in this case we're telling


812
00:23:56,476 --> 00:23:57,796
the connection, make sure


813
00:23:57,796 --> 00:23:59,496
there's 8 bytes before you wake


814
00:23:59,496 --> 00:24:01,376
me up again.


815
00:24:01,556 --> 00:24:04,376
If you are able to successfully


816
00:24:04,376 --> 00:24:06,706
read out your header, you can


817
00:24:06,706 --> 00:24:09,426
create a message object that you


818
00:24:09,426 --> 00:24:10,276
can deliver up to the


819
00:24:10,276 --> 00:24:11,826
application along with the data.


820
00:24:12,456 --> 00:24:14,796
This allows you to put in any


821
00:24:14,796 --> 00:24:16,846
custom values, types or other


822
00:24:16,896 --> 00:24:18,446
indicators that you want to send


823
00:24:18,516 --> 00:24:19,326
up to your application.


824
00:24:19,936 --> 00:24:23,766
And then lastly you call


825
00:24:23,766 --> 00:24:25,326
deliverInput or


826
00:24:25,326 --> 00:24:27,506
deliverInputNoCopy in this case.


827
00:24:28,096 --> 00:24:29,866
This allows you to mark the next


828
00:24:29,866 --> 00:24:31,656
certain range of bytes as


829
00:24:31,656 --> 00:24:32,916
application data that should be


830
00:24:32,916 --> 00:24:34,596
delivered directly up to the


831
00:24:34,596 --> 00:24:35,186
application.


832
00:24:35,736 --> 00:24:39,086
And this returns Boolean value


833
00:24:39,086 --> 00:24:41,446
to indicate whether or not all


834
00:24:41,446 --> 00:24:43,006
of the bytes were available and


835
00:24:43,136 --> 00:24:45,296
successfully were sent up or if


836
00:24:45,296 --> 00:24:46,656
the connection is going to wait.


837
00:24:47,096 --> 00:24:48,766
So you can actually deliverInput


838
00:24:48,766 --> 00:24:50,116
of a message that's a megabyte


839
00:24:50,116 --> 00:24:51,506
long, a gigabyte long if you


840
00:24:51,506 --> 00:24:53,476
need to, and will keep on


841
00:24:53,476 --> 00:24:54,866
streaming those bytes up as part


842
00:24:54,866 --> 00:24:56,336
of that one message and you


843
00:24:56,336 --> 00:24:57,426
don't need to wait for all the


844
00:24:57,426 --> 00:24:59,166
bytes to be present or handle


845
00:24:59,166 --> 00:24:59,956
them yourself.


846
00:25:02,466 --> 00:25:04,676
OK. So, I know it's a lot of


847
00:25:04,676 --> 00:25:06,176
code, but I think we're ready to


848
00:25:06,176 --> 00:25:08,266
go and implement the protocol


849
00:25:08,266 --> 00:25:09,786
for our game tic-tac-toe.


850
00:25:19,176 --> 00:25:19,886
OK. All right.


851
00:25:20,806 --> 00:25:22,546
So this is the same game that


852
00:25:22,666 --> 00:25:24,076
Eric began earlier.


853
00:25:24,906 --> 00:25:26,676
But I'm now creating a new class


854
00:25:26,816 --> 00:25:28,326
which I'm calling game protocol


855
00:25:28,396 --> 00:25:29,966
and this is going to conform to


856
00:25:29,966 --> 00:25:31,766
ProtocolFramerImplementation.


857
00:25:32,266 --> 00:25:34,786
I have defined two different


858
00:25:34,786 --> 00:25:36,616
types for my game.


859
00:25:36,616 --> 00:25:37,836
I want to have two different


860
00:25:37,836 --> 00:25:38,726
commands that we send.


861
00:25:39,696 --> 00:25:41,336
One is to select the character.


862
00:25:41,826 --> 00:25:43,826
So the first step of the game is


863
00:25:43,826 --> 00:25:45,176
that the player will decide


864
00:25:45,276 --> 00:25:46,766
which emoji family they want to


865
00:25:46,766 --> 00:25:46,976
be.


866
00:25:46,976 --> 00:25:48,346
Do they want to be a monkey or a


867
00:25:48,346 --> 00:25:48,726
bird?


868
00:25:49,986 --> 00:25:51,496
And then once each character has


869
00:25:51,496 --> 00:25:53,566
selected their character, they


870
00:25:53,566 --> 00:25:55,216
can start sending moves.


871
00:25:55,516 --> 00:25:57,006
And this would be a longer body.


872
00:25:57,006 --> 00:25:59,026
It will include the character


873
00:25:59,026 --> 00:26:01,436
along with the row and column


874
00:26:01,436 --> 00:26:02,026
values.


875
00:26:03,996 --> 00:26:04,666
All right.


876
00:26:04,666 --> 00:26:06,826
So, I remember that the first


877
00:26:06,826 --> 00:26:07,936
thing I need to do when I'm


878
00:26:07,936 --> 00:26:10,836
implementing a protocol is


879
00:26:11,046 --> 00:26:12,126
create a definition.


880
00:26:12,126 --> 00:26:15,446
And this is a handle based on my


881
00:26:15,446 --> 00:26:17,846
object that registers my object


882
00:26:17,896 --> 00:26:20,236
with the system and allows me to


883
00:26:20,236 --> 00:26:21,796
use this in connections.


884
00:26:26,476 --> 00:26:28,476
Next, I handle all of the basic


885
00:26:28,476 --> 00:26:29,226
callbacks.


886
00:26:29,576 --> 00:26:30,876
And here again, because I don't


887
00:26:30,876 --> 00:26:32,646
need to have my own handshake,


888
00:26:32,926 --> 00:26:34,456
when I get called with start, I


889
00:26:35,026 --> 00:26:37,576
can return a start result of


890
00:26:37,576 --> 00:26:37,806
ready.


891
00:26:40,026 --> 00:26:42,246
Next, let's handle sending and


892
00:26:42,246 --> 00:26:43,796
encapsulating my messages.


893
00:26:47,616 --> 00:26:49,696
Here I'm going to define my


894
00:26:49,696 --> 00:26:51,296
implementation of handleOutput.


895
00:26:55,696 --> 00:26:58,416
So my header is an 8-byte header


896
00:26:58,666 --> 00:26:59,946
that includes a type and a


897
00:26:59,946 --> 00:27:00,436
length.


898
00:27:00,626 --> 00:27:02,366
So first I need to know what is


899
00:27:02,366 --> 00:27:04,786
my type, and this I get from the


900
00:27:04,786 --> 00:27:06,326
message that the application


901
00:27:06,326 --> 00:27:06,636
sent.


902
00:27:06,636 --> 00:27:08,426
And we'll see that later on.


903
00:27:08,926 --> 00:27:12,376
I've created a custom extension


904
00:27:12,376 --> 00:27:14,386
to the framer message to extract


905
00:27:14,426 --> 00:27:16,456
my particular enum type out so


906
00:27:16,886 --> 00:27:18,646
that I can know if this is a


907
00:27:18,686 --> 00:27:20,356
character selection or a move.


908
00:27:21,096 --> 00:27:22,896
So once I have the type, I can


909
00:27:22,896 --> 00:27:25,426
instantiate my struct, my game


910
00:27:25,426 --> 00:27:27,126
protocol header with the type


911
00:27:27,906 --> 00:27:29,956
and the length that I was passed


912
00:27:29,956 --> 00:27:30,796
in handleOutput.


913
00:27:32,096 --> 00:27:33,736
I've already written code to


914
00:27:34,096 --> 00:27:35,776
encode that data that I got the


915
00:27:35,776 --> 00:27:38,286
type and the length as an 8-byte


916
00:27:38,476 --> 00:27:39,466
range of bytes.


917
00:27:39,786 --> 00:27:42,006
And I call writeOutput to queue


918
00:27:42,006 --> 00:27:43,356
that in the output stream.


919
00:27:43,856 --> 00:27:47,676
And the last thing I need to do


920
00:27:47,706 --> 00:27:48,896
now that I've written my header


921
00:27:49,116 --> 00:27:50,516
is write the body.


922
00:27:50,986 --> 00:27:51,846
And here I just call


923
00:27:51,846 --> 00:27:53,606
writeOutputNoCopy and indicate


924
00:27:53,606 --> 00:27:55,956
that the next range bytes are


925
00:27:55,956 --> 00:27:57,046
going to be the body of this


926
00:27:57,046 --> 00:27:57,516
message.


927
00:27:58,736 --> 00:28:00,256
And so once this returns, those


928
00:28:00,256 --> 00:28:01,586
bytes will be sent and I'm ready


929
00:28:01,586 --> 00:28:03,306
to handle more messages either


930
00:28:03,306 --> 00:28:04,086
in or out.


931
00:28:04,676 --> 00:28:08,656
OK. So that was writing.


932
00:28:08,656 --> 00:28:10,746
Now on reading, I'm going to


933
00:28:10,746 --> 00:28:11,646
handleInput.


934
00:28:14,536 --> 00:28:16,886
So first I want to read out and


935
00:28:16,886 --> 00:28:17,676
parse my header.


936
00:28:18,126 --> 00:28:19,836
So have a fixed sized header.


937
00:28:20,066 --> 00:28:21,346
It's going to be 8 bytes.


938
00:28:22,546 --> 00:28:24,486
I'm going to try to parse out a


939
00:28:24,486 --> 00:28:26,696
minimum of eight and a maximum


940
00:28:26,696 --> 00:28:28,816
of eight and I'll get called


941
00:28:28,816 --> 00:28:32,276
with my buffer whenever those 8


942
00:28:32,276 --> 00:28:34,296
bytes are available.


943
00:28:34,916 --> 00:28:37,156
So here I validate that the


944
00:28:37,156 --> 00:28:39,196
buffer is valid and then I


945
00:28:39,196 --> 00:28:42,296
create my structure to parse out


946
00:28:42,296 --> 00:28:44,146
those 8 bytes into the type and


947
00:28:44,146 --> 00:28:44,776
length field.


948
00:28:46,716 --> 00:28:47,746
Once I've successfully done


949
00:28:47,746 --> 00:28:49,556
that, I indicate that I want to


950
00:28:49,586 --> 00:28:51,996
increment my input cursor by 8


951
00:28:52,056 --> 00:28:53,486
bytes to say that I've consumed


952
00:28:53,486 --> 00:28:54,166
these bytes.


953
00:28:54,276 --> 00:28:59,036
I'm done with them.


954
00:28:59,256 --> 00:29:01,236
Now, I do need to also handle


955
00:29:01,236 --> 00:29:02,746
the case in which I didn't


956
00:29:02,746 --> 00:29:04,596
successfully parse all 8 bytes.


957
00:29:04,786 --> 00:29:06,106
Maybe only 5 bytes were


958
00:29:06,106 --> 00:29:06,596
available.


959
00:29:07,636 --> 00:29:08,876
And so parse will have failed


960
00:29:09,436 --> 00:29:10,926
and I will return from handle


961
00:29:10,926 --> 00:29:13,726
input and indicate that I need


962
00:29:13,726 --> 00:29:15,246
to wait for 8 bytes to be


963
00:29:15,246 --> 00:29:18,166
available before I do more work.


964
00:29:18,716 --> 00:29:20,026
But if I did get past this


965
00:29:20,066 --> 00:29:21,786
point, I know that I have a


966
00:29:21,786 --> 00:29:23,886
valid header that I can use to


967
00:29:23,886 --> 00:29:25,466
deliver up the rest of the


968
00:29:25,466 --> 00:29:25,976
application data.


969
00:29:29,756 --> 00:29:31,546
So now I'm going to create a


970
00:29:31,546 --> 00:29:32,516
message object.


971
00:29:32,806 --> 00:29:34,326
I'm going to store within that


972
00:29:34,326 --> 00:29:36,496
message object my specific


973
00:29:36,496 --> 00:29:37,986
message type.


974
00:29:40,176 --> 00:29:44,066
And lastly, I will call


975
00:29:44,066 --> 00:29:47,006
deliverInput with no copying and


976
00:29:47,006 --> 00:29:48,976
just tell the connection those


977
00:29:48,976 --> 00:29:50,706
next bytes that I parsed out


978
00:29:50,746 --> 00:29:52,266
based on the length, those are


979
00:29:52,266 --> 00:29:53,506
going to be the application


980
00:29:53,506 --> 00:29:55,256
data, and when your application


981
00:29:55,256 --> 00:29:56,586
receives a message, they'll


982
00:29:56,586 --> 00:29:58,106
receive exactly that chunk.


983
00:29:59,026 --> 00:30:00,266
So that's all I need to do.


984
00:30:00,396 --> 00:30:01,606
That's my full protocol.


985
00:30:01,606 --> 00:30:04,236
I am ready to learn how to int


986
00:30:04,346 --> 00:30:05,316
input that into my game


987
00:30:05,316 --> 00:30:05,846
connections.


988
00:30:09,181 --> 00:30:11,181
[ Aapplause ]


989
00:30:11,346 --> 00:30:11,586
All right.


990
00:30:14,756 --> 00:30:16,706
So, the good news is that this


991
00:30:16,706 --> 00:30:17,826
part is really easy.


992
00:30:18,516 --> 00:30:20,166
So all you have to do to add


993
00:30:20,236 --> 00:30:21,116
your protocol into your


994
00:30:21,116 --> 00:30:23,966
connections and reuse it is take


995
00:30:23,966 --> 00:30:25,426
that definition you made earlier


996
00:30:26,316 --> 00:30:28,306
and create some protocol options


997
00:30:28,396 --> 00:30:29,516
using that definition.


998
00:30:30,016 --> 00:30:32,426
So protocol options are the


999
00:30:32,476 --> 00:30:33,966
things that protocol stacks are


1000
00:30:33,966 --> 00:30:34,426
made out of.


1001
00:30:35,036 --> 00:30:37,016
You have your TCP options, your


1002
00:30:37,016 --> 00:30:38,546
TLS options, and now you have


1003
00:30:38,546 --> 00:30:39,806
your own custom protocol


1004
00:30:39,806 --> 00:30:40,396
options.


1005
00:30:41,036 --> 00:30:42,576
So when you create your


1006
00:30:42,576 --> 00:30:43,816
parameters for your connection,


1007
00:30:43,996 --> 00:30:45,766
let's say you're using TLS as


1008
00:30:45,766 --> 00:30:46,946
you should to be secure,


1009
00:30:48,226 --> 00:30:50,806
alongside TLS in your protocol


1010
00:30:50,806 --> 00:30:53,096
stack, you can add directly into


1011
00:30:53,096 --> 00:30:54,446
that array of application


1012
00:30:54,446 --> 00:30:56,626
protocols your own protocol on


1013
00:30:56,626 --> 00:30:56,926
top.


1014
00:30:57,696 --> 00:30:58,736
And you can add multiple of


1015
00:30:58,736 --> 00:31:00,506
these to have multiple layers of


1016
00:31:00,506 --> 00:31:01,406
framing going on.


1017
00:31:02,046 --> 00:31:03,206
And this is the same place that


1018
00:31:03,206 --> 00:31:04,806
if you want to use WebSocket,


1019
00:31:05,346 --> 00:31:06,676
which is a new system


1020
00:31:06,676 --> 00:31:07,996
implementation that we have for


1021
00:31:07,996 --> 00:31:09,746
you this year, you can add it


1022
00:31:09,746 --> 00:31:10,496
into your connection.


1023
00:31:11,886 --> 00:31:14,586
So WebSocket itself is


1024
00:31:14,766 --> 00:31:16,976
implemented as a protocol framer


1025
00:31:17,266 --> 00:31:19,226
using exactly the same API that


1026
00:31:19,556 --> 00:31:21,036
you have available to you now.


1027
00:31:21,356 --> 00:31:22,506
So it shows you just how


1028
00:31:22,506 --> 00:31:24,786
powerful a framing protocol can


1029
00:31:24,786 --> 00:31:25,006
be.


1030
00:31:25,736 --> 00:31:26,596
But if you don't want to go


1031
00:31:26,596 --> 00:31:27,556
through the work of writing your


1032
00:31:27,556 --> 00:31:29,386
own, you can use WebSocket.


1033
00:31:33,546 --> 00:31:34,726
So one point I want to make here


1034
00:31:34,726 --> 00:31:36,666
is that some applications need


1035
00:31:36,666 --> 00:31:38,926
to use different protocol stacks


1036
00:31:39,256 --> 00:31:40,456
in different situations.


1037
00:31:41,366 --> 00:31:43,156
And framing protocols are a


1038
00:31:43,156 --> 00:31:46,136
really great way to make the


1039
00:31:46,136 --> 00:31:47,436
contract between your


1040
00:31:47,436 --> 00:31:48,806
application and the networking


1041
00:31:48,806 --> 00:31:51,006
connection the same even when


1042
00:31:51,006 --> 00:31:52,066
you're using different protocol


1043
00:31:52,066 --> 00:31:52,596
stacks.


1044
00:31:53,466 --> 00:31:54,916
So to give you an example of


1045
00:31:54,916 --> 00:31:57,176
this, we use this on our system


1046
00:31:57,516 --> 00:31:58,026
for DNS.


1047
00:31:58,936 --> 00:32:01,506
So DNS usually sends datagram


1048
00:32:01,506 --> 00:32:04,206
messages over UDP.


1049
00:32:05,876 --> 00:32:08,306
But occasionally, DNS needs to


1050
00:32:08,306 --> 00:32:10,256
run on top of the stream like


1051
00:32:10,256 --> 00:32:10,736
TCP.


1052
00:32:11,236 --> 00:32:12,846
And when it does this, there's a


1053
00:32:12,846 --> 00:32:14,596
protocol that just has a very


1054
00:32:14,596 --> 00:32:17,356
basic length body format to


1055
00:32:17,356 --> 00:32:19,726
encode DNS over TCP.


1056
00:32:20,726 --> 00:32:23,206
So we wrote a framer to define


1057
00:32:23,206 --> 00:32:26,216
this simple encapsulation so


1058
00:32:26,216 --> 00:32:28,106
that we can have the same code


1059
00:32:28,106 --> 00:32:31,316
on top that sends DNS datagrams


1060
00:32:31,456 --> 00:32:32,716
that doesn't have to care about


1061
00:32:32,716 --> 00:32:34,626
whether it's going over UDP or


1062
00:32:34,626 --> 00:32:36,526
TCP and it can just be the same


1063
00:32:36,526 --> 00:32:36,876
logic.


1064
00:32:37,396 --> 00:32:38,236
So this is a great way to


1065
00:32:38,236 --> 00:32:40,676
separate out the concerns and be


1066
00:32:40,676 --> 00:32:41,946
able to debug the parts of your


1067
00:32:41,946 --> 00:32:43,196
application separately.


1068
00:32:43,766 --> 00:32:47,506
So now that we've added our


1069
00:32:47,506 --> 00:32:48,776
framing protocol onto our


1070
00:32:48,776 --> 00:32:50,706
connections, we're ready to send


1071
00:32:50,706 --> 00:32:52,306
and receive messages and we can


1072
00:32:52,306 --> 00:32:55,086
use custom values as we're going


1073
00:32:55,086 --> 00:32:56,166
to be using in our game.


1074
00:32:57,476 --> 00:33:00,256
So Framer.Message lets you store


1075
00:33:00,256 --> 00:33:02,896
key value pairs of any object


1076
00:33:02,896 --> 00:33:05,436
type so that you can add in your


1077
00:33:05,436 --> 00:33:07,366
own custom values to decorate


1078
00:33:07,886 --> 00:33:10,586
your send operations and receive


1079
00:33:10,586 --> 00:33:12,196
that information inside your


1080
00:33:12,196 --> 00:33:12,646
protocol.


1081
00:33:13,586 --> 00:33:15,416
So you can create a message and


1082
00:33:15,486 --> 00:33:16,906
then when you've set it up how


1083
00:33:16,906 --> 00:33:18,516
you like, you can add it to the


1084
00:33:18,546 --> 00:33:21,476
context that you're sending your


1085
00:33:21,476 --> 00:33:22,126
data on.


1086
00:33:22,676 --> 00:33:25,006
So every send operation already


1087
00:33:25,006 --> 00:33:28,186
has content along with context.


1088
00:33:28,526 --> 00:33:30,376
And so the context describes how


1089
00:33:30,376 --> 00:33:31,396
you want to send your data.


1090
00:33:31,856 --> 00:33:33,546
So your Framer.Message is just a


1091
00:33:33,546 --> 00:33:37,096
new way to send data.


1092
00:33:37,276 --> 00:33:38,936
Receiving is very similar.


1093
00:33:39,046 --> 00:33:40,936
When you call receiveMessage,


1094
00:33:41,776 --> 00:33:43,196
you receive along with your


1095
00:33:43,196 --> 00:33:44,936
content the context that


1096
00:33:44,936 --> 00:33:46,766
describes how this data was


1097
00:33:46,766 --> 00:33:47,276
received.


1098
00:33:48,056 --> 00:33:49,746
And you can look using the


1099
00:33:49,746 --> 00:33:52,026
definition of your protocol at


1100
00:33:52,126 --> 00:33:53,956
the specific message values that


1101
00:33:53,956 --> 00:33:56,196
your protocol framer delivered


1102
00:33:56,196 --> 00:33:57,116
to you.


1103
00:33:58,006 --> 00:34:00,786
OK. I think we are ready to go


1104
00:34:00,936 --> 00:34:04,556
finish our tic-tac-toe game.


1105
00:34:05,316 --> 00:34:05,826
All right.


1106
00:34:06,696 --> 00:34:08,726
So we've already finished our


1107
00:34:08,726 --> 00:34:09,565
game protocol.


1108
00:34:10,206 --> 00:34:12,985
To add it into our connections,


1109
00:34:13,045 --> 00:34:14,795
I'm going to go back to the


1110
00:34:14,795 --> 00:34:16,496
parameters that Eric set up


1111
00:34:16,556 --> 00:34:17,025
earlier.


1112
00:34:17,025 --> 00:34:18,166
So he already set up our


1113
00:34:18,166 --> 00:34:21,065
connections to use TCP and TLS


1114
00:34:21,106 --> 00:34:22,216
with our passcode.


1115
00:34:24,106 --> 00:34:28,085
Now, all I need to do is just


1116
00:34:28,085 --> 00:34:29,036
add these two lines in.


1117
00:34:29,036 --> 00:34:30,406
We're going to create some


1118
00:34:30,406 --> 00:34:32,286
options based on my game


1119
00:34:32,286 --> 00:34:34,696
protocol definition and just


1120
00:34:34,696 --> 00:34:36,485
insert them into the array of


1121
00:34:36,485 --> 00:34:37,956
application protocols I want to


1122
00:34:37,956 --> 00:34:38,716
use in my connection.


1123
00:34:39,386 --> 00:34:41,036
Now when the connection starts


1124
00:34:41,036 --> 00:34:42,396
up between those two devices, it


1125
00:34:42,646 --> 00:34:44,985
will be ready to start encoding


1126
00:34:44,985 --> 00:34:46,616
messages over that stream.


1127
00:34:47,096 --> 00:34:51,576
Now I'm also going to do a


1128
00:34:51,576 --> 00:34:53,346
couple convenience functions


1129
00:34:53,346 --> 00:34:54,676
within my connection to make it


1130
00:34:54,746 --> 00:34:56,116
easier for my application to


1131
00:34:56,116 --> 00:34:57,896
send and receive my custom


1132
00:34:57,896 --> 00:34:58,786
message types.


1133
00:34:59,836 --> 00:35:01,326
So here I have a connection


1134
00:35:01,326 --> 00:35:03,856
object that sets up an


1135
00:35:03,856 --> 00:35:05,646
NWConnection using the


1136
00:35:05,646 --> 00:35:07,216
parameters that we just defined.


1137
00:35:08,346 --> 00:35:09,726
Whenever the connection becomes


1138
00:35:09,726 --> 00:35:11,326
ready, it's going to start


1139
00:35:11,326 --> 00:35:13,496
receiving messages from the


1140
00:35:13,496 --> 00:35:13,786
peer.


1141
00:35:15,286 --> 00:35:16,746
So we need to receive next


1142
00:35:16,746 --> 00:35:17,876
message and implement this.


1143
00:35:21,376 --> 00:35:23,316
So what I'm going to do here is


1144
00:35:23,316 --> 00:35:24,776
take my connection and call


1145
00:35:24,776 --> 00:35:25,766
receiveMessage on it.


1146
00:35:26,716 --> 00:35:28,116
I'm going to get the content


1147
00:35:28,276 --> 00:35:29,656
along with the context.


1148
00:35:30,516 --> 00:35:31,596
So I'm going to take that


1149
00:35:31,596 --> 00:35:34,506
context and look at the specific


1150
00:35:34,506 --> 00:35:37,086
metadata for my protocol, the


1151
00:35:37,086 --> 00:35:38,476
game protocol definition.


1152
00:35:39,516 --> 00:35:40,856
And that will give me my message


1153
00:35:40,856 --> 00:35:43,266
object and allow me to deliver


1154
00:35:43,266 --> 00:35:44,986
the message type along with the


1155
00:35:44,986 --> 00:35:46,146
data up to the application.


1156
00:35:47,116 --> 00:35:48,436
And then of course once I've


1157
00:35:48,436 --> 00:35:49,616
successfully received one


1158
00:35:49,616 --> 00:35:51,136
message, I'm going to call


1159
00:35:51,136 --> 00:35:52,776
receiveNextMessage to do it all


1160
00:35:52,776 --> 00:35:53,236
over again.


1161
00:35:56,016 --> 00:35:57,676
I'm also going to define some


1162
00:35:57,946 --> 00:35:59,236
helpers for sending.


1163
00:35:59,646 --> 00:36:01,096
So whenever the application


1164
00:36:01,096 --> 00:36:02,206
decides that the player is


1165
00:36:02,206 --> 00:36:04,466
selecting a character, we can


1166
00:36:04,466 --> 00:36:07,716
create a message and add the


1167
00:36:07,716 --> 00:36:09,306
selected character type to it,


1168
00:36:10,096 --> 00:36:11,946
add that on to our context and


1169
00:36:11,946 --> 00:36:12,406
send it.


1170
00:36:12,916 --> 00:36:15,826
I can do the same thing for


1171
00:36:15,826 --> 00:36:16,816
sending a move, have a


1172
00:36:16,816 --> 00:36:18,486
convenience here to say that I


1173
00:36:18,486 --> 00:36:20,106
wanted to send a move, and then


1174
00:36:20,106 --> 00:36:21,846
just take the application data


1175
00:36:22,316 --> 00:36:23,556
and send it down the connection.


1176
00:36:24,626 --> 00:36:25,626
So that's all we need to do.


1177
00:36:25,886 --> 00:36:27,606
I think we're ready to play the


1178
00:36:27,606 --> 00:36:28,616
game and I think we're going to


1179
00:36:28,616 --> 00:36:29,416
need some help to this.


1180
00:36:29,416 --> 00:36:30,626
So Eric, come back on stage.


1181
00:36:32,456 --> 00:36:33,156
All right.


1182
00:36:34,336 --> 00:36:35,896
So here Eric had already started


1183
00:36:35,896 --> 00:36:38,476
hosting a game but I want to be


1184
00:36:38,476 --> 00:36:39,546
the one hosting this one.


1185
00:36:40,726 --> 00:36:41,136
Here we go.


1186
00:36:41,136 --> 00:36:42,946
So Eric, how about you type in


1187
00:36:42,946 --> 00:36:47,406
that passcode, 5176.


1188
00:36:47,906 --> 00:36:48,686
Don't tell anyone [laughter].


1189
00:36:49,906 --> 00:36:51,116
All right.


1190
00:36:51,116 --> 00:36:52,826
So now we have a secure


1191
00:36:52,826 --> 00:36:53,896
connection set up.


1192
00:36:54,286 --> 00:36:55,336
It's using TLS.


1193
00:36:55,826 --> 00:36:57,666
And when Eric selects a


1194
00:36:57,666 --> 00:36:59,746
character-- he chose birds--


1195
00:37:00,536 --> 00:37:02,136
he's sending the select


1196
00:37:02,636 --> 00:37:04,556
character message across and I


1197
00:37:04,556 --> 00:37:06,806
call receiveMessage over here, I


1198
00:37:06,806 --> 00:37:07,926
receive that he selected that,


1199
00:37:07,926 --> 00:37:08,936
I'm going to choose to be


1200
00:37:08,936 --> 00:37:10,246
monkeys, why not.


1201
00:37:11,066 --> 00:37:13,566
At this point, Eric will select


1202
00:37:14,326 --> 00:37:16,186
a box to play and choose a


1203
00:37:16,186 --> 00:37:16,806
character.


1204
00:37:17,846 --> 00:37:18,116
All right.


1205
00:37:18,116 --> 00:37:20,846
So he sent the move message over


1206
00:37:20,846 --> 00:37:21,276
to me.


1207
00:37:21,626 --> 00:37:22,616
I can receive a message.


1208
00:37:22,616 --> 00:37:23,846
I get that it's a move.


1209
00:37:23,846 --> 00:37:25,946
I know where he's placed it and


1210
00:37:25,946 --> 00:37:29,606
I can decide, all right, there's


1211
00:37:29,606 --> 00:37:30,936
a monkey up in the top corner,


1212
00:37:31,386 --> 00:37:32,476
what's he going to do next?


1213
00:37:33,786 --> 00:37:35,066
Uh-oh, he's looking like he's


1214
00:37:35,106 --> 00:37:36,076
racing for the win.


1215
00:37:36,256 --> 00:37:36,866
I don't know.


1216
00:37:36,906 --> 00:37:38,336
I can't look at this.


1217
00:37:38,756 --> 00:37:39,896
Tic-tac-toe is hard.


1218
00:37:40,376 --> 00:37:42,236
It sounds like birds got the


1219
00:37:42,296 --> 00:37:42,736
day.


1220
00:37:43,446 --> 00:37:45,636
But as you can see, it's really


1221
00:37:45,636 --> 00:37:47,496
easy to build this type of game


1222
00:37:47,496 --> 00:37:50,076
and there's hopefully a lot more


1223
00:37:50,076 --> 00:37:51,666
nuanced games you can build with


1224
00:37:51,666 --> 00:37:53,196
this and lots of other


1225
00:37:53,196 --> 00:37:53,846
applications.


1226
00:37:53,846 --> 00:37:54,896
So we're really excited to see


1227
00:37:54,896 --> 00:37:55,236
what you do.


1228
00:37:56,516 --> 00:38:02,616
[ Applause ]


1229
00:38:03,116 --> 00:38:04,546
All right.


1230
00:38:07,116 --> 00:38:08,856
So before I move on, I want to


1231
00:38:08,856 --> 00:38:10,276
make one last comment about


1232
00:38:10,276 --> 00:38:11,316
framing protocols.


1233
00:38:11,936 --> 00:38:14,156
So, many of you have been asking


1234
00:38:14,156 --> 00:38:16,976
how you can use techniques like


1235
00:38:17,136 --> 00:38:19,236
STARTTLS with your


1236
00:38:19,236 --> 00:38:20,326
NWConnections.


1237
00:38:20,776 --> 00:38:23,406
So STARTTLS is a technique that


1238
00:38:23,406 --> 00:38:25,026
comes from the SMTP mail


1239
00:38:25,026 --> 00:38:25,556
protocol.


1240
00:38:25,556 --> 00:38:29,586
And it allows you to talk to a


1241
00:38:29,586 --> 00:38:31,406
legacy server that you don't


1242
00:38:31,406 --> 00:38:32,916
know whether or not it supports


1243
00:38:32,996 --> 00:38:35,186
TLS and secure connections and


1244
00:38:35,186 --> 00:38:36,576
do an initial handshake with it.


1245
00:38:37,106 --> 00:38:39,096
And then if TLS is supported,


1246
00:38:39,096 --> 00:38:40,956
you can add it part way through


1247
00:38:40,956 --> 00:38:41,586
your connection.


1248
00:38:41,856 --> 00:38:43,476
Now there wasn't a good way to


1249
00:38:43,476 --> 00:38:45,196
do this before, but framing


1250
00:38:45,196 --> 00:38:46,456
protocols gives you a great


1251
00:38:46,456 --> 00:38:46,876
solution.


1252
00:38:47,856 --> 00:38:50,726
So, if you create a STARTTLS


1253
00:38:50,726 --> 00:38:52,206
framing protocol and add it into


1254
00:38:52,206 --> 00:38:53,526
your connection, when your


1255
00:38:53,526 --> 00:38:55,806
application starts, you can


1256
00:38:55,916 --> 00:38:57,186
begin a handshake with the


1257
00:38:57,186 --> 00:38:58,376
server to determine whether or


1258
00:38:58,376 --> 00:38:59,606
not it supports TLS.


1259
00:39:00,416 --> 00:39:01,386
And then we allow you to


1260
00:39:01,386 --> 00:39:02,956
dynamically add in other


1261
00:39:02,956 --> 00:39:04,836
protocols onto the stack above


1262
00:39:04,836 --> 00:39:06,746
your framing protocol before you


1263
00:39:06,746 --> 00:39:07,286
call ready.


1264
00:39:07,956 --> 00:39:09,156
This way the application can


1265
00:39:09,156 --> 00:39:11,736
remain unchanged and not have to


1266
00:39:11,736 --> 00:39:13,436
worry about adding TLS part way


1267
00:39:13,436 --> 00:39:13,866
through.


1268
00:39:14,216 --> 00:39:15,926
It can just happen automatically


1269
00:39:16,226 --> 00:39:17,446
with your framing protocol.


1270
00:39:18,246 --> 00:39:19,216
So we think it's a really


1271
00:39:19,216 --> 00:39:19,936
elegant solution.


1272
00:39:21,516 --> 00:39:22,256
All right.


1273
00:39:23,576 --> 00:39:24,366
Let's move on.


1274
00:39:25,006 --> 00:39:27,146
So, we've talked about Bonjour,


1275
00:39:27,146 --> 00:39:28,836
how we can make better


1276
00:39:28,836 --> 00:39:30,276
peer-to-peer connections and use


1277
00:39:30,276 --> 00:39:31,456
wide-area discovery.


1278
00:39:31,686 --> 00:39:33,406
We talked about framing


1279
00:39:33,406 --> 00:39:34,136
protocols.


1280
00:39:35,086 --> 00:39:36,136
But now I want to take a bit of


1281
00:39:36,136 --> 00:39:38,166
a step back and look at how you


1282
00:39:38,166 --> 00:39:40,096
can collect metrics about the


1283
00:39:40,096 --> 00:39:42,306
connections within your app.


1284
00:39:43,356 --> 00:39:45,046
So collecting metrics is really,


1285
00:39:45,046 --> 00:39:45,726
really critical.


1286
00:39:46,876 --> 00:39:50,006
It allows you to validate that


1287
00:39:50,006 --> 00:39:52,836
when you add new features into


1288
00:39:52,836 --> 00:39:54,736
your app or onto your server


1289
00:39:55,446 --> 00:39:56,366
that are supposed to help you


1290
00:39:56,366 --> 00:39:57,546
get better performance that


1291
00:39:57,546 --> 00:39:58,656
they're really doing it, like


1292
00:39:58,656 --> 00:39:59,936
you're having the effects that


1293
00:39:59,936 --> 00:40:00,566
you want.


1294
00:40:01,526 --> 00:40:03,756
But it also helps you identify


1295
00:40:04,346 --> 00:40:06,196
problems that your users may be


1296
00:40:06,196 --> 00:40:08,016
encountering out in the real


1297
00:40:08,016 --> 00:40:09,946
world that you don't notice on


1298
00:40:10,826 --> 00:40:12,056
your desk.


1299
00:40:12,516 --> 00:40:14,606
So this year, we have a lot of


1300
00:40:14,606 --> 00:40:16,206
great new metrics to help you


1301
00:40:16,206 --> 00:40:17,396
analyze your connections even


1302
00:40:17,396 --> 00:40:17,696
more.


1303
00:40:18,446 --> 00:40:20,426
URLSession already has many


1304
00:40:20,426 --> 00:40:22,236
fantastic metrics but you'll be


1305
00:40:22,236 --> 00:40:23,476
able to get even more.


1306
00:40:23,546 --> 00:40:24,996
And for the first time in


1307
00:40:24,996 --> 00:40:26,496
Network.framework, you will


1308
00:40:26,496 --> 00:40:28,286
inspect your connections to


1309
00:40:28,286 --> 00:40:30,486
understand many aspects of their


1310
00:40:30,486 --> 00:40:31,166
performance.


1311
00:40:32,926 --> 00:40:35,326
So in URLSession, you can


1312
00:40:35,326 --> 00:40:37,016
already get a timing breakdown


1313
00:40:37,286 --> 00:40:40,896
of DNS, TCP, TLS, and HTTP


1314
00:40:40,896 --> 00:40:43,016
messages within your app.


1315
00:40:44,456 --> 00:40:46,086
Now you'll be able to introspect


1316
00:40:46,386 --> 00:40:48,726
even more connection properties


1317
00:40:49,706 --> 00:40:53,006
along with the amount of data


1318
00:40:53,006 --> 00:40:54,146
that you're sending for


1319
00:40:54,146 --> 00:40:55,866
individual requests and


1320
00:40:55,866 --> 00:40:56,546
responses.


1321
00:40:58,816 --> 00:41:00,376
And in Network.framework, you'll


1322
00:41:00,376 --> 00:41:01,856
be able to access a connection


1323
00:41:01,856 --> 00:41:03,506
establishment report that


1324
00:41:03,506 --> 00:41:04,966
summarizes everything that


1325
00:41:04,966 --> 00:41:06,396
happened during your connection


1326
00:41:06,396 --> 00:41:08,966
bring up along with data


1327
00:41:08,966 --> 00:41:10,946
transfer reports that allow you


1328
00:41:10,946 --> 00:41:12,236
to look at the performance of


1329
00:41:12,346 --> 00:41:14,386
individual periods of time over


1330
00:41:14,386 --> 00:41:15,036
your connection.


1331
00:41:15,106 --> 00:41:16,666
And you have multiple of these


1332
00:41:16,666 --> 00:41:17,836
running at the same time.


1333
00:41:18,426 --> 00:41:21,546
So let's start with URLSession.


1334
00:41:21,996 --> 00:41:25,116
As a reminder, all of the


1335
00:41:25,116 --> 00:41:26,596
metrics in URLSession are


1336
00:41:26,596 --> 00:41:27,356
available in the


1337
00:41:27,356 --> 00:41:29,226
didFinishCollectingMetrics


1338
00:41:29,416 --> 00:41:30,116
delegate call.


1339
00:41:32,096 --> 00:41:34,086
So, here are some of the new


1340
00:41:34,086 --> 00:41:36,016
things that you can access are


1341
00:41:36,016 --> 00:41:37,326
the endpoints of the connection,


1342
00:41:38,276 --> 00:41:40,566
the local and remote addresses


1343
00:41:40,566 --> 00:41:41,236
and ports.


1344
00:41:41,646 --> 00:41:43,756
You can also check out the


1345
00:41:43,756 --> 00:41:45,036
security properties.


1346
00:41:45,396 --> 00:41:48,836
Are you using TLS 1.3, the


1347
00:41:48,836 --> 00:41:50,986
latest most secure and most


1348
00:41:50,986 --> 00:41:52,436
performant version of TLS?


1349
00:41:52,436 --> 00:41:55,886
You can also check the path


1350
00:41:55,886 --> 00:41:56,666
properties.


1351
00:41:57,636 --> 00:41:59,546
So, this tells you things like


1352
00:41:59,796 --> 00:42:01,606
did your connection use a


1353
00:42:01,606 --> 00:42:03,446
constrained low data mode


1354
00:42:03,446 --> 00:42:05,656
network, or did you use an


1355
00:42:05,656 --> 00:42:07,586
expensive cellular network?


1356
00:42:10,216 --> 00:42:12,266
The equivalent metrics within


1357
00:42:12,456 --> 00:42:14,586
Network.framework are in the


1358
00:42:14,586 --> 00:42:15,506
establishment report.


1359
00:42:16,346 --> 00:42:17,776
So this is available to you any


1360
00:42:17,776 --> 00:42:19,056
time after your connection has


1361
00:42:19,056 --> 00:42:20,816
moved into the ready state.


1362
00:42:20,926 --> 00:42:23,416
And this gives you a breakdown


1363
00:42:23,486 --> 00:42:26,426
if your DNS times, your protocol


1364
00:42:26,426 --> 00:42:29,216
handshakes for TCP and TLS, as


1365
00:42:29,216 --> 00:42:30,526
well as whether or not you used


1366
00:42:30,526 --> 00:42:31,006
a proxy.


1367
00:42:31,536 --> 00:42:33,576
Here's how it looks in code.


1368
00:42:33,856 --> 00:42:34,986
So you take your connection and


1369
00:42:34,986 --> 00:42:35,476
you call


1370
00:42:35,676 --> 00:42:37,146
requestEstablishmentReport.


1371
00:42:37,806 --> 00:42:39,886
And this takes a queue on which


1372
00:42:39,886 --> 00:42:41,516
it will deliver the report.


1373
00:42:42,696 --> 00:42:43,986
Once you have that you can check


1374
00:42:43,986 --> 00:42:45,136
the overall time that the


1375
00:42:45,136 --> 00:42:45,776
connection took.


1376
00:42:46,296 --> 00:42:48,486
You can check the individual


1377
00:42:48,486 --> 00:42:49,626
resolution steps.


1378
00:42:49,836 --> 00:42:51,306
So if you were connecting by a


1379
00:42:51,306 --> 00:42:53,416
Bonjour name, it may be


1380
00:42:53,416 --> 00:42:55,056
resolving Bonjour names into


1381
00:42:55,056 --> 00:42:56,886
host names and host names into


1382
00:42:56,886 --> 00:42:58,756
addresses, and you can look at


1383
00:42:58,786 --> 00:42:59,966
the timing breakdown on each of


1384
00:42:59,966 --> 00:43:00,626
those steps.


1385
00:43:01,136 --> 00:43:03,806
And you can also look at the


1386
00:43:03,806 --> 00:43:06,286
individual timings for a TCP,


1387
00:43:06,346 --> 00:43:08,256
TLS, as well as the round-trip


1388
00:43:08,256 --> 00:43:09,126
times they observed.


1389
00:43:09,346 --> 00:43:13,476
One point that I want to


1390
00:43:13,476 --> 00:43:14,306
highlight that's really


1391
00:43:14,306 --> 00:43:15,386
important to the overall


1392
00:43:15,386 --> 00:43:16,566
performance of your connection


1393
00:43:16,566 --> 00:43:18,936
establishment is the amount of


1394
00:43:18,936 --> 00:43:20,756
time that it takes to resolve


1395
00:43:20,886 --> 00:43:23,376
DNS and the source of where your


1396
00:43:23,376 --> 00:43:25,166
DNS resolution came.


1397
00:43:27,386 --> 00:43:30,286
So, many servers have a very


1398
00:43:30,286 --> 00:43:32,876
short time to live configured on


1399
00:43:32,876 --> 00:43:34,046
their DNS records.


1400
00:43:34,446 --> 00:43:36,846
And they do this such that if a


1401
00:43:36,846 --> 00:43:39,866
server goes down or the server


1402
00:43:39,866 --> 00:43:40,886
wants to load balance over


1403
00:43:40,946 --> 00:43:43,246
another IP address, it can


1404
00:43:43,246 --> 00:43:44,956
quickly change the IP address


1405
00:43:44,956 --> 00:43:47,546
record and have clients adjust


1406
00:43:47,546 --> 00:43:49,056
and start using the new address.


1407
00:43:50,166 --> 00:43:52,116
The downside, though, is that


1408
00:43:52,116 --> 00:43:53,806
this really can hurt client


1409
00:43:53,806 --> 00:43:54,546
performance.


1410
00:43:55,736 --> 00:43:57,666
With a short time to live, a


1411
00:43:57,666 --> 00:43:59,546
client will almost always have


1412
00:43:59,616 --> 00:44:01,646
to take the round trip to do


1413
00:44:01,646 --> 00:44:04,236
DNS, to request the address for


1414
00:44:04,236 --> 00:44:06,106
the host name that you are


1415
00:44:06,106 --> 00:44:06,766
connecting to.


1416
00:44:07,286 --> 00:44:11,066
And this can be particularly bad


1417
00:44:11,366 --> 00:44:12,866
for clients that have a high


1418
00:44:12,866 --> 00:44:13,636
latency link.


1419
00:44:14,286 --> 00:44:16,396
This is going to add hundreds of


1420
00:44:16,396 --> 00:44:17,946
milliseconds or even seconds on


1421
00:44:17,946 --> 00:44:19,156
to their connection times.


1422
00:44:19,786 --> 00:44:22,126
And the worst part is most of


1423
00:44:22,126 --> 00:44:23,816
the time, the server address has


1424
00:44:23,816 --> 00:44:26,256
not changed at all, and so this


1425
00:44:26,256 --> 00:44:27,296
is a wasted round trip.


1426
00:44:28,426 --> 00:44:30,906
So, optimistic DNS is a solution


1427
00:44:30,906 --> 00:44:33,016
that we released last year that


1428
00:44:33,016 --> 00:44:34,256
solves this problem.


1429
00:44:35,786 --> 00:44:37,636
Optimistic DNS allows your


1430
00:44:37,636 --> 00:44:39,636
connection to optimistically


1431
00:44:39,916 --> 00:44:42,376
connect to the last known good


1432
00:44:42,376 --> 00:44:43,846
IP address for that host name,


1433
00:44:44,816 --> 00:44:46,716
in parallel with issuing a new


1434
00:44:46,716 --> 00:44:48,586
query for the host name's


1435
00:44:48,636 --> 00:44:49,766
current address.


1436
00:44:51,146 --> 00:44:52,776
If nothing has changed, which is


1437
00:44:52,776 --> 00:44:55,246
almost always the case, the


1438
00:44:55,246 --> 00:44:56,456
connection will just establish


1439
00:44:56,456 --> 00:44:58,356
to the old IP address.


1440
00:44:58,676 --> 00:45:00,016
But if something has changed


1441
00:45:00,016 --> 00:45:01,266
you'll still get the new IP


1442
00:45:01,266 --> 00:45:02,316
address and connect to it


1443
00:45:02,316 --> 00:45:02,776
instead.


1444
00:45:03,376 --> 00:45:05,126
We have been doing a lot of


1445
00:45:05,126 --> 00:45:06,676
measurements on this and testing


1446
00:45:07,206 --> 00:45:08,996
and it is a really great


1447
00:45:08,996 --> 00:45:09,456
solution.


1448
00:45:09,456 --> 00:45:11,126
And so this year, it is on by


1449
00:45:11,126 --> 00:45:12,976
default for connections using


1450
00:45:12,976 --> 00:45:14,156
Network.framework and


1451
00:45:14,156 --> 00:45:14,936
URLSession.


1452
00:45:16,736 --> 00:45:17,866
When you're looking at your


1453
00:45:17,866 --> 00:45:19,146
establishment report, you can


1454
00:45:19,146 --> 00:45:21,046
tell whether or not you used


1455
00:45:21,046 --> 00:45:22,986
optimistic DNS by looking at the


1456
00:45:22,986 --> 00:45:23,636
source.


1457
00:45:24,116 --> 00:45:25,216
And if it says it's from the


1458
00:45:25,216 --> 00:45:27,746
expired cache, that means we


1459
00:45:27,746 --> 00:45:29,656
ended up using and benefiting


1460
00:45:29,746 --> 00:45:30,966
from optimistic DNS.


1461
00:45:31,726 --> 00:45:34,566
I want to show you a bit how you


1462
00:45:34,566 --> 00:45:36,416
can use metrics to look at the


1463
00:45:36,416 --> 00:45:38,196
performance of your connections


1464
00:45:38,196 --> 00:45:39,926
and the benefit of optimistic


1465
00:45:39,926 --> 00:45:47,196
DNS and TLS 1.3.


1466
00:45:47,426 --> 00:45:49,766
OK. So here I have an


1467
00:45:49,766 --> 00:45:51,556
application that's a very basic


1468
00:45:51,556 --> 00:45:53,666
app to collect connection


1469
00:45:53,666 --> 00:45:54,216
metrics.


1470
00:45:54,346 --> 00:45:56,526
All it does is run a probe to a


1471
00:45:56,526 --> 00:45:57,286
given website.


1472
00:45:57,756 --> 00:45:58,006
All right.


1473
00:45:58,656 --> 00:46:00,186
So here it is.


1474
00:46:00,186 --> 00:46:01,836
I clicked Run Probe and I


1475
00:46:01,836 --> 00:46:03,306
connected and it's pretty fast.


1476
00:46:03,306 --> 00:46:07,156
I'm doing this on a great Wi-Fi


1477
00:46:07,716 --> 00:46:07,916
network.


1478
00:46:08,506 --> 00:46:10,336
But if you want to test a more


1479
00:46:10,336 --> 00:46:12,176
realistic scenario or see the


1480
00:46:12,176 --> 00:46:13,496
effects of different network


1481
00:46:13,496 --> 00:46:15,606
conditions, you are now able to


1482
00:46:16,146 --> 00:46:18,026
within the devices and


1483
00:46:18,026 --> 00:46:20,806
simulators panel of Xcode access


1484
00:46:20,806 --> 00:46:23,226
device conditions and simulate


1485
00:46:23,646 --> 00:46:24,976
different network link


1486
00:46:24,976 --> 00:46:25,626
conditions.


1487
00:46:25,806 --> 00:46:26,886
So you can see what it's like


1488
00:46:26,886 --> 00:46:29,226
potentially for your users in


1489
00:46:29,446 --> 00:46:30,416
different scenarios [applause].


1490
00:46:31,196 --> 00:46:33,286
Yes, it's great.


1491
00:46:35,736 --> 00:46:37,126
So let's see what it looks like


1492
00:46:37,296 --> 00:46:39,096
to have a high latency DNS link.


1493
00:46:40,256 --> 00:46:41,826
So I clicked Start and you can


1494
00:46:41,826 --> 00:46:42,936
tell that it's running because I


1495
00:46:42,936 --> 00:46:45,496
have this gray box up in the


1496
00:46:45,496 --> 00:46:46,426
upper left hand corner.


1497
00:46:47,546 --> 00:46:50,266
So now, let's run that probe


1498
00:46:50,266 --> 00:46:50,716
again.


1499
00:46:50,716 --> 00:46:53,086
So it was fast.


1500
00:46:53,796 --> 00:46:54,326
That's great.


1501
00:46:54,546 --> 00:46:55,926
But you'll notice that it came


1502
00:46:55,926 --> 00:46:57,486
from the expired cache.


1503
00:46:57,966 --> 00:46:59,226
So this means that we ended up


1504
00:46:59,276 --> 00:47:00,616
using optimistic DNS.


1505
00:47:01,486 --> 00:47:04,476
So optimistic DNS is on by


1506
00:47:04,476 --> 00:47:06,196
default but you-- we let you


1507
00:47:06,196 --> 00:47:07,626
turn it off if you don't think


1508
00:47:07,626 --> 00:47:08,826
it's appropriate for your


1509
00:47:08,826 --> 00:47:09,236
server.


1510
00:47:09,956 --> 00:47:11,186
So let's run the probe again.


1511
00:47:11,836 --> 00:47:14,796
You can feel the seconds go by.


1512
00:47:15,796 --> 00:47:17,766
So, this is potentially a bit


1513
00:47:17,766 --> 00:47:18,606
exaggerated.


1514
00:47:18,696 --> 00:47:19,936
Hopefully your users don't have


1515
00:47:19,936 --> 00:47:21,986
three seconds of DNS latency but


1516
00:47:21,986 --> 00:47:23,526
it can make a huge difference.


1517
00:47:24,146 --> 00:47:26,956
Let's go to a bit more realistic


1518
00:47:26,956 --> 00:47:30,086
scenario now, something like an


1519
00:47:30,086 --> 00:47:31,836
average 3G network.


1520
00:47:32,496 --> 00:47:35,956
I'm going to start this and run


1521
00:47:35,956 --> 00:47:37,166
the probe one more time.


1522
00:47:37,766 --> 00:47:40,436
So it wasn't quite as snappy as


1523
00:47:40,436 --> 00:47:41,356
the first time I ran it.


1524
00:47:42,096 --> 00:47:43,726
Overall you can see that I have


1525
00:47:43,726 --> 00:47:45,866
about 600 milliseconds for the


1526
00:47:45,866 --> 00:47:46,846
connection to establish.


1527
00:47:47,306 --> 00:47:51,786
And TLS alone took around little


1528
00:47:51,786 --> 00:47:53,416
bit less than 300 milliseconds,


1529
00:47:53,416 --> 00:47:56,826
so about half of that time.


1530
00:47:57,016 --> 00:47:59,006
So our server is configured to


1531
00:47:59,006 --> 00:48:00,506
support TLS 1.3.


1532
00:48:00,906 --> 00:48:04,166
Now TLS 1.3 generally only takes


1533
00:48:04,206 --> 00:48:06,066
one round trip to do the full


1534
00:48:06,066 --> 00:48:06,486
handshake.


1535
00:48:06,776 --> 00:48:08,146
It's great improvement.


1536
00:48:09,086 --> 00:48:10,286
But if your server doesn't


1537
00:48:10,286 --> 00:48:11,946
support TLS 1.3, if it only


1538
00:48:11,946 --> 00:48:14,806
supports TLS 1.2 or if you're


1539
00:48:14,806 --> 00:48:18,416
using an API on your app that


1540
00:48:18,416 --> 00:48:22,476
doesn't support TLS 1.3, you may


1541
00:48:22,476 --> 00:48:24,836
see scenarios more like this in


1542
00:48:24,836 --> 00:48:27,326
which TLS alone is now taking


1543
00:48:27,616 --> 00:48:29,466
over 500 milliseconds, taking an


1544
00:48:29,466 --> 00:48:30,246
extra round trip.


1545
00:48:31,166 --> 00:48:31,906
And you can see that the


1546
00:48:31,906 --> 00:48:34,286
connection time is almost-- it's


1547
00:48:34,286 --> 00:48:35,576
over three-quarters of a second,


1548
00:48:35,656 --> 00:48:36,496
almost at a second.


1549
00:48:36,926 --> 00:48:37,946
And if you have many


1550
00:48:37,946 --> 00:48:39,796
connections, this can really add


1551
00:48:39,796 --> 00:48:42,466
up to perceivable user latency.


1552
00:48:43,216 --> 00:48:44,376
So we encourage you that


1553
00:48:44,376 --> 00:48:45,326
whenever you're testing your


1554
00:48:45,326 --> 00:48:47,576
app, do a run through network


1555
00:48:47,576 --> 00:48:49,276
link conditioner and try out


1556
00:48:49,276 --> 00:48:50,856
some of these scenarios and


1557
00:48:50,856 --> 00:48:52,746
validate that your app performs


1558
00:48:52,746 --> 00:48:53,026
well.


1559
00:49:01,196 --> 00:49:02,476
So the other category of


1560
00:49:02,476 --> 00:49:04,546
metrics, have to do with the


1561
00:49:04,546 --> 00:49:05,956
data transfer after the


1562
00:49:05,956 --> 00:49:07,186
connection is established.


1563
00:49:08,356 --> 00:49:10,576
So in URLSession, you are now


1564
00:49:10,576 --> 00:49:12,456
going to be able to access more


1565
00:49:12,456 --> 00:49:13,566
metrics about the number of


1566
00:49:13,566 --> 00:49:15,496
bytes that you sent in the


1567
00:49:15,496 --> 00:49:17,186
header and the body of your


1568
00:49:17,186 --> 00:49:19,606
requests as well as the number


1569
00:49:19,606 --> 00:49:21,356
of bytes that your receive in


1570
00:49:21,356 --> 00:49:23,856
the headers and bodies of your


1571
00:49:23,856 --> 00:49:24,686
responses.


1572
00:49:25,606 --> 00:49:27,286
And this is really important if


1573
00:49:27,286 --> 00:49:29,866
you are choosing a different URL


1574
00:49:30,126 --> 00:49:32,916
to download less data in a low


1575
00:49:32,916 --> 00:49:35,946
data mode network scenario, use


1576
00:49:36,026 --> 00:49:37,196
this to validate that you're


1577
00:49:37,256 --> 00:49:38,976
actually saving your user's


1578
00:49:39,986 --> 00:49:40,106
bytes.


1579
00:49:42,796 --> 00:49:44,616
In Network.framework, you can


1580
00:49:44,616 --> 00:49:46,506
now access a data transfer


1581
00:49:46,506 --> 00:49:48,426
report that summarizes the


1582
00:49:48,426 --> 00:49:50,536
performance in terms of bytes


1583
00:49:50,926 --> 00:49:52,886
and packets and round trip times


1584
00:49:53,416 --> 00:49:56,026
for a given period of time on


1585
00:49:56,026 --> 00:49:56,606
your connection.


1586
00:49:56,986 --> 00:49:58,136
You can have multiple of these


1587
00:49:58,136 --> 00:49:59,156
running at the same time and


1588
00:49:59,246 --> 00:50:00,236
they should correspond to your


1589
00:50:00,236 --> 00:50:00,976
application's activity.


1590
00:50:01,236 --> 00:50:03,116
So if you send a burst of


1591
00:50:03,116 --> 00:50:05,176
traffic, have that be within a


1592
00:50:05,176 --> 00:50:06,236
data transfer report.


1593
00:50:06,896 --> 00:50:08,576
And it's not as interesting to


1594
00:50:08,656 --> 00:50:11,446
take reports of idle periods.


1595
00:50:11,976 --> 00:50:14,176
The way that you do this is that


1596
00:50:14,176 --> 00:50:15,956
at any point you can call start


1597
00:50:15,956 --> 00:50:18,266
data transfer report on your


1598
00:50:18,266 --> 00:50:18,776
connection.


1599
00:50:19,286 --> 00:50:21,896
This begins gathering data about


1600
00:50:21,896 --> 00:50:23,366
your connection's performance.


1601
00:50:24,336 --> 00:50:25,946
And when you're done sending a


1602
00:50:25,946 --> 00:50:27,126
bunch of data, you can call


1603
00:50:27,126 --> 00:50:27,606
collect.


1604
00:50:28,316 --> 00:50:29,746
This will summarize all of the


1605
00:50:29,746 --> 00:50:31,606
data and give you a report.


1606
00:50:32,836 --> 00:50:34,936
Now, if you're using multipath


1607
00:50:34,996 --> 00:50:36,996
protocols, this will give you a


1608
00:50:36,996 --> 00:50:39,446
breakdown of the amounts that


1609
00:50:39,446 --> 00:50:41,456
were sent over each link that


1610
00:50:41,456 --> 00:50:42,556
the multipath protocol was


1611
00:50:42,556 --> 00:50:42,976
using.


1612
00:50:43,896 --> 00:50:45,006
But many of you may be


1613
00:50:45,006 --> 00:50:46,526
interested just in the aggregate


1614
00:50:46,656 --> 00:50:47,316
path report.


1615
00:50:48,716 --> 00:50:50,506
Here you can look at the number


1616
00:50:50,506 --> 00:50:51,566
of packets that you sent and


1617
00:50:51,566 --> 00:50:53,386
received, the number of bytes


1618
00:50:53,386 --> 00:50:55,036
that were transferred, as well


1619
00:50:55,036 --> 00:50:56,696
as the round-trip time details


1620
00:50:56,696 --> 00:50:57,336
that you observed.


1621
00:50:58,806 --> 00:51:00,756
So this is metrics we were


1622
00:51:00,756 --> 00:51:02,306
really excited to see people


1623
00:51:02,306 --> 00:51:04,316
adopt more metrics and help


1624
00:51:04,416 --> 00:51:05,606
improve the performance of their


1625
00:51:05,666 --> 00:51:06,076
apps.


1626
00:51:06,966 --> 00:51:08,726
And to leave us with some great


1627
00:51:08,726 --> 00:51:10,386
advice and new updates, I'd like


1628
00:51:10,386 --> 00:51:11,416
to invite Stuart up to the


1629
00:51:11,416 --> 00:51:11,856
stage.


1630
00:51:12,516 --> 00:51:14,866
[ Applause ]


1631
00:51:15,366 --> 00:51:16,116
>> Thank you, Tommy.


1632
00:51:17,516 --> 00:51:19,286
It is my pleasure and privilege


1633
00:51:19,606 --> 00:51:21,306
to present the wrap-up for what


1634
00:51:21,306 --> 00:51:23,326
has been two hours of really


1635
00:51:23,326 --> 00:51:24,766
great networking information


1636
00:51:24,766 --> 00:51:26,046
from my fellow presenters.


1637
00:51:26,916 --> 00:51:29,986
I'm going to start off with iPad


1638
00:51:29,986 --> 00:51:30,906
apps for Mac.


1639
00:51:31,956 --> 00:51:33,046
I know a lot of you are excited


1640
00:51:33,046 --> 00:51:33,666
about this.


1641
00:51:34,206 --> 00:51:35,626
When it comes to networking,


1642
00:51:36,296 --> 00:51:36,936
there are very little


1643
00:51:36,936 --> 00:51:38,726
differences on Apple platforms.


1644
00:51:39,536 --> 00:51:41,056
One thing you will want to be


1645
00:51:41,056 --> 00:51:44,626
aware of is in your Xcode


1646
00:51:44,626 --> 00:51:47,166
settings, when you check the box


1647
00:51:47,166 --> 00:51:51,036
for Mac, you will now see some


1648
00:51:51,036 --> 00:51:51,826
new options.


1649
00:51:52,216 --> 00:51:54,786
By default, outgoing connections


1650
00:51:54,786 --> 00:51:56,306
are allowed but if you want


1651
00:51:56,366 --> 00:51:57,636
incoming connections for your


1652
00:51:57,636 --> 00:51:59,296
app as well, you have to check


1653
00:51:59,296 --> 00:51:59,916
that box.


1654
00:52:05,696 --> 00:52:07,976
On watchOS, we have new


1655
00:52:07,976 --> 00:52:09,396
networking capabilities.


1656
00:52:11,036 --> 00:52:12,946
Applications that do audio


1657
00:52:12,946 --> 00:52:16,016
streaming using AVFoundation can


1658
00:52:16,016 --> 00:52:18,756
now use direct networking, as


1659
00:52:18,756 --> 00:52:20,696
long as they're using URLSession


1660
00:52:21,046 --> 00:52:22,136
or Network.framework.


1661
00:52:23,036 --> 00:52:24,576
Sockets is not available.


1662
00:52:30,156 --> 00:52:33,226
We are also introducing TLS 1.3


1663
00:52:33,636 --> 00:52:34,516
which gives you lots of


1664
00:52:34,516 --> 00:52:35,196
benefits.


1665
00:52:36,136 --> 00:52:38,166
TLS 1.3 has better connection


1666
00:52:38,166 --> 00:52:38,866
performance.


1667
00:52:39,036 --> 00:52:42,106
TLS 1.2 typically has two round


1668
00:52:42,106 --> 00:52:43,466
trips to set up a connection.


1669
00:52:43,546 --> 00:52:46,066
TLS 1.3 almost always does it in


1670
00:52:46,066 --> 00:52:46,806
one round trip.


1671
00:52:48,146 --> 00:52:51,646
TLS 1.2 used cryptographic


1672
00:52:51,646 --> 00:52:53,236
algorithms that were believed to


1673
00:52:53,236 --> 00:52:54,896
be good at the time but have


1674
00:52:54,896 --> 00:52:55,986
since been shown type of


1675
00:52:55,986 --> 00:52:56,586
weaknesses.


1676
00:52:56,586 --> 00:52:58,096
And this is not just an academic


1677
00:52:58,096 --> 00:52:58,756
concern.


1678
00:52:58,806 --> 00:52:59,966
These have been exploited in


1679
00:52:59,966 --> 00:53:00,486
practice.


1680
00:53:01,676 --> 00:53:03,566
Those have all been removed in


1681
00:53:03,566 --> 00:53:07,026
TLS 1.3 and all the


1682
00:53:07,026 --> 00:53:08,866
cryptographic algorithms in TLS


1683
00:53:08,866 --> 00:53:11,726
1.3 support authenticated


1684
00:53:11,726 --> 00:53:13,696
encryption with associated data


1685
00:53:13,986 --> 00:53:14,996
and forward secrecy.


1686
00:53:16,176 --> 00:53:18,626
And finally, you all know that


1687
00:53:18,626 --> 00:53:19,966
privacy is very important to


1688
00:53:19,966 --> 00:53:20,466
Apple.


1689
00:53:20,986 --> 00:53:23,416
TLS 1.3 has much better privacy.


1690
00:53:24,176 --> 00:53:26,796
Many of their header fields and


1691
00:53:27,006 --> 00:53:30,166
certificates in TLS 1.2 was sent


1692
00:53:30,166 --> 00:53:30,706
in the clear.


1693
00:53:31,186 --> 00:53:32,926
Those are now all encrypted in


1694
00:53:32,926 --> 00:53:34,076
TLS 1.3.


1695
00:53:34,686 --> 00:53:38,276
So, the call to action is start


1696
00:53:38,276 --> 00:53:39,736
using TLS 1.3 on your


1697
00:53:39,736 --> 00:53:41,856
applications and of course, make


1698
00:53:41,856 --> 00:53:43,456
sure your servers are updated to


1699
00:53:43,456 --> 00:53:46,996
support TLS 1.3 too.


1700
00:53:47,616 --> 00:53:49,476
Now, you all know the importance


1701
00:53:49,476 --> 00:53:50,476
of privacy to Apple.


1702
00:53:51,146 --> 00:53:52,936
And one of the things we


1703
00:53:52,936 --> 00:53:56,416
realized is that accessing Wi-Fi


1704
00:53:56,416 --> 00:53:58,456
information can be used to infer


1705
00:53:58,456 --> 00:53:59,286
locations.


1706
00:53:59,916 --> 00:54:02,936
So starting now, to access that


1707
00:54:02,936 --> 00:54:05,066
Wi-Fi information, you will need


1708
00:54:05,456 --> 00:54:07,586
the same kind of privileges that


1709
00:54:07,586 --> 00:54:09,126
you need to get other location


1710
00:54:09,126 --> 00:54:09,736
information.


1711
00:54:10,786 --> 00:54:12,626
The first step is in Xcode you


1712
00:54:12,626 --> 00:54:14,716
have to add the capability to


1713
00:54:14,716 --> 00:54:16,846
access Wi-Fi information to add


1714
00:54:16,846 --> 00:54:18,666
the entitlement to your project,


1715
00:54:18,666 --> 00:54:22,266
and then your app must meet one


1716
00:54:22,266 --> 00:54:23,706
of three other criteria.


1717
00:54:23,706 --> 00:54:26,086
If the user has given your app


1718
00:54:26,386 --> 00:54:28,496
location access, then you can


1719
00:54:28,496 --> 00:54:29,786
access the Wi-Fi network


1720
00:54:29,786 --> 00:54:30,416
information.


1721
00:54:31,556 --> 00:54:33,356
If your app is the currently


1722
00:54:33,356 --> 00:54:35,766
enabled VPN app on the device,


1723
00:54:36,376 --> 00:54:37,816
you can access the information.


1724
00:54:37,986 --> 00:54:40,146
And finally, if your app is in


1725
00:54:40,146 --> 00:54:42,276
any hotspot configuration app,


1726
00:54:42,676 --> 00:54:44,036
then it can also access the


1727
00:54:44,036 --> 00:54:45,396
information but only for the


1728
00:54:45,396 --> 00:54:47,276
networks that it has configured.


1729
00:54:48,496 --> 00:54:49,896
For more information you can


1730
00:54:49,896 --> 00:54:51,436
also see the Wi-Fi framework.


1731
00:54:52,066 --> 00:54:55,996
You've heard many times today


1732
00:54:55,996 --> 00:54:57,096
I'm going to finish with a


1733
00:54:57,096 --> 00:54:58,846
reminder about the importance of


1734
00:54:58,846 --> 00:54:59,896
using the network link


1735
00:54:59,896 --> 00:55:00,356
conditioner.


1736
00:55:02,166 --> 00:55:03,716
It's very easy when you're


1737
00:55:03,716 --> 00:55:05,446
developing your application in


1738
00:55:05,446 --> 00:55:08,666
the simulator on a Mac with


1739
00:55:08,666 --> 00:55:10,296
gigabit ethernet in it or


1740
00:55:10,296 --> 00:55:12,276
talking to a local server on


1741
00:55:12,276 --> 00:55:12,816
loop-back.


1742
00:55:13,396 --> 00:55:15,686
When you have a server with zero


1743
00:55:15,786 --> 00:55:18,216
latency and infinite bandwidth,


1744
00:55:18,776 --> 00:55:19,796
it's not surprising that it


1745
00:55:19,796 --> 00:55:20,496
performs well.


1746
00:55:20,496 --> 00:55:21,746
But if you build your


1747
00:55:21,746 --> 00:55:23,276
application that way, it can be


1748
00:55:23,276 --> 00:55:25,996
very misleading and you can find


1749
00:55:25,996 --> 00:55:27,836
out later when your app is in


1750
00:55:27,836 --> 00:55:29,186
the hands of real users that it


1751
00:55:29,186 --> 00:55:30,336
doesn't perform very well.


1752
00:55:31,006 --> 00:55:33,566
If you get in the habit of going


1753
00:55:33,826 --> 00:55:36,736
to device conditions and


1754
00:55:37,406 --> 00:55:40,706
selecting a realistic network


1755
00:55:40,706 --> 00:55:42,816
link condition, right from the


1756
00:55:42,816 --> 00:55:44,056
start when you're developing


1757
00:55:44,056 --> 00:55:46,396
your application and always test


1758
00:55:46,396 --> 00:55:47,626
and run your application


1759
00:55:47,936 --> 00:55:49,516
simulating realistic network


1760
00:55:49,516 --> 00:55:52,866
conditions, then those bugs will


1761
00:55:52,866 --> 00:55:54,986
not even happen in the first


1762
00:55:56,876 --> 00:55:57,106
place.


1763
00:55:57,186 --> 00:55:59,056
Another message we've been


1764
00:55:59,056 --> 00:56:01,706
giving you for many years is to


1765
00:56:01,706 --> 00:56:04,966
avoid pre-flight checks.


1766
00:56:05,186 --> 00:56:08,936
Using constraints such as allow


1767
00:56:08,936 --> 00:56:10,696
cellular or allow expansive


1768
00:56:10,696 --> 00:56:12,546
networks gives you much better


1769
00:56:12,546 --> 00:56:13,216
control.


1770
00:56:13,366 --> 00:56:14,756
It's much easier to use.


1771
00:56:14,926 --> 00:56:16,606
Once you start writing your apps


1772
00:56:16,606 --> 00:56:18,606
this way, you'll wonder why you


1773
00:56:18,606 --> 00:56:19,986
ever did pre-flight checks.


1774
00:56:20,236 --> 00:56:22,326
And besides, pre-flight checks


1775
00:56:22,326 --> 00:56:24,156
can never work reliably because


1776
00:56:24,156 --> 00:56:25,056
they always have raised


1777
00:56:25,056 --> 00:56:25,636
conditions.


1778
00:56:26,526 --> 00:56:28,666
So to illustrate that, I'm going


1779
00:56:28,666 --> 00:56:30,556
to use an example.


1780
00:56:30,556 --> 00:56:32,476
This is an app that I really


1781
00:56:32,476 --> 00:56:32,776
like.


1782
00:56:33,316 --> 00:56:36,136
And to illustrate this, I've


1783
00:56:36,636 --> 00:56:38,356
given them a deliberately


1784
00:56:38,626 --> 00:56:41,366
exaggerated example of what it


1785
00:56:41,366 --> 00:56:42,506
might do if it was a badly


1786
00:56:42,506 --> 00:56:43,166
written app.


1787
00:56:43,736 --> 00:56:45,036
This is telling the user to make


1788
00:56:45,176 --> 00:56:46,646
sure that we're on Wi-Fi then


1789
00:56:46,646 --> 00:56:47,376
click the button.


1790
00:56:48,056 --> 00:56:49,536
But the user has no way to


1791
00:56:49,536 --> 00:56:51,836
control what path the network


1792
00:56:51,836 --> 00:56:52,926
connection will take, what they


1793
00:56:53,366 --> 00:56:55,556
will typically do is look for


1794
00:56:55,556 --> 00:56:57,016
the Wi-Fi bars and hope for the


1795
00:56:57,016 --> 00:56:57,406
best.


1796
00:56:58,226 --> 00:57:00,016
But as you learned today,


1797
00:57:01,536 --> 00:57:03,336
knowing in advance how Wi-Fi is


1798
00:57:03,336 --> 00:57:04,956
going to perform until you try


1799
00:57:05,786 --> 00:57:06,776
is impossible.


1800
00:57:07,516 --> 00:57:09,696
And the device may think it's on


1801
00:57:09,696 --> 00:57:11,286
Wi-Fi but when it tries to use


1802
00:57:11,286 --> 00:57:13,396
it, it turns out not to work.


1803
00:57:13,496 --> 00:57:15,906
Now, when Wi-Fi Assist switches


1804
00:57:15,906 --> 00:57:18,036
you from Wi-Fi to cellular,


1805
00:57:18,036 --> 00:57:19,776
those Wi-Fi bars will disappear


1806
00:57:20,236 --> 00:57:21,496
but by then it's too late, your


1807
00:57:21,496 --> 00:57:22,746
connection has already happened.


1808
00:57:23,546 --> 00:57:28,816
So, don't make the user guess.


1809
00:57:29,256 --> 00:57:30,436
Don't just make connections and


1810
00:57:30,436 --> 00:57:31,136
hope for the best.


1811
00:57:31,706 --> 00:57:32,576
Let me show you how this


1812
00:57:32,576 --> 00:57:35,096
application actually works.


1813
00:57:35,386 --> 00:57:36,886
It makes its connections


1814
00:57:37,796 --> 00:57:39,656
constrained to not allow


1815
00:57:39,656 --> 00:57:40,576
cellular access.


1816
00:57:41,176 --> 00:57:44,816
And starting in iOS 13, it can


1817
00:57:44,816 --> 00:57:47,186
actually use the


1818
00:57:47,186 --> 00:57:49,036
allowsExpensiveNetworkAccess


1819
00:57:49,186 --> 00:57:50,956
control to let the system decide


1820
00:57:51,096 --> 00:57:52,486
which is an expensive network.


1821
00:57:53,666 --> 00:57:55,226
It also sets


1822
00:57:55,226 --> 00:57:56,656
waitsForConnectivity equals


1823
00:57:56,656 --> 00:57:57,076
true.


1824
00:57:57,466 --> 00:57:58,866
That means the application


1825
00:57:59,196 --> 00:58:00,376
doesn't have to retry


1826
00:58:00,446 --> 00:58:01,276
repeatedly.


1827
00:58:01,586 --> 00:58:02,766
The system will just wait


1828
00:58:02,766 --> 00:58:04,046
patiently for as long as it


1829
00:58:04,046 --> 00:58:05,216
takes for that connection to


1830
00:58:05,216 --> 00:58:05,726
succeed.


1831
00:58:07,306 --> 00:58:09,876
When the application tries to


1832
00:58:09,876 --> 00:58:11,896
connect, if there is no Wi-Fi,


1833
00:58:12,526 --> 00:58:14,506
its taskIsWaitingForConnectivity


1834
00:58:14,506 --> 00:58:16,776
delegate gets called and that's


1835
00:58:16,776 --> 00:58:18,616
when it can display UI giving


1836
00:58:18,616 --> 00:58:20,906
the user the choice either move


1837
00:58:20,906 --> 00:58:22,516
to somewhere with Wi-Fi or you


1838
00:58:22,516 --> 00:58:23,986
can press the button if you want


1839
00:58:23,986 --> 00:58:25,166
to go ahead and use cellular


1840
00:58:25,166 --> 00:58:25,576
data.


1841
00:58:26,896 --> 00:58:29,126
Some news about deprecations.


1842
00:58:30,236 --> 00:58:31,786
If any of you are still using


1843
00:58:31,786 --> 00:58:35,046
PAC files using the file or FTP


1844
00:58:35,226 --> 00:58:36,946
URL schemes, those are no longer


1845
00:58:36,946 --> 00:58:37,476
supported.


1846
00:58:38,656 --> 00:58:40,366
If any of you are still using


1847
00:58:40,366 --> 00:58:41,906
SPDY, SPDY was a great


1848
00:58:41,906 --> 00:58:44,176
experimental protocol, that has


1849
00:58:44,176 --> 00:58:46,496
now been replaced by HTTP 2,


1850
00:58:47,006 --> 00:58:48,786
that's what Apple supports and


1851
00:58:48,786 --> 00:58:49,506
that's where everything should


1852
00:58:49,506 --> 00:58:50,726
be moving towards.


1853
00:58:51,516 --> 00:58:54,066
And Secure Transport does not


1854
00:58:54,066 --> 00:58:56,906
support TLS 1.3 and it will


1855
00:58:56,906 --> 00:58:59,636
never support TLS 1.3 so another


1856
00:58:59,636 --> 00:59:01,646
reason to move to URLSession or


1857
00:59:01,646 --> 00:59:02,536
Network.framework.


1858
00:59:03,066 --> 00:59:08,156
So to wrap up, this morning we


1859
00:59:08,156 --> 00:59:10,606
talked about wide-area Bonjour


1860
00:59:10,606 --> 00:59:17,756
discovery and how to advertise a


1861
00:59:17,756 --> 00:59:18,796
tic-tac-toe game.


1862
00:59:19,076 --> 00:59:22,386
Some of you may have wondered if


1863
00:59:22,386 --> 00:59:23,816
that service type underscore


1864
00:59:23,816 --> 00:59:26,546
tic-tac-toe was registered with


1865
00:59:26,546 --> 00:59:26,796
Ayana.


1866
00:59:27,056 --> 00:59:28,786
The answer is yes it is, you can


1867
00:59:28,786 --> 00:59:29,716
check on the website [laughter].


1868
00:59:33,376 --> 00:59:34,736
Tommy talked about building


1869
00:59:34,736 --> 00:59:37,086
framing protocols and collecting


1870
00:59:37,086 --> 00:59:39,436
metrics that make it easier for


1871
00:59:39,436 --> 00:59:40,936
you to write your applications


1872
00:59:41,396 --> 00:59:42,536
and make it easy for you to


1873
00:59:42,536 --> 00:59:43,616
measure performance.


1874
00:59:44,226 --> 00:59:48,226
And this morning, we talked


1875
00:59:48,226 --> 00:59:50,506
about low data mode that lets


1876
00:59:50,506 --> 00:59:52,206
you respect your user's wishes


1877
00:59:52,206 --> 00:59:53,836
about when to conserve data.


1878
00:59:54,526 --> 00:59:56,006
We talked about combining


1879
00:59:56,006 --> 00:59:57,636
URLSession which is a great way


1880
00:59:57,636 --> 00:59:59,356
to chain asynchronous operations


1881
00:59:59,356 --> 00:59:59,866
together.


1882
00:59:59,866 --> 01:00:01,976
And we talked about WebSocket.


1883
01:00:02,046 --> 01:00:04,776
If you have web-based


1884
01:00:04,776 --> 01:00:06,466
applications that use WebSocket


1885
01:00:06,466 --> 01:00:08,126
to talk to the server, you can


1886
01:00:08,126 --> 01:00:09,726
now use that same server with


1887
01:00:09,726 --> 01:00:11,876
your native iOS apps.


1888
01:00:12,886 --> 01:00:14,816
And Christoph Paasch told us all


1889
01:00:14,816 --> 01:00:16,376
about mobility improvements with


1890
01:00:16,376 --> 01:00:20,626
multipath TCP and Wi-Fi Assist.


1891
01:00:21,486 --> 01:00:23,946
And on that note, many of you


1892
01:00:24,456 --> 01:00:27,446
will know that ACM SIGCOMM is


1893
01:00:27,806 --> 01:00:30,906
the world's leading academic


1894
01:00:31,116 --> 01:00:32,546
conference for network research.


1895
01:00:34,036 --> 01:00:35,686
And every year they have the


1896
01:00:35,686 --> 01:00:37,446
Networking Systems Award that


1897
01:00:37,446 --> 01:00:39,366
recognizes the work that's had


1898
01:00:39,366 --> 01:00:41,756
the biggest impact in the area


1899
01:00:41,756 --> 01:00:42,586
of networking.


1900
01:00:43,336 --> 01:00:45,286
And this year, today, they


1901
01:00:45,516 --> 01:00:47,536
announced that this year's award


1902
01:00:47,996 --> 01:00:49,566
goes to Christoph Paasch and the


1903
01:00:49,566 --> 01:00:51,346
rest of the team for multipath


1904
01:00:51,426 --> 01:00:51,676
TCP.


1905
01:00:52,516 --> 01:01:00,886
[ Applause ]


1906
01:01:01,386 --> 01:01:02,606
We would love to see you all


1907
01:01:02,606 --> 01:01:04,376
tomorrow in the networking lab.


1908
01:01:04,986 --> 01:01:07,036
And if any of you are currently


1909
01:01:07,036 --> 01:01:08,076
writing network kernel


1910
01:01:08,076 --> 01:01:09,786
extensions, definitely go to


1911
01:01:09,786 --> 01:01:11,746
tomorrow's session about network


1912
01:01:11,746 --> 01:01:13,426
extensions for modern macOS.


1913
01:01:13,706 --> 01:01:13,976
Thank you.


1914
01:01:14,516 --> 01:01:17,500
[ Applause ]

