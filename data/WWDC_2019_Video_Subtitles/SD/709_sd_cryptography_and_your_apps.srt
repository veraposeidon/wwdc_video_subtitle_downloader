1
00:00:00,506 --> 00:00:04,500
[ Music ]


2
00:00:12,516 --> 00:00:14,636
[ Applause ]


3
00:00:15,136 --> 00:00:15,666
>> Good afternoon.


4
00:00:16,366 --> 00:00:17,206
Good afternoon everyone.


5
00:00:18,456 --> 00:00:22,546
Welcome to the bitcoin session


6
00:00:22,546 --> 00:00:23,156
[laughter].


7
00:00:23,156 --> 00:00:25,276
Kidding. Welcome to Cryptography


8
00:00:25,276 --> 00:00:26,306
and Your Apps session.


9
00:00:27,206 --> 00:00:29,126
Today, my colleague, Frederic,


10
00:00:29,126 --> 00:00:31,326
and I are here to show you that


11
00:00:31,326 --> 00:00:33,026
using cryptography on Apple


12
00:00:33,026 --> 00:00:34,936
products has never been easier.


13
00:00:35,776 --> 00:00:36,636
I am Yannick Sierra.


14
00:00:36,636 --> 00:00:37,846
I manage the Cryptographic


15
00:00:37,846 --> 00:00:39,496
Engineering Team at Apple.


16
00:00:39,496 --> 00:00:43,466
So today on one hand we have a


17
00:00:43,466 --> 00:00:45,756
set of great system features


18
00:00:45,926 --> 00:00:47,606
which solve a set of common


19
00:00:47,636 --> 00:00:48,456
security problems.


20
00:00:49,326 --> 00:00:51,306
On the other hand, we have an


21
00:00:51,446 --> 00:00:54,406
exciting new Swift API for


22
00:00:54,406 --> 00:00:55,576
cryptographic operation.


23
00:00:56,336 --> 00:00:58,476
We're really excited about it.


24
00:00:58,476 --> 00:01:00,056
If you here, it's probably


25
00:01:00,056 --> 00:01:01,506
because there's some information


26
00:01:01,506 --> 00:01:02,766
you want to protect, right.


27
00:01:05,476 --> 00:01:08,246
We know that you as developers


28
00:01:08,396 --> 00:01:11,016
and as users find it really


29
00:01:11,016 --> 00:01:12,526
important to protect user's


30
00:01:12,526 --> 00:01:13,976
information, your information.


31
00:01:16,656 --> 00:01:17,806
There are different kind of


32
00:01:17,806 --> 00:01:19,326
information, which are all


33
00:01:19,426 --> 00:01:19,826
sensitive.


34
00:01:19,866 --> 00:01:21,966
It starts with profile


35
00:01:21,966 --> 00:01:23,796
information such as phone


36
00:01:23,796 --> 00:01:25,746
numbers and email addresses.


37
00:01:26,636 --> 00:01:28,156
Your applications may also be


38
00:01:28,156 --> 00:01:31,866
handling user information such


39
00:01:31,866 --> 00:01:34,386
as photos or music by using an


40
00:01:34,386 --> 00:01:36,256
application to process and


41
00:01:36,256 --> 00:01:36,686
improve.


42
00:01:38,196 --> 00:01:39,976
Your application may also be


43
00:01:39,976 --> 00:01:41,596
handling business assets.


44
00:01:42,826 --> 00:01:44,846
This could be paid content your


45
00:01:45,026 --> 00:01:46,266
app is making available to


46
00:01:46,266 --> 00:01:46,886
users.


47
00:01:47,716 --> 00:01:49,586
Or account information like in


48
00:01:49,586 --> 00:01:51,626
the mobile banking scenarios.


49
00:01:53,136 --> 00:01:54,836
For all of this information, it


50
00:01:54,836 --> 00:01:56,636
is critical to keep them secure,


51
00:01:57,106 --> 00:01:58,926
and you need to have great tools


52
00:01:58,926 --> 00:01:59,346
for that.


53
00:01:59,986 --> 00:02:04,436
At Apple, security and privacy


54
00:02:04,716 --> 00:02:06,146
are core values.


55
00:02:06,826 --> 00:02:08,406
We built it in all of the


56
00:02:08,406 --> 00:02:11,056
features that we work on.


57
00:02:12,356 --> 00:02:14,626
Cryptography is a big part of


58
00:02:15,416 --> 00:02:15,486
it.


59
00:02:16,036 --> 00:02:18,086
For example, with device


60
00:02:18,086 --> 00:02:20,476
integrity we use cryptography to


61
00:02:20,476 --> 00:02:21,886
validate the integrity of the


62
00:02:21,886 --> 00:02:23,506
software running on the platform


63
00:02:23,876 --> 00:02:25,206
to make sure it has not been


64
00:02:25,206 --> 00:02:27,216
tampered with and guarantee its


65
00:02:27,216 --> 00:02:28,936
security properties are not


66
00:02:28,936 --> 00:02:29,376
changed.


67
00:02:30,746 --> 00:02:32,236
We use cryptography to protect


68
00:02:32,236 --> 00:02:32,996
data at rest.


69
00:02:34,086 --> 00:02:36,236
We use cryptography across a


70
00:02:36,476 --> 00:02:38,166
wide variety of applications


71
00:02:38,666 --> 00:02:42,416
users love, use extensively for


72
00:02:42,616 --> 00:02:44,736
capturing very personal moments


73
00:02:44,866 --> 00:02:45,816
and sharing them.


74
00:02:46,426 --> 00:02:47,946
This is a case of Messages,


75
00:02:48,766 --> 00:02:50,876
Safari, and iCloud.


76
00:02:51,876 --> 00:02:53,806
With over a billion device, we


77
00:02:53,806 --> 00:02:55,346
operation cryptography at a huge


78
00:02:55,386 --> 00:02:55,726
scale.


79
00:02:57,056 --> 00:02:58,806
The stakes, as you can imagine,


80
00:02:59,186 --> 00:03:00,206
are really high too.


81
00:03:00,626 --> 00:03:02,936
Performance is critical for a


82
00:03:02,936 --> 00:03:04,066
great user experience.


83
00:03:05,016 --> 00:03:07,006
Energy is fundamental for that


84
00:03:07,136 --> 00:03:09,296
full-day battery life, and


85
00:03:09,296 --> 00:03:10,966
security, it's a cornerstone


86
00:03:10,966 --> 00:03:11,166
here.


87
00:03:12,526 --> 00:03:13,856
Now, let's have a closer look at


88
00:03:13,856 --> 00:03:14,516
cryptography.


89
00:03:16,196 --> 00:03:17,896
Cryptography is really a tool.


90
00:03:18,286 --> 00:03:20,116
It provides solution to a set of


91
00:03:20,306 --> 00:03:21,956
basic properties.


92
00:03:23,186 --> 00:03:25,096
It starts with authentication as


93
00:03:25,096 --> 00:03:27,356
an example, knowing who sent you


94
00:03:27,356 --> 00:03:27,776
a message.


95
00:03:29,456 --> 00:03:31,406
Encryption, knowing that that


96
00:03:31,406 --> 00:03:34,546
message only you can decrypt it.


97
00:03:35,456 --> 00:03:37,836
And Integrity, knowing that no


98
00:03:37,836 --> 00:03:39,536
one else could have modified the


99
00:03:39,536 --> 00:03:41,316
content of that message before


100
00:03:41,316 --> 00:03:42,506
it got to you.


101
00:03:43,456 --> 00:03:45,636
To solve broader security


102
00:03:45,636 --> 00:03:47,166
problem, we combine


103
00:03:47,166 --> 00:03:48,916
cryptographic functions into


104
00:03:48,916 --> 00:03:51,376
cryptographic protocol, and


105
00:03:51,376 --> 00:03:52,466
that's no easy task.


106
00:03:54,036 --> 00:03:56,266
Actually, many of you, most of


107
00:03:56,266 --> 00:03:57,316
you have probably heard the


108
00:03:57,356 --> 00:03:58,476
saying, "don't roll your own


109
00:03:58,476 --> 00:03:59,426
crypto", right.


110
00:04:00,206 --> 00:04:01,616
There are good reasons for that.


111
00:04:01,616 --> 00:04:04,256
A lot of things can go wrong.


112
00:04:05,456 --> 00:04:07,476
It starts with maybe not picking


113
00:04:07,476 --> 00:04:09,116
the right primitives and


114
00:04:09,116 --> 00:04:09,946
therefore not getting the


115
00:04:09,946 --> 00:04:11,766
security you want to achieve.


116
00:04:12,636 --> 00:04:14,566
It may also be adding the right


117
00:04:14,566 --> 00:04:16,745
primitives but not using them


118
00:04:16,745 --> 00:04:19,656
the right way, and the lowest


119
00:04:19,656 --> 00:04:22,366
level, the implementation may


120
00:04:22,366 --> 00:04:23,526
give away the secrets or the


121
00:04:23,526 --> 00:04:23,916
keys.


122
00:04:24,296 --> 00:04:25,476
That could be the case of timing


123
00:04:25,476 --> 00:04:27,016
attacks or padding oracle


124
00:04:27,016 --> 00:04:27,556
attacks.


125
00:04:28,886 --> 00:04:30,696
This is why cryptography is


126
00:04:30,696 --> 00:04:32,056
incredibly difficult.


127
00:04:32,386 --> 00:04:35,046
There are endless examples of


128
00:04:35,186 --> 00:04:36,356
failures of cryptographic


129
00:04:36,356 --> 00:04:39,636
protocols in the news, and the


130
00:04:39,636 --> 00:04:41,236
worst thing is, security


131
00:04:41,236 --> 00:04:42,656
vulnerabilities may take a while


132
00:04:42,656 --> 00:04:43,426
to be discovered.


133
00:04:43,426 --> 00:04:45,186
It may take years before someone


134
00:04:45,186 --> 00:04:46,306
reports finding an issue.


135
00:04:47,656 --> 00:04:50,386
This is why the risks are really


136
00:04:50,386 --> 00:04:53,146
high, and so it's an effort to


137
00:04:53,146 --> 00:04:53,736
get it right.


138
00:04:55,026 --> 00:04:56,286
Designing a robust protocol


139
00:04:56,636 --> 00:04:59,336
takes a lot of time, skills, and


140
00:04:59,336 --> 00:05:01,446
expertise you need to be a


141
00:05:01,446 --> 00:05:02,166
cryptographer.


142
00:05:03,306 --> 00:05:04,686
Even when you got the protocol,


143
00:05:05,056 --> 00:05:06,226
the work is not done yet.


144
00:05:06,946 --> 00:05:07,996
There is a continuous amount of


145
00:05:07,996 --> 00:05:10,576
work to monitor new attacks, see


146
00:05:10,576 --> 00:05:12,156
what is applicable to your own


147
00:05:12,156 --> 00:05:14,806
code, and then respond to it,


148
00:05:15,476 --> 00:05:16,746
but sometimes it's not even that


149
00:05:16,746 --> 00:05:17,096
easy.


150
00:05:17,486 --> 00:05:18,676
It can be dependencies.


151
00:05:19,226 --> 00:05:20,606
Those libraries that you picked


152
00:05:20,606 --> 00:05:23,846
to integrate in your app.


153
00:05:24,106 --> 00:05:25,856
And in some situation, you also


154
00:05:25,856 --> 00:05:27,006
need to revise and carry the


155
00:05:27,006 --> 00:05:29,196
protocol and manage all kind of


156
00:05:29,196 --> 00:05:30,916
interpretability scenarios.


157
00:05:31,516 --> 00:05:35,436
All of this is a lot of work,


158
00:05:36,076 --> 00:05:38,326
and it's taking time and energy


159
00:05:38,326 --> 00:05:40,106
away of the big ideas you may


160
00:05:40,106 --> 00:05:42,546
have or the next cool features.


161
00:05:44,416 --> 00:05:46,936
This is why you can truly


162
00:05:46,936 --> 00:05:49,136
benefit from native features.


163
00:05:50,256 --> 00:05:51,766
Our philosophy has been to


164
00:05:51,766 --> 00:05:55,306
provide full solutions for a set


165
00:05:55,646 --> 00:05:57,836
of common problems so that we do


166
00:05:57,836 --> 00:05:59,416
the hard work and you don't have


167
00:05:59,466 --> 00:05:59,626
to.


168
00:06:00,936 --> 00:06:03,726
For you, it raises the risk and


169
00:06:03,726 --> 00:06:05,586
the effort, and we can even


170
00:06:05,586 --> 00:06:07,716
achieve better security through


171
00:06:07,716 --> 00:06:09,856
the assistance of delegated


172
00:06:09,856 --> 00:06:11,406
hardware features we have on our


173
00:06:11,406 --> 00:06:11,936
platforms.


174
00:06:14,686 --> 00:06:17,046
Now, we actually look through a


175
00:06:17,046 --> 00:06:18,626
set of very common scenarios


176
00:06:19,156 --> 00:06:20,406
many of you may be familiar


177
00:06:20,406 --> 00:06:20,646
with.


178
00:06:20,646 --> 00:06:24,146
We're going to start with how to


179
00:06:24,146 --> 00:06:25,736
protect data on a device.


180
00:06:26,366 --> 00:06:28,676
Then we can look at protecting


181
00:06:28,676 --> 00:06:30,206
credentials and keys.


182
00:06:30,766 --> 00:06:34,446
After that, sharing data across


183
00:06:34,446 --> 00:06:36,456
devices and users.


184
00:06:38,256 --> 00:06:40,106
Then, securing network


185
00:06:40,106 --> 00:06:42,196
connections, and finally,


186
00:06:42,346 --> 00:06:44,126
verifying remote parties with


187
00:06:44,166 --> 00:06:44,846
certificates.


188
00:06:46,426 --> 00:06:48,186
Now, I'm going to look into the


189
00:06:48,276 --> 00:06:49,276
first example.


190
00:06:49,406 --> 00:06:50,456
Like I'm sure many of you have


191
00:06:50,546 --> 00:06:54,106
found that scenario and find


192
00:06:54,106 --> 00:06:55,196
yourself trying to protect data


193
00:06:55,716 --> 00:06:56,556
on device.


194
00:06:57,406 --> 00:07:00,496
Well, the best advice is not to


195
00:07:00,496 --> 00:07:01,586
just copy and paste what you


196
00:07:01,586 --> 00:07:03,246
find on some of those websites.


197
00:07:03,896 --> 00:07:06,436
You're better off using data


198
00:07:06,436 --> 00:07:06,976
protection.


199
00:07:08,016 --> 00:07:09,276
Data protection combines the


200
00:07:09,276 --> 00:07:11,046
strengths of the passcode with


201
00:07:11,046 --> 00:07:12,766
the hardware technologies in the


202
00:07:12,766 --> 00:07:14,696
Secure Enclave to make sure the


203
00:07:14,816 --> 00:07:16,966
keys are well secured, and the


204
00:07:16,966 --> 00:07:19,886
encrypted data cannot be used to


205
00:07:19,886 --> 00:07:20,796
brute-force the passcode.


206
00:07:21,396 --> 00:07:23,816
But there's even more.


207
00:07:24,526 --> 00:07:26,586
Data protection provides post


208
00:07:26,586 --> 00:07:27,556
compromise recovery.


209
00:07:28,726 --> 00:07:30,656
Post compromise recovery, also


210
00:07:30,656 --> 00:07:31,806
known as forward secrecy,


211
00:07:32,156 --> 00:07:34,166
guarantees that if adversary


212
00:07:34,456 --> 00:07:35,666
gets his hand on the keys on the


213
00:07:35,666 --> 00:07:37,736
device and the users change the


214
00:07:37,736 --> 00:07:40,276
passcode, well, all the data


215
00:07:40,276 --> 00:07:42,086
encrypted after that cannot be


216
00:07:42,086 --> 00:07:43,346
recovered from those old keys.


217
00:07:44,496 --> 00:07:47,296
This is important, critical, and


218
00:07:47,296 --> 00:07:48,476
if you want to learn more,


219
00:07:49,086 --> 00:07:49,996
there's even more data


220
00:07:49,996 --> 00:07:51,946
protection does, and you can


221
00:07:51,946 --> 00:07:53,276
look at the iOS security white


222
00:07:53,276 --> 00:07:56,086
paper to get more information.


223
00:07:56,926 --> 00:07:58,386
The one thing you need to know


224
00:07:59,166 --> 00:07:59,996
is that there are different


225
00:07:59,996 --> 00:08:02,336
protection attributes you can


226
00:08:02,396 --> 00:08:03,626
set when your app fails.


227
00:08:04,276 --> 00:08:07,876
It starts from until first


228
00:08:07,876 --> 00:08:08,736
authentication.


229
00:08:09,496 --> 00:08:12,776
Even the data is protected until


230
00:08:14,096 --> 00:08:15,526
the first time the user unlocks


231
00:08:15,526 --> 00:08:17,096
the phone after boot.


232
00:08:18,346 --> 00:08:19,126
It's great.


233
00:08:20,136 --> 00:08:21,576
Today is a lot better you can


234
00:08:21,576 --> 00:08:21,766
do.


235
00:08:22,316 --> 00:08:23,716
There is the complete file


236
00:08:23,716 --> 00:08:24,236
protection.


237
00:08:24,766 --> 00:08:26,076
Complete file protection means


238
00:08:26,546 --> 00:08:28,746
the data is only available after


239
00:08:28,796 --> 00:08:30,876
the user unlocks his phone.


240
00:08:31,326 --> 00:08:32,836
As soon as the user locks his


241
00:08:32,836 --> 00:08:33,846
phone back, put it back in the


242
00:08:33,846 --> 00:08:35,826
pocket or in a bag, the data is


243
00:08:35,866 --> 00:08:36,336
secure again.


244
00:08:36,885 --> 00:08:39,846
And it's really easy to use.


245
00:08:40,145 --> 00:08:40,775
Here's an example.


246
00:08:41,566 --> 00:08:42,686
The only thing you need to use


247
00:08:42,846 --> 00:08:43,606
is this option,


248
00:08:43,916 --> 00:08:44,966
completeFileProtection.


249
00:08:44,966 --> 00:08:46,496
It can't be easier than that,


250
00:08:46,496 --> 00:08:46,706
right.


251
00:08:47,216 --> 00:08:48,376
If you're not using this option


252
00:08:48,376 --> 00:08:49,686
yet, please go ahead and look in


253
00:08:49,686 --> 00:08:50,906
your application where you could


254
00:08:50,906 --> 00:08:52,866
use it to get that best level of


255
00:08:52,866 --> 00:08:53,446
security.


256
00:08:55,576 --> 00:08:58,506
Now, in addition to files, there


257
00:08:58,506 --> 00:08:59,616
may be more sensitive


258
00:08:59,616 --> 00:09:00,746
information that you may want to


259
00:09:00,746 --> 00:09:01,066
protect.


260
00:09:02,076 --> 00:09:03,596
There could be credentials like


261
00:09:03,836 --> 00:09:05,906
authentication tokens used to


262
00:09:05,906 --> 00:09:08,216
authenticate on services or


263
00:09:08,216 --> 00:09:09,006
cryptography keys.


264
00:09:09,546 --> 00:09:13,986
But for those, please don't


265
00:09:13,986 --> 00:09:15,436
write them in defaults that you


266
00:09:15,436 --> 00:09:16,936
could see on all the platforms.


267
00:09:17,736 --> 00:09:19,666
Instead, there is Keychain.


268
00:09:21,106 --> 00:09:22,826
Keychain in the Secitem APIs


269
00:09:23,356 --> 00:09:24,826
allows you to write those items


270
00:09:25,446 --> 00:09:27,036
as in the local Keychain, which


271
00:09:27,036 --> 00:09:28,146
means they stay on that one


272
00:09:28,146 --> 00:09:30,976
device or on iCloud Keychain


273
00:09:31,836 --> 00:09:33,076
where they synchronize across


274
00:09:33,076 --> 00:09:34,426
all of the devices for a


275
00:09:34,546 --> 00:09:36,916
seamless experience in the user


276
00:09:36,916 --> 00:09:37,306
account.


277
00:09:37,946 --> 00:09:40,086
This requires user accounts with


278
00:09:40,306 --> 00:09:41,286
two-factor authentication


279
00:09:41,286 --> 00:09:41,706
enabled.


280
00:09:42,306 --> 00:09:45,006
For Keychain, you find very


281
00:09:45,006 --> 00:09:47,466
similar protection as for the


282
00:09:47,466 --> 00:09:48,906
files that I mentioned before


283
00:09:49,576 --> 00:09:50,696
and a few extra ones.


284
00:09:51,246 --> 00:09:52,556
Here, again, I will recommend


285
00:09:52,556 --> 00:09:53,786
you to look at the documentation


286
00:09:53,786 --> 00:09:54,286
to learn more.


287
00:09:55,686 --> 00:09:56,946
In addition to when a key is


288
00:09:56,986 --> 00:09:58,136
cryptographically available,


289
00:09:58,636 --> 00:10:00,306
sometimes important for you to


290
00:10:00,306 --> 00:10:01,676
know how the user authenticated


291
00:10:01,676 --> 00:10:01,976
it and when.


292
00:10:03,656 --> 00:10:05,576
This is why we have


293
00:10:05,576 --> 00:10:06,976
LocalAuthentication.


294
00:10:08,256 --> 00:10:10,196
LocalAuthentication allows you


295
00:10:10,196 --> 00:10:12,446
to put restrictions as to when


296
00:10:12,446 --> 00:10:14,726
an operation can be executed.


297
00:10:15,306 --> 00:10:16,746
For example, you could define


298
00:10:16,886 --> 00:10:18,336
that it is required for the user


299
00:10:18,336 --> 00:10:19,646
to authenticate with biometrics


300
00:10:19,646 --> 00:10:20,296
with Face ID.


301
00:10:21,256 --> 00:10:22,906
It can be very handy, and in


302
00:10:22,906 --> 00:10:25,336
this world, on macOS we have


303
00:10:25,336 --> 00:10:26,446
some exciting news.


304
00:10:27,036 --> 00:10:31,066
On macOS, you're used to device


305
00:10:31,146 --> 00:10:33,776
authentication properties, and


306
00:10:33,776 --> 00:10:35,986
it gives two way for the user to


307
00:10:35,986 --> 00:10:38,256
authenticate, the password or


308
00:10:38,256 --> 00:10:39,886
biometrics for Macs which


309
00:10:39,886 --> 00:10:41,286
support biometrics with Touch


310
00:10:41,286 --> 00:10:41,496
ID.


311
00:10:42,466 --> 00:10:43,606
This year we're really excited


312
00:10:43,606 --> 00:10:46,006
to announce that now without any


313
00:10:46,006 --> 00:10:48,746
change in your application, the


314
00:10:48,746 --> 00:10:50,446
user can authenticate with Apple


315
00:10:50,446 --> 00:10:52,186
Watch and a double-click on Apple


316
00:10:52,186 --> 00:10:52,496
Watch.


317
00:10:53,376 --> 00:10:54,606
It's a great new experience,


318
00:10:54,796 --> 00:10:56,506
which is going to reduce the use


319
00:10:56,506 --> 00:10:57,986
of the password and reduce the


320
00:10:58,026 --> 00:10:59,356
friction, improves user


321
00:10:59,356 --> 00:10:59,926
experience.


322
00:11:00,916 --> 00:11:02,366
Now, with these new capabilities


323
00:11:02,536 --> 00:11:04,306
we added two new policies.


324
00:11:05,236 --> 00:11:08,386
The first one, to reduce the


325
00:11:08,386 --> 00:11:10,416
authentication to biometrics


326
00:11:10,416 --> 00:11:11,926
only and Watch.


327
00:11:12,506 --> 00:11:15,586
And the second one to the Watch


328
00:11:15,936 --> 00:11:16,426
alone.


329
00:11:17,696 --> 00:11:18,686
We are looking forward to see


330
00:11:18,776 --> 00:11:19,946
how you're going to use those in


331
00:11:20,076 --> 00:11:21,566
your application on macOS.


332
00:11:25,196 --> 00:11:26,386
Now, I mentioned the Keychain,


333
00:11:27,316 --> 00:11:28,186
there is an easy way to


334
00:11:28,236 --> 00:11:30,376
synchronize items across all of


335
00:11:30,376 --> 00:11:32,286
the devices of an account.


336
00:11:33,196 --> 00:11:34,066
What if you have data?


337
00:11:35,086 --> 00:11:36,636
Well, for data we have a great


338
00:11:36,636 --> 00:11:37,236
solution too.


339
00:11:38,626 --> 00:11:41,436
CloudKit. CloudKit allows you to


340
00:11:41,436 --> 00:11:43,336
encrypt assets in the Private


341
00:11:43,336 --> 00:11:46,856
CloudKit Database, and the data


342
00:11:46,856 --> 00:11:48,556
will be available across all of


343
00:11:48,556 --> 00:11:50,156
the devices without the user


344
00:11:50,156 --> 00:11:51,656
having to sign in into the


345
00:11:51,656 --> 00:11:52,376
application.


346
00:11:52,936 --> 00:11:56,296
It is great, and even more, you


347
00:11:56,296 --> 00:11:57,926
can also use it to share to all


348
00:11:57,926 --> 00:11:58,636
the users.


349
00:12:00,796 --> 00:12:02,896
The way it works is Apple as a


350
00:12:02,936 --> 00:12:05,746
trusted party help manage the


351
00:12:05,846 --> 00:12:08,046
iCloud identities and the


352
00:12:08,046 --> 00:12:09,886
control to the data.


353
00:12:10,596 --> 00:12:13,776
And I have an example here


354
00:12:13,776 --> 00:12:15,656
again, to show it's easy to set


355
00:12:15,656 --> 00:12:15,786
up.


356
00:12:16,946 --> 00:12:17,856
From the file, we create an


357
00:12:17,856 --> 00:12:17,976
asset.


358
00:12:20,556 --> 00:12:22,206
With this asset, we created a


359
00:12:22,206 --> 00:12:22,626
record.


360
00:12:23,496 --> 00:12:24,846
And then we upload this record


361
00:12:24,906 --> 00:12:25,976
into the Private CloudKit


362
00:12:25,976 --> 00:12:26,476
Database.


363
00:12:27,166 --> 00:12:31,386
And this is it, and if you want


364
00:12:31,436 --> 00:12:32,816
to add sharing to other users,


365
00:12:32,816 --> 00:12:33,886
it is possible for a set of defined


366
00:12:33,886 --> 00:12:34,486
APIs.


367
00:12:34,486 --> 00:12:36,326
If you haven't looked into


368
00:12:36,356 --> 00:12:38,076
CloudKit before, it's great time


369
00:12:38,376 --> 00:12:39,366
to go have a look at the


370
00:12:39,366 --> 00:12:40,656
documentation and see how


371
00:12:40,656 --> 00:12:42,046
powerful it can be for you.


372
00:12:42,046 --> 00:12:45,326
Now, with this, we talked about


373
00:12:45,326 --> 00:12:47,846
protecting data inside of


374
00:12:47,846 --> 00:12:49,876
devices, share it across


375
00:12:49,876 --> 00:12:52,626
devices, even devices from


376
00:12:52,626 --> 00:12:55,756
another user, what when you want


377
00:12:55,756 --> 00:12:57,086
it done on data from your own


378
00:12:57,086 --> 00:12:58,206
server for example.


379
00:12:59,436 --> 00:13:00,986
Where for that you want to


380
00:13:00,986 --> 00:13:02,276
establish a secure connection.


381
00:13:03,556 --> 00:13:04,646
A secure connection is really,


382
00:13:04,646 --> 00:13:06,956
really important because it


383
00:13:07,126 --> 00:13:08,916
helps guaranteeing the


384
00:13:08,916 --> 00:13:10,376
confidentiality of all of the


385
00:13:10,376 --> 00:13:12,076
information that the user is


386
00:13:12,076 --> 00:13:12,826
accessing through your


387
00:13:12,826 --> 00:13:14,896
application as well as guarantee


388
00:13:14,896 --> 00:13:16,676
the trustworthiness of that


389
00:13:16,676 --> 00:13:18,066
information, make sure it does


390
00:13:18,066 --> 00:13:18,976
not be tampered with.


391
00:13:21,226 --> 00:13:22,346
And the first thing you should


392
00:13:22,346 --> 00:13:23,936
not do here again, you're just


393
00:13:23,936 --> 00:13:25,266
trying to use your custom own


394
00:13:25,266 --> 00:13:25,696
protocol.


395
00:13:26,296 --> 00:13:27,776
There is a great solution.


396
00:13:28,626 --> 00:13:29,696
It's a standard solution.


397
00:13:30,946 --> 00:13:32,446
Transport Layer Security.


398
00:13:33,236 --> 00:13:35,206
And it's really easy to use on


399
00:13:35,206 --> 00:13:35,826
our platforms.


400
00:13:36,246 --> 00:13:37,966
We have two great APIs that make


401
00:13:37,966 --> 00:13:39,096
that really easy.


402
00:13:39,906 --> 00:13:41,076
The first one is network


403
00:13:41,076 --> 00:13:42,796
framework, which you may have


404
00:13:42,796 --> 00:13:44,156
discovered last year with a


405
00:13:44,156 --> 00:13:46,316
great talk at WWDC.


406
00:13:47,036 --> 00:13:48,946
The second one is URL Sessions,


407
00:13:49,286 --> 00:13:51,356
which you may know about as part


408
00:13:51,356 --> 00:13:53,236
of the App Transport Security.


409
00:13:55,116 --> 00:13:56,726
For URL Session, the only thing


410
00:13:56,726 --> 00:13:59,816
you need to do is use an https


411
00:14:00,656 --> 00:14:00,986
endpoint.


412
00:14:00,986 --> 00:14:02,926
In either of those cases, it


413
00:14:03,786 --> 00:14:07,106
relies on our implementation of TLS with


414
00:14:07,866 --> 00:14:09,496
great defaults underneath.


415
00:14:10,336 --> 00:14:12,876
Defaults ensures cypher suites are chosen to


416
00:14:13,436 --> 00:14:14,676
provide strong security


417
00:14:14,966 --> 00:14:16,486
including perfect forward secrecy as


418
00:14:16,556 --> 00:14:18,796
well as the algorithm that would


419
00:14:18,796 --> 00:14:20,656
be the most efficient on Apple


420
00:14:20,656 --> 00:14:21,276
products.


421
00:14:21,816 --> 00:14:24,576
Or implementation of TLS also


422
00:14:26,156 --> 00:14:28,086
use TLS 1.3 by default.


423
00:14:28,086 --> 00:14:30,766
If you're not familiar with TLS


424
00:14:30,766 --> 00:14:32,936
1.3, it has a lot of


425
00:14:32,936 --> 00:14:34,596
improvements from the previous


426
00:14:34,596 --> 00:14:37,446
revisions, a lot better security


427
00:14:37,726 --> 00:14:39,156
and even better efficiency by


428
00:14:39,156 --> 00:14:40,236
reducing some of those round


429
00:14:41,096 --> 00:14:41,246
trips.


430
00:14:42,996 --> 00:14:45,166
If you are not using TLS 1.3,


431
00:14:46,026 --> 00:14:46,876
please go ahead and try to


432
00:14:46,876 --> 00:14:48,816
deploy that on your servers and


433
00:14:48,816 --> 00:14:50,526
without any change of the


434
00:14:50,526 --> 00:14:51,556
Code of your application, you


435
00:14:51,556 --> 00:14:52,846
will have the benefit of it in


436
00:14:52,846 --> 00:14:53,826
your app.


437
00:14:55,456 --> 00:14:56,836
And now, to show you it's really


438
00:14:56,836 --> 00:14:58,936
easy, I have two examples to


439
00:14:58,936 --> 00:15:01,206
show you with Network Framework


440
00:15:02,026 --> 00:15:04,016
and URL Session, but before


441
00:15:04,016 --> 00:15:05,586
jumping into those, I want to


442
00:15:05,586 --> 00:15:06,826
highlight that Secure Transport


443
00:15:07,096 --> 00:15:08,376
is not the recommended way


444
00:15:08,376 --> 00:15:10,886
anymore, and we ask you to


445
00:15:10,886 --> 00:15:12,576
migrate to Network Framework and


446
00:15:12,576 --> 00:15:13,776
URL Sessions if you're already


447
00:15:13,776 --> 00:15:14,776
using Secure Transport.


448
00:15:15,686 --> 00:15:17,186
With that, here's a couple of


449
00:15:17,186 --> 00:15:17,806
examples.


450
00:15:18,776 --> 00:15:20,896
With Network Framework, when you


451
00:15:20,896 --> 00:15:22,676
establish a connection, the only


452
00:15:22,676 --> 00:15:24,926
thing you need to do is using


453
00:15:25,006 --> 00:15:27,926
:.tls, and here we go, you add


454
00:15:27,926 --> 00:15:30,516
that TLS connection, providing


455
00:15:30,516 --> 00:15:32,226
great security and performance.


456
00:15:33,296 --> 00:15:35,356
For URL Session, the only thing


457
00:15:35,356 --> 00:15:38,186
here, it's https endpoint, and


458
00:15:38,236 --> 00:15:40,866
this is it.


459
00:15:41,136 --> 00:15:43,636
In some situation, you may not


460
00:15:44,286 --> 00:15:45,736
have the possibility to use TLS.


461
00:15:45,986 --> 00:15:47,566
For example, if you have trying


462
00:15:47,566 --> 00:15:49,876
to secure data through a content


463
00:15:49,876 --> 00:15:51,356
delivery network, for example.


464
00:15:52,146 --> 00:15:54,116
In this case, you manage those


465
00:15:54,116 --> 00:15:56,296
certificates, and for


466
00:15:56,456 --> 00:15:59,606
certificates, one of the things


467
00:15:59,606 --> 00:16:01,816
to avoid is using it on parser


468
00:16:01,816 --> 00:16:02,896
or trying to take a parser you


469
00:16:02,896 --> 00:16:04,416
find somewhere on a website.


470
00:16:05,066 --> 00:16:06,626
Parsers are incredibly


471
00:16:06,626 --> 00:16:08,606
vulnerable by providing a great


472
00:16:08,606 --> 00:16:09,526
attack exposure.


473
00:16:10,956 --> 00:16:12,026
They're critical.


474
00:16:13,216 --> 00:16:15,866
On a platform, we have SecTrust


475
00:16:15,866 --> 00:16:16,286
for that.


476
00:16:17,126 --> 00:16:18,466
SecTrust provides you an easy


477
00:16:18,466 --> 00:16:20,436
way to validate the certificate


478
00:16:21,056 --> 00:16:22,286
against a trust policy.


479
00:16:23,086 --> 00:16:24,286
The trust policy may contain


480
00:16:24,286 --> 00:16:26,096
information about expiration,


481
00:16:27,006 --> 00:16:29,786
revocation, and until


482
00:16:29,786 --> 00:16:31,666
certificate has been validated,


483
00:16:31,836 --> 00:16:36,386
you know that you can use a key.


484
00:16:36,636 --> 00:16:38,196
Note that if using TLS you don't


485
00:16:38,196 --> 00:16:40,056
have a need to worry about


486
00:16:40,056 --> 00:16:40,566
certificate.


487
00:16:40,736 --> 00:16:42,236
It's all handled for you


488
00:16:42,696 --> 00:16:43,326
underneath.


489
00:16:43,886 --> 00:16:47,546
Now, in this release, we're


490
00:16:47,546 --> 00:16:49,606
happy to introduce a new


491
00:16:49,606 --> 00:16:51,846
function in SecTrust.


492
00:16:52,716 --> 00:16:54,256
This new function combines two


493
00:16:54,256 --> 00:16:56,426
things you were able to do


494
00:16:56,426 --> 00:16:56,686
before.


495
00:16:57,286 --> 00:16:58,476
On one hand, it's a function,


496
00:16:58,476 --> 00:17:00,206
which allows to asynchronously


497
00:17:00,656 --> 00:17:02,796
through an explicit action, do a


498
00:17:02,796 --> 00:17:04,806
certificate validation so that


499
00:17:04,806 --> 00:17:06,026
your application can do


500
00:17:06,026 --> 00:17:07,336
something else while the


501
00:17:07,336 --> 00:17:09,026
certificate is being validated.


502
00:17:09,626 --> 00:17:11,925
But also this function gives you


503
00:17:11,925 --> 00:17:13,026
a richer handling.


504
00:17:13,685 --> 00:17:15,996
So, as a developer, you know


505
00:17:16,705 --> 00:17:18,726
what is going on in case of


506
00:17:18,776 --> 00:17:20,665
failure, and you can debug it.


507
00:17:21,306 --> 00:17:22,675
But also, you can build logic


508
00:17:22,675 --> 00:17:25,215
into your application to respond


509
00:17:25,215 --> 00:17:26,556
to different error scenarios.


510
00:17:27,146 --> 00:17:29,086
So this new function is going to


511
00:17:29,086 --> 00:17:30,736
make things even more convenient


512
00:17:30,736 --> 00:17:31,856
and easier for you to debug.


513
00:17:31,856 --> 00:17:33,046
We're looking forward to you


514
00:17:33,046 --> 00:17:34,106
adopting it.


515
00:17:34,656 --> 00:17:37,626
So, with this, I just walked you


516
00:17:37,626 --> 00:17:40,336
through a set of five different


517
00:17:40,336 --> 00:17:42,466
scenarios for which we have


518
00:17:42,836 --> 00:17:44,976
really easy to use solutions,


519
00:17:45,456 --> 00:17:47,536
which provide great security by


520
00:17:47,536 --> 00:17:50,186
defaults or you're only a few


521
00:17:50,186 --> 00:17:52,756
attributes away from great


522
00:17:52,756 --> 00:17:53,306
security.


523
00:17:53,876 --> 00:17:57,546
And here again, we benefit from


524
00:17:58,156 --> 00:17:59,326
deep integration with the


525
00:17:59,326 --> 00:18:00,756
hardware to provide security


526
00:18:00,816 --> 00:18:02,326
features which otherwise are


527
00:18:02,326 --> 00:18:03,396
very challenging to provide.


528
00:18:04,026 --> 00:18:06,646
So, in any of the scenarios,


529
00:18:06,906 --> 00:18:09,496
when you encounter them, go


530
00:18:09,496 --> 00:18:10,406
ahead and use the system


531
00:18:10,406 --> 00:18:11,986
frameworks, and if you already


532
00:18:11,986 --> 00:18:13,296
do, go ahead and make sure


533
00:18:13,296 --> 00:18:14,016
you're using those best


534
00:18:14,016 --> 00:18:14,936
attributes so that you can


535
00:18:14,936 --> 00:18:17,656
protect users and business


536
00:18:17,656 --> 00:18:19,466
assets the best possible way.


537
00:18:20,086 --> 00:18:24,056
And we understand that in some


538
00:18:24,056 --> 00:18:26,186
situations it may not be


539
00:18:26,186 --> 00:18:28,386
practical for you to use the


540
00:18:28,386 --> 00:18:29,216
system features.


541
00:18:29,746 --> 00:18:32,556
For example, you may need to


542
00:18:32,926 --> 00:18:35,236
have interoperability outside of


543
00:18:35,236 --> 00:18:35,726
the Apple ecosystem.


544
00:18:35,856 --> 00:18:38,626
You may to authenticate with


545
00:18:38,626 --> 00:18:41,936
your service or simply you're


546
00:18:41,936 --> 00:18:44,096
given a specification you will


547
00:18:44,096 --> 00:18:46,386
need to implement.


548
00:18:46,386 --> 00:18:49,536
For all of these cases, we now


549
00:18:49,536 --> 00:18:50,766
have a great solution for you.


550
00:18:51,976 --> 00:18:53,006
Apple CryptoKit.


551
00:18:53,936 --> 00:18:57,026
Apple CryptoKit is new Swift


552
00:18:57,096 --> 00:18:59,576
cryptographic API which has been


553
00:18:59,576 --> 00:19:00,956
designed to follow the same


554
00:19:00,956 --> 00:19:02,866
philosophy as for those features


555
00:19:02,866 --> 00:19:05,396
we talked about and give you an


556
00:19:05,396 --> 00:19:06,886
easy access to cryptographic


557
00:19:06,886 --> 00:19:09,616
functions and hard to misuse


558
00:19:09,616 --> 00:19:10,096
functions.


559
00:19:11,006 --> 00:19:13,146
We're really excited to give


560
00:19:13,146 --> 00:19:14,966
that in this release.


561
00:19:16,106 --> 00:19:17,766
And now, I'm going to hand over


562
00:19:17,886 --> 00:19:18,916
to Frederic who is going to tell


563
00:19:18,916 --> 00:19:20,136
you all about this exciting new


564
00:19:20,136 --> 00:19:20,386
API.


565
00:19:21,076 --> 00:19:22,306
So please join me in welcoming


566
00:19:22,306 --> 00:19:22,976
Frederic on stage.


567
00:19:23,516 --> 00:19:29,546
[ Applause ]


568
00:19:30,046 --> 00:19:30,846
>> Thanks Yannick.


569
00:19:31,776 --> 00:19:32,386
Hello everyone.


570
00:19:32,796 --> 00:19:34,946
My name is Frederic Jacobs, and


571
00:19:34,946 --> 00:19:36,526
I'm working on the Cryptographic


572
00:19:36,526 --> 00:19:37,936
Engineering Team here at Apple.


573
00:19:38,646 --> 00:19:40,536
I'm excited to tell you more


574
00:19:40,536 --> 00:19:42,546
today about Apple CryptoKit.


575
00:19:43,386 --> 00:19:44,866
We think you're really going to


576
00:19:44,866 --> 00:19:46,676
like implementing cryptographic


577
00:19:46,676 --> 00:19:49,346
protocols in Swift.


578
00:19:49,396 --> 00:19:51,786
There are four aspects of Apple


579
00:19:51,786 --> 00:19:53,376
CryptoKit I would like to share


580
00:19:53,376 --> 00:19:54,346
with you this afternoon.


581
00:19:55,216 --> 00:19:57,596
First, we are going to talk


582
00:19:57,786 --> 00:19:59,656
about CryptoKit and Swift.


583
00:20:00,876 --> 00:20:03,876
Second, we will talk about the


584
00:20:03,876 --> 00:20:06,016
curated set of algorithms that


585
00:20:06,016 --> 00:20:07,566
is available in CryptoKit.


586
00:20:08,556 --> 00:20:11,016
Third, we are going to discuss


587
00:20:11,126 --> 00:20:14,146
about the Secure Enclave and


588
00:20:14,146 --> 00:20:16,016
biometric authentication, and


589
00:20:16,586 --> 00:20:18,136
finally, we'll talk about


590
00:20:18,186 --> 00:20:18,746
performance.


591
00:20:19,706 --> 00:20:21,006
Let's dive right in.


592
00:20:22,096 --> 00:20:23,806
In the past, you might have had


593
00:20:23,856 --> 00:20:25,556
to write code that looks like


594
00:20:25,556 --> 00:20:28,726
this when you were calling into


595
00:20:28,726 --> 00:20:30,366
C crypto API from Swift.


596
00:20:31,126 --> 00:20:33,326
You had to allocate buffers,


597
00:20:33,596 --> 00:20:34,806
figure out for each of the


598
00:20:34,806 --> 00:20:36,706
buffers what size it had to be,


599
00:20:37,406 --> 00:20:39,576
and there were values such as


600
00:20:39,576 --> 00:20:42,246
the nonce that you might have to


601
00:20:42,246 --> 00:20:44,456
search what the safe value for


602
00:20:44,456 --> 00:20:45,366
that value was.


603
00:20:46,326 --> 00:20:47,836
And then you have all of these


604
00:20:47,836 --> 00:20:50,406
nested calls into the encryption


605
00:20:50,406 --> 00:20:52,746
function where you're passing


606
00:20:52,746 --> 00:20:54,346
pointers, and there are no


607
00:20:54,346 --> 00:20:56,556
argument labels that help you


608
00:20:56,846 --> 00:20:58,996
figure out which pointer needs


609
00:20:58,996 --> 00:21:01,426
to go into which argument.


610
00:21:02,306 --> 00:21:04,716
In contrast, with Apple


611
00:21:04,716 --> 00:21:07,556
CryptoKit, you can do exactly


612
00:21:07,556 --> 00:21:09,246
the same operation with a single


613
00:21:09,246 --> 00:21:09,836
line of code.


614
00:21:11,086 --> 00:21:12,696
In this-- isn't this cool?


615
00:21:13,516 --> 00:21:18,506
[ Applause ]


616
00:21:19,006 --> 00:21:21,746
So, in order to do so, you're


617
00:21:21,746 --> 00:21:23,036
passing the data you want to


618
00:21:23,036 --> 00:21:24,666
encrypt to cipher.


619
00:21:24,786 --> 00:21:26,836
In this case we're using


620
00:21:26,836 --> 00:21:29,536
AES.GCM, and you're using the


621
00:21:29,536 --> 00:21:31,616
key you want to encrypt the data


622
00:21:31,616 --> 00:21:34,716
with and that's it.


623
00:21:35,926 --> 00:21:38,276
Something else you might have


624
00:21:38,276 --> 00:21:40,016
had to do is generating your own


625
00:21:40,016 --> 00:21:42,036
cryptographic key when you were


626
00:21:42,036 --> 00:21:43,826
calling into a C crypto API from


627
00:21:43,826 --> 00:21:44,146
Swift.


628
00:21:44,766 --> 00:21:46,796
And that involved first


629
00:21:47,116 --> 00:21:48,646
converting a number of bits and


630
00:21:48,646 --> 00:21:50,456
bytes because cryptographic keys


631
00:21:50,456 --> 00:21:52,996
are commonly expressed in bits.


632
00:21:54,066 --> 00:21:56,446
Then you have to allocate a


633
00:21:56,446 --> 00:22:01,416
buffer for that amount of bytes


634
00:22:01,576 --> 00:22:03,576
and use the system, random


635
00:22:03,576 --> 00:22:05,606
number generator to fill that


636
00:22:05,666 --> 00:22:08,096
buffer with cryptographically


637
00:22:08,096 --> 00:22:09,556
secure random numbers.


638
00:22:11,216 --> 00:22:14,606
Then, if an error occurred you


639
00:22:14,606 --> 00:22:15,666
had to handle that.


640
00:22:16,726 --> 00:22:19,646
You're then finally ready to use


641
00:22:19,646 --> 00:22:22,816
that key, and when you're done


642
00:22:22,816 --> 00:22:24,706
with that key, you don't have to


643
00:22:24,706 --> 00:22:27,556
forget to zeroize it to remove


644
00:22:27,556 --> 00:22:28,216
it from memory.


645
00:22:28,836 --> 00:22:32,956
In contrast the CryptoKit,


646
00:22:32,956 --> 00:22:34,986
generating a key is just a


647
00:22:34,986 --> 00:22:37,906
single line of code.


648
00:22:38,636 --> 00:22:40,376
You call the SymmetricKey


649
00:22:40,906 --> 00:22:42,796
initializer, and you pass the


650
00:22:42,796 --> 00:22:45,386
number of bits you want the key


651
00:22:45,386 --> 00:22:45,836
to hold.


652
00:22:50,096 --> 00:22:52,666
We're able to zeroize this key


653
00:22:52,666 --> 00:22:55,966
on release for you because


654
00:22:56,566 --> 00:22:58,916
knowing about the auto reference


655
00:22:58,916 --> 00:23:02,626
counting of this value whenever


656
00:23:03,096 --> 00:23:04,806
it is getting deallocated, we're


657
00:23:04,806 --> 00:23:09,246
zeroizing that buffer for you.


658
00:23:09,456 --> 00:23:11,376
So, CryptoKit and Swift.


659
00:23:12,266 --> 00:23:15,426
We have a strongly typed API,


660
00:23:16,366 --> 00:23:18,726
and whenever you're initializing


661
00:23:19,426 --> 00:23:22,436
a value, we are verifying that


662
00:23:22,436 --> 00:23:24,826
the data you're passing is a


663
00:23:25,076 --> 00:23:26,596
strong value for that argument.


664
00:23:28,116 --> 00:23:32,706
Thanks to Swift's memory


665
00:23:32,706 --> 00:23:34,506
management model, we're able to


666
00:23:34,946 --> 00:23:38,376
zeroize on release all of the


667
00:23:38,376 --> 00:23:40,156
secret values allocated within


668
00:23:40,156 --> 00:23:40,656
CryptoKit.


669
00:23:41,986 --> 00:23:43,646
We perform equitable


670
00:23:43,646 --> 00:23:46,846
conformances for values like


671
00:23:47,066 --> 00:23:49,416
message authentication code if


672
00:23:49,736 --> 00:23:50,746
you're familiar with that


673
00:23:50,746 --> 00:23:52,756
content so that you're able to


674
00:23:52,756 --> 00:23:53,966
verify two-message


675
00:23:53,966 --> 00:23:56,006
authentication codes in constant


676
00:23:56,006 --> 00:23:58,786
time by just using the equals


677
00:23:58,786 --> 00:23:59,866
equals operator.


678
00:24:03,556 --> 00:24:06,516
CryptoKit also defines protocols


679
00:24:06,806 --> 00:24:09,296
so that you can write generic


680
00:24:09,296 --> 00:24:12,336
code over a hash function H, and


681
00:24:12,426 --> 00:24:14,176
if in multiple places of your


682
00:24:14,176 --> 00:24:16,136
code base you have to pass


683
00:24:16,136 --> 00:24:17,656
different hash functions, you


684
00:24:17,656 --> 00:24:19,346
can write the code once and then


685
00:24:19,496 --> 00:24:21,036
parametrize the function call on


686
00:24:21,036 --> 00:24:21,976
a different hash function.


687
00:24:24,776 --> 00:24:27,456
So, we talked about CryptoKit


688
00:24:27,456 --> 00:24:29,836
and Swift, and now I want to


689
00:24:29,836 --> 00:24:32,996
dive into the curated set of


690
00:24:33,066 --> 00:24:36,166
algorithms that is supported in


691
00:24:36,166 --> 00:24:36,716
CryptoKit.


692
00:24:37,756 --> 00:24:40,716
All algorithms are standard and


693
00:24:40,716 --> 00:24:41,896
peer-reviewed algorithms.


694
00:24:42,526 --> 00:24:45,726
Let's see what's available in


695
00:24:45,726 --> 00:24:46,216
CryptoKit.


696
00:24:47,716 --> 00:24:49,066
We have support for hash


697
00:24:49,066 --> 00:24:51,276
functions, message


698
00:24:51,276 --> 00:24:53,056
authentication codes,


699
00:24:53,696 --> 00:24:56,796
authenticated encryption, key


700
00:24:57,026 --> 00:25:01,126
agreement, and signatures.


701
00:25:02,876 --> 00:25:05,096
Some of these algorithms are


702
00:25:05,096 --> 00:25:06,686
algorithms we have supported


703
00:25:06,686 --> 00:25:09,316
before in frameworks such as


704
00:25:09,316 --> 00:25:11,576
Common Crypto or SecKey, but


705
00:25:11,576 --> 00:25:13,136
some of these algorithms are


706
00:25:13,136 --> 00:25:14,546
algorithms we're supporting for


707
00:25:14,546 --> 00:25:15,206
the first time.


708
00:25:15,726 --> 00:25:17,206
Those are highlighted in green


709
00:25:17,206 --> 00:25:17,816
on the slide.


710
00:25:18,466 --> 00:25:21,656
Note that we also have an


711
00:25:21,656 --> 00:25:22,596
insecure module.


712
00:25:23,936 --> 00:25:27,216
This module provides algorithms


713
00:25:27,216 --> 00:25:30,776
such as MD5 and SHA1 so that you


714
00:25:30,776 --> 00:25:32,806
can adopt CryptoKit even if you


715
00:25:32,806 --> 00:25:35,356
need to be using some algorithms


716
00:25:35,356 --> 00:25:37,356
that no longer meet the best


717
00:25:37,446 --> 00:25:38,526
security standards.


718
00:25:42,836 --> 00:25:46,306
Let's focus on a few examples to


719
00:25:46,636 --> 00:25:47,986
see how CryptoKit works.


720
00:25:48,806 --> 00:25:50,356
Let's start with hash functions.


721
00:25:50,926 --> 00:25:53,406
Hash functions produced


722
00:25:53,406 --> 00:25:56,456
deterministic fixed-size output


723
00:25:56,616 --> 00:25:58,816
that is called a digest, and


724
00:25:58,996 --> 00:26:01,526
unlike hashable in Swift, hash


725
00:26:01,526 --> 00:26:04,326
functions in CryptoKit provide


726
00:26:04,726 --> 00:26:06,636
cryptographic properties such as


727
00:26:06,716 --> 00:26:07,686
collision resistance.


728
00:26:08,626 --> 00:26:10,876
This means that it is hard to


729
00:26:10,876 --> 00:26:13,426
find two inputs that will hash


730
00:26:13,466 --> 00:26:16,986
to the same digest.


731
00:26:16,986 --> 00:26:19,606
In order to compute the hash, it


732
00:26:19,606 --> 00:26:22,926
is as easy as calling the hash


733
00:26:22,926 --> 00:26:24,976
method on the hash function you


734
00:26:24,976 --> 00:26:27,386
want to use, passing the data


735
00:26:27,386 --> 00:26:28,166
you want to hash.


736
00:26:29,196 --> 00:26:32,016
Here, I have some audio data I


737
00:26:32,016 --> 00:26:35,496
want to hash, and I use the


738
00:26:35,496 --> 00:26:38,636
SHA256 hash function to compute


739
00:26:38,636 --> 00:26:38,976
a digest.


740
00:26:42,906 --> 00:26:45,146
If you're streaming a file, you


741
00:26:45,146 --> 00:26:47,086
might be reading it from an


742
00:26:47,086 --> 00:26:47,676
input stream.


743
00:26:49,096 --> 00:26:50,416
In that case, you want to


744
00:26:50,416 --> 00:26:53,216
compute the digest


745
00:26:53,216 --> 00:26:53,906
incrementally.


746
00:26:55,096 --> 00:26:57,566
You start by initializing a


747
00:26:57,566 --> 00:26:59,836
hasher by calling the MT


748
00:26:59,836 --> 00:27:01,336
initializer on the hash


749
00:27:01,336 --> 00:27:01,746
function.


750
00:27:02,236 --> 00:27:07,016
You then pass the data you want


751
00:27:07,016 --> 00:27:09,146
to hash, and you call the update


752
00:27:09,146 --> 00:27:11,286
method one or multiple times in


753
00:27:11,286 --> 00:27:14,516
order to do so.


754
00:27:14,756 --> 00:27:17,966
And when you want the digest to


755
00:27:17,966 --> 00:27:20,446
be computed, you just call the


756
00:27:20,446 --> 00:27:22,226
finalize method on the hash for


757
00:27:22,226 --> 00:27:23,916
instance, and that will return


758
00:27:23,916 --> 00:27:24,466
the digest.


759
00:27:24,886 --> 00:27:29,396
Next, let's talk about


760
00:27:29,636 --> 00:27:30,886
authenticated encryption.


761
00:27:31,716 --> 00:27:33,456
This is something you've long


762
00:27:33,456 --> 00:27:34,446
been asking for.


763
00:27:35,106 --> 00:27:37,496
As its name suggests, it


764
00:27:37,496 --> 00:27:39,326
provides both authentication and


765
00:27:39,326 --> 00:27:39,896
encryption.


766
00:27:41,436 --> 00:27:44,146
The lack of authentication in


767
00:27:44,146 --> 00:27:46,686
cryptographic protocols can lead


768
00:27:46,686 --> 00:27:49,276
to a variety of attacks, and


769
00:27:49,836 --> 00:27:51,316
manually combining


770
00:27:51,436 --> 00:27:53,636
authentication with encryption


771
00:27:54,356 --> 00:27:56,266
can lead to things like padding


772
00:27:56,266 --> 00:27:58,076
oracle attacks.


773
00:27:58,436 --> 00:28:00,586
So, instead we're really happy


774
00:28:00,656 --> 00:28:02,426
to provide it to you as a single


775
00:28:02,426 --> 00:28:03,036
API call.


776
00:28:07,076 --> 00:28:08,846
I'm working on the site project.


777
00:28:09,096 --> 00:28:10,586
It's a hiking app.


778
00:28:11,216 --> 00:28:12,786
Most of the content on the app


779
00:28:12,786 --> 00:28:15,316
is free, but there's additional


780
00:28:15,316 --> 00:28:17,006
content you can purchase through


781
00:28:17,006 --> 00:28:21,276
the in-app purchase.


782
00:28:21,386 --> 00:28:22,876
Once you purchase the content,


783
00:28:23,216 --> 00:28:24,696
you can retrieve the additional


784
00:28:24,696 --> 00:28:25,156
content.


785
00:28:26,576 --> 00:28:27,936
I'm using a content delivery


786
00:28:27,936 --> 00:28:29,706
network in order to keep the


787
00:28:29,706 --> 00:28:32,516
downloads fast, as my user base


788
00:28:32,556 --> 00:28:32,776
grows.


789
00:28:35,436 --> 00:28:37,776
In order to obtain the content,


790
00:28:38,026 --> 00:28:41,366
I first check with my server if


791
00:28:41,366 --> 00:28:44,976
the in-app purchase is valid.


792
00:28:45,596 --> 00:28:49,706
Then, the key is retrieved from


793
00:28:49,706 --> 00:28:50,966
the server and passed on the


794
00:28:50,966 --> 00:28:51,296
phone.


795
00:28:52,656 --> 00:28:54,836
I download the encrypted data


796
00:28:55,136 --> 00:28:56,286
from the content delivery


797
00:28:56,286 --> 00:29:00,686
network, and I use the key in


798
00:29:00,686 --> 00:29:02,326
order to decrypt the encrypted


799
00:29:02,326 --> 00:29:02,736
content.


800
00:29:03,136 --> 00:29:06,346
And if the key is right, and the


801
00:29:06,346 --> 00:29:08,276
data wasn't tampered with on the


802
00:29:08,276 --> 00:29:10,816
content delivery network, I'm


803
00:29:10,866 --> 00:29:12,696
able to retrieve the map data.


804
00:29:13,306 --> 00:29:17,376
Let's see how this translates to


805
00:29:19,056 --> 00:29:19,166
code.


806
00:29:19,336 --> 00:29:22,166
First, we start by initializing


807
00:29:22,166 --> 00:29:24,366
a SymmetricKey from the key data


808
00:29:24,366 --> 00:29:26,696
that was retrieved from the


809
00:29:28,856 --> 00:29:29,036
server.


810
00:29:29,186 --> 00:29:31,256
Then we are initializing a


811
00:29:31,256 --> 00:29:31,976
sealed box.


812
00:29:32,996 --> 00:29:35,576
In this case, it doesn't really


813
00:29:35,576 --> 00:29:37,246
matter what's in the sealed box,


814
00:29:37,306 --> 00:29:39,216
but know that if you're working


815
00:29:39,556 --> 00:29:42,106
on implementing a specification


816
00:29:42,106 --> 00:29:44,066
that requires you to combine the


817
00:29:44,066 --> 00:29:46,146
nonce, the cipher text and the


818
00:29:46,146 --> 00:29:48,286
tag in a specific way, you can


819
00:29:48,286 --> 00:29:49,986
use the sealed box to do that.


820
00:29:50,816 --> 00:29:52,216
If you're implementing a


821
00:29:52,216 --> 00:29:54,446
protocol that requires you to


822
00:29:54,446 --> 00:29:57,146
pass specific nonce values we're


823
00:29:57,366 --> 00:29:59,176
also able to support that.


824
00:29:59,336 --> 00:30:01,376
But, in this example, we'll


825
00:30:01,416 --> 00:30:02,676
focus on the simple case.


826
00:30:04,096 --> 00:30:06,216
So, we're passing the downloaded


827
00:30:06,216 --> 00:30:08,086
data as a combined


828
00:30:08,086 --> 00:30:09,636
representation to the sealed


829
00:30:09,636 --> 00:30:12,156
box, and now that we have a box,


830
00:30:12,896 --> 00:30:15,496
we can simply open it by calling


831
00:30:15,496 --> 00:30:18,936
the open method on the cipher.


832
00:30:19,566 --> 00:30:22,816
And we're passing the key.


833
00:30:23,426 --> 00:30:23,976
It's that easy.


834
00:30:26,916 --> 00:30:28,366
Next, let's talk about


835
00:30:28,366 --> 00:30:28,896
signatures.


836
00:30:30,196 --> 00:30:31,946
Signatures are used to


837
00:30:31,946 --> 00:30:34,036
authenticate data using a


838
00:30:34,036 --> 00:30:36,616
private key, and using the


839
00:30:36,616 --> 00:30:38,926
signature, we are able to verify


840
00:30:38,926 --> 00:30:41,106
data using the associated public


841
00:30:41,166 --> 00:30:41,346
key.


842
00:30:41,866 --> 00:30:45,856
Let's take an example where we


843
00:30:45,856 --> 00:30:47,846
want to use the signature in


844
00:30:47,846 --> 00:30:49,366
order to authorize and


845
00:30:49,366 --> 00:30:49,976
operation.


846
00:30:50,796 --> 00:30:54,496
The operation here can be a


847
00:30:54,496 --> 00:30:56,866
two-factor log-in or some


848
00:30:56,916 --> 00:30:58,916
sensitive transaction such as


849
00:30:58,916 --> 00:31:00,866
wiring money to another user of


850
00:31:00,866 --> 00:31:01,536
the application.


851
00:31:03,666 --> 00:31:07,096
In order to do so, we start by


852
00:31:07,406 --> 00:31:08,976
generating a private key on the


853
00:31:08,976 --> 00:31:09,466
device.


854
00:31:10,956 --> 00:31:12,566
We then retrieve the associated


855
00:31:12,566 --> 00:31:13,246
public key.


856
00:31:13,816 --> 00:31:16,666
The associated public key is


857
00:31:16,666 --> 00:31:20,826
registered with your service,


858
00:31:20,956 --> 00:31:24,016
and once we want to perform that


859
00:31:24,016 --> 00:31:25,926
operation, we're using the


860
00:31:25,926 --> 00:31:27,536
private key to generate the


861
00:31:27,536 --> 00:31:29,516
signature on the transaction


862
00:31:29,516 --> 00:31:33,056
data and then sending over the


863
00:31:33,056 --> 00:31:34,226
transaction data and the


864
00:31:34,226 --> 00:31:35,456
signature to the server.


865
00:31:36,866 --> 00:31:40,566
The server will verify that the


866
00:31:40,566 --> 00:31:44,686
signature is correct, and if the


867
00:31:44,686 --> 00:31:47,636
signature is right, it will


868
00:31:47,636 --> 00:31:51,276
proceed to doing the operation.


869
00:31:51,756 --> 00:31:54,806
Let's see what this code looks


870
00:31:54,806 --> 00:31:54,976
like.


871
00:31:54,976 --> 00:31:57,676
In order to generate a


872
00:31:57,676 --> 00:32:00,066
cryptographically strong private


873
00:32:00,066 --> 00:32:02,896
key, we call the PrivateKey


874
00:32:02,896 --> 00:32:03,566
initializer.


875
00:32:06,876 --> 00:32:09,546
Then we want to register some


876
00:32:09,546 --> 00:32:11,316
public key data on the server.


877
00:32:12,176 --> 00:32:14,556
We start by retrieving the


878
00:32:14,806 --> 00:32:17,506
public key by just calling


879
00:32:17,596 --> 00:32:19,326
public key on the private key,


880
00:32:19,956 --> 00:32:24,536
and then we want to say what


881
00:32:24,596 --> 00:32:26,766
representation we want to get


882
00:32:27,156 --> 00:32:28,346
from the public key.


883
00:32:29,026 --> 00:32:30,546
Multiple representations of


884
00:32:30,546 --> 00:32:32,406
public keys exist, and we have


885
00:32:32,456 --> 00:32:35,916
support in CryptoKit for a lot


886
00:32:35,916 --> 00:32:36,216
of them.


887
00:32:37,536 --> 00:32:39,886
In this case, we're taking the


888
00:32:39,886 --> 00:32:41,106
compact representation.


889
00:32:41,776 --> 00:32:44,106
As always, we're storing the


890
00:32:44,106 --> 00:32:45,586
private key in the Keychain.


891
00:32:46,676 --> 00:32:48,996
Sample code in order to do that


892
00:32:48,996 --> 00:32:50,236
will be available on the


893
00:32:50,236 --> 00:32:51,266
developer portal.


894
00:32:51,266 --> 00:32:54,946
In order to produce the


895
00:32:54,946 --> 00:32:57,456
signature, we are calling the


896
00:32:57,516 --> 00:32:59,346
signature method on the private


897
00:32:59,346 --> 00:33:02,446
key, and we're passing the


898
00:33:02,446 --> 00:33:03,796
transaction data we wish to


899
00:33:03,796 --> 00:33:05,486
sign, and this returns the


900
00:33:05,486 --> 00:33:05,926
signature.


901
00:33:09,136 --> 00:33:13,126
Now, this key that protects


902
00:33:13,266 --> 00:33:16,416
these operations is of high


903
00:33:16,416 --> 00:33:19,366
value, so we want to give it the


904
00:33:19,366 --> 00:33:21,416
best security it can.


905
00:33:21,906 --> 00:33:23,316
That's where the Secure Enclave


906
00:33:23,396 --> 00:33:23,846
comes in.


907
00:33:25,716 --> 00:33:27,726
The Secure Enclave is s


908
00:33:27,726 --> 00:33:29,156
hardware-based key manager


909
00:33:29,466 --> 00:33:30,886
that's isolated from the main


910
00:33:30,886 --> 00:33:32,816
processor to provide an extra


911
00:33:32,816 --> 00:33:33,766
layer of security.


912
00:33:34,466 --> 00:33:36,316
It is used as part of critical


913
00:33:36,316 --> 00:33:38,106
system features, such as Touch


914
00:33:38,106 --> 00:33:39,606
ID or Face ID.


915
00:33:41,336 --> 00:33:45,186
Let's see how to improve on or


916
00:33:45,186 --> 00:33:48,156
code that uses signatures to


917
00:33:48,156 --> 00:33:49,576
take advantage of the Secure


918
00:33:49,576 --> 00:33:49,986
Enclave.


919
00:33:50,596 --> 00:33:54,726
We start by checking if a Secure


920
00:33:54,726 --> 00:33:56,186
Enclave is available on the


921
00:33:56,186 --> 00:33:56,496
device.


922
00:33:57,206 --> 00:34:00,476
We do so by calling isAvailable


923
00:34:00,476 --> 00:34:01,446
on SecureEnclave.


924
00:34:01,936 --> 00:34:07,286
And from there, we can use


925
00:34:07,286 --> 00:34:09,565
exactly the same code as before


926
00:34:10,886 --> 00:34:14,356
in order to produce, to generate


927
00:34:14,356 --> 00:34:15,516
the key and produce the


928
00:34:15,516 --> 00:34:17,696
signature within the Secure


929
00:34:17,696 --> 00:34:18,076
Enclave.


930
00:34:18,606 --> 00:34:20,966
Note that in order to do so, we


931
00:34:21,016 --> 00:34:24,656
simply prefix or call to the


932
00:34:24,656 --> 00:34:27,985
PrivateKey initializer call that


933
00:34:27,985 --> 00:34:30,016
generates the key, and we prefix


934
00:34:30,016 --> 00:34:31,356
it with Secure Enclave dot.


935
00:34:32,596 --> 00:34:34,735
It's that easy to take advantage


936
00:34:34,835 --> 00:34:35,746
of the Secure Enclave.


937
00:34:37,755 --> 00:34:41,646
An advantage of using the Secure


938
00:34:41,646 --> 00:34:43,456
Enclave is that you can


939
00:34:43,456 --> 00:34:44,536
constrain key usage.


940
00:34:45,096 --> 00:34:48,045
In this case, we want to say


941
00:34:48,045 --> 00:34:50,126
that the key that we're


942
00:34:50,126 --> 00:34:51,755
generating on the Secure Enclave


943
00:34:52,656 --> 00:34:54,866
is only accessible when the


944
00:34:54,866 --> 00:34:58,596
device is unlocked and that this


945
00:34:58,596 --> 00:35:01,026
key will be available on this


946
00:35:01,026 --> 00:35:01,786
device only.


947
00:35:02,886 --> 00:35:04,706
We can further constrain key


948
00:35:04,706 --> 00:35:06,816
usage by saying that when we're


949
00:35:06,816 --> 00:35:09,556
performing an operation with the


950
00:35:09,556 --> 00:35:11,566
private key, we want to require


951
00:35:11,566 --> 00:35:12,326
user presence.


952
00:35:13,496 --> 00:35:16,076
Requiring user presence means


953
00:35:16,076 --> 00:35:18,006
that the user will either be


954
00:35:18,006 --> 00:35:19,186
prompted for biometric


955
00:35:19,186 --> 00:35:22,336
authentication or they will be


956
00:35:22,336 --> 00:35:24,316
requested for their device


957
00:35:24,386 --> 00:35:24,846
password.


958
00:35:25,466 --> 00:35:29,956
Now that we have composed an


959
00:35:29,956 --> 00:35:32,156
access control policy, we are


960
00:35:32,216 --> 00:35:33,726
simply passing it to the


961
00:35:33,726 --> 00:35:35,426
initializer of the key we're


962
00:35:35,426 --> 00:35:39,106
generating, and that policy will


963
00:35:39,106 --> 00:35:39,616
be enforced.


964
00:35:40,626 --> 00:35:41,846
You might want to give some


965
00:35:41,846 --> 00:35:43,576
additional context to your users


966
00:35:43,656 --> 00:35:45,646
about why they're required to


967
00:35:45,646 --> 00:35:46,236
authenticate.


968
00:35:46,886 --> 00:35:49,216
In order to do so, you can pass


969
00:35:49,216 --> 00:35:51,126
a LocalAuthentication context.


970
00:35:51,696 --> 00:35:56,206
In this case, we say that we


971
00:35:56,236 --> 00:35:58,166
want the LocalAuthentication


972
00:35:58,166 --> 00:36:00,376
context to be valid for ten


973
00:36:00,376 --> 00:36:02,476
seconds, so the user will not be


974
00:36:02,476 --> 00:36:03,896
required to reauthenticate


975
00:36:04,426 --> 00:36:06,746
during that amount of time, and


976
00:36:07,116 --> 00:36:09,056
we want to tell the user that


977
00:36:09,056 --> 00:36:10,546
they're required to authenticate


978
00:36:10,656 --> 00:36:12,476
because they're authorizing a


979
00:36:12,476 --> 00:36:14,066
$10 transfer to Bob.


980
00:36:14,576 --> 00:36:17,506
In order to use that


981
00:36:17,786 --> 00:36:19,516
authentication context, you


982
00:36:19,556 --> 00:36:22,236
simply pass it to the key's


983
00:36:22,316 --> 00:36:23,136
initializer.


984
00:36:26,976 --> 00:36:28,766
Finally, let's talk about


985
00:36:28,766 --> 00:36:29,456
performance.


986
00:36:32,226 --> 00:36:33,876
CryptoKit is built on top of


987
00:36:33,876 --> 00:36:34,546
corecrypto.


988
00:36:35,386 --> 00:36:37,556
Corecrypto is Apple's native


989
00:36:38,056 --> 00:36:40,286
cryptographic library that


990
00:36:40,286 --> 00:36:41,816
features all of the system


991
00:36:41,816 --> 00:36:42,916
frameworks that Yannick has


992
00:36:42,916 --> 00:36:43,726
described before.


993
00:36:44,306 --> 00:36:47,676
With the help of the team that


994
00:36:47,676 --> 00:36:48,726
brought you the Accelerate


995
00:36:48,726 --> 00:36:50,826
framework and the CPU design


996
00:36:50,866 --> 00:36:53,216
team, corecrypto has hand-tuned


997
00:36:53,216 --> 00:36:55,196
assembly code, squeezing every


998
00:36:55,196 --> 00:36:57,646
cycle out of each of the support


999
00:36:57,646 --> 00:36:58,646
micro architectures.


1000
00:37:00,636 --> 00:37:03,466
In addition to that, because it


1001
00:37:03,466 --> 00:37:05,776
uses corecrypto, it takes


1002
00:37:05,776 --> 00:37:07,916
advantage of security


1003
00:37:07,916 --> 00:37:10,886
mitigations in corecrypto such


1004
00:37:10,886 --> 00:37:13,986
as side-channel resistance, and


1005
00:37:14,356 --> 00:37:16,446
because corecrypto is FIPS


1006
00:37:16,446 --> 00:37:19,156
validated, that means that you


1007
00:37:19,156 --> 00:37:21,496
can use CryptoKit in the FIPS


1008
00:37:21,496 --> 00:37:22,196
compliant way.


1009
00:37:22,996 --> 00:37:24,576
Yannick opened with this slide


1010
00:37:24,716 --> 00:37:27,586
showing large categories of bug


1011
00:37:27,586 --> 00:37:31,006
classes that are available in


1012
00:37:31,006 --> 00:37:32,236
cryptographic protocols and


1013
00:37:32,236 --> 00:37:33,076
implementations.


1014
00:37:34,116 --> 00:37:36,086
With CryptoKit, we are starting


1015
00:37:36,086 --> 00:37:37,896
to eliminate some of these bug


1016
00:37:37,896 --> 00:37:40,036
classes, but CryptoKit remains a


1017
00:37:40,036 --> 00:37:42,036
low-level crypto API that's


1018
00:37:42,036 --> 00:37:44,226
powerful to let you implement a


1019
00:37:44,226 --> 00:37:46,236
wide range of protocols, even


1020
00:37:46,236 --> 00:37:48,906
broken ones.


1021
00:37:49,076 --> 00:37:50,726
Not all cryptographic weaknesses


1022
00:37:50,726 --> 00:37:52,046
can be addressed at the level of


1023
00:37:52,046 --> 00:37:53,136
the cryptographic library.


1024
00:37:53,496 --> 00:37:55,266
Therefore, we strongly recommend


1025
00:37:55,266 --> 00:37:56,706
you to rely on higher level


1026
00:37:56,706 --> 00:37:59,626
system frameworks when you can.


1027
00:38:00,176 --> 00:38:01,786
This is only the beginning, and


1028
00:38:01,786 --> 00:38:03,586
we want to continue helping you


1029
00:38:03,686 --> 00:38:05,646
ship the safest apps as possible


1030
00:38:05,846 --> 00:38:07,646
by delivering on APIs that help


1031
00:38:07,646 --> 00:38:08,856
you prevent secure legal


1032
00:38:08,856 --> 00:38:09,846
vulnerabilities in your


1033
00:38:09,846 --> 00:38:10,526
applications.


1034
00:38:11,056 --> 00:38:13,486
We can't wait for you to start


1035
00:38:13,486 --> 00:38:15,566
adopting CryptoKit in your apps.


1036
00:38:15,896 --> 00:38:17,146
On the page of this session,


1037
00:38:17,446 --> 00:38:18,546
you'll find a link to the


1038
00:38:18,546 --> 00:38:20,986
CryptoKit documentation, and it


1039
00:38:20,986 --> 00:38:22,536
comes with Xcode Playground.


1040
00:38:23,746 --> 00:38:25,866
Download it, play with it for an


1041
00:38:25,866 --> 00:38:28,096
hour, and see what's available.


1042
00:38:28,756 --> 00:38:30,596
See how you could take advantage


1043
00:38:30,596 --> 00:38:32,366
of CryptoKit in your apps.


1044
00:38:34,156 --> 00:38:36,016
We will be at the labs tomorrow


1045
00:38:36,376 --> 00:38:38,466
to answer any of your questions,


1046
00:38:38,466 --> 00:38:39,816
and we're looking forward to


1047
00:38:39,816 --> 00:38:40,366
your feedback.


1048
00:38:40,926 --> 00:38:41,636
Thank you.


1049
00:38:42,016 --> 00:38:44,000
[ Applause ]

