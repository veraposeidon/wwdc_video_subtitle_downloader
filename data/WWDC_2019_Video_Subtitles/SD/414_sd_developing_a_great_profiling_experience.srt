1
00:00:01,516 --> 00:00:05,500
[ Music ]


2
00:00:09,516 --> 00:00:14,546
[ Applause ]


3
00:00:15,046 --> 00:00:16,276
>> Good afternoon and welcome to


4
00:00:16,276 --> 00:00:17,536
our session on Developing a


5
00:00:17,536 --> 00:00:18,886
Great Profiling Experience.


6
00:00:19,316 --> 00:00:20,406
I'm Daniel Delwood and I'll be


7
00:00:20,406 --> 00:00:21,656
joined by Kasper Harasim


8
00:00:21,656 --> 00:00:22,116
[phonetic].


9
00:00:22,116 --> 00:00:23,036
And today we're here to talk


10
00:00:23,036 --> 00:00:24,286
about making great Custom


11
00:00:24,286 --> 00:00:25,186
Instruments packages.


12
00:00:26,546 --> 00:00:28,256
Now as developers, we all strive


13
00:00:28,256 --> 00:00:29,366
to create excellent,


14
00:00:29,536 --> 00:00:31,026
maintainable, modular and


15
00:00:31,026 --> 00:00:31,666
reusable code.


16
00:00:32,156 --> 00:00:33,106
And we've all used frameworks


17
00:00:33,166 --> 00:00:34,766
designed by others and created


18
00:00:34,766 --> 00:00:35,786
code that we want others to be


19
00:00:35,786 --> 00:00:36,786
able to use well.


20
00:00:38,016 --> 00:00:39,436
And good API design and


21
00:00:39,436 --> 00:00:40,966
documentation are critical to


22
00:00:40,966 --> 00:00:42,646
the user's experience with your


23
00:00:42,646 --> 00:00:43,136
framework.


24
00:00:43,596 --> 00:00:45,066
But my hope is today that you


25
00:00:45,066 --> 00:00:46,036
consider developing an


26
00:00:46,036 --> 00:00:47,196
Instruments package as well.


27
00:00:48,226 --> 00:00:50,276
To see why, take Metal as an


28
00:00:50,276 --> 00:00:50,996
example.


29
00:00:51,376 --> 00:00:53,106
API design is central and the


30
00:00:53,106 --> 00:00:54,446
calls are organized around a set


31
00:00:54,446 --> 00:00:56,426
of core concepts, devices,


32
00:00:56,476 --> 00:00:57,876
command buffers, textures and


33
00:00:57,876 --> 00:00:58,116
more.


34
00:00:58,136 --> 00:01:00,326
But that's not the whole story.


35
00:01:00,906 --> 00:01:02,356
An API surface expresses what's


36
00:01:02,426 --> 00:01:04,385
possible, but documentation and


37
00:01:04,385 --> 00:01:06,436
example code are how others


38
00:01:06,436 --> 00:01:08,116
learn to compose these concepts


39
00:01:08,176 --> 00:01:08,906
into a great app.


40
00:01:09,516 --> 00:01:10,946
But that's not the whole story


41
00:01:10,946 --> 00:01:11,256
either.


42
00:01:12,046 --> 00:01:13,006
Both of the first two help


43
00:01:13,006 --> 00:01:14,836
developers write code using your


44
00:01:14,916 --> 00:01:15,876
classes or framework.


45
00:01:15,976 --> 00:01:17,546
But what happens when something


46
00:01:17,546 --> 00:01:17,996
goes wrong?


47
00:01:18,726 --> 00:01:20,326
Well, custom Instruments are a


48
00:01:20,326 --> 00:01:22,246
way for you as the author to


49
00:01:22,246 --> 00:01:23,316
teach others how to debug,


50
00:01:23,766 --> 00:01:25,426
optimize and really get the most


51
00:01:25,426 --> 00:01:26,346
out of your APIs.


52
00:01:26,856 --> 00:01:28,096
If you've used the Metal System


53
00:01:28,096 --> 00:01:29,266
Trace template in Instruments,


54
00:01:29,686 --> 00:01:30,536
then you've seen some of what's


55
00:01:30,606 --> 00:01:31,126
possible.


56
00:01:31,406 --> 00:01:33,186
Creating visual tools designed


57
00:01:33,216 --> 00:01:34,836
specifically for the concepts


58
00:01:34,836 --> 00:01:36,396
and APIs that you define.


59
00:01:36,646 --> 00:01:39,216
An Instruments package is a way


60
00:01:39,216 --> 00:01:40,786
for you to build transparency


61
00:01:41,196 --> 00:01:42,416
that under the hood your


62
00:01:42,416 --> 00:01:43,496
framework is tested,


63
00:01:43,626 --> 00:01:44,446
understandable and


64
00:01:44,446 --> 00:01:45,066
well-supported.


65
00:01:45,516 --> 00:01:46,626
And investing that time to


66
00:01:46,706 --> 00:01:48,156
create a custom instrument helps


67
00:01:48,256 --> 00:01:50,216
create confidence and trust that


68
00:01:50,216 --> 00:01:51,676
the code's doing exactly what


69
00:01:51,676 --> 00:01:52,216
you expect.


70
00:01:53,396 --> 00:01:54,886
Tools are also a great way to


71
00:01:54,886 --> 00:01:56,596
develop a cost model to know


72
00:01:56,596 --> 00:01:58,006
which calls are expensive and


73
00:01:58,006 --> 00:01:58,896
which are inexpensive.


74
00:01:59,466 --> 00:02:00,426
And when there's a performance


75
00:02:00,426 --> 00:02:01,866
problem, they're the best way to


76
00:02:01,866 --> 00:02:02,996
differentiate between a


77
00:02:02,996 --> 00:02:04,496
framework bug or a bug in the


78
00:02:04,496 --> 00:02:06,386
client code.


79
00:02:06,686 --> 00:02:08,506
Most importantly though, an


80
00:02:08,506 --> 00:02:10,265
instrument is an opportunity for


81
00:02:10,265 --> 00:02:11,596
you to tell your story.


82
00:02:11,596 --> 00:02:14,106
An Instruments package is your


83
00:02:14,106 --> 00:02:15,246
chance to explain what's going


84
00:02:15,246 --> 00:02:17,206
on to help visualize important


85
00:02:17,206 --> 00:02:18,786
metrics and help users quickly


86
00:02:18,786 --> 00:02:20,086
find problems when they arise.


87
00:02:20,966 --> 00:02:23,026
So today, we're going to cover


88
00:02:23,026 --> 00:02:23,696
how to build great


89
00:02:23,696 --> 00:02:24,946
instrumentation from the inside


90
00:02:24,946 --> 00:02:26,266
out, starting from the inside


91
00:02:26,266 --> 00:02:27,946
out of developing great trace


92
00:02:27,996 --> 00:02:29,066
points in your framework, and


93
00:02:29,376 --> 00:02:30,396
then building on them with


94
00:02:30,396 --> 00:02:32,446
schemas, modeling and structure


95
00:02:32,746 --> 00:02:34,356
inside Instruments before


96
00:02:34,356 --> 00:02:35,426
finally moving on to talking


97
00:02:35,426 --> 00:02:36,846
about visualization and the


98
00:02:36,846 --> 00:02:37,466
instrument's UI.


99
00:02:38,266 --> 00:02:40,486
So with tracing, modeling and


100
00:02:40,486 --> 00:02:41,896
visualization as our roadmap for


101
00:02:41,896 --> 00:02:44,426
today, let's dive right in and


102
00:02:44,426 --> 00:02:46,266
talk about OSSignpost.


103
00:02:47,896 --> 00:02:49,746
Now OSSignpost is a low-cost


104
00:02:49,746 --> 00:02:51,076
tracing primitive introduced in


105
00:02:51,076 --> 00:02:52,086
2018.


106
00:02:52,486 --> 00:02:53,856
And signposts come in two


107
00:02:53,856 --> 00:02:55,466
different kinds: .events and


108
00:02:55,466 --> 00:02:56,016
intervals.


109
00:02:56,786 --> 00:02:58,176
Now they support recording any


110
00:02:58,176 --> 00:02:59,356
kind of data through their


111
00:02:59,416 --> 00:03:01,326
printf like formatString in


112
00:03:01,326 --> 00:03:01,896
arguments.


113
00:03:02,356 --> 00:03:03,646
And different from printf, all


114
00:03:03,646 --> 00:03:05,496
signposts are named with a


115
00:03:05,496 --> 00:03:06,106
static string.


116
00:03:07,926 --> 00:03:09,816
Now in Swift, OSSignpost is just


117
00:03:09,816 --> 00:03:11,036
one core API with three


118
00:03:11,036 --> 00:03:13,256
different types: begin, end and


119
00:03:13,256 --> 00:03:13,446
event.


120
00:03:13,446 --> 00:03:15,936
And in C, their interface is


121
00:03:15,936 --> 00:03:17,416
exposed through three helpful


122
00:03:17,416 --> 00:03:17,956
macros.


123
00:03:19,076 --> 00:03:20,646
Now it's important to note that


124
00:03:20,646 --> 00:03:22,826
OSSignpost is built on OSLog


125
00:03:23,386 --> 00:03:24,206
which means that much of the


126
00:03:24,206 --> 00:03:25,106
tracing behavior and


127
00:03:25,106 --> 00:03:27,356
configurability is determined by


128
00:03:27,356 --> 00:03:28,406
the provided log handle.


129
00:03:29,436 --> 00:03:30,816
Now log handles are effectively


130
00:03:30,816 --> 00:03:32,136
named spaces for your tracing.


131
00:03:32,676 --> 00:03:34,196
They allow you to specify


132
00:03:34,296 --> 00:03:36,566
subsystem and category and


133
00:03:36,566 --> 00:03:39,136
together with that static name


134
00:03:39,136 --> 00:03:41,006
for each signpost, this provides


135
00:03:41,046 --> 00:03:42,296
the logical structure and


136
00:03:42,296 --> 00:03:43,836
hierarchy for your trace points.


137
00:03:46,046 --> 00:03:47,036
Now custom Instruments are built


138
00:03:47,036 --> 00:03:48,546
on OSSignpost for two main


139
00:03:48,546 --> 00:03:48,946
reasons.


140
00:03:49,656 --> 00:03:51,026
First, they're temporal.


141
00:03:52,076 --> 00:03:54,016
All signposts, whether .events


142
00:03:54,016 --> 00:03:56,206
or intervals, implicitly record


143
00:03:56,206 --> 00:03:57,756
a high-accuracy timestamp.


144
00:03:59,816 --> 00:04:00,776
It's also important to have


145
00:04:00,856 --> 00:04:02,056
first class support for


146
00:04:02,056 --> 00:04:03,396
overlapping intervals in our


147
00:04:03,466 --> 00:04:04,556
highly-concurrent world.


148
00:04:04,786 --> 00:04:06,636
And OSSignpost does this with


149
00:04:06,636 --> 00:04:07,526
Signpost IDs.


150
00:04:08,266 --> 00:04:10,816
These record enough context for


151
00:04:10,816 --> 00:04:12,186
matching up the related events,


152
00:04:12,476 --> 00:04:14,016
even when the begin or end event


153
00:04:14,076 --> 00:04:15,836
happen on different threads or


154
00:04:15,836 --> 00:04:16,745
different dispatch queues.


155
00:04:17,366 --> 00:04:19,406
Now the second reason for


156
00:04:19,406 --> 00:04:20,906
OSSignpost is that they're


157
00:04:20,906 --> 00:04:21,606
low-cost.


158
00:04:22,236 --> 00:04:23,726
The logging mechanism is


159
00:04:23,726 --> 00:04:25,096
designed with efficiency in mind


160
00:04:25,576 --> 00:04:27,446
and it records a minimal amount


161
00:04:27,446 --> 00:04:28,636
of data whenever you admit an


162
00:04:28,636 --> 00:04:29,516
OSSignpost.


163
00:04:30,236 --> 00:04:31,586
Now there are optimizations


164
00:04:31,586 --> 00:04:33,766
around static strings, so things


165
00:04:33,766 --> 00:04:35,016
like your format string and your


166
00:04:35,016 --> 00:04:37,076
signpost name are actually


167
00:04:37,076 --> 00:04:38,906
emitted as just an offset into


168
00:04:38,906 --> 00:04:40,066
your binary text segment.


169
00:04:40,776 --> 00:04:41,826
Now in fact the overhead of


170
00:04:41,826 --> 00:04:44,716
OSSignpost is low enough that in


171
00:04:44,716 --> 00:04:46,486
most cases you can leave them in


172
00:04:46,486 --> 00:04:47,406
production code.


173
00:04:47,886 --> 00:04:49,056
So this is what makes them


174
00:04:49,056 --> 00:04:50,966
useful for building tools that


175
00:04:50,966 --> 00:04:52,726
debug optimized code in addition


176
00:04:52,726 --> 00:04:54,146
to helping you solve problems at


177
00:04:54,146 --> 00:04:55,546
your desk.


178
00:04:56,136 --> 00:04:57,136
Now when Instruments record


179
00:04:57,136 --> 00:04:58,666
signpost data, you'll get access


180
00:04:58,696 --> 00:05:00,766
to all the explicitly specified


181
00:05:00,866 --> 00:05:02,756
fields including that format


182
00:05:02,756 --> 00:05:03,796
string and then the arguments


183
00:05:03,796 --> 00:05:04,306
you provide.


184
00:05:05,226 --> 00:05:06,546
But in Instruments you'll also


185
00:05:06,546 --> 00:05:07,786
get access to all of the


186
00:05:07,786 --> 00:05:09,306
implicitly specified fields.


187
00:05:09,786 --> 00:05:11,766
Things like the timestamp or the


188
00:05:11,766 --> 00:05:12,926
calling thread which comes in


189
00:05:12,926 --> 00:05:13,496
really useful.


190
00:05:13,906 --> 00:05:15,746
If you're using a log handle


191
00:05:15,746 --> 00:05:17,566
that has backtraces enabled,


192
00:05:18,056 --> 00:05:20,136
then the call stack will also be


193
00:05:20,136 --> 00:05:21,746
recorded and made available to


194
00:05:21,746 --> 00:05:22,426
you in Instruments.


195
00:05:23,796 --> 00:05:25,186
So when adding tracing to your


196
00:05:25,186 --> 00:05:26,346
code, it's important to note


197
00:05:26,346 --> 00:05:28,596
that OSLog and OSSignpost


198
00:05:28,596 --> 00:05:30,286
behaves in three different


199
00:05:30,806 --> 00:05:30,926
modes.


200
00:05:31,366 --> 00:05:34,686
By default, OSLog is -- each


201
00:05:34,686 --> 00:05:36,436
OSLog handle has signposts


202
00:05:36,436 --> 00:05:36,866
enabled.


203
00:05:37,416 --> 00:05:39,096
And so they're still low-cost


204
00:05:39,096 --> 00:05:40,296
and only logged to a ring


205
00:05:40,296 --> 00:05:40,666
buffer.


206
00:05:41,936 --> 00:05:43,146
Now when Instruments or another


207
00:05:43,196 --> 00:05:45,606
client requests to display this


208
00:05:45,606 --> 00:05:48,506
data immediately, the OSLog


209
00:05:48,506 --> 00:05:49,736
system goes into a streaming


210
00:05:49,736 --> 00:05:51,546
mode which is a bit higher-cost.


211
00:05:53,106 --> 00:05:54,266
This year though there are two


212
00:05:54,266 --> 00:05:56,776
new dynamic categories that are


213
00:05:56,776 --> 00:05:57,886
only enabled when Instruments is


214
00:05:57,886 --> 00:05:58,386
recording.


215
00:05:59,126 --> 00:06:01,876
Now these dynamic categories are


216
00:06:01,876 --> 00:06:04,096
configured to record stack


217
00:06:04,096 --> 00:06:05,696
traces for the second one which


218
00:06:05,966 --> 00:06:07,056
adds a little bit of additional


219
00:06:07,056 --> 00:06:07,466
overhead.


220
00:06:08,006 --> 00:06:09,226
So with this in mind, what is


221
00:06:09,256 --> 00:06:11,376
the actual cost of OSSignpost?


222
00:06:13,056 --> 00:06:15,166
Well, many factors impact the


223
00:06:15,166 --> 00:06:16,336
real-world performance.


224
00:06:16,636 --> 00:06:17,946
Things like device type,


225
00:06:17,946 --> 00:06:20,246
hardware model, OS version,


226
00:06:20,246 --> 00:06:22,166
system load, thermals and more.


227
00:06:22,776 --> 00:06:23,936
So it's hard to give an exact


228
00:06:23,936 --> 00:06:24,306
number.


229
00:06:24,906 --> 00:06:26,116
But I'd like to give some order


230
00:06:26,116 --> 00:06:27,436
of magnitude approximations on a


231
00:06:27,436 --> 00:06:29,066
logarithmic scale, because I


232
00:06:29,066 --> 00:06:29,696
think it's useful for


233
00:06:29,696 --> 00:06:30,866
understanding the relative


234
00:06:30,866 --> 00:06:31,406
costs.


235
00:06:32,036 --> 00:06:33,636
If we look at Signposts in a


236
00:06:33,636 --> 00:06:35,836
release build, all of them clock


237
00:06:35,836 --> 00:06:37,136
in at under a microsecond.


238
00:06:37,476 --> 00:06:39,186
The new off-by-default dynamic


239
00:06:39,186 --> 00:06:40,926
categories are actually in the


240
00:06:40,926 --> 00:06:42,136
low nanosecond range.


241
00:06:43,256 --> 00:06:45,536
Now when Instruments is


242
00:06:45,536 --> 00:06:46,946
recording in deferred or last


243
00:06:46,946 --> 00:06:49,336
few second mode, these dynamic


244
00:06:49,336 --> 00:06:50,836
categories turn on to match the


245
00:06:50,836 --> 00:06:52,226
behavior of the on-by-default


246
00:06:52,226 --> 00:06:52,866
categories.


247
00:06:53,166 --> 00:06:55,336
And they are the same expense


248
00:06:55,336 --> 00:06:57,536
except for that dynamic stacks


249
00:06:57,536 --> 00:06:58,886
category which is a little bit


250
00:06:58,886 --> 00:07:00,076
more expensive in the low


251
00:07:00,076 --> 00:07:01,866
microsecond range due to the


252
00:07:01,866 --> 00:07:02,806
recording a call stack.


253
00:07:03,446 --> 00:07:05,436
Now when streaming mode is


254
00:07:05,436 --> 00:07:07,186
required though, all of these


255
00:07:07,186 --> 00:07:08,426
become significantly more


256
00:07:08,426 --> 00:07:10,496
expensive, moving into the tens


257
00:07:10,496 --> 00:07:11,426
of microseconds range.


258
00:07:12,086 --> 00:07:16,936
So with this in mind, what can


259
00:07:16,936 --> 00:07:18,126
you do to minimize the


260
00:07:18,126 --> 00:07:19,276
OSSignpost overhead while


261
00:07:19,276 --> 00:07:20,706
recording if you're concerned


262
00:07:20,706 --> 00:07:22,666
about that runtime cost or they


263
00:07:22,666 --> 00:07:23,506
start showing up in your


264
00:07:23,506 --> 00:07:23,986
profiles?


265
00:07:25,136 --> 00:07:26,446
Well, there's two easy things


266
00:07:26,506 --> 00:07:26,926
you can do.


267
00:07:27,446 --> 00:07:28,956
First of all, you can use


268
00:07:28,956 --> 00:07:30,386
Instruments' deferred or last few


269
00:07:30,386 --> 00:07:31,496
seconds mode instead of


270
00:07:31,496 --> 00:07:32,096
immediate mode.


271
00:07:32,586 --> 00:07:34,046
This keeps OSSignpost out of


272
00:07:34,046 --> 00:07:35,826
that streaming mode and reduces


273
00:07:35,826 --> 00:07:36,386
the overhead.


274
00:07:36,566 --> 00:07:37,796
And it's easy to configure a


275
00:07:37,796 --> 00:07:39,386
template to record in one of


276
00:07:39,386 --> 00:07:40,796
these modes when you open it.


277
00:07:43,506 --> 00:07:45,736
Also, if you use the new dynamic


278
00:07:45,736 --> 00:07:47,196
tracing categories, that's a


279
00:07:47,196 --> 00:07:48,686
great way to minimize overhead


280
00:07:48,686 --> 00:07:49,726
while not recording.


281
00:07:49,726 --> 00:07:51,926
Because the signposts will be


282
00:07:52,246 --> 00:07:53,966
off by default.


283
00:07:54,746 --> 00:07:55,776
They can only be enabled by


284
00:07:55,776 --> 00:07:57,396
custom instruments, so this data


285
00:07:57,396 --> 00:07:58,786
also won't crowd the tracks in


286
00:07:58,786 --> 00:08:01,596
the built-in OSSignpost tool.


287
00:08:02,476 --> 00:08:04,406
So as the author of a framework


288
00:08:04,406 --> 00:08:05,806
or a subsystem, just how many


289
00:08:05,806 --> 00:08:07,376
signposts is it reasonable to


290
00:08:07,376 --> 00:08:08,486
emit while you're profiling?


291
00:08:09,086 --> 00:08:10,086
Well, you can emit a lot.


292
00:08:10,086 --> 00:08:11,176
But let's assume a very


293
00:08:11,176 --> 00:08:12,486
conservative goal of staying


294
00:08:12,486 --> 00:08:15,226
under 1% CPU of even a single


295
00:08:15,226 --> 00:08:16,726
core while you're profiling.


296
00:08:17,136 --> 00:08:20,576
And then let's assume that the


297
00:08:20,896 --> 00:08:22,256
signposts have a rough cost,


298
00:08:22,256 --> 00:08:24,456
about half a microsecond per


299
00:08:24,456 --> 00:08:25,336
signpost enabled.


300
00:08:26,486 --> 00:08:28,016
Well, that math works out to


301
00:08:28,016 --> 00:08:29,456
20,000 signposts per second.


302
00:08:30,306 --> 00:08:31,956
And even in a display-link


303
00:08:31,956 --> 00:08:33,876
context on an iPad Pro running


304
00:08:33,876 --> 00:08:36,155
at 120 frames per second, that's


305
00:08:36,155 --> 00:08:38,076
still enough for 83 intervals


306
00:08:38,405 --> 00:08:39,035
per frame.


307
00:08:40,676 --> 00:08:43,066
Now again, the real-world


308
00:08:43,066 --> 00:08:45,626
performance will change and


309
00:08:45,626 --> 00:08:46,696
these are just estimates.


310
00:08:47,096 --> 00:08:48,836
So it's important to remember


311
00:08:48,836 --> 00:08:49,916
that signposts are a shared


312
00:08:49,916 --> 00:08:50,556
resource.


313
00:08:51,226 --> 00:08:53,046
The more you use, the more it


314
00:08:53,046 --> 00:08:54,246
will impact the logging system.


315
00:08:54,686 --> 00:08:56,706
That said, they're designed to


316
00:08:56,706 --> 00:08:58,146
allow for this high-rate tracing


317
00:08:58,146 --> 00:08:59,806
and it can come in really useful


318
00:08:59,806 --> 00:09:00,406
sometimes.


319
00:09:00,996 --> 00:09:02,216
Sometimes it's the key to


320
00:09:02,216 --> 00:09:04,016
figuring out a pipeline install


321
00:09:04,316 --> 00:09:05,746
or an ordering issue in your


322
00:09:05,746 --> 00:09:06,086
code.


323
00:09:06,956 --> 00:09:08,446
Keep in mind though that you may


324
00:09:08,446 --> 00:09:10,066
want to separate signposts out


325
00:09:10,496 --> 00:09:12,176
into different categories per


326
00:09:12,176 --> 00:09:12,766
audience.


327
00:09:13,406 --> 00:09:15,336
It's likely that your clients of


328
00:09:15,336 --> 00:09:16,496
your framework will need less


329
00:09:16,566 --> 00:09:18,046
detail than contributors of your


330
00:09:18,046 --> 00:09:19,686
framework who might need tracing


331
00:09:19,686 --> 00:09:21,016
of more implementation details.


332
00:09:21,336 --> 00:09:23,236
And if you split your trace


333
00:09:23,236 --> 00:09:24,816
points across multiple log


334
00:09:24,816 --> 00:09:26,796
handles, this allows your tools


335
00:09:26,796 --> 00:09:28,096
to only enable the necessary


336
00:09:28,096 --> 00:09:28,456
subset.


337
00:09:29,866 --> 00:09:31,636
Now as tracing is the basis for


338
00:09:31,636 --> 00:09:32,586
instrumentation, I want to


339
00:09:32,586 --> 00:09:33,656
quickly cover four best


340
00:09:33,656 --> 00:09:34,256
practices.


341
00:09:36,286 --> 00:09:37,526
First and most importantly,


342
00:09:38,186 --> 00:09:40,256
always end any intervals you


343
00:09:40,256 --> 00:09:40,636
begin.


344
00:09:41,326 --> 00:09:42,626
It's critical for correctness


345
00:09:43,536 --> 00:09:45,326
and permanently open intervals


346
00:09:45,326 --> 00:09:46,116
can really slow down


347
00:09:46,116 --> 00:09:47,406
Instruments' analysis as well.


348
00:09:48,426 --> 00:09:50,116
In this example, we have


349
00:09:50,266 --> 00:09:52,336
OSSignpost calls wrapping an


350
00:09:52,576 --> 00:09:53,956
expensive and potentially


351
00:09:53,956 --> 00:09:55,586
error-throwing piece of code.


352
00:09:56,456 --> 00:09:58,176
The problem is that if an error


353
00:09:58,176 --> 00:09:59,956
is thrown, then control flow


354
00:09:59,956 --> 00:10:01,926
jumps to the catch scope and


355
00:10:01,926 --> 00:10:03,526
skips our end signpost entirely.


356
00:10:05,036 --> 00:10:06,466
Now Swift's defer statement is


357
00:10:06,466 --> 00:10:07,696
really a great way to handle


358
00:10:07,696 --> 00:10:08,546
this, making sure that


359
00:10:08,546 --> 00:10:10,866
regardless of early returns or


360
00:10:10,866 --> 00:10:14,016
errors being thrown, that


361
00:10:14,016 --> 00:10:15,696
OSSignpost end call will still


362
00:10:15,696 --> 00:10:16,866
be called when we exit the


363
00:10:16,866 --> 00:10:17,416
current scope.


364
00:10:18,696 --> 00:10:21,396
So second, for efficiency, avoid


365
00:10:21,396 --> 00:10:22,936
logging identical data in both


366
00:10:23,006 --> 00:10:25,146
the begin and end trace points


367
00:10:25,326 --> 00:10:26,566
and log it in the first point


368
00:10:26,566 --> 00:10:27,306
it's available.


369
00:10:27,956 --> 00:10:29,396
This avoids that duplicate work


370
00:10:29,766 --> 00:10:31,266
and it gives Instruments a value


371
00:10:31,266 --> 00:10:32,196
as soon as possible.


372
00:10:32,576 --> 00:10:34,196
In this example, we don't need


373
00:10:34,196 --> 00:10:37,376
to repeat the request number or


374
00:10:37,376 --> 00:10:40,236
raw size, and instead of using


375
00:10:40,236 --> 00:10:41,826
the request number to match up


376
00:10:41,826 --> 00:10:43,306
the intervals in case of


377
00:10:43,306 --> 00:10:45,436
overlap, these points could


378
00:10:45,436 --> 00:10:47,906
actually use and generate a


379
00:10:47,906 --> 00:10:49,966
unique Signpost ID for this log


380
00:10:49,966 --> 00:10:51,876
handle per interval pair.


381
00:10:53,126 --> 00:10:55,196
So third, avoid doing


382
00:10:55,196 --> 00:10:57,786
unnecessary work when signposts


383
00:10:57,826 --> 00:10:58,496
aren't enabled.


384
00:10:59,366 --> 00:11:00,696
If your log handle is configured


385
00:11:00,696 --> 00:11:01,746
to use one of the dynamic


386
00:11:01,746 --> 00:11:03,326
tracing categories, then the


387
00:11:03,366 --> 00:11:04,716
signposts enabled property will


388
00:11:04,716 --> 00:11:05,536
indicate whether or not


389
00:11:05,536 --> 00:11:06,536
Instruments is recording at the


390
00:11:06,536 --> 00:11:08,466
time, which means it's a great


391
00:11:08,466 --> 00:11:11,126
way to put your expensive data


392
00:11:11,206 --> 00:11:13,026
computation behind that


393
00:11:13,326 --> 00:11:15,666
OSSignpost-enabled check.


394
00:11:16,656 --> 00:11:19,506
Fourth, only trace data that you


395
00:11:19,506 --> 00:11:20,516
actually need for your tools.


396
00:11:21,436 --> 00:11:22,266
Think about your guard


397
00:11:22,266 --> 00:11:23,406
statements and preconditions,


398
00:11:23,966 --> 00:11:25,096
because sometimes you'll want to


399
00:11:25,096 --> 00:11:26,686
trace these to include the short


400
00:11:26,686 --> 00:11:26,996
intervals.


401
00:11:27,526 --> 00:11:28,936
For example, if you've got a


402
00:11:28,936 --> 00:11:30,466
method and you want to see the


403
00:11:30,466 --> 00:11:31,756
difference between a cash hit


404
00:11:31,756 --> 00:11:32,636
and a cash miss.


405
00:11:33,696 --> 00:11:34,766
But other times these early


406
00:11:34,766 --> 00:11:36,366
returns will be uninteresting.


407
00:11:36,926 --> 00:11:39,156
And for these cases, consider


408
00:11:39,156 --> 00:11:41,146
moving the signpost after the


409
00:11:41,146 --> 00:11:42,846
preconditions to reduce the


410
00:11:42,846 --> 00:11:44,976
amount of data you send to the


411
00:11:44,976 --> 00:11:45,756
signpost system.


412
00:11:46,896 --> 00:11:48,466
Now with all these tips, it's


413
00:11:48,466 --> 00:11:50,126
important to remember that trace


414
00:11:50,166 --> 00:11:51,866
points are really the basis for


415
00:11:51,866 --> 00:11:52,836
all of the tools that you build


416
00:11:52,836 --> 00:11:53,466
on top.


417
00:11:53,726 --> 00:11:54,856
And most of the time they'll be


418
00:11:54,916 --> 00:11:56,546
present in your production code.


419
00:11:56,546 --> 00:11:57,996
So that's why it's important to


420
00:11:57,996 --> 00:11:59,526
think about performance and


421
00:11:59,526 --> 00:12:00,706
maintainability of your trace


422
00:12:00,756 --> 00:12:01,106
points.


423
00:12:01,916 --> 00:12:03,246
And since they're at the core,


424
00:12:03,576 --> 00:12:05,076
changes to your signpost calls


425
00:12:05,076 --> 00:12:06,116
might result in needing to


426
00:12:06,116 --> 00:12:07,286
change the tools that you build


427
00:12:07,286 --> 00:12:07,756
on top.


428
00:12:08,386 --> 00:12:10,546
So to keep your trace points


429
00:12:10,546 --> 00:12:12,196
stable, avoid tracing


430
00:12:12,196 --> 00:12:14,126
implementation details and try


431
00:12:14,126 --> 00:12:15,576
to add your OSSignpost calls


432
00:12:16,166 --> 00:12:17,516
closer to the API layer when


433
00:12:17,516 --> 00:12:18,006
possible.


434
00:12:18,986 --> 00:12:20,066
Now moving your trace points


435
00:12:20,066 --> 00:12:21,216
around your code base isn't a


436
00:12:21,216 --> 00:12:21,706
problem.


437
00:12:21,706 --> 00:12:22,776
Now you don't need to worry


438
00:12:22,776 --> 00:12:24,206
about compiler optimizations


439
00:12:24,206 --> 00:12:25,376
like inlining that might move


440
00:12:25,376 --> 00:12:25,896
them for you.


441
00:12:26,886 --> 00:12:28,616
The things that you need to make


442
00:12:28,616 --> 00:12:31,496
sure don't change are the static


443
00:12:31,496 --> 00:12:34,606
strings, specifically I mean the


444
00:12:34,816 --> 00:12:37,216
subsystem, the category, the


445
00:12:37,216 --> 00:12:39,266
signpost name or the format


446
00:12:39,266 --> 00:12:39,546
string.


447
00:12:39,786 --> 00:12:41,096
If you change any of these,


448
00:12:41,186 --> 00:12:41,926
you'll need to remember to


449
00:12:41,926 --> 00:12:43,276
update your Instruments package


450
00:12:43,276 --> 00:12:43,536
as well.


451
00:12:44,596 --> 00:12:46,326
So with that, let's move on to


452
00:12:46,326 --> 00:12:48,266
talking about modeling and


453
00:12:48,266 --> 00:12:50,386
adding structure to your data


454
00:12:50,386 --> 00:12:50,976
within Instruments.


455
00:12:53,166 --> 00:12:54,416
Instruments' architecture is


456
00:12:54,466 --> 00:12:55,786
based on everything being stored


457
00:12:55,786 --> 00:12:56,336
in tables.


458
00:12:56,896 --> 00:12:57,986
And schemas define the


459
00:12:57,986 --> 00:12:59,506
structures of those tables, all


460
00:12:59,506 --> 00:13:00,236
of which are measured by


461
00:13:00,236 --> 00:13:01,106
Instruments instant analysis


462
00:13:01,106 --> 00:13:01,326
core.


463
00:13:01,916 --> 00:13:03,996
For more in-depth intro to


464
00:13:03,996 --> 00:13:05,466
Instruments architecture, I'd


465
00:13:05,506 --> 00:13:07,046
recommend the Creating Custom


466
00:13:07,046 --> 00:13:08,476
Instruments talk from 2018.


467
00:13:08,726 --> 00:13:09,816
For now though, let's look at


468
00:13:09,816 --> 00:13:11,276
where modeling fits into


469
00:13:11,276 --> 00:13:12,946
creating a profiling experience.


470
00:13:13,586 --> 00:13:15,846
On the left, we've covered


471
00:13:15,846 --> 00:13:17,076
OSSignpost which is one of the


472
00:13:17,076 --> 00:13:18,326
main data sources that


473
00:13:18,326 --> 00:13:19,316
Instruments records from.


474
00:13:20,076 --> 00:13:21,056
This data is filled in the


475
00:13:21,056 --> 00:13:22,626
tables with the pre-defined


476
00:13:22,626 --> 00:13:24,016
schema for use by your Custom


477
00:13:24,016 --> 00:13:24,486
Instruments.


478
00:13:26,156 --> 00:13:27,426
Modeling is that next phase in


479
00:13:27,426 --> 00:13:27,906
the middle.


480
00:13:28,006 --> 00:13:29,946
A modeler observes data from one


481
00:13:29,946 --> 00:13:31,956
or more input tables, reasons


482
00:13:31,956 --> 00:13:34,596
about it and then emits data to


483
00:13:34,596 --> 00:13:36,026
one or more output tables of


484
00:13:36,026 --> 00:13:36,926
your specification.


485
00:13:38,146 --> 00:13:38,986
The modeler is where your


486
00:13:38,986 --> 00:13:40,696
domain-specific logic resides,


487
00:13:41,196 --> 00:13:42,486
and the schemas of the output


488
00:13:42,486 --> 00:13:45,106
tables are yours to specify


489
00:13:45,106 --> 00:13:46,956
which types and formatters to


490
00:13:46,956 --> 00:13:47,626
apply to your data.


491
00:13:49,406 --> 00:13:50,626
The final step on the right is


492
00:13:50,626 --> 00:13:52,606
visualization which is described


493
00:13:52,606 --> 00:13:54,376
in XML to the standard UI in


494
00:13:54,376 --> 00:13:54,956
Instruments.


495
00:13:55,456 --> 00:13:56,886
It's where you specify how to


496
00:13:56,946 --> 00:13:58,116
graph and display the data in


497
00:13:58,116 --> 00:13:59,186
your modeler's output tables.


498
00:13:59,886 --> 00:14:01,156
Things like which columns to


499
00:14:01,156 --> 00:14:02,436
plot and uses the value.


500
00:14:02,436 --> 00:14:03,836
Or which columns to use for


501
00:14:03,836 --> 00:14:04,526
labels in color.


502
00:14:05,596 --> 00:14:06,716
Since all of the custom


503
00:14:06,716 --> 00:14:07,966
instrument's visualization is


504
00:14:08,046 --> 00:14:10,086
based on your schemas and your


505
00:14:10,086 --> 00:14:12,016
modelers' output, it's important


506
00:14:12,016 --> 00:14:13,606
to talk through that process of


507
00:14:13,606 --> 00:14:15,546
checking that your OSSignpost


508
00:14:15,546 --> 00:14:17,486
trace point are good, and then


509
00:14:17,656 --> 00:14:19,066
how to get this data into your


510
00:14:19,066 --> 00:14:19,886
custom-defined schema.


511
00:14:23,056 --> 00:14:24,216
So all data in a custom


512
00:14:24,216 --> 00:14:25,406
instrument must be stored in


513
00:14:25,406 --> 00:14:27,326
tables that handle data in one


514
00:14:27,326 --> 00:14:27,986
of two ways.


515
00:14:28,836 --> 00:14:30,266
Point schemas have a timestamp


516
00:14:30,266 --> 00:14:32,766
column, and interval schemas


517
00:14:32,866 --> 00:14:34,216
have both a timestamp and a


518
00:14:34,216 --> 00:14:34,866
duration column.


519
00:14:35,706 --> 00:14:37,246
This means you'll need to define


520
00:14:37,246 --> 00:14:38,666
at least one pointer interval


521
00:14:38,666 --> 00:14:40,396
schema and then give names and


522
00:14:40,396 --> 00:14:41,186
types to the rest of the


523
00:14:41,186 --> 00:14:41,566
columns.


524
00:14:42,766 --> 00:14:44,226
Now the data will be filled in


525
00:14:44,536 --> 00:14:46,766
by modeling rules that operate


526
00:14:46,766 --> 00:14:47,396
on the input data.


527
00:14:47,396 --> 00:14:49,006
And these rules are expressed in


528
00:14:49,006 --> 00:14:49,756
Eclipse language.


529
00:14:50,446 --> 00:14:51,306
The good news is that


530
00:14:51,516 --> 00:14:53,616
Instruments provides a few


531
00:14:53,616 --> 00:14:55,546
schemas that will auto-generate


532
00:14:55,546 --> 00:14:56,016
modelers.


533
00:14:56,486 --> 00:14:57,716
So you don't have to jump into


534
00:14:57,716 --> 00:14:58,946
writing Eclipse code until you


535
00:14:58,946 --> 00:14:59,276
want to.


536
00:15:00,616 --> 00:15:02,466
In fact, if you're just starting


537
00:15:02,466 --> 00:15:03,386
and you want to make sure that


538
00:15:03,386 --> 00:15:05,086
your data's correct, Instruments


539
00:15:05,086 --> 00:15:06,626
provides a built-in OSSignpost


540
00:15:06,626 --> 00:15:08,606
tool in the library that's great


541
00:15:08,606 --> 00:15:10,196
for recording and checking that


542
00:15:10,196 --> 00:15:12,046
your OSSignpost intervals look


543
00:15:12,146 --> 00:15:12,586
reasonable.


544
00:15:12,586 --> 00:15:14,316
And the inspector can help you


545
00:15:14,316 --> 00:15:15,526
verify that the raw data is


546
00:15:15,526 --> 00:15:16,656
exactly what you expect.


547
00:15:17,766 --> 00:15:19,136
Now once you've checked your


548
00:15:19,266 --> 00:15:21,096
data, a new instruments target


549
00:15:21,576 --> 00:15:22,616
is a great way to start for


550
00:15:22,616 --> 00:15:23,266
building your own tool.


551
00:15:23,266 --> 00:15:25,506
With Xcode's built-in XML


552
00:15:25,506 --> 00:15:27,506
snippets for custom instruments,


553
00:15:27,876 --> 00:15:29,776
you're only a few elements away


554
00:15:30,006 --> 00:15:31,336
from an automatic modeler and an


555
00:15:31,436 --> 00:15:32,586
instrument in the library.


556
00:15:32,586 --> 00:15:34,076
And the best way to see what


557
00:15:34,076 --> 00:15:35,466
this looks like is with a demo.


558
00:15:35,466 --> 00:15:37,406
And for that, I'd like to invite


559
00:15:37,586 --> 00:15:38,936
up Kasper.


560
00:15:39,516 --> 00:15:44,546
[ Applause ]


561
00:15:45,046 --> 00:15:45,546
>> Thank you, Daniel.


562
00:15:45,546 --> 00:15:46,326
And hello, everyone.


563
00:15:49,046 --> 00:15:50,366
Our Solar System application on


564
00:15:50,366 --> 00:15:51,816
the Mac is dealing with a large


565
00:15:51,816 --> 00:15:53,866
amount of data about planets,


566
00:15:54,366 --> 00:15:56,386
images, videos and binary data.


567
00:15:57,116 --> 00:15:58,916
In order to optimize this usage,


568
00:15:59,126 --> 00:16:00,626
I built a framework called solar


569
00:16:00,626 --> 00:16:02,206
compression that uses samples


570
00:16:02,206 --> 00:16:03,546
compression library to


571
00:16:03,546 --> 00:16:05,296
efficiently encode and decode


572
00:16:05,296 --> 00:16:06,126
data from the disk.


573
00:16:07,166 --> 00:16:08,246
Now I want to build


574
00:16:08,246 --> 00:16:09,616
instrumentation for my framework


575
00:16:09,896 --> 00:16:11,006
to provide insights to the


576
00:16:11,006 --> 00:16:11,816
future users.


577
00:16:13,046 --> 00:16:14,206
We have two concepts that are


578
00:16:14,206 --> 00:16:15,616
worth tracking and presenting


579
00:16:15,616 --> 00:16:16,146
visually.


580
00:16:16,626 --> 00:16:18,816
Firstly, CompressionManager is


581
00:16:18,816 --> 00:16:19,886
an object that coordinates


582
00:16:19,886 --> 00:16:20,816
compression tasks.


583
00:16:21,476 --> 00:16:22,596
It's created with a number of


584
00:16:22,646 --> 00:16:24,266
channels which specifies how


585
00:16:24,266 --> 00:16:25,816
many tasks can be executed


586
00:16:25,816 --> 00:16:26,396
concurrently.


587
00:16:27,606 --> 00:16:28,986
Secondly, I would like to


588
00:16:28,986 --> 00:16:30,436
measure how well compression did


589
00:16:30,436 --> 00:16:32,086
for specific file types and


590
00:16:32,086 --> 00:16:33,626
algorithms by capturing


591
00:16:33,626 --> 00:16:34,516
compression ratio.


592
00:16:35,296 --> 00:16:37,166
By examining this, users can


593
00:16:37,166 --> 00:16:38,356
decide whether it's worth it to


594
00:16:38,356 --> 00:16:39,156
compress their data.


595
00:16:39,156 --> 00:16:41,916
I wrote intervals that represent


596
00:16:41,916 --> 00:16:43,636
this concept of my framework in


597
00:16:43,636 --> 00:16:45,836
OSSignpost API, so let's jump to


598
00:16:45,836 --> 00:16:46,926
the CompressionManager Swift


599
00:16:46,926 --> 00:16:47,876
file to take a look.


600
00:16:49,216 --> 00:16:50,656
Firstly, let's take a look at


601
00:16:50,656 --> 00:16:51,306
the log handle.


602
00:16:51,776 --> 00:16:53,156
My log handle specifies my


603
00:16:53,156 --> 00:16:54,786
framework's bundle identifier as


604
00:16:54,786 --> 00:16:56,906
a subsystem and my class name as


605
00:16:56,906 --> 00:16:57,666
a category.


606
00:16:59,296 --> 00:17:01,356
Compress and decompress are part


607
00:17:01,356 --> 00:17:02,566
of the public interface of


608
00:17:02,566 --> 00:17:03,516
compression manager.


609
00:17:04,626 --> 00:17:05,965
They both start by creating


610
00:17:05,965 --> 00:17:07,536
compression work item instance


611
00:17:07,665 --> 00:17:08,976
which encapsulates information


612
00:17:08,976 --> 00:17:10,415
about certain compression tasks.


613
00:17:11,236 --> 00:17:12,816
Next, they call into private


614
00:17:12,816 --> 00:17:14,026
SubmitWorkItemMethod.


615
00:17:15,796 --> 00:17:17,156
Because compression channels can


616
00:17:17,156 --> 00:17:18,705
be busy with work, there might


617
00:17:18,705 --> 00:17:20,486
be significant time between


618
00:17:20,486 --> 00:17:22,185
compression item creation and


619
00:17:22,185 --> 00:17:23,215
execution on the channel.


620
00:17:23,836 --> 00:17:24,996
And this is the perfect place to


621
00:17:24,996 --> 00:17:26,175
start measuring this delay.


622
00:17:27,236 --> 00:17:28,376
We'll do it by calling our


623
00:17:28,376 --> 00:17:30,346
signpost of type begin with


624
00:17:30,346 --> 00:17:31,576
CompressionItemWait name.


625
00:17:33,026 --> 00:17:34,466
Next, we can see our guard


626
00:17:34,466 --> 00:17:36,136
condition here which ensures


627
00:17:36,136 --> 00:17:37,966
that source file exists before


628
00:17:37,966 --> 00:17:38,976
we proceed any further.


629
00:17:39,866 --> 00:17:41,066
Following Daniel's advice, I


630
00:17:41,066 --> 00:17:42,366
will move it to the top of the


631
00:17:42,366 --> 00:17:43,856
function to ensure that my


632
00:17:43,856 --> 00:17:45,246
intervals are always closed.


633
00:17:46,686 --> 00:17:47,926
Next, we have


634
00:17:48,016 --> 00:17:50,216
ExecuteWorkItemMethod which is


635
00:17:50,216 --> 00:17:51,866
called when the compression task


636
00:17:51,866 --> 00:17:53,136
is ready to be executed on the


637
00:17:53,136 --> 00:17:53,486
channel.


638
00:17:53,776 --> 00:17:56,486
At first we need to indicate end


639
00:17:56,486 --> 00:17:58,256
of the wait time for the item by


640
00:17:58,256 --> 00:17:59,846
calling our signpost of type end


641
00:18:00,286 --> 00:18:01,466
with the same name as before.


642
00:18:02,046 --> 00:18:04,726
Next, we indicate beginning of


643
00:18:04,726 --> 00:18:05,936
the compression with


644
00:18:05,936 --> 00:18:07,396
CompressionExecution signpost.


645
00:18:08,256 --> 00:18:09,606
In the metadata, we have such


646
00:18:09,606 --> 00:18:11,466
things like algorithm, the kind


647
00:18:11,466 --> 00:18:13,876
of operation, information about


648
00:18:13,876 --> 00:18:16,306
the source, destination, channel


649
00:18:16,306 --> 00:18:17,156
and calling thread.


650
00:18:18,346 --> 00:18:20,236
As we learned before, OSSignpost


651
00:18:20,236 --> 00:18:22,146
implicitly records several


652
00:18:22,146 --> 00:18:24,386
parameters including thread so


653
00:18:24,386 --> 00:18:25,616
you are safe to remove the


654
00:18:25,706 --> 00:18:25,966
thread now.


655
00:18:31,456 --> 00:18:33,216
Next, we create destination file


656
00:18:33,766 --> 00:18:36,266
and synchronously execute


657
00:18:36,316 --> 00:18:37,326
compression operation.


658
00:18:37,806 --> 00:18:39,846
After it's finished, we log it


659
00:18:39,846 --> 00:18:41,436
and attach destination file


660
00:18:41,436 --> 00:18:41,726
size.


661
00:18:42,616 --> 00:18:43,686
This is another place where I


662
00:18:43,686 --> 00:18:44,826
can improve on my signpost


663
00:18:44,826 --> 00:18:45,456
invocations.


664
00:18:46,026 --> 00:18:46,986
You can notice that


665
00:18:46,986 --> 00:18:48,606
StartCompressionMethod over here


666
00:18:48,806 --> 00:18:49,676
is a throwing one.


667
00:18:50,206 --> 00:18:51,706
And if it does throw an error,


668
00:18:52,126 --> 00:18:53,326
the signpost invocation here


669
00:18:53,326 --> 00:18:54,086
will not be called.


670
00:18:55,066 --> 00:18:56,196
To prevent this from happening,


671
00:18:56,466 --> 00:18:58,006
I can introduce the defer block


672
00:18:58,006 --> 00:19:02,146
over here and move my code to be


673
00:19:02,146 --> 00:19:04,146
sure that the intervals are


674
00:19:04,146 --> 00:19:04,786
always closed.


675
00:19:07,656 --> 00:19:09,676
Now let's see our signpost in


676
00:19:09,676 --> 00:19:11,446
Instruments by using Xcode's


677
00:19:11,506 --> 00:19:11,956
Profile action.


678
00:19:19,416 --> 00:19:20,276
Let's start with a blank


679
00:19:20,326 --> 00:19:23,396
template, add our signpost


680
00:19:23,396 --> 00:19:26,656
instrument to it and record for


681
00:19:26,786 --> 00:19:27,966
just a few seconds.


682
00:19:32,366 --> 00:19:33,576
We can now examine the data.


683
00:19:33,786 --> 00:19:35,876
I will expand our signpost


684
00:19:35,876 --> 00:19:37,256
instrument to see all of the


685
00:19:37,256 --> 00:19:38,306
recorded subsystems.


686
00:19:39,856 --> 00:19:41,646
Here's our Solar Compression


687
00:19:41,646 --> 00:19:41,866
one.


688
00:19:42,046 --> 00:19:44,166
I can extend it further to see


689
00:19:44,166 --> 00:19:45,816
my Compression Manager category.


690
00:19:47,056 --> 00:19:48,846
Now I can resize this track to


691
00:19:48,846 --> 00:19:50,406
fit all of the contained graphs


692
00:19:50,456 --> 00:19:51,466
by using Control-Z.


693
00:19:52,896 --> 00:19:54,346
Let's pinch to zoom to examine


694
00:19:54,346 --> 00:19:55,456
the data in more detail.


695
00:19:56,116 --> 00:19:58,826
On the top we have all of the


696
00:19:58,826 --> 00:20:00,556
Compression Execution signposts.


697
00:20:01,416 --> 00:20:02,656
And on the bottom we see all of


698
00:20:02,656 --> 00:20:03,926
the intervals for the waiting


699
00:20:03,926 --> 00:20:04,396
tasks.


700
00:20:04,956 --> 00:20:06,676
And we can notice some patterns


701
00:20:06,676 --> 00:20:07,136
over here.


702
00:20:08,466 --> 00:20:10,366
For example, at most two tasks


703
00:20:10,436 --> 00:20:11,726
are executing at once, so


704
00:20:12,386 --> 00:20:14,086
probably application code is


705
00:20:14,086 --> 00:20:15,436
using two compression channels.


706
00:20:16,886 --> 00:20:19,206
Also we can see some spikes over


707
00:20:19,286 --> 00:20:21,396
here that indicate that a lot of


708
00:20:21,396 --> 00:20:22,516
tasks are waiting to be


709
00:20:22,516 --> 00:20:22,946
compressed.


710
00:20:25,446 --> 00:20:27,656
OSSignpost is a great tool for


711
00:20:27,656 --> 00:20:29,276
analysis of your own signposts,


712
00:20:29,546 --> 00:20:30,656
but usually doesn't provide


713
00:20:30,656 --> 00:20:32,666
enough context for analyzing


714
00:20:32,666 --> 00:20:33,506
them by your framework's


715
00:20:33,506 --> 00:20:33,936
audience.


716
00:20:35,076 --> 00:20:36,926
To improve on this, I built


717
00:20:36,926 --> 00:20:39,756
Solar Compression instrument


718
00:20:39,976 --> 00:20:41,426
that uses custom instruments.


719
00:20:42,366 --> 00:20:43,916
But putting these two signposts


720
00:20:44,156 --> 00:20:45,986
into two separate tables and


721
00:20:45,986 --> 00:20:47,136
adjusting instrument-standard


722
00:20:47,186 --> 00:20:48,996
UI, I managed to improve on our


723
00:20:48,996 --> 00:20:49,776
visualization.


724
00:20:50,296 --> 00:20:51,536
Let's open trace document


725
00:20:51,656 --> 00:20:52,946
containing this instrument now.


726
00:20:59,046 --> 00:21:00,616
On the bottom line we see all of


727
00:21:00,616 --> 00:21:01,976
the waiting tasks which are


728
00:21:01,976 --> 00:21:03,276
represented similarly to the


729
00:21:03,276 --> 00:21:04,306
OSSignpost instrument.


730
00:21:07,316 --> 00:21:08,926
On the top we see all of the


731
00:21:08,926 --> 00:21:10,536
execution intervals now


732
00:21:10,536 --> 00:21:12,286
separated by a channel so we can


733
00:21:12,286 --> 00:21:13,616
indeed see that there are two


734
00:21:13,616 --> 00:21:14,566
channels available.


735
00:21:16,216 --> 00:21:17,956
On the bottom over here I see


736
00:21:17,956 --> 00:21:19,296
all of the compression tasks


737
00:21:19,536 --> 00:21:20,416
with information on the


738
00:21:20,416 --> 00:21:22,596
interval, source path, file


739
00:21:22,596 --> 00:21:24,326
sizes, compression ratio, et


740
00:21:24,326 --> 00:21:24,666
cetera.


741
00:21:25,806 --> 00:21:27,046
There's one task that brings my


742
00:21:27,046 --> 00:21:27,596
attention.


743
00:21:27,886 --> 00:21:29,326
It's pretty long and it's


744
00:21:29,376 --> 00:21:31,356
colored in red, which means that


745
00:21:31,356 --> 00:21:32,646
the compression for this ratio


746
00:21:32,646 --> 00:21:34,676
for this task was slow.


747
00:21:34,676 --> 00:21:35,786
To easily see what kind of task


748
00:21:35,786 --> 00:21:37,506
it is, I can switch to active


749
00:21:37,506 --> 00:21:40,336
tasks detail which is set up to


750
00:21:40,336 --> 00:21:41,896
only show intervals that are


751
00:21:41,896 --> 00:21:43,476
intersecting my inspection head.


752
00:21:43,476 --> 00:21:45,876
I can move my inspection head


753
00:21:45,876 --> 00:21:48,796
and analyze a task.


754
00:21:48,796 --> 00:21:50,076
It seems that we are trying to


755
00:21:50,076 --> 00:21:52,066
compress zip archive and the


756
00:21:52,066 --> 00:21:53,986
file size decreased by a bit


757
00:21:53,986 --> 00:21:54,976
over 1%.


758
00:21:55,606 --> 00:21:57,016
That doesn't seem much and maybe


759
00:21:57,016 --> 00:21:58,036
you shouldn't be compressing it


760
00:21:58,036 --> 00:21:58,326
at all.


761
00:22:00,546 --> 00:22:02,306
Next, let's see task summary


762
00:22:02,306 --> 00:22:03,726
detail which aggregates all of


763
00:22:03,726 --> 00:22:04,766
the compression tasks.


764
00:22:05,286 --> 00:22:06,906
It provides three aggregation


765
00:22:06,906 --> 00:22:09,426
levels: compression kind, source


766
00:22:09,426 --> 00:22:11,046
extension and algorithm.


767
00:22:12,286 --> 00:22:13,666
On the right we see different


768
00:22:13,666 --> 00:22:15,406
statistical information such as


769
00:22:15,496 --> 00:22:16,786
average compression ratio,


770
00:22:17,086 --> 00:22:19,586
duration or total saved space.


771
00:22:20,556 --> 00:22:22,406
This detail is very useful for


772
00:22:22,406 --> 00:22:23,516
comparing between different


773
00:22:23,516 --> 00:22:25,206
algorithms or looking at how


774
00:22:25,206 --> 00:22:27,026
compression ratio changes along


775
00:22:27,026 --> 00:22:27,786
with the file type.


776
00:22:28,736 --> 00:22:30,556
For example, we can see that our


777
00:22:30,556 --> 00:22:33,246
JPEG file size decreased by on


778
00:22:33,246 --> 00:22:35,986
average by 34% which seems


779
00:22:35,986 --> 00:22:37,026
pretty good for already


780
00:22:37,026 --> 00:22:38,066
heavily-compressed file.


781
00:22:38,066 --> 00:22:40,966
Now let's take a look at how it


782
00:22:40,966 --> 00:22:42,836
all looks in the Instrument


783
00:22:42,836 --> 00:22:43,376
Inspector.


784
00:22:47,236 --> 00:22:48,996
We have OSSignpost table over


785
00:22:48,996 --> 00:22:51,356
here which is a point schema.


786
00:22:51,946 --> 00:22:54,286
It looks at all of our begin and


787
00:22:54,286 --> 00:22:54,986
end events.


788
00:22:56,356 --> 00:22:58,166
We also have two tables for our


789
00:22:58,166 --> 00:22:59,506
signposts.


790
00:23:00,256 --> 00:23:02,156
Here is our execution table.


791
00:23:02,446 --> 00:23:03,966
It contains all of the data


792
00:23:03,966 --> 00:23:05,826
about tasks that we logged, but


793
00:23:05,826 --> 00:23:07,396
now it's formatted according to


794
00:23:07,396 --> 00:23:08,736
the engineering types that we


795
00:23:08,736 --> 00:23:09,126
assigned.


796
00:23:09,696 --> 00:23:13,296
On the right over here we can


797
00:23:13,296 --> 00:23:14,816
see that this table is directly


798
00:23:14,816 --> 00:23:15,866
consumed by the UI.


799
00:23:19,406 --> 00:23:20,406
I'm pretty happy about my


800
00:23:20,406 --> 00:23:21,306
instruments so far.


801
00:23:21,896 --> 00:23:22,976
One thing I would like to


802
00:23:22,976 --> 00:23:24,556
improve on is how the waiting


803
00:23:24,556 --> 00:23:25,746
tasks are represented.


804
00:23:26,516 --> 00:23:27,736
Instead of seeing specific


805
00:23:27,736 --> 00:23:29,166
intervals, I would like to have


806
00:23:29,286 --> 00:23:31,396
some way of summarizing them to


807
00:23:31,496 --> 00:23:32,946
clearly point out the areas of


808
00:23:33,036 --> 00:23:33,536
higher load.


809
00:23:34,396 --> 00:23:35,366
I think that Daniel might have


810
00:23:35,366 --> 00:23:36,746
some ideas on how to achieve it.


811
00:23:37,426 --> 00:23:37,796
Daniel?


812
00:23:41,516 --> 00:23:45,796
[ Applause ]


813
00:23:46,296 --> 00:23:46,946
>> Thanks, Kasper.


814
00:23:46,946 --> 00:23:48,996
As Kasper showed, the OSSignpost


815
00:23:48,996 --> 00:23:50,276
instrument in the library and


816
00:23:50,476 --> 00:23:52,316
the Inspector are great ways to


817
00:23:52,316 --> 00:23:54,006
visualize your raw data and to


818
00:23:54,006 --> 00:23:55,246
check that instrument sees the


819
00:23:55,246 --> 00:23:56,046
data you expect.


820
00:23:56,646 --> 00:23:58,496
And even without diving into


821
00:23:58,496 --> 00:23:59,496
writing a custom Eclipse


822
00:23:59,496 --> 00:24:01,066
modeler, Kasper was able to


823
00:24:01,116 --> 00:24:02,126
present an instrument that


824
00:24:02,126 --> 00:24:03,306
presented his data in a more


825
00:24:03,306 --> 00:24:04,896
meaningful way using his


826
00:24:04,976 --> 00:24:05,986
framework's compression


827
00:24:05,986 --> 00:24:06,646
concepts.


828
00:24:07,066 --> 00:24:08,586
There were just four trace


829
00:24:08,586 --> 00:24:10,686
points and two OSSignpost


830
00:24:10,686 --> 00:24:11,486
interval schemas.


831
00:24:12,336 --> 00:24:13,906
That said, it wasn't quite the


832
00:24:13,906 --> 00:24:15,476
profiling experience he wanted


833
00:24:15,476 --> 00:24:15,846
to create.


834
00:24:16,596 --> 00:24:18,396
Now custom modelers are a great


835
00:24:18,396 --> 00:24:19,736
way for tailoring that


836
00:24:19,736 --> 00:24:20,406
experience.


837
00:24:20,826 --> 00:24:22,406
They all you to fuse data for


838
00:24:22,406 --> 00:24:23,926
multiple log handles and even


839
00:24:23,926 --> 00:24:25,296
use data from built-in tables.


840
00:24:25,936 --> 00:24:27,236
They enable you to embed more


841
00:24:27,356 --> 00:24:29,326
complex logic, to maintain


842
00:24:29,326 --> 00:24:31,076
state, and the reason about the


843
00:24:31,076 --> 00:24:32,526
order of events.


844
00:24:32,886 --> 00:24:33,996
Writing your own custom modeler


845
00:24:33,996 --> 00:24:35,306
can also be useful for some of


846
00:24:35,306 --> 00:24:37,416
the more custom graphing and


847
00:24:37,506 --> 00:24:38,576
detailed use schemas.


848
00:24:39,206 --> 00:24:40,826
The point schema, interval


849
00:24:40,826 --> 00:24:42,456
schema and modeler tags are a


850
00:24:42,456 --> 00:24:44,086
great way to get started, but


851
00:24:44,086 --> 00:24:45,016
it's a deep subject we don't


852
00:24:45,016 --> 00:24:45,886
have time to cover in this


853
00:24:45,886 --> 00:24:46,206
session.


854
00:24:46,526 --> 00:24:48,046
For more on custom modeling


855
00:24:48,046 --> 00:24:50,046
though, the 2019 Modeling and


856
00:24:50,046 --> 00:24:51,606
Custom Instruments talk goes


857
00:24:51,606 --> 00:24:52,926
into a lot more depth and it


858
00:24:52,926 --> 00:24:53,826
comes with sample code.


859
00:24:54,666 --> 00:24:56,246
So let's move on to talking


860
00:24:56,246 --> 00:24:58,826
about the UI part of a profiling


861
00:24:58,826 --> 00:25:01,056
experience, visualization.


862
00:25:02,426 --> 00:25:03,736
Visualization is all about the


863
00:25:03,736 --> 00:25:06,106
chance for you as the author to


864
00:25:06,106 --> 00:25:07,076
tell your story to the


865
00:25:07,076 --> 00:25:08,076
developers who will use your


866
00:25:08,076 --> 00:25:08,336
code.


867
00:25:08,336 --> 00:25:10,386
And the most important principle


868
00:25:10,386 --> 00:25:12,896
to remember is that data is not


869
00:25:12,896 --> 00:25:14,286
the same thing as a story.


870
00:25:15,216 --> 00:25:17,326
Just as Kasper showed by looking


871
00:25:17,326 --> 00:25:18,726
at the built-in OSSignpost


872
00:25:18,726 --> 00:25:20,876
graphs, raw intervals are only


873
00:25:20,876 --> 00:25:21,866
good at conveying meaning to


874
00:25:21,866 --> 00:25:22,356
their author.


875
00:25:23,356 --> 00:25:25,106
Users of your tool aren't going


876
00:25:25,106 --> 00:25:26,616
to intuitively know whether a


877
00:25:26,616 --> 00:25:28,896
gap in the timeline is good or


878
00:25:28,896 --> 00:25:31,066
bad or what processing phase was


879
00:25:31,106 --> 00:25:32,126
supposed to come next but


880
00:25:32,126 --> 00:25:32,536
didn't.


881
00:25:33,606 --> 00:25:34,366
As the developer of an


882
00:25:34,366 --> 00:25:35,966
instruments package, you get to


883
00:25:35,966 --> 00:25:37,416
go beyond just building


884
00:25:37,416 --> 00:25:38,816
visualization showing what


885
00:25:38,816 --> 00:25:39,326
happened.


886
00:25:39,946 --> 00:25:41,406
You get to teach and diagnose.


887
00:25:41,926 --> 00:25:43,136
You get to help your users find


888
00:25:43,136 --> 00:25:44,186
problems even when you're not


889
00:25:44,186 --> 00:25:44,416
there.


890
00:25:45,756 --> 00:25:47,236
And visualization isn't just


891
00:25:47,236 --> 00:25:48,046
about the graph either.


892
00:25:48,546 --> 00:25:49,606
Sometimes the best way to


893
00:25:49,606 --> 00:25:51,466
communicate a problem is with a


894
00:25:51,466 --> 00:25:53,126
right set of statistical data or


895
00:25:53,126 --> 00:25:55,136
with a well-crafted textual


896
00:25:55,136 --> 00:25:56,676
narrative of exactly what went


897
00:25:56,676 --> 00:25:56,976
wrong.


898
00:25:58,256 --> 00:26:00,196
The reason that graphing is so


899
00:26:00,196 --> 00:26:01,876
important though is that most of


900
00:26:01,876 --> 00:26:02,826
the time it's the user's


901
00:26:02,826 --> 00:26:03,436
starting point.


902
00:26:03,816 --> 00:26:04,886
It's the first page to your


903
00:26:04,886 --> 00:26:05,516
story's book.


904
00:26:06,636 --> 00:26:08,216
Visualization should help others


905
00:26:08,216 --> 00:26:10,266
learn, understand and debug, and


906
00:26:10,266 --> 00:26:11,906
the selfish motivation is that


907
00:26:11,976 --> 00:26:13,656
good tools also speed up triage.


908
00:26:14,306 --> 00:26:15,006
That's the goal of


909
00:26:15,006 --> 00:26:16,836
visualization, making problems


910
00:26:16,836 --> 00:26:17,266
apparent.


911
00:26:17,986 --> 00:26:19,206
Graphs are the first summary


912
00:26:19,206 --> 00:26:20,476
that you'll see and they should


913
00:26:20,476 --> 00:26:21,546
draw your eyes to areas of


914
00:26:21,546 --> 00:26:22,036
importance.


915
00:26:22,646 --> 00:26:23,896
And once you've started digging


916
00:26:23,896 --> 00:26:25,406
in, that's where detail views


917
00:26:25,406 --> 00:26:27,206
and metrics should be centered


918
00:26:27,206 --> 00:26:28,736
around those core concepts in


919
00:26:28,736 --> 00:26:29,806
your code.


920
00:26:29,986 --> 00:26:31,456
Now since Instruments deals with


921
00:26:31,926 --> 00:26:33,086
two types of time-ordered data,


922
00:26:33,316 --> 00:26:34,756
points and intervals, I want to


923
00:26:34,756 --> 00:26:35,976
talk through ways of displaying


924
00:26:35,976 --> 00:26:36,886
both.


925
00:26:37,856 --> 00:26:40,106
To summarize .events, it helps


926
00:26:40,106 --> 00:26:41,566
to evaluate their importance.


927
00:26:42,076 --> 00:26:43,766
If they're all relatively equal,


928
00:26:44,006 --> 00:26:45,596
then a histogram is a really


929
00:26:45,596 --> 00:26:46,926
great way to show the density of


930
00:26:46,926 --> 00:26:48,156
events on a timeline.


931
00:26:48,726 --> 00:26:50,346
The taller bars immediately


932
00:26:50,346 --> 00:26:51,556
convey at a quick glance where


933
00:26:51,556 --> 00:26:52,936
to start and where to zoom in.


934
00:26:53,416 --> 00:26:54,656
And for custom instruments, the


935
00:26:54,656 --> 00:26:55,706
graphing behavior is easy to


936
00:26:55,706 --> 00:26:56,276
customize.


937
00:26:57,076 --> 00:26:58,466
The histogram element allows you


938
00:26:58,466 --> 00:26:59,716
to specify the width of each


939
00:26:59,716 --> 00:27:01,626
time bucket and there's a best


940
00:27:01,626 --> 00:27:03,286
for resolution element that lets


941
00:27:03,286 --> 00:27:04,306
you use a histogram when the


942
00:27:04,306 --> 00:27:06,406
user zooms out and then swap for


943
00:27:06,406 --> 00:27:08,286
a plot of the individual events


944
00:27:08,426 --> 00:27:10,826
when the user zooms in.


945
00:27:12,036 --> 00:27:14,236
Now, when .events vary in


946
00:27:14,266 --> 00:27:15,956
importance, it's sometimes


947
00:27:15,956 --> 00:27:17,346
helpful to dedicate a lane to


948
00:27:17,346 --> 00:27:18,896
the critical events.


949
00:27:19,946 --> 00:27:21,546
Multiple graphs and detail views


950
00:27:21,656 --> 00:27:22,986
can reference data from the same


951
00:27:22,986 --> 00:27:24,916
table, so specifying the top


952
00:27:24,916 --> 00:27:26,696
plot just means describing to


953
00:27:26,696 --> 00:27:28,226
Instruments how to slice and


954
00:27:28,226 --> 00:27:29,756
choose which values to display


955
00:27:29,756 --> 00:27:30,306
from the table.


956
00:27:30,736 --> 00:27:32,306
Now both of these can be


957
00:27:32,306 --> 00:27:34,066
accomplished purely in XML and


958
00:27:34,066 --> 00:27:35,006
without a custom modeler.


959
00:27:37,216 --> 00:27:38,786
Tabular summaries of either


960
00:27:38,826 --> 00:27:40,406
point or interval data are your


961
00:27:40,406 --> 00:27:41,756
opportunity to define what


962
00:27:41,756 --> 00:27:42,596
metrics are important.


963
00:27:43,486 --> 00:27:45,116
Within aggregation detail view,


964
00:27:45,266 --> 00:27:46,656
there are functions like Min,


965
00:27:46,656 --> 00:27:48,026
Max, Average and Standard


966
00:27:48,026 --> 00:27:50,016
Deviation for combining values.


967
00:27:50,746 --> 00:27:52,256
And new users will look to these


968
00:27:52,296 --> 00:27:54,456
summaries that you provide for


969
00:27:54,456 --> 00:27:56,366
guidance on what's important and


970
00:27:56,366 --> 00:27:57,246
what to optimize.


971
00:27:57,936 --> 00:27:59,696
So even display attributes like


972
00:28:00,246 --> 00:28:01,456
what the title of the columns


973
00:28:01,456 --> 00:28:03,026
are or what order they appear in


974
00:28:03,336 --> 00:28:03,876
really matter.


975
00:28:04,536 --> 00:28:07,356
Now when users dig further into


976
00:28:07,356 --> 00:28:08,856
the details, the narrative


977
00:28:08,856 --> 00:28:10,586
engineering type is a great way


978
00:28:10,766 --> 00:28:11,896
to explain what's going on.


979
00:28:12,576 --> 00:28:14,156
It allows you to use natural


980
00:28:14,156 --> 00:28:15,196
language and other type


981
00:28:15,256 --> 00:28:17,616
formatters to explain runtime


982
00:28:17,616 --> 00:28:18,536
behavior in a way that's


983
00:28:18,536 --> 00:28:19,076
approachable.


984
00:28:19,706 --> 00:28:21,806
These views are a great way to


985
00:28:21,806 --> 00:28:23,626
tell users what was expected to


986
00:28:23,626 --> 00:28:25,936
happen and didn't, or when


987
00:28:25,936 --> 00:28:27,116
something interesting happened


988
00:28:27,116 --> 00:28:27,876
that they might want to


989
00:28:27,876 --> 00:28:28,676
investigate further.


990
00:28:30,046 --> 00:28:31,976
So plotting interval data can be


991
00:28:31,976 --> 00:28:32,536
a bit trickier.


992
00:28:33,736 --> 00:28:35,816
Unlike points, intervals won't


993
00:28:35,816 --> 00:28:36,816
usually fit within a single


994
00:28:36,816 --> 00:28:37,936
vertical space because of


995
00:28:37,936 --> 00:28:38,336
overlap.


996
00:28:38,766 --> 00:28:41,566
If you can plan for a fixed or


997
00:28:41,566 --> 00:28:42,776
bounded number of overlapping


998
00:28:42,776 --> 00:28:44,306
intervals, there are two ways to


999
00:28:44,306 --> 00:28:46,176
split a lane into multiple


1000
00:28:46,176 --> 00:28:47,376
visual areas vertically.


1001
00:28:48,286 --> 00:28:49,996
Qualified plots are useful for


1002
00:28:49,996 --> 00:28:51,296
splitting lanes into multiple


1003
00:28:51,296 --> 00:28:52,496
spaces with a single title,


1004
00:28:53,236 --> 00:28:55,476
while instance plots are useful


1005
00:28:55,476 --> 00:28:56,686
for each getting their own


1006
00:28:56,686 --> 00:28:57,026
title.


1007
00:28:57,026 --> 00:29:00,056
Now the OSSignpost tool uses


1008
00:29:00,056 --> 00:29:00,916
both of these techniques


1009
00:29:00,916 --> 00:29:02,436
together, but it only works well


1010
00:29:02,436 --> 00:29:04,046
when there is a limited number


1011
00:29:04,046 --> 00:29:05,106
of overlapping intervals to


1012
00:29:05,106 --> 00:29:05,446
display.


1013
00:29:06,416 --> 00:29:07,226
When there are a lot,


1014
00:29:08,126 --> 00:29:09,986
hierarchies, new in Instruments


1015
00:29:09,986 --> 00:29:11,446
11, may be the way to go.


1016
00:29:12,456 --> 00:29:13,576
Separating trace data into


1017
00:29:13,576 --> 00:29:15,776
nested tracks makes it easier to


1018
00:29:15,866 --> 00:29:18,206
filter, to find and even pin


1019
00:29:18,206 --> 00:29:19,146
just what you're looking for,


1020
00:29:19,706 --> 00:29:20,776
especially when the number of


1021
00:29:20,776 --> 00:29:22,236
graphing contexts is large.


1022
00:29:23,176 --> 00:29:24,766
But whether or not you provide a


1023
00:29:24,766 --> 00:29:25,786
hierarchy of tracks, it's


1024
00:29:25,786 --> 00:29:26,906
important to plan for


1025
00:29:26,906 --> 00:29:28,256
summarizing your interval data


1026
00:29:28,846 --> 00:29:30,516
either at each level of your


1027
00:29:30,516 --> 00:29:32,386
hierarchy or as the primary


1028
00:29:32,386 --> 00:29:33,276
graph of your instrument.


1029
00:29:33,736 --> 00:29:36,986
For simple interval data, it


1030
00:29:36,986 --> 00:29:38,016
might be tempting to apply the


1031
00:29:38,016 --> 00:29:39,636
same solution as for points,


1032
00:29:40,086 --> 00:29:41,186
using a histogram element.


1033
00:29:42,386 --> 00:29:43,706
However, this only works well if


1034
00:29:43,706 --> 00:29:44,846
you have short intervals as the


1035
00:29:44,846 --> 00:29:46,876
histogram element aggregates by


1036
00:29:46,936 --> 00:29:48,106
start time.


1037
00:29:48,336 --> 00:29:49,846
With longer intervals, this can


1038
00:29:49,846 --> 00:29:52,276
cause a left-sided skew and it


1039
00:29:52,276 --> 00:29:53,346
produces very large values.


1040
00:29:54,836 --> 00:29:56,006
More importantly, when you graph


1041
00:29:56,056 --> 00:29:59,046
things that have duration, don't


1042
00:29:59,046 --> 00:30:01,006
graph time on the Y axis as it's


1043
00:30:01,406 --> 00:30:02,546
already the X axis.


1044
00:30:03,446 --> 00:30:05,206
Metrics like percent utilization


1045
00:30:05,206 --> 00:30:06,246
are better for displaying this


1046
00:30:06,296 --> 00:30:08,296
kind of data.


1047
00:30:08,756 --> 00:30:10,606
Now in more real-world usage,


1048
00:30:10,696 --> 00:30:11,866
intervals overlap a lot more,


1049
00:30:12,386 --> 00:30:13,646
and so I want to show three


1050
00:30:13,646 --> 00:30:16,136
examples of summary graphs and


1051
00:30:16,136 --> 00:30:17,806
how the represented concept in


1052
00:30:17,806 --> 00:30:18,826
your framework and usage


1053
00:30:18,826 --> 00:30:20,686
patterns that you want can


1054
00:30:20,686 --> 00:30:22,036
impact your table schemas and


1055
00:30:22,066 --> 00:30:23,376
held determine the presentation


1056
00:30:23,376 --> 00:30:23,676
style.


1057
00:30:25,126 --> 00:30:26,586
So for some scenarios,


1058
00:30:26,746 --> 00:30:28,566
persistent overlap indicates


1059
00:30:28,686 --> 00:30:29,966
high resource utilization.


1060
00:30:30,606 --> 00:30:31,816
And for this kind of data, a


1061
00:30:31,816 --> 00:30:33,326
quantized load average is a good


1062
00:30:33,326 --> 00:30:35,036
way to visualize it, even


1063
00:30:35,036 --> 00:30:36,216
coloring some extreme values.


1064
00:30:37,316 --> 00:30:39,026
Now Eclipse modelers and


1065
00:30:39,026 --> 00:30:39,736
Instruments are great at


1066
00:30:39,736 --> 00:30:40,836
maintaining state and fusing


1067
00:30:40,836 --> 00:30:42,396
data, so combining that


1068
00:30:42,396 --> 00:30:44,516
OSSignpost event stream with the


1069
00:30:44,516 --> 00:30:46,306
input from an internal timer


1070
00:30:46,306 --> 00:30:48,676
tag, a modeler can calculate and


1071
00:30:48,676 --> 00:30:50,346
emit a quantized utilization


1072
00:30:50,346 --> 00:30:51,666
average when a timer signal


1073
00:30:51,666 --> 00:30:51,966
arrives.


1074
00:30:52,486 --> 00:30:53,896
Now the output table of a


1075
00:30:53,896 --> 00:30:55,956
modeler might look like this,


1076
00:30:55,956 --> 00:30:57,166
expressing just four columns of


1077
00:30:57,166 --> 00:30:58,926
data to draw the plot that you


1078
00:30:58,926 --> 00:31:01,146
see, including a utilization


1079
00:31:01,146 --> 00:31:02,706
column for determining the


1080
00:31:02,706 --> 00:31:04,886
plot's value and a severity


1081
00:31:04,886 --> 00:31:06,106
column for determining color.


1082
00:31:06,656 --> 00:31:09,966
Now for other scenarios, lots of


1083
00:31:10,006 --> 00:31:10,996
quickly running intervals might


1084
00:31:11,026 --> 00:31:12,236
be more important because they


1085
00:31:12,236 --> 00:31:13,786
represent inefficient use of


1086
00:31:13,786 --> 00:31:14,286
your framework.


1087
00:31:15,316 --> 00:31:16,796
Looking at the same data as the


1088
00:31:16,796 --> 00:31:19,056
last example, a better graph


1089
00:31:19,116 --> 00:31:20,486
might be based on the modeler


1090
00:31:20,486 --> 00:31:21,956
counting the number of unique


1091
00:31:21,956 --> 00:31:23,656
intervals seen within a specific


1092
00:31:23,656 --> 00:31:24,236
time period.


1093
00:31:24,986 --> 00:31:26,796
Now the modeler's output table


1094
00:31:26,796 --> 00:31:27,806
would look very similar to the


1095
00:31:27,806 --> 00:31:30,616
last, but the user's eye is


1096
00:31:30,646 --> 00:31:32,156
immediately drawn to a very


1097
00:31:32,266 --> 00:31:33,516
different area of the timeline


1098
00:31:33,876 --> 00:31:34,906
which helps with zooming in and


1099
00:31:34,906 --> 00:31:36,066
investigating the cause of these


1100
00:31:36,066 --> 00:31:36,636
short intervals.


1101
00:31:37,246 --> 00:31:39,506
And both of the first two


1102
00:31:39,506 --> 00:31:41,576
examples summarize the data into


1103
00:31:41,576 --> 00:31:42,796
10-millisecond groups.


1104
00:31:43,006 --> 00:31:45,096
But what if the exact periods of


1105
00:31:45,096 --> 00:31:46,216
the overlap are important,


1106
00:31:46,456 --> 00:31:48,346
differentiating between one, two


1107
00:31:48,346 --> 00:31:50,356
or more concurrent intervals?


1108
00:31:51,396 --> 00:31:52,576
Well, instead of quantizing


1109
00:31:52,926 --> 00:31:55,186
based on time, a more helpful


1110
00:31:55,186 --> 00:31:58,166
graph might categorize these by


1111
00:31:58,166 --> 00:31:59,726
degree of overlap and show the


1112
00:31:59,726 --> 00:32:01,076
exact durations.


1113
00:32:02,956 --> 00:32:05,136
A modeler tracking just the


1114
00:32:05,136 --> 00:32:07,366
OSSignpost events could output


1115
00:32:07,366 --> 00:32:08,316
an additional table with a


1116
00:32:08,316 --> 00:32:09,226
custom interval schema.


1117
00:32:10,436 --> 00:32:12,486
And this time, the schema would


1118
00:32:12,486 --> 00:32:13,476
be filled in with a variable


1119
00:32:13,476 --> 00:32:14,906
duration and a description


1120
00:32:14,906 --> 00:32:16,016
column for use as a label.


1121
00:32:17,236 --> 00:32:18,946
So all three of these are just


1122
00:32:18,946 --> 00:32:20,926
examples but hopefully they help


1123
00:32:20,926 --> 00:32:22,506
to show that when it comes to


1124
00:32:22,506 --> 00:32:23,656
the presentation of your data,


1125
00:32:24,176 --> 00:32:25,626
the concepts matter when you're


1126
00:32:25,626 --> 00:32:26,626
designing a graphing schema.


1127
00:32:26,626 --> 00:32:29,096
Now for many cases an


1128
00:32:29,096 --> 00:32:30,546
automatically generated modeler


1129
00:32:30,766 --> 00:32:31,606
will give you the power and


1130
00:32:31,606 --> 00:32:33,116
flexibility you need to create


1131
00:32:33,116 --> 00:32:33,986
the right experience.


1132
00:32:34,706 --> 00:32:35,876
But there will definitely be


1133
00:32:35,876 --> 00:32:37,326
times when you want to have more


1134
00:32:37,326 --> 00:32:38,956
than one input or output.


1135
00:32:39,506 --> 00:32:40,826
And for those cases in some of


1136
00:32:40,826 --> 00:32:42,436
the example tables I've showed,


1137
00:32:42,966 --> 00:32:44,816
custom modelers can provide that


1138
00:32:44,816 --> 00:32:45,796
additional control and


1139
00:32:45,796 --> 00:32:47,466
flexibility to express their


1140
00:32:47,466 --> 00:32:50,006
concepts visually or textually,


1141
00:32:50,006 --> 00:32:51,886
enrich narratives and graphs and


1142
00:32:51,886 --> 00:32:52,206
details.


1143
00:32:53,066 --> 00:32:54,526
So now I'm excited to hand it


1144
00:32:54,526 --> 00:32:55,646
back to Kasper to see what


1145
00:32:55,646 --> 00:32:56,756
visualizations he's come up


1146
00:32:57,466 --> 00:32:57,886
with.


1147
00:32:58,516 --> 00:33:02,376
[ Applause ]


1148
00:33:02,876 --> 00:33:03,516
>> Thank you, Daniel.


1149
00:33:04,216 --> 00:33:06,226
I played around with custom


1150
00:33:06,226 --> 00:33:07,886
modelers and managed to improve


1151
00:33:07,886 --> 00:33:09,476
on our existing instrumentation.


1152
00:33:10,036 --> 00:33:10,656
Let's take a look.


1153
00:33:11,126 --> 00:33:12,876
I will start with the Solar


1154
00:33:12,876 --> 00:33:13,996
Conversion template that I


1155
00:33:13,996 --> 00:33:14,336
crafted.


1156
00:33:18,046 --> 00:33:19,836
It now includes a file system


1157
00:33:19,836 --> 00:33:21,526
activity instrument to provide


1158
00:33:21,526 --> 00:33:22,796
some additional information


1159
00:33:23,026 --> 00:33:24,586
about I/O operations overhead


1160
00:33:24,706 --> 00:33:26,106
when using compression library.


1161
00:33:27,296 --> 00:33:27,886
Let's record.


1162
00:33:30,046 --> 00:33:31,316
Now I'm recording in the


1163
00:33:31,316 --> 00:33:33,426
windowed mode to reduce the


1164
00:33:33,426 --> 00:33:34,836
overhead of the recording.


1165
00:33:36,276 --> 00:33:38,606
Instrument is transferring all


1166
00:33:38,606 --> 00:33:40,116
the data from the host and


1167
00:33:40,116 --> 00:33:40,936
running the modelers.


1168
00:33:46,056 --> 00:33:47,206
Let's examine the data now.


1169
00:33:47,846 --> 00:33:50,096
I can immediately see that


1170
00:33:50,096 --> 00:33:51,566
there's some correlation between


1171
00:33:51,566 --> 00:33:53,436
file system activity and my


1172
00:33:53,436 --> 00:33:54,896
execution signpost over here.


1173
00:33:55,536 --> 00:33:57,636
Let's focus on the longer zip


1174
00:33:57,636 --> 00:33:58,626
compression task that we


1175
00:33:58,626 --> 00:33:59,376
analyzed before.


1176
00:34:00,466 --> 00:34:01,826
It was good to have it colored


1177
00:34:01,826 --> 00:34:03,266
on the red to get the user's


1178
00:34:03,266 --> 00:34:03,756
attention.


1179
00:34:04,056 --> 00:34:05,446
But even better it would be to


1180
00:34:05,486 --> 00:34:06,736
provide some additional


1181
00:34:06,736 --> 00:34:08,656
information by using narratives.


1182
00:34:09,966 --> 00:34:11,726
I wrote modeler to detect low


1183
00:34:11,726 --> 00:34:13,735
compression ratio situations and


1184
00:34:13,735 --> 00:34:15,156
present some possible solutions.


1185
00:34:15,826 --> 00:34:18,156
Let's take a look at the


1186
00:34:18,156 --> 00:34:19,606
suggestions detail to take a


1187
00:34:19,606 --> 00:34:20,806
look at the output of this


1188
00:34:20,806 --> 00:34:21,505
modeler.


1189
00:34:25,295 --> 00:34:27,246
This modeler -- and we get one


1190
00:34:27,396 --> 00:34:27,966
suggestion.


1191
00:34:28,366 --> 00:34:30,356
It's saying that file size for


1192
00:34:30,656 --> 00:34:32,696
archive zip deceased by a bit


1193
00:34:32,696 --> 00:34:33,766
over 1%.


1194
00:34:34,386 --> 00:34:35,876
And compression may not be


1195
00:34:35,876 --> 00:34:37,036
necessary for this file.


1196
00:34:38,016 --> 00:34:39,716
It's also hinting that if speed


1197
00:34:39,716 --> 00:34:41,335
is not an issue, I should try


1198
00:34:41,335 --> 00:34:43,716
using LZMA algorithm which may


1199
00:34:43,716 --> 00:34:45,025
provide higher compression


1200
00:34:45,025 --> 00:34:45,466
ratio.


1201
00:34:46,306 --> 00:34:47,186
That seems useful.


1202
00:34:47,186 --> 00:34:49,005
I can now try to change the


1203
00:34:49,005 --> 00:34:50,775
algorithm, record again and


1204
00:34:50,775 --> 00:34:51,976
reevaluate the results.


1205
00:34:54,076 --> 00:34:55,136
Let's take a look at how the


1206
00:34:55,136 --> 00:34:56,376
waiting tasks are summarized.


1207
00:34:57,005 --> 00:34:58,996
I'm calculating average load of


1208
00:34:58,996 --> 00:34:59,886
the waiting tasks.


1209
00:35:00,536 --> 00:35:03,376
This way users can clearly point


1210
00:35:03,376 --> 00:35:04,776
out the areas of higher load.


1211
00:35:05,926 --> 00:35:07,406
Let's take a look at this area


1212
00:35:07,406 --> 00:35:08,786
which is colored in red.


1213
00:35:10,216 --> 00:35:12,136
It seems that a lot of tasks are


1214
00:35:12,136 --> 00:35:13,726
waiting on average, but as they


1215
00:35:13,726 --> 00:35:15,236
get executed on the channels


1216
00:35:15,236 --> 00:35:16,816
here, the number is going down.


1217
00:35:17,976 --> 00:35:19,816
Users can analyze areas like


1218
00:35:19,816 --> 00:35:21,906
that and if necessary increase


1219
00:35:21,906 --> 00:35:22,886
the number of compression


1220
00:35:22,886 --> 00:35:24,286
channels to achieve higher level


1221
00:35:24,286 --> 00:35:25,076
of concurrency.


1222
00:35:26,576 --> 00:35:28,256
Actually, this conclusion would


1223
00:35:28,256 --> 00:35:29,736
be a good candidate for another


1224
00:35:29,736 --> 00:35:31,106
suggestion in our detail.


1225
00:35:31,106 --> 00:35:34,136
Now let's take a look at how it


1226
00:35:34,136 --> 00:35:36,146
all plays out in Instrument


1227
00:35:36,146 --> 00:35:36,656
Inspector.


1228
00:35:37,776 --> 00:35:39,006
Let's search for our Solar


1229
00:35:39,006 --> 00:35:42,096
Compression execution table and


1230
00:35:42,186 --> 00:35:43,076
take a look at the binding


1231
00:35:43,076 --> 00:35:43,596
solution.


1232
00:35:46,076 --> 00:35:49,006
OSSignpost point schema data is


1233
00:35:49,066 --> 00:35:51,656
transferred by OSSignpost


1234
00:35:51,656 --> 00:35:53,616
auto-generated modeler into our


1235
00:35:53,616 --> 00:35:55,006
Solar Compression execution


1236
00:35:55,006 --> 00:35:55,416
table.


1237
00:35:56,056 --> 00:35:57,686
It's right here as we saw before


1238
00:35:57,686 --> 00:35:58,846
consumed by the UI.


1239
00:35:59,546 --> 00:36:01,056
We also have this new entity


1240
00:36:01,056 --> 00:36:02,176
over here which is our


1241
00:36:02,176 --> 00:36:03,136
suggestions modeler.


1242
00:36:03,596 --> 00:36:05,196
It's transferring intervals from


1243
00:36:05,196 --> 00:36:07,206
the compression execution table


1244
00:36:07,796 --> 00:36:10,336
into the suggestions in the


1245
00:36:10,336 --> 00:36:11,946
point schema which is later


1246
00:36:12,146 --> 00:36:15,516
driving the narrative detail.


1247
00:36:15,676 --> 00:36:17,476
Now I'm happy about how this


1248
00:36:17,476 --> 00:36:19,046
Instruments conveys the concepts


1249
00:36:19,046 --> 00:36:20,856
of my library and I feel that we


1250
00:36:20,856 --> 00:36:21,786
are ready to ship it to our


1251
00:36:21,786 --> 00:36:22,246
users.


1252
00:36:22,896 --> 00:36:23,886
Let's go back to the slides.


1253
00:36:28,516 --> 00:36:32,776
[ Applause ]


1254
00:36:33,276 --> 00:36:34,396
Creating great profiling


1255
00:36:34,396 --> 00:36:36,186
experience is about giving your


1256
00:36:36,186 --> 00:36:37,466
users a path to explore.


1257
00:36:38,426 --> 00:36:39,956
They should start with a useful


1258
00:36:39,956 --> 00:36:41,376
template which is set up to


1259
00:36:41,376 --> 00:36:42,726
provide necessary instruments


1260
00:36:42,726 --> 00:36:43,766
for looking at the issue.


1261
00:36:44,646 --> 00:36:46,216
Remember that if your code is


1262
00:36:46,216 --> 00:36:47,756
sensitive to information that is


1263
00:36:47,756 --> 00:36:49,406
exposed by other instrumentation


1264
00:36:49,756 --> 00:36:51,766
such as sampling, system tracing


1265
00:36:51,966 --> 00:36:53,986
or priority activity, you should


1266
00:36:53,986 --> 00:36:55,226
include this in your template.


1267
00:36:56,326 --> 00:36:57,696
When analyzing the recording,


1268
00:36:58,016 --> 00:36:59,436
top-level graphs should quickly


1269
00:36:59,436 --> 00:37:01,316
draw user attention to where the


1270
00:37:01,316 --> 00:37:02,556
problems might be in the


1271
00:37:02,556 --> 00:37:03,416
execution timeline.


1272
00:37:03,976 --> 00:37:05,916
And details should lead them to


1273
00:37:05,916 --> 00:37:07,126
the main cause of the issue,


1274
00:37:07,466 --> 00:37:08,636
often providing meaningful


1275
00:37:08,636 --> 00:37:09,076
hints.


1276
00:37:09,636 --> 00:37:12,016
To help you develop even better


1277
00:37:12,016 --> 00:37:13,806
profiling experience, this year


1278
00:37:13,806 --> 00:37:14,896
we've introduced two new


1279
00:37:14,896 --> 00:37:16,396
features in Instruments, the


1280
00:37:16,396 --> 00:37:17,686
first of which is the concept of


1281
00:37:17,686 --> 00:37:18,746
hierarchical tracks.


1282
00:37:19,666 --> 00:37:21,666
One example is OSSignpost


1283
00:37:21,666 --> 00:37:23,316
instrument visible here which


1284
00:37:23,316 --> 00:37:25,546
exposes underlying subsystem and


1285
00:37:25,546 --> 00:37:27,126
category name space through the


1286
00:37:27,196 --> 00:37:27,716
hierarchy.


1287
00:37:29,176 --> 00:37:31,056
Hierarchies are part of custom


1288
00:37:31,056 --> 00:37:32,616
instruments and any hierarchy


1289
00:37:32,616 --> 00:37:34,026
that you saw today can be


1290
00:37:34,026 --> 00:37:35,486
created by your own instrument.


1291
00:37:37,296 --> 00:37:38,856
We also have a new way of


1292
00:37:38,856 --> 00:37:40,056
customizing your profiling


1293
00:37:40,056 --> 00:37:41,846
workflow through creating custom


1294
00:37:41,846 --> 00:37:42,626
track scopes.


1295
00:37:43,996 --> 00:37:45,176
These allow you to take a look


1296
00:37:45,176 --> 00:37:46,536
at data gathered in your trace


1297
00:37:46,536 --> 00:37:47,826
document from different


1298
00:37:47,826 --> 00:37:49,596
perspectives by applying track


1299
00:37:49,596 --> 00:37:51,476
filters or choosing different


1300
00:37:51,476 --> 00:37:52,766
track branches for each scope.


1301
00:37:54,176 --> 00:37:55,756
If I'm only interested in seeing


1302
00:37:55,756 --> 00:37:57,496
system calls and signposts for


1303
00:37:57,496 --> 00:37:59,336
compression library, or


1304
00:37:59,336 --> 00:38:01,926
analyzing virtual memory impact


1305
00:38:01,926 --> 00:38:03,836
of the application, I can create


1306
00:38:03,836 --> 00:38:05,406
scopes that filter out other


1307
00:38:05,406 --> 00:38:07,166
tracks and keep coming back to


1308
00:38:07,166 --> 00:38:07,426
them.


1309
00:38:08,816 --> 00:38:10,476
Like here I can save them in my


1310
00:38:10,476 --> 00:38:12,296
template to share with my team


1311
00:38:12,516 --> 00:38:14,246
or instrument audience.


1312
00:38:15,616 --> 00:38:16,796
Tools in the form of


1313
00:38:16,846 --> 00:38:18,376
instrumentation are a way to


1314
00:38:18,376 --> 00:38:19,836
take experience of interacting


1315
00:38:19,836 --> 00:38:21,556
with your framework from good to


1316
00:38:21,556 --> 00:38:23,156
great and from unknown to


1317
00:38:23,156 --> 00:38:23,726
trusted.


1318
00:38:24,676 --> 00:38:26,036
They are your opportunity to


1319
00:38:26,096 --> 00:38:27,466
tell stories about concepts


1320
00:38:27,466 --> 00:38:28,576
existing in your framework.


1321
00:38:29,766 --> 00:38:31,466
They should educate people and


1322
00:38:31,466 --> 00:38:32,956
help catch easy mistakes.


1323
00:38:34,056 --> 00:38:35,746
Whenever clients get performance


1324
00:38:35,746 --> 00:38:37,566
debugging issues, they should


1325
00:38:37,566 --> 00:38:39,076
turn to tools to see the answer.


1326
00:38:39,426 --> 00:38:41,166
And this interaction will


1327
00:38:41,166 --> 00:38:42,676
increase their confidence and


1328
00:38:42,676 --> 00:38:43,646
trust in your library.


1329
00:38:44,306 --> 00:38:46,636
To learn more about Custom


1330
00:38:46,636 --> 00:38:48,016
Instruments, please visit


1331
00:38:48,016 --> 00:38:49,206
Instruments Developer Help.


1332
00:38:49,956 --> 00:38:51,106
We also recommend looking at


1333
00:38:51,106 --> 00:38:52,056
these other sessions.


1334
00:38:52,836 --> 00:38:54,086
Thank you and have a great rest


1335
00:38:54,086 --> 00:38:54,706
of the conference.


1336
00:38:55,516 --> 00:38:58,500
[ Applause ]

