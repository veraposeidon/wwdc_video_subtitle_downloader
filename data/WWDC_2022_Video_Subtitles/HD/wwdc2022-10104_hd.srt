2
00:00:00.267 --> 00:00:03.003 line:-1 position:50%
♪ instrumental hip hop music ♪


3
00:00:03,003 --> 00:00:10,077 size:2% align:right line:0
♪


4
00:00:10,077 --> 00:00:11,912 line:-1
Hi, my name is Jaideep Joshi,


5
00:00:11.912 --> 00:00:14.781 line:-1 position:50%
and I'm a GPU software engineer
at Apple.


6
00:00:14,781 --> 00:00:16,516 line:-1
In this session,
I will introduce


7
00:00:16,516 --> 00:00:19,253 line:-1
a new feature in Metal 3
that will simplify


8
00:00:19,253 --> 00:00:23,223 line:-1
and optimize resource loading
for your games and apps.


9
00:00:23,223 --> 00:00:24,458 line:-1
I'll start by showing you


10
00:00:24.458 --> 00:00:26.426 line:-1 position:50%
how the fast resource loading
feature


11
00:00:26,426 --> 00:00:30,230 line:-1
can fit into your app's
asset-loading pipeline.


12
00:00:30.230 --> 00:00:33.700 line:-1 position:50%
It has several key features that
harness new storage technologies


13
00:00:33,700 --> 00:00:36,236 line:-1
on Apple products.


14
00:00:36,236 --> 00:00:39,039 line:-1
Fast resource loading
has some advanced features


15
00:00:39.039 --> 00:00:43.343 line:-1 position:50%
that solve interesting scenarios
your applications may run into.


16
00:00:43,343 --> 00:00:45,646 line:-1
There are a few best practice
recommendations


17
00:00:45.646 --> 00:00:47.414 line:-1 position:50%
you should know about
that will help you


18
00:00:47.414 --> 00:00:52.319 line:-1 position:50%
effectively use
these features in your apps.


19
00:00:52.319 --> 00:00:55.022 line:-1 position:50%
As you add fast resource loading
to your apps,


20
00:00:55,022 --> 00:00:58,392 line:-1
tools like Metal System Trace
and the GPU debugger


21
00:00:58,392 --> 00:01:02,896 line:-1
can help profile and fix
issues you may run into.


22
00:01:02,896 --> 00:01:05,232 line:-1
At the end, I'll walk through
an example


23
00:01:05,232 --> 00:01:09,636 line:-1
that shows fast resource loading
in action.


24
00:01:09.636 --> 00:01:13.173 line:-1 position:50%
So here's what you can do with
Metal 3's fast resource loading.


25
00:01:15.175 --> 00:01:17.277 line:-1 position:50%
With Metal 3's
fast resource loading,


26
00:01:17.277 --> 00:01:20.547 line:-1 position:50%
your games and apps
can load assets with low latency


27
00:01:20,547 --> 00:01:23,050 line:-1
and high throughput
by taking advantage


28
00:01:23,050 --> 00:01:25,652 line:-1
of the Apple silicon
unified memory architecture


29
00:01:25,652 --> 00:01:30,357 line:-1
and fast SSD storage
included with Apple platforms.


30
00:01:30.357 --> 00:01:31.658 line:-1 position:50%
You will learn the best ways


31
00:01:31,658 --> 00:01:34,094 line:-1
to stream data
and reduce load times


32
00:01:34.094 --> 00:01:38.598 line:-1 position:50%
to ensure that your game's
assets are ready on time.


33
00:01:38,598 --> 00:01:41,001 line:-1
A key aspect
of reducing load times


34
00:01:41,001 --> 00:01:42,903 line:-1
is to load only what you need


35
00:01:42,903 --> 00:01:45,973 line:-1
at the smallest
possible granularity.


36
00:01:45,973 --> 00:01:49,142 line:-1
The high throughput
and low latency in Metal 3


37
00:01:49.142 --> 00:01:52.012 line:-1 position:50%
lets your apps stream
higher-quality assets,


38
00:01:52,012 --> 00:01:56,283 line:-1
including textures, audio,
and geometry data.


39
00:01:56,283 --> 00:01:59,219 line:-1
Now I'll walk you through
an example of asset loading


40
00:01:59,219 --> 00:02:01,621 line:-1
in a game.


41
00:02:01.621 --> 00:02:03.623 line:-1 position:50%
Games typically show
a loading screen


42
00:02:03,623 --> 00:02:07,361 line:-1
when they first start up, or
at the beginning of a new level,


43
00:02:07,361 --> 00:02:10,931 line:-1
so they can load
the game's assets into memory.


44
00:02:10,931 --> 00:02:12,866 line:-1
As the player moves
through the level,


45
00:02:12.866 --> 00:02:16.436 line:-1 position:50%
the game loads
more assets for the scene.


46
00:02:16.436 --> 00:02:19.940 line:-1 position:50%
The downside is the player
has to wait a long time


47
00:02:19,940 --> 00:02:21,842 line:-1
while the game makes
multiple requests


48
00:02:21,842 --> 00:02:25,846 line:-1
to the storage system
to load assets up front.


49
00:02:25,846 --> 00:02:29,850 line:-1
Plus, those assets can have
a large memory footprint.


50
00:02:29.850 --> 00:02:34.221 line:-1 position:50%
There are a few ways
to improve this experience.


51
00:02:34.221 --> 00:02:35.822 line:-1 position:50%
Games can improve
this experience


52
00:02:35,822 --> 00:02:37,691 line:-1
by dynamically streaming objects


53
00:02:37,691 --> 00:02:40,427 line:-1
as the player
gets closer to them.


54
00:02:40,427 --> 00:02:44,131 line:-1
This way, the game only loads
what it needs at first


55
00:02:44.131 --> 00:02:46.366 line:-1 position:50%
and gradually streams
other resources


56
00:02:46.366 --> 00:02:49.369 line:-1 position:50%
as the player moves
through the level.


57
00:02:49.369 --> 00:02:53.340 line:-1 position:50%
For example, the game
initially loads this chalkboard


58
00:02:53.340 --> 00:02:56.710 line:-1 position:50%
at a lower resolution, but as
the player walks towards it,


59
00:02:56.710 --> 00:03:00.313 line:-1 position:50%
the game loads
a higher-resolution version.


60
00:03:00.313 --> 00:03:03.050 line:-1 position:50%
This approach reduces
the time the player waits


61
00:03:03,050 --> 00:03:05,218 line:-1
at the loading screen.


62
00:03:05.218 --> 00:03:08.922 line:-1 position:50%
However, the player might
still see lower-resolution items


63
00:03:08,922 --> 00:03:11,758 line:-1
in the scene even
when they are up close,


64
00:03:11.758 --> 00:03:13.760 line:-1 position:50%
because it takes too long
to load


65
00:03:13,760 --> 00:03:16,797 line:-1
the higher-resolution versions.


66
00:03:16,797 --> 00:03:19,900 line:-1
One way to deal with this
is to stream smaller portions


67
00:03:19.900 --> 00:03:23.270 line:-1 position:50%
of each asset.


68
00:03:23,270 --> 00:03:26,206 line:-1
For example, your game could
load only the visible regions


69
00:03:26.206 --> 00:03:29.876 line:-1 position:50%
of the scene with sparse
textures that stream tiles


70
00:03:29.876 --> 00:03:32.279 line:-1 position:50%
instead of whole mip levels.


71
00:03:32,279 --> 00:03:34,781 line:-1
This vastly reduces
the amount of data


72
00:03:34,781 --> 00:03:37,317 line:-1
your app needs to stream.


73
00:03:37.317 --> 00:03:40.053 line:-1 position:50%
With that approach,
the load requests get smaller,


74
00:03:40,053 --> 00:03:41,955 line:-1
and there are more of them.


75
00:03:41,955 --> 00:03:44,891 line:-1
But that's OK,
because modern storage hardware


76
00:03:44,891 --> 00:03:48,528 line:-1
can run multiple
load requests at once.


77
00:03:48,528 --> 00:03:50,730 line:-1
This means that you can
increase the resolution


78
00:03:50.730 --> 00:03:55.202 line:-1 position:50%
and scale of your scene without
compromising the gameplay.


79
00:03:55.202 --> 00:03:58.405 line:-1 position:50%
Along with issuing a large
number of small-load requests,


80
00:03:58.405 --> 00:04:02.075 line:-1 position:50%
you also have the ability to
prioritize your load requests,


81
00:04:02,075 --> 00:04:06,379 line:-1
to ensure that high-priority
requests finish in time.


82
00:04:06.379 --> 00:04:07.948 line:-1 position:50%
Now that I have covered the ways


83
00:04:07,948 --> 00:04:11,952 line:-1
to boost visual fidelity of
games while reducing load times,


84
00:04:11,952 --> 00:04:15,021 line:-1
I'll show you how Metal 3's
fast resource loading


85
00:04:15,021 --> 00:04:16,523 line:-1
helps you do this.


86
00:04:16.523 --> 00:04:19.659 line:-1 position:50%
Fast resource loading
is an asynchronous API


87
00:04:19,659 --> 00:04:22,295 line:-1
that loads resources
from storage.


88
00:04:22,295 --> 00:04:26,166 line:-1
Unlike existing load APIs, the
thread which issues the loads


89
00:04:26,166 --> 00:04:29,503 line:-1
does not need to wait
for the loads to finish.


90
00:04:29,503 --> 00:04:32,239 line:-1
The load operations
execute concurrently


91
00:04:32,239 --> 00:04:36,309 line:-1
to better utilize the throughput
of faster storage.


92
00:04:36.309 --> 00:04:38.278 line:-1 position:50%
You can batch load operations


93
00:04:38.278 --> 00:04:42.048 line:-1 position:50%
to further minimize the overhead
of resource loading.


94
00:04:42.048 --> 00:04:43.984 line:-1 position:50%
And finally, with Metal 3,


95
00:04:43,984 --> 00:04:48,622 line:-1
you can prioritize load
operations for lower latency.


96
00:04:48.622 --> 00:04:50.524 line:-1 position:50%
Now I'll show you
the key features


97
00:04:50,524 --> 00:04:53,160 line:-1
that will help you build
your asset-loading pipeline,


98
00:04:53.160 --> 00:04:56.429 line:-1 position:50%
starting with the steps
to load resources.


99
00:04:56,429 --> 00:04:59,099 line:-1
There are three steps
to load resources:


100
00:04:59.099 --> 00:05:00.500 line:-1 position:50%
open a file,


101
00:05:00,500 --> 00:05:02,936 line:-1
issue the necessary
load commands,


102
00:05:02.936 --> 00:05:07.040 line:-1 position:50%
and then synchronize these load
commands with rendering work.


103
00:05:07.040 --> 00:05:10.911 line:-1 position:50%
Here's how you do that,
starting with opening a file.


104
00:05:10.911 --> 00:05:14.414 line:-1 position:50%
You open an existing file
by creating a file handle


105
00:05:14,414 --> 00:05:16,816 line:-1
with a Metal device instance.


106
00:05:16,816 --> 00:05:20,420 line:-1
For example, this code uses
the Metal device instance


107
00:05:20.420 --> 00:05:21.821 line:-1 position:50%
to create a file handle


108
00:05:21.821 --> 00:05:28.562 line:-1 position:50%
by calling its new makeIOHandle
method with a file path URL.


109
00:05:28,562 --> 00:05:30,297 line:-1
Once you have a file handle,


110
00:05:30.297 --> 00:05:33.934 line:-1 position:50%
you can use it
to issue load commands.


111
00:05:33,934 --> 00:05:36,469 line:-1
Here's a typical scenario
in an application,


112
00:05:36,469 --> 00:05:40,273 line:-1
where it performs load
operations and encodes GPU work.


113
00:05:40.273 --> 00:05:43.577 line:-1 position:50%
With existing load APIs, the app
has to wait for the loading work


114
00:05:43.577 --> 00:05:46.680 line:-1 position:50%
to finish before it can encode
the rendering work.


115
00:05:46,680 --> 00:05:48,381 line:-1
Metal 3 lets your app


116
00:05:48,381 --> 00:05:51,851 line:-1
asynchronously
execute load commands.


117
00:05:51.851 --> 00:05:55.255 line:-1 position:50%
Start by creating
a Metal IO command queue.


118
00:05:55,255 --> 00:05:58,792 line:-1
Then use that queue
to create IO command buffers


119
00:05:58,792 --> 00:06:02,529 line:-1
and encode load commands
to those buffers.


120
00:06:02.529 --> 00:06:05.799 line:-1 position:50%
However, as command buffers
execute asynchronously


121
00:06:05.799 --> 00:06:09.002 line:-1 position:50%
on the command queue,
your app does not need to wait


122
00:06:09.002 --> 00:06:12.205 line:-1 position:50%
for the load operations
to finish.


123
00:06:12,205 --> 00:06:14,174 line:-1
In fact, not only do
all commands


124
00:06:14,174 --> 00:06:17,010 line:-1
within an IO command buffer
execute concurrently,


125
00:06:17,010 --> 00:06:20,180 line:-1
IO command buffers themselves
execute concurrently


126
00:06:20,180 --> 00:06:22,616 line:-1
and complete out of order.


127
00:06:22,616 --> 00:06:26,086 line:-1
This concurrent execution model
better utilizes


128
00:06:26,086 --> 00:06:30,323 line:-1
faster-storage hardware
by maximizing throughput.


129
00:06:30,323 --> 00:06:35,195 position:50%
You can encode three types of
IO commands to a command buffer:


130
00:06:35,195 --> 00:06:37,831 line:0
loadTexture, which loads
to a Metal texture


131
00:06:37,831 --> 00:06:39,432 line:0
for texture streaming;


132
00:06:39,432 --> 00:06:41,835 line:0
loadBuffer, which loads
to a Metal buffer


133
00:06:41,835 --> 00:06:44,371 line:0
for streaming scene
or geometry data;


134
00:06:44,371 --> 00:06:49,476 line:0
and loadBytes, which loads
to CPU-accessible memory.


135
00:06:49,476 --> 00:06:53,513 line:-1
You create IO command buffers
from an IO command queue.


136
00:06:53.513 --> 00:06:56.516 line:-1 position:50%
To create a queue,
first make and configure


137
00:06:56.516 --> 00:06:59.419 line:-1 position:50%
an IO command
queue descriptor.


138
00:06:59,419 --> 00:07:02,389 line:-1
By default, the queues
are concurrent,


139
00:07:02,389 --> 00:07:04,791 line:-1
but you can also set them
to run command buffers


140
00:07:04,791 --> 00:07:08,161 line:-1
sequentially and completely
in order.


141
00:07:08,161 --> 00:07:10,163 line:-1
Then pass the queue descriptor


142
00:07:10,163 --> 00:07:16,369 line:-1
to the Metal device instance's
makeIOCommandQueue method.


143
00:07:16,369 --> 00:07:18,171 line:-1
Create an IO command buffer


144
00:07:18.171 --> 00:07:22.842 line:-1 position:50%
by calling the command queue's
makeCommandBuffer method.


145
00:07:22,842 --> 00:07:26,446 line:-1
Then use that command buffer
to encode load commands


146
00:07:26,446 --> 00:07:29,115 line:-1
that load textures and buffers.


147
00:07:29,115 --> 00:07:32,085 line:-1
Metal's validation layer
will catch encoding errors


148
00:07:32.085 --> 00:07:33.553 line:-1 position:50%
at runtime.


149
00:07:33.553 --> 00:07:36.823 line:-1 position:50%
The load commands are what use
the fileHandle instance


150
00:07:36,823 --> 00:07:39,392 line:-1
created earlier.


151
00:07:39.392 --> 00:07:42.362 line:-1 position:50%
When you are done adding load
commands to a command buffer,


152
00:07:42.362 --> 00:07:44.664 line:-1 position:50%
submit it to the queue
for execution


153
00:07:44,664 --> 00:07:49,202 line:-1
by calling the command buffer's
commit method.


154
00:07:49,202 --> 00:07:52,138 line:-1
Now that I've covered how
to create IO command queues,


155
00:07:52,138 --> 00:07:54,341 line:-1
command buffers,
issue load commands,


156
00:07:54.341 --> 00:07:57.143 line:-1 position:50%
and submit them to the queue,
I want to show you


157
00:07:57.143 --> 00:08:01.915 line:-1 position:50%
how you can synchronize loading
work with the other GPU work.


158
00:08:01,915 --> 00:08:04,517 line:-1
An app typically kicks off
its rendering work


159
00:08:04.517 --> 00:08:08.488 line:-1 position:50%
after it finishes loading
resources for that rendering.


160
00:08:08,488 --> 00:08:11,358 line:-1
But an app that uses
fast resource loading


161
00:08:11,358 --> 00:08:14,294 line:-1
needs a way to synchronize
the IO command queue


162
00:08:14.294 --> 00:08:17.197 line:-1 position:50%
with the render command queue.


163
00:08:17,197 --> 00:08:21,301 line:-1
You can synchronize these queues
with a Metal shared event.


164
00:08:21,301 --> 00:08:24,571 line:-1
Metal hared events let you
synchronize the command buffers


165
00:08:24.571 --> 00:08:27.140 line:-1 position:50%
from your IO queue
with the command buffers


166
00:08:27,140 --> 00:08:30,110 line:-1
from your rendering queue.


167
00:08:30,110 --> 00:08:33,046 line:0
You can tell a command buffer
to wait for a shared event


168
00:08:33,046 --> 00:08:35,782 line:0
by encoding a waitEvent command.


169
00:08:35,782 --> 00:08:38,284 line:0
Similarly, you can tell
that command buffer


170
00:08:38,284 --> 00:08:42,455 line:0
to signal a shared event by
encoding a signalEvent command.


171
00:08:42,455 --> 00:08:44,791 line:0
Metal ensures
that all IO commands


172
00:08:44,791 --> 00:08:46,926 position:50%
within the command buffer
are complete


173
00:08:46,926 --> 00:08:50,130 line:0
before it signals
the shared event.


174
00:08:50.130 --> 00:08:52.098 line:-1 position:50%
To synchronize
between command buffers,


175
00:08:52,098 --> 00:08:55,001 line:-1
you first need
a Metal shared event.


176
00:08:55.001 --> 00:08:57.837 line:-1 position:50%
You can tell a command buffer
to wait for a shared event


177
00:08:57,837 --> 00:09:01,174 line:-1
by calling
its waitForEvent method.


178
00:09:01.174 --> 00:09:03.309 line:-1 position:50%
Similarly, you can tell
a command buffer


179
00:09:03.309 --> 00:09:04.611 line:-1 position:50%
to signal a shared event


180
00:09:04,611 --> 00:09:07,680 line:-1
by calling
its signalEvent method.


181
00:09:07.680 --> 00:09:08.948 line:-1 position:50%
You can add similar logic


182
00:09:08,948 --> 00:09:11,017 line:-1
to a corresponding
GPU command buffer


183
00:09:11,017 --> 00:09:13,219 line:-1
so that it waits for
the IO command buffer


184
00:09:13,219 --> 00:09:15,488 line:-1
to signal the same shared event.


185
00:09:15,488 --> 00:09:18,291 line:-1
To recap, here are
the key features and APIs


186
00:09:18.291 --> 00:09:21.761 line:-1 position:50%
that load resources
in your Metal apps.


187
00:09:21,761 --> 00:09:25,365 line:-1
Open a file by creating
a Metal file handle.


188
00:09:25.365 --> 00:09:28.668 line:-1 position:50%
Issue load commands by creating
an IO command queue


189
00:09:28.668 --> 00:09:30.870 line:-1 position:50%
and an IO command buffer.


190
00:09:30,870 --> 00:09:33,606 line:-1
Then, encode load commands
to the command buffer


191
00:09:33,606 --> 00:09:36,109 line:-1
for execution on the queue.


192
00:09:36,109 --> 00:09:38,912 line:0
And finally, use wait
and signalEvent commands


193
00:09:38,912 --> 00:09:41,648 line:0
with Metal shared events
to synchronize loading


194
00:09:41,648 --> 00:09:43,983 position:50%
and rendering.


195
00:09:43.983 --> 00:09:46.219 line:-1 position:50%
Now, I'll go over
a few advanced features


196
00:09:46,219 --> 00:09:48,688 line:-1
that you might find helpful.


197
00:09:48,688 --> 00:09:50,089 line:-1
Here's a typical scenario


198
00:09:50,089 --> 00:09:53,393 line:-1
where a game can't fit
its entire map in memory,


199
00:09:53,393 --> 00:09:56,296 line:-1
which is why it subdivides
the map into regions.


200
00:09:56,296 --> 00:09:58,431 line:-1
As the player progresses
through the map,


201
00:09:58.431 --> 00:10:02.535 line:-1 position:50%
the game starts preloading
regions of the map.


202
00:10:02.535 --> 00:10:05.171 line:-1 position:50%
Based on the player's direction,
the game determines


203
00:10:05,171 --> 00:10:07,974 line:-1
that the best regions to preload
are the northwest,


204
00:10:07.974 --> 00:10:10.276 line:-1 position:50%
west, and southwest regions.


205
00:10:10,276 --> 00:10:13,112 line:-1
However, once the player
moves to the western region


206
00:10:13.112 --> 00:10:14.814 line:-1 position:50%
and starts heading south,


207
00:10:14.814 --> 00:10:18.751 line:-1 position:50%
preloading the northwestern
region is no longer beneficial.


208
00:10:18,751 --> 00:10:21,120 line:-1
To reduce the latency
of future loads,


209
00:10:21.120 --> 00:10:25.859 line:-1 position:50%
Metal 3 allows you to attempt
to cancel load operation.


210
00:10:25,859 --> 00:10:29,696 line:-1
Let's look at how to do that
in practice.


211
00:10:29,696 --> 00:10:31,764 line:-1
When the player is
in the center region,


212
00:10:31.764 --> 00:10:36.035 line:-1 position:50%
encode and commit IO command
buffers for three regions.


213
00:10:36,035 --> 00:10:38,104 line:-1
Then when the player
is in the western region


214
00:10:38,104 --> 00:10:41,207 line:-1
and heading south,
use the tryCancel method


215
00:10:41.207 --> 00:10:44.811 line:-1 position:50%
to cancel the loads
for the northwestern region.


216
00:10:44,811 --> 00:10:48,214 line:-1
Cancelling is at
the command buffer granularity,


217
00:10:48,214 --> 00:10:51,851 line:-1
so you can cancel the
command buffer mid-execution.


218
00:10:51,851 --> 00:10:53,987 line:-1
If at some later point,
you want to know


219
00:10:53,987 --> 00:10:56,389 line:-1
whether the region
was completely loaded,


220
00:10:56,389 --> 00:11:00,927 line:-1
you can check the status
of the command buffer.


221
00:11:00.927 --> 00:11:05.665 line:-1 position:50%
Metal 3 also lets you
prioritize your IO work.


222
00:11:05,665 --> 00:11:08,501 line:-1
Consider a game scenario
where the player teleports


223
00:11:08.501 --> 00:11:12.138 line:-1 position:50%
to a new part of the scene and
your game starts streaming in


224
00:11:12,138 --> 00:11:14,641 line:-1
large amounts
of graphics assets.


225
00:11:14,641 --> 00:11:16,009 line:-1
At the same time,


226
00:11:16,009 --> 00:11:19,546 line:-1
the game needs to play
the teleportation sound effect.


227
00:11:19.546 --> 00:11:23.182 line:-1 position:50%
Fast resource loading allows you
to load all your app's assets,


228
00:11:23,182 --> 00:11:25,518 line:-1
including audio data.


229
00:11:25,518 --> 00:11:28,221 line:-1
To load audio, you can use
the loadBytes command


230
00:11:28.221 --> 00:11:32.492 line:-1 position:50%
discussed earlier to load to
application-allocated memory.


231
00:11:32,492 --> 00:11:36,129 line:-1
In this example, texture
and audio IO command buffers


232
00:11:36.129 --> 00:11:40.667 line:-1 position:50%
are concurrently executing
on a single IO command queue.


233
00:11:40.667 --> 00:11:43.102 line:-1 position:50%
This simplified diagram
shows the requests


234
00:11:43,102 --> 00:11:45,004 line:-1
at the storage layer.


235
00:11:45,004 --> 00:11:46,973 line:-1
The storage system
is able to execute


236
00:11:46,973 --> 00:11:50,577 line:-1
both audio and texture
load requests in parallel.


237
00:11:50.577 --> 00:11:53.079 line:-1 position:50%
To avoid delayed audio,
it is critical


238
00:11:53,079 --> 00:11:55,515 line:-1
that the streaming system
be able to prioritize


239
00:11:55,515 --> 00:11:58,685 line:-1
audio requests
over texture requests.


240
00:11:58,685 --> 00:12:01,421 line:-1
To prioritize audio requests,
you can create


241
00:12:01.421 --> 00:12:06.326 line:-1 position:50%
a separate IO command queue,
and set its priority to high.


242
00:12:06,326 --> 00:12:10,430 line:-1
The storage system will ensure
that high-priority IO requests


243
00:12:10,430 --> 00:12:15,268 line:-1
have a lower latency and are
prioritized over other requests.


244
00:12:15.268 --> 00:12:17.870 line:-1 position:50%
After creating a separate
high-priority queue


245
00:12:17.870 --> 00:12:20.373 line:-1 position:50%
for audio assets,
the execution time


246
00:12:20,373 --> 00:12:22,976 line:-1
of the audio load requests
has gotten smaller,


247
00:12:22.976 --> 00:12:25.211 line:-1 position:50%
while that of the parallel
texture load requests


248
00:12:25.211 --> 00:12:28.147 line:-1 position:50%
has gotten larger.


249
00:12:28,147 --> 00:12:31,084 line:-1
Here's how you create
a high-priority queue.


250
00:12:31,084 --> 00:12:34,554 line:-1
Simply set the command queue
descriptor's priority property


251
00:12:34,554 --> 00:12:36,089 line:-1
to high.


252
00:12:36.089 --> 00:12:39.392 line:-1 position:50%
You can also set the priority
to normal or low,


253
00:12:39.392 --> 00:12:41.427 line:-1 position:50%
then create a new
IO command queue


254
00:12:41,427 --> 00:12:44,330 line:-1
from the descriptor as usual.


255
00:12:44,330 --> 00:12:47,266 line:-1
Just remember that you cannot
change a queue's priority level


256
00:12:47,266 --> 00:12:49,669 line:-1
after you create it.


257
00:12:49.669 --> 00:12:52.572 line:-1 position:50%
As you add fast resource loading
to your apps,


258
00:12:52.572 --> 00:12:56.442 line:-1 position:50%
here's some best practices
to keep in mind.


259
00:12:56,442 --> 00:12:59,212 line:-1
First, consider
compressing your assets.


260
00:12:59.212 --> 00:13:01.881 line:-1 position:50%
You can reduce
your app's disk footprint


261
00:13:01.881 --> 00:13:05.018 line:-1 position:50%
by using built-in
or custom compression.


262
00:13:05,018 --> 00:13:07,587 line:-1
Compression lets you trade
runtime performance


263
00:13:07,587 --> 00:13:10,456 line:-1
for a smaller disk footprint.


264
00:13:10.456 --> 00:13:12.959 line:-1 position:50%
Additionally, you can improve
storage throughput


265
00:13:12,959 --> 00:13:17,397 line:-1
by tuning the sparse page size
when using sparse textures.


266
00:13:17.397 --> 00:13:20.099 line:-1 position:50%
I'll go through each of these
in more detail,


267
00:13:20,099 --> 00:13:22,301 line:-1
starting with compression.


268
00:13:22.301 --> 00:13:24.804 line:-1 position:50%
You can use Metals 3's APIs


269
00:13:24,804 --> 00:13:28,474 line:-1
to compress
your asset files offline.


270
00:13:28,474 --> 00:13:31,644 line:-1
First, create a compression
context and configure it


271
00:13:31.644 --> 00:13:35.214 line:-1 position:50%
with a chunk size
and compression method.


272
00:13:35,214 --> 00:13:38,284 line:-1
Then pass parts of
your asset files to the context


273
00:13:38,284 --> 00:13:42,555 line:-1
to produce a single compressed
version of all your files.


274
00:13:42.555 --> 00:13:46.059 line:-1 position:50%
The compression context works
by chunking all the data


275
00:13:46,059 --> 00:13:48,795 line:-1
and compresses it with the codec
of your choosing


276
00:13:48.795 --> 00:13:51.731 line:-1 position:50%
and stores it to a pack file.


277
00:13:51.731 --> 00:13:53.466 line:-1 position:50%
In this example,


278
00:13:53,466 --> 00:13:57,336 line:-1
the context compresses
the data in 64K chunks,


279
00:13:57.336 --> 00:13:59.672 line:-1 position:50%
but you can choose
a suitable chunk size


280
00:13:59,672 --> 00:14:03,843 line:-1
based on the size and type
of data you want to compress.


281
00:14:03,843 --> 00:14:08,114 line:-1
Here's how you use
the compression APIs in Metal 3.


282
00:14:08.114 --> 00:14:10.383 line:-1 position:50%
First, create
a compression context


283
00:14:10,383 --> 00:14:13,519 line:-1
by providing a path for creating
the compressed file,


284
00:14:13.519 --> 00:14:16.856 line:-1 position:50%
a compression method,
and a chunk size.


285
00:14:16.856 --> 00:14:20.860 line:-1 position:50%
Next, get file data
and append it to the context.


286
00:14:20,860 --> 00:14:24,764 line:-1
Here, the file data is
in an NSData object.


287
00:14:24,764 --> 00:14:27,133 line:-1
You can append data
from different files


288
00:14:27,133 --> 00:14:31,137 line:-1
by making multiple calls
to append data.


289
00:14:31.137 --> 00:14:32.839 line:-1 position:50%
When you're done adding data,


290
00:14:32,839 --> 00:14:34,907 line:-1
finalize and save
the compressed file


291
00:14:34.907 --> 00:14:40.480 line:-1 position:50%
by calling the flush and destroy
compression context function.


292
00:14:40,480 --> 00:14:43,349 line:-1
You can open and access
a compressed file


293
00:14:43.349 --> 00:14:45.685 line:-1 position:50%
by creating a file handle.


294
00:14:45,685 --> 00:14:49,655 line:-1
This file handle is used
when issuing load commands.


295
00:14:49,655 --> 00:14:53,593 line:-1
For compressed files, Metal 3
performs inline decompression,


296
00:14:53,593 --> 00:14:56,095 line:-1
by translating the offsets
to a list of chunks


297
00:14:56.095 --> 00:15:00.633 line:-1 position:50%
it needs to decompress, and
loads them to your resources.


298
00:15:00.633 --> 00:15:05.638 line:-1 position:50%
You create a file handle
with a Metal device instance.


299
00:15:05,638 --> 00:15:08,741 line:-1
For example, this code uses
the Metal device instance


300
00:15:08,741 --> 00:15:10,243 line:-1
to create a file handle


301
00:15:10,243 --> 00:15:12,578 line:-1
by providing
the compressed file path


302
00:15:12,578 --> 00:15:16,349 line:-1
to the makeIOHandle method
I covered earlier.


303
00:15:16,349 --> 00:15:18,885 line:-1
For compressed files,
an additional parameter


304
00:15:18.885 --> 00:15:21.220 line:-1 position:50%
is the compression method.


305
00:15:21,220 --> 00:15:22,855 line:-1
This is the same
compression method


306
00:15:22.855 --> 00:15:26.959 line:-1 position:50%
you used at the time of creating
the compressed file.


307
00:15:26,959 --> 00:15:28,027 line:-1
Now, I'll go through


308
00:15:28,027 --> 00:15:30,463 line:-1
the different compression
methods supported


309
00:15:30.463 --> 00:15:32.665 line:-1 position:50%
and the characteristics
of each of them,


310
00:15:32.665 --> 00:15:36.135 line:-1 position:50%
so you can better understand
how to choose between them.


311
00:15:36.135 --> 00:15:39.438 line:-1 position:50%
Use LZ4 when decompression
speed is critical


312
00:15:39,438 --> 00:15:42,775 line:-1
and your app can afford
a large disk footprint.


313
00:15:42.775 --> 00:15:45.645 line:-1 position:50%
If a balance between codec
speed and compression ratio


314
00:15:45.645 --> 00:15:51.250 line:-1 position:50%
is important to you,
use ZLib, LZBitmap, or LZFSE.


315
00:15:51.250 --> 00:15:53.085 line:-1 position:50%
Amongst the balanced codecs,


316
00:15:53.085 --> 00:15:56.756 line:-1 position:50%
ZLib works better
with non-Apple devices.


317
00:15:56,756 --> 00:16:00,760 line:-1
LZBitmap is fast
at encoding and decoding,


318
00:16:00,760 --> 00:16:04,263 line:-1
and LZFSE has
a high compression ratio.


319
00:16:04,263 --> 00:16:06,666 line:0
If you need the best
compression ratio,


320
00:16:06,666 --> 00:16:09,101 position:50%
consider using the LZMA codec,


321
00:16:09,101 --> 00:16:14,407 line:0
if your app can afford the extra
time it takes to decode assets.


322
00:16:14,407 --> 00:16:18,411 position:50%
It is also possible to use
your own compression scheme.


323
00:16:18.411 --> 00:16:20.947 line:-1 position:50%
You may have cases
where your data benefits


324
00:16:20.947 --> 00:16:23.282 line:-1 position:50%
from a custom compression codec.


325
00:16:23.282 --> 00:16:26.252 line:-1 position:50%
In that case, you can replace
the compression context


326
00:16:26.252 --> 00:16:29.055 line:-1 position:50%
with your own compressor
and translate offsets


327
00:16:29,055 --> 00:16:33,392 line:-1
and perform decompression
at runtime yourself.


328
00:16:33,392 --> 00:16:35,461 line:-1
Now that you have seen
how to use compression


329
00:16:35.461 --> 00:16:37.296 line:-1 position:50%
to reduce disk footprint,


330
00:16:37.296 --> 00:16:40.633 line:-1 position:50%
let's look at tuning
sparse page size.


331
00:16:40.633 --> 00:16:43.336 line:-1 position:50%
Earlier versions
of Metal support loading tiles


332
00:16:43,336 --> 00:16:47,373 line:-1
to sparse textures
at a 16K granularity.


333
00:16:47.373 --> 00:16:51.777 line:-1 position:50%
With Metal 3, you can specify
two new sparse tile sizes:


334
00:16:51.777 --> 00:16:54.747 line:-1 position:50%
64 and 256K.


335
00:16:54,747 --> 00:16:57,450 line:-1
These new sizes let you
to stream textures


336
00:16:57.450 --> 00:17:00.219 line:-1 position:50%
at a larger granularity
to better utilize


337
00:17:00.219 --> 00:17:02.989 line:-1 position:50%
and saturate
the storage hardware.


338
00:17:02.989 --> 00:17:04.690 line:-1 position:50%
Note that there is a tradeoff


339
00:17:04,690 --> 00:17:06,959 line:-1
between streaming
larger tiles sizes


340
00:17:06.959 --> 00:17:09.328 line:-1 position:50%
and the amount of data
you stream,


341
00:17:09,328 --> 00:17:12,665 line:-1
so you'll have to experiment
to see which sizes work best


342
00:17:12.665 --> 00:17:16.102 line:-1 position:50%
with your app
and its sparse textures.


343
00:17:16.102 --> 00:17:18.271 line:-1 position:50%
Next, let's look at
how you can use


344
00:17:18.271 --> 00:17:21.574 line:-1 position:50%
the set of Metal Developer Tools
to profile and debug


345
00:17:21,574 --> 00:17:24,110 line:-1
fast resource loading
in your app.


346
00:17:24,110 --> 00:17:28,948 line:-1
Xcode 14 includes full support
for fast resource loading.


347
00:17:28,948 --> 00:17:32,018 line:-1
From runtime profiling
with Metal System Trace


348
00:17:32.018 --> 00:17:35.321 line:-1 position:50%
to API inspection and
advanced dependency analysis


349
00:17:35.321 --> 00:17:37.256 line:-1 position:50%
with Metal debugger.


350
00:17:39,392 --> 00:17:42,128 line:-1
Let's start with
runtime profiling.


351
00:17:42.128 --> 00:17:45.932 line:-1 position:50%
In Xcode 14, Instruments can
profile fast resource loading


352
00:17:45.932 --> 00:17:48.434 line:-1 position:50%
with the Metal System Trace
template.


353
00:17:48.434 --> 00:17:51.537 line:-1 position:50%
Instruments is a powerful
analysis and profiling tool


354
00:17:51.537 --> 00:17:53.506 line:-1 position:50%
that will help you achieve
the best performance


355
00:17:53.506 --> 00:17:56.042 line:-1 position:50%
in your Metal app.


356
00:17:56.042 --> 00:17:58.678 line:-1 position:50%
The Metal System Trace template
allows you to check


357
00:17:58.678 --> 00:18:02.181 line:-1 position:50%
when load operations
are encoded and executed.


358
00:18:02.181 --> 00:18:04.483 line:-1 position:50%
You will be able to understand
how they correlate


359
00:18:04.483 --> 00:18:06.786 line:-1 position:50%
with the activity that
your app is performing


360
00:18:06,786 --> 00:18:10,256 line:-1
on both the CPU and the GPU.


361
00:18:10,256 --> 00:18:13,659 line:0
To learn how to profile your
Metal app with Instruments,


362
00:18:13,659 --> 00:18:16,095 line:0
please check out
these previous sessions,


363
00:18:16,095 --> 00:18:19,365 position:50%
"Optimize Metal apps and games
with GPU counters"


364
00:18:19,365 --> 00:18:23,235 line:0
and "Optimize high-end games
for Apple GPUs."


365
00:18:23,235 --> 00:18:26,372 line:-1
Now, let's switch gears
to debugging.


366
00:18:26,372 --> 00:18:28,908 line:-1
With the Metal debugger
in Xcode 14,


367
00:18:28.908 --> 00:18:30.776 line:-1 position:50%
you can now analyze
your game's use


368
00:18:30.776 --> 00:18:33.980 line:-1 position:50%
of the new
fast resource loading API.


369
00:18:33,980 --> 00:18:36,716 line:-1
Once you take a frame capture,
you will be able to inspect


370
00:18:36,716 --> 00:18:40,553 line:-1
all fast resource loading
API calls.


371
00:18:40,553 --> 00:18:43,122 line:-1
From the IO command buffers
created


372
00:18:43.122 --> 00:18:46.559 line:-1 position:50%
to the load operations
that were issued.


373
00:18:46.559 --> 00:18:48.227 line:-1 position:50%
You can now visually inspect


374
00:18:48.227 --> 00:18:50.296 line:-1 position:50%
fast resource loading
dependencies


375
00:18:50.296 --> 00:18:53.366 line:-1 position:50%
with the new
Dependency viewer.


376
00:18:53,366 --> 00:18:56,202 line:-1
The Dependency viewer
gives a detailed overview


377
00:18:56.202 --> 00:18:59.305 line:-1 position:50%
of resource dependencies
between IO command buffers


378
00:18:59,305 --> 00:19:01,540 line:-1
and Metal passes.


379
00:19:01.540 --> 00:19:04.143 line:-1 position:50%
From here, you can use
all the features


380
00:19:04.143 --> 00:19:05.911 line:-1 position:50%
in the new
Dependency viewer,


381
00:19:05.911 --> 00:19:09.482 line:-1 position:50%
such as the new synchronization
edges and graph filtering,


382
00:19:09,482 --> 00:19:13,586 line:-1
to deep dive and optimize your
resource loading dependencies.


383
00:19:13,586 --> 00:19:17,356 position:50%
To learn more about the new
Dependency viewer in Xcode 14,


384
00:19:17,356 --> 00:19:18,758 position:50%
please check out this year's


385
00:19:18,758 --> 00:19:22,361 position:50%
"Go bindless with Metal 3"
session.


386
00:19:22,361 --> 00:19:26,332 line:-1
Now, let's look at
fast resource loading in action.


387
00:19:26,332 --> 00:19:27,967 line:-1
This is a test scene that uses


388
00:19:27.967 --> 00:19:31.337 line:-1 position:50%
the new fast resource loading
APIs to stream texture data


389
00:19:31,337 --> 00:19:35,307 line:-1
by using sparse textures
with a tile size of 16 kilobytes.


390
00:19:35,307 --> 00:19:38,778 line:-1
This video is from a MacBook Pro
with an M1 Pro chip.


391
00:19:38.778 --> 00:19:40.246 line:-1 position:50%
The streaming system queries


392
00:19:40.246 --> 00:19:44.517 line:-1 position:50%
the GPU's sparse texture access
counters to identify two things:


393
00:19:44.517 --> 00:19:46.685 line:-1 position:50%
the tiles it has sampled
but not loaded


394
00:19:46,685 --> 00:19:49,422 line:-1
and the loaded tiles
the app isn't using.


395
00:19:49.422 --> 00:19:52.658 line:-1 position:50%
The app uses this information
to encode a list of loads


396
00:19:52,658 --> 00:19:54,126 line:-1
for the tiles it needs


397
00:19:54.126 --> 00:19:57.396 line:-1 position:50%
and a list of evictions
for tiles it doesn't need.


398
00:19:57.396 --> 00:20:00.232 line:-1 position:50%
That way, the working set
contains only the tiles


399
00:20:00,232 --> 00:20:03,202 line:-1
the app is mostly likely to use.


400
00:20:03,202 --> 00:20:06,338 line:-1
If the player decides to travel
to another part of the scene,


401
00:20:06.338 --> 00:20:08.908 line:-1 position:50%
the app needs to stream in
a completely new set


402
00:20:08.908 --> 00:20:11.010 line:-1 position:50%
of high-resolution textures.


403
00:20:11.010 --> 00:20:13.345 line:-1 position:50%
If the streaming system
is fast enough,


404
00:20:13.345 --> 00:20:17.116 line:-1 position:50%
the player will not notice
this streaming occurring.


405
00:20:17.116 --> 00:20:18.384 line:-1 position:50%
If I pause the scene,


406
00:20:18.384 --> 00:20:21.320 line:-1 position:50%
you can observe the image
differences more clearly.


407
00:20:21,320 --> 00:20:23,622 line:0
The left side
is loading sparse tiles


408
00:20:23,622 --> 00:20:26,525 position:50%
on a single thread
using the pread API.


409
00:20:26,525 --> 00:20:28,627 position:50%
The right side
is loading sparse tiles


410
00:20:28,627 --> 00:20:31,730 position:50%
using the fast resource loading
APIs.


411
00:20:31,730 --> 00:20:33,666 line:0
As the player enters the scene,


412
00:20:33,666 --> 00:20:36,735 position:50%
most of the textures
haven't fully loaded.


413
00:20:36,735 --> 00:20:39,905 line:0
Once the loads complete, the
final high-resolution version


414
00:20:39,905 --> 00:20:42,908 position:50%
of the textures is visible.


415
00:20:42,908 --> 00:20:46,112 position:50%
If I go back to the beginning
of this scene and slow it down,


416
00:20:46,112 --> 00:20:48,481 position:50%
it is easier to notice
the improvements


417
00:20:48,481 --> 00:20:51,417 position:50%
that fast resource loading
provides.


418
00:20:51,417 --> 00:20:54,053 line:0
To highlight the differences,
this rendering


419
00:20:54,053 --> 00:20:59,425 line:0
marks tiles the app has not
yet loaded with a red tint.


420
00:20:59,425 --> 00:21:01,527 line:0
At first, the scene shows


421
00:21:01,527 --> 00:21:05,631 position:50%
that the app hasn't loaded
most of the tiles.


422
00:21:05,631 --> 00:21:08,601 position:50%
However, as the player
enters the scene,


423
00:21:08,601 --> 00:21:11,036 line:0
fast resource loading
improves the loading


424
00:21:11,036 --> 00:21:14,006 position:50%
of high-resolution tiles
and minimizes the delay


425
00:21:14,006 --> 00:21:18,711 position:50%
compared to the single-threaded
pread version.


426
00:21:18,711 --> 00:21:21,780 line:-1
Metal 3's fast resource loading
helps you build a powerful


427
00:21:21,780 --> 00:21:24,683 line:-1
and efficient asset-streaming
system that lets your app


428
00:21:24,683 --> 00:21:28,387 line:-1
take advantage of the latest
storage technologies.


429
00:21:28,387 --> 00:21:32,791 line:-1
Use it to reduce load times by
streaming assets just in time,


430
00:21:32.791 --> 00:21:35.761 line:-1 position:50%
including higher-quality images.


431
00:21:35,761 --> 00:21:40,232 line:-1
Use Metal's shared events
to asynchronously load assets


432
00:21:40.232 --> 00:21:43.102 line:-1 position:50%
while the GPU renders a scene.


433
00:21:43.102 --> 00:21:46.005 line:-1 position:50%
For assets that your app
needs in a hurry,


434
00:21:46.005 --> 00:21:48.807 line:-1 position:50%
minimize latency
by creating a command queue


435
00:21:48,807 --> 00:21:51,010 line:-1
with a higher priority.


436
00:21:51,010 --> 00:21:54,013 line:-1
And remember,
keep the storage system busy


437
00:21:54.013 --> 00:21:56.282 line:-1 position:50%
by sending load commands early.


438
00:21:56.282 --> 00:22:00.953 line:-1 position:50%
You can always cancel
the ones you don't need.


439
00:22:00.953 --> 00:22:04.256 line:-1 position:50%
Fast resource loading in Metal 3
introduces new ways


440
00:22:04,256 --> 00:22:06,859 line:-1
to harness the power
of modern storage hardware


441
00:22:06.859 --> 00:22:09.828 line:-1 position:50%
for high-throughput
asset loading.


442
00:22:09,828 --> 00:22:12,264 line:-1
I can't wait to see
how you use these features


443
00:22:12.264 --> 00:22:15.968 line:-1 position:50%
to improve your app's visual
quality and responsiveness.


444
00:22:15,968 --> 00:22:17,136 line:-1
Thanks for watching.


445
00:22:17,136 --> 00:22:20,873 line:0 align:right size:2%
♪

