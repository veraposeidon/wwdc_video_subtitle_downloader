2
00:00:00,000 --> 00:00:03,737
♪ Mellow instrumental
hip-hop music ♪


3
00:00:03,737 --> 00:00:09,543 position:90% align:right line:0
♪


4
00:00:09,543 --> 00:00:11,745
Hi, folks.
My name is Michael Gorbach


5
00:00:11,745 --> 00:00:13,714
from Shortcuts Engineering.


6
00:00:13,714 --> 00:00:17,117
Thanks for tuning in for this
deep dive into App Intents,


7
00:00:17,117 --> 00:00:18,118
our new framework


8
00:00:18,118 --> 00:00:22,489
for exposing your app's
functionality to the system.


9
00:00:22,489 --> 00:00:24,224
Here's the plan for our dive.


10
00:00:24,224 --> 00:00:26,159
After a quick introduction,


11
00:00:26,159 --> 00:00:28,729
I'll talk about intents
and their parameters,


12
00:00:28,729 --> 00:00:31,431
and how to define entities.


13
00:00:31,431 --> 00:00:33,834
I'll go over some powerful
finding and filtering features


14
00:00:33,834 --> 00:00:35,102
you can build,


15
00:00:35,102 --> 00:00:38,472
and how your intents
can interact with the user.


16
00:00:38,472 --> 00:00:43,277
Lastly, I'll cover App Intents
architecture and lifecycle.


17
00:00:43,277 --> 00:00:45,913
Let's start at the beginning.


18
00:00:45,913 --> 00:00:49,683
In iOS 10, we introduced
the SiriKit Intents framework,


19
00:00:49,683 --> 00:00:51,952
which lets you hook up
your app's functionality


20
00:00:51,952 --> 00:00:56,690
to Siri domains like messaging,
workouts, and payments.


21
00:00:56,690 --> 00:00:59,192
Now we're introducing
a new framework


22
00:00:59,192 --> 00:01:01,528
called App Intents.


23
00:01:01,528 --> 00:01:04,097
It has three key components.


24
00:01:04,097 --> 00:01:06,400
Intents are actions
built into your app


25
00:01:06,400 --> 00:01:08,602
that can be used
throughout the system.


26
00:01:08,602 --> 00:01:12,906
Intents use entities to
represent your app's concepts.


27
00:01:12,906 --> 00:01:15,175
App Shortcuts wrap your intents


28
00:01:15,175 --> 00:01:18,378
to make them automatic
and discoverable.


29
00:01:18,378 --> 00:01:19,980
Let's talk about
a couple of the ways


30
00:01:19,980 --> 00:01:22,582
that App Intents can make your
app's functionality available


31
00:01:22,582 --> 00:01:26,653
in more places,
and benefit your customers.


32
00:01:26,653 --> 00:01:28,755
With App Shortcuts,
everyone can use


33
00:01:28,755 --> 00:01:31,591
your app's features
with their voice through Siri,


34
00:01:31,591 --> 00:01:34,928
without needing
to set anything up first.


35
00:01:34,928 --> 00:01:38,398
The same adoption also makes
your intents appear in Spotlight


36
00:01:38,398 --> 00:01:42,135
when people search for your app
and when your app's suggested.


37
00:01:42,135 --> 00:01:45,872
This will put your work
front and center.


38
00:01:45,872 --> 00:01:49,576
Using App Intents, you can also
build Focus Filters,


39
00:01:49,576 --> 00:01:53,947
letting customers customize
your app for a specific Focus.


40
00:01:53,947 --> 00:01:56,450
For example, they might
set up their Calendar app


41
00:01:56,450 --> 00:02:01,021
to only show their work calendar
while they're actually at work.


42
00:02:01,021 --> 00:02:02,923
Check out this session
to learn more about


43
00:02:02,923 --> 00:02:06,660
how to adopt Focus Filters.


44
00:02:06,660 --> 00:02:08,161
With App Shortcuts,


45
00:02:08,161 --> 00:02:11,298
your intents show up in the
Shortcuts app automatically,


46
00:02:11,298 --> 00:02:14,201
without needing
to be added manually.


47
00:02:14,201 --> 00:02:16,737
Integrating your actions
into Shortcuts


48
00:02:16,737 --> 00:02:18,939
is incredibly valuable
for customers


49
00:02:18,939 --> 00:02:20,674
because they can run shortcuts,


50
00:02:20,674 --> 00:02:22,876
and take advantage
of your app's features,


51
00:02:22,876 --> 00:02:25,912
from so many places
throughout the system.


52
00:02:25,912 --> 00:02:28,882
They can run shortcuts with
a single tap on the Home Screen,


53
00:02:28,882 --> 00:02:32,386
from the menu bar on macOS,
and in many other ways.


54
00:02:32,386 --> 00:02:34,955
They can even set shortcuts up
to run automatically


55
00:02:34,955 --> 00:02:37,991
with automations.


56
00:02:37,991 --> 00:02:40,727
Supporting shortcuts
multiplies the power


57
00:02:40,727 --> 00:02:43,296
and capability of your app
by connecting it


58
00:02:43,296 --> 00:02:46,366
to the entire
Shortcuts ecosystem,


59
00:02:46,366 --> 00:02:49,236
harnessing the power
of an array of apps from Apple


60
00:02:49,236 --> 00:02:51,271
and other developers.


61
00:02:51,271 --> 00:02:53,874
That's because a shortcut
can combine actions


62
00:02:53,874 --> 00:02:55,242
from multiple apps,


63
00:02:55,242 --> 00:02:59,046
letting users invent entirely
new features and capabilities


64
00:02:59,046 --> 00:03:02,816
without you needing
to do any work.


65
00:03:02,816 --> 00:03:05,052
If you want to learn
how to make your actions


66
00:03:05,052 --> 00:03:08,655
work well with others and fit
seamlessly into this ecosystem,


67
00:03:08,655 --> 00:03:11,191
check out our design talk.


68
00:03:11,191 --> 00:03:13,026
Our goal in building App Intents


69
00:03:13,026 --> 00:03:16,163
was to make it a joy
to develop for.


70
00:03:16,163 --> 00:03:18,598
App Intents is concise.


71
00:03:18,598 --> 00:03:21,668
Writing a simple intent can take
only a few lines of code,


72
00:03:21,668 --> 00:03:23,870
but the API also scales


73
00:03:23,870 --> 00:03:27,374
to deeper and more
customizable actions.


74
00:03:27,374 --> 00:03:29,276
App Intents is modern.


75
00:03:29,276 --> 00:03:30,644
We've gone all in on Swift,


76
00:03:30,644 --> 00:03:33,213
leveraging result builders,
property wrappers,


77
00:03:33,213 --> 00:03:36,049
protocol-oriented programming,
and generics.


78
00:03:36,049 --> 00:03:37,851
These APIs just couldn't exist


79
00:03:37,851 --> 00:03:41,221
without cutting-edge
language features.


80
00:03:41,221 --> 00:03:43,623
Adopting App Intents
is also easy,


81
00:03:43,623 --> 00:03:45,258
because it doesn't require
re-architecting


82
00:03:45,258 --> 00:03:49,029
your products and targets
or creating a framework.


83
00:03:49,029 --> 00:03:50,697
It doesn't require an extension


84
00:03:50,697 --> 00:03:53,233
and can be adopted
right in your app.


85
00:03:53,233 --> 00:03:55,802
And App Intents code
is maintainable.


86
00:03:55,802 --> 00:03:58,605
Like SwiftUI,
App Intents uses your code


87
00:03:58,605 --> 00:04:00,574
as the fundamental
source of truth,


88
00:04:00,574 --> 00:04:04,578
avoiding the need for separate
editors or definition files.


89
00:04:04,578 --> 00:04:07,881
This lets you rapidly build
and iterate on your adoption,


90
00:04:07,881 --> 00:04:09,082
and simplifies maintenance


91
00:04:09,082 --> 00:04:12,452
because everything
lives in one place.


92
00:04:12,452 --> 00:04:15,388
With that said,
let's explore these new APIs,


93
00:04:15,388 --> 00:04:16,790
starting with the intent,


94
00:04:16,790 --> 00:04:19,960
the central building block
of our new framework.


95
00:04:19,960 --> 00:04:22,662
An app intent --
or "intent" for short --


96
00:04:22,662 --> 00:04:25,265
is a single, isolated unit
of functionality


97
00:04:25,265 --> 00:04:27,634
that your app
exposes to the system.


98
00:04:27,634 --> 00:04:30,537
For example, an intent
could make a new calendar event,


99
00:04:30,537 --> 00:04:34,007
open a particular screen,
or place an order.


100
00:04:34,007 --> 00:04:37,277
An intent can be run
by the user on request --


101
00:04:37,277 --> 00:04:40,180
like by running a shortcut
or asking Siri --


102
00:04:40,180 --> 00:04:41,348
or automatically --


103
00:04:41,348 --> 00:04:45,318
like using Focus filters
or a Shortcuts automation.


104
00:04:45,318 --> 00:04:46,586
When an intent is run,


105
00:04:46,586 --> 00:04:51,024
it will either return a result
or throw an error.


106
00:04:51,024 --> 00:04:54,294
An intent includes
three key pieces:


107
00:04:54,294 --> 00:04:56,796
metadata,
or information about the intent,


108
00:04:56,796 --> 00:04:59,065
including a localized title;


109
00:04:59,065 --> 00:05:01,801
parameters, which are inputs
that the intent can use


110
00:05:01,801 --> 00:05:03,036
when it's run;


111
00:05:03,036 --> 00:05:05,572
and a perform method,
which does the actual work


112
00:05:05,572 --> 00:05:09,042
when the intent is executed.


113
00:05:09,042 --> 00:05:11,945
Our starting point today
is this Library app.


114
00:05:11,945 --> 00:05:13,480
Since I'm a huge bookworm,


115
00:05:13,480 --> 00:05:15,515
it's all about tracking
books I've read,


116
00:05:15,515 --> 00:05:18,485
want to read,
or am currently reading.


117
00:05:18,485 --> 00:05:21,421
Each category is shown
in separate tab of the app


118
00:05:21,421 --> 00:05:24,391
that I call a Shelf.


119
00:05:24,391 --> 00:05:26,593
My users visit
the Currently Reading shelf


120
00:05:26,593 --> 00:05:27,694
all the time,


121
00:05:27,694 --> 00:05:29,896
so I'm going expose
an app intent


122
00:05:29,896 --> 00:05:34,034
to make opening it quicker
and more convenient.


123
00:05:34,034 --> 00:05:36,970
I'll create an
OpenCurrentlyReading intent here


124
00:05:36,970 --> 00:05:38,471
by defining a Swift struct


125
00:05:38,471 --> 00:05:41,975
that conforms to
the AppIntent protocol.


126
00:05:41,975 --> 00:05:45,478
I need to implement
only one method, called perform.


127
00:05:45,478 --> 00:05:48,949
In my app, I've already got
a navigator that can open tabs,


128
00:05:48,949 --> 00:05:50,317
so implementing
the intent for me


129
00:05:50,317 --> 00:05:52,852
is only a few lines of code.


130
00:05:52,852 --> 00:05:55,755
I'll annotate the perform method
with @MainActor,


131
00:05:55,755 --> 00:05:59,859
since my Navigator
expects the main thread.


132
00:05:59,859 --> 00:06:02,662
My intent also needs a title.


133
00:06:02,662 --> 00:06:04,631
Like all the other strings
I'll be showing you today,


134
00:06:04,631 --> 00:06:06,299
this will get localized
automatically


135
00:06:06,299 --> 00:06:09,135
if I add the key
to my strings files.


136
00:06:09,135 --> 00:06:13,907
This is all I need to do to get
a basic app intent working.


137
00:06:13,907 --> 00:06:15,775
Now that it's defined
in my code,


138
00:06:15,775 --> 00:06:19,179
it will automatically appear
in the Shortcuts editor,


139
00:06:19,179 --> 00:06:24,084
where my user
can add it to a shortcut.


140
00:06:24,084 --> 00:06:27,621
Just exposing this intent
provides huge leverage,


141
00:06:27,621 --> 00:06:30,423
because once customers turn
this intent into a shortcut,


142
00:06:30,423 --> 00:06:33,293
it can be used from
a ton of places in the system,


143
00:06:33,293 --> 00:06:36,129
including all of these.


144
00:06:36,129 --> 00:06:39,099
To make my new intent
easy to use and discover,


145
00:06:39,099 --> 00:06:41,635
I'll also add support
for App Shortcuts.


146
00:06:41,635 --> 00:06:43,003
With a little bit of code,


147
00:06:43,003 --> 00:06:46,239
I can make my intent show up
automatically in Spotlight


148
00:06:46,239 --> 00:06:47,841
and the Shortcuts app,


149
00:06:47,841 --> 00:06:51,044
and I can define a phrase
that people can say to Siri


150
00:06:51,044 --> 00:06:53,980
to use this intent
with their voice.


151
00:06:53,980 --> 00:06:56,516
Check out the "Implement App
Shortcuts with App Intents"


152
00:06:56,516 --> 00:07:00,487
session to get all the details.


153
00:07:00,487 --> 00:07:02,322
So far, I've exposed an intent


154
00:07:02,322 --> 00:07:05,025
to open the Currently Reading
shelf.


155
00:07:05,025 --> 00:07:06,860
Next, let's generalize it,


156
00:07:06,860 --> 00:07:12,432
adding a parameter so it can
open any of the shelves.


157
00:07:12,432 --> 00:07:15,235
I have an enum
that represents shelves.


158
00:07:15,235 --> 00:07:17,671
In order for it to be used
as an intent parameter,


159
00:07:17,671 --> 00:07:21,174
I need to conform it
to the AppEnum protocol.


160
00:07:21,174 --> 00:07:24,044
AppEnum requires
a String raw value,


161
00:07:24,044 --> 00:07:26,413
so I'll add that first.


162
00:07:26,413 --> 00:07:28,915
It also requires
that I provide localizable,


163
00:07:28,915 --> 00:07:32,752
human-readable titles
for each of my enum cases.


164
00:07:32,752 --> 00:07:35,188
These must be provided
as a dictionary literal,


165
00:07:35,188 --> 00:07:39,626
since the compiler will
read this code at build time.


166
00:07:39,626 --> 00:07:42,095
Finally, I'll add
a typeDisplayName:


167
00:07:42,095 --> 00:07:44,397
a user-visible, localizable name


168
00:07:44,397 --> 00:07:46,999
for this enum type
as a whole.


169
00:07:46,999 --> 00:07:49,436
I'll use "Shelf."


170
00:07:49,436 --> 00:07:51,938
In an intent,
each parameter is declared


171
00:07:51,938 --> 00:07:54,407
using an @Parameter
property wrapper,


172
00:07:54,407 --> 00:07:57,177
which is initialized with
information about the parameter,


173
00:07:57,177 --> 00:07:58,845
like the title.


174
00:07:58,845 --> 00:08:01,514
Here, I define
a new shelf parameter,


175
00:08:01,514 --> 00:08:04,818
which I read
in my perform method.


176
00:08:04,818 --> 00:08:06,820
Parameters support
all of these types,


177
00:08:06,820 --> 00:08:10,023
including numbers, strings,
files, and more,


178
00:08:10,023 --> 00:08:13,593
as well as entities and enums
from your app.


179
00:08:13,593 --> 00:08:17,297
Here's how this intent looks
in the Shortcuts editor.


180
00:08:17,297 --> 00:08:21,201
Note that the shelf parameter
appears in a table row.


181
00:08:21,201 --> 00:08:23,069
I can make the UI
more streamlined,


182
00:08:23,069 --> 00:08:24,938
and make it fit better
into Shortcuts,


183
00:08:24,938 --> 00:08:29,008
by using the
ParameterSummary API.


184
00:08:29,008 --> 00:08:31,077
The Parameter Summary
is a sentence


185
00:08:31,077 --> 00:08:33,680
that represents your intent
and its parameters


186
00:08:33,680 --> 00:08:37,684
in the editor,
like "Open [Shelf]."


187
00:08:37,684 --> 00:08:39,619
For best results in Shortcuts,


188
00:08:39,619 --> 00:08:41,988
you should always provide
a Parameter Summary


189
00:08:41,988 --> 00:08:45,458
for every intent you create.


190
00:08:45,458 --> 00:08:47,026
You can also define
which parameters


191
00:08:47,026 --> 00:08:50,497
show up below the fold
and which are hidden.


192
00:08:50,497 --> 00:08:53,166
These APIs can
do some pretty cool stuff,


193
00:08:53,166 --> 00:08:56,102
like varying the summary
based on the actual values


194
00:08:56,102 --> 00:08:58,371
of any parameter of your intent,


195
00:08:58,371 --> 00:09:00,807
using the When
and Otherwise APIs,


196
00:09:00,807 --> 00:09:05,512
or the Switch, Case,
and Default APIs.


197
00:09:05,512 --> 00:09:06,946
To add a parameter summary,


198
00:09:06,946 --> 00:09:09,649
I implement
this static property.


199
00:09:09,649 --> 00:09:11,718
Here I'll return the string
"Open",


200
00:09:11,718 --> 00:09:15,755
and interpolate
the shelf parameter.


201
00:09:15,755 --> 00:09:18,758
The last thing I need to do
to get Open Shelf working


202
00:09:18,758 --> 00:09:21,494
is make sure that the intent
opens the Library app


203
00:09:21,494 --> 00:09:25,865
when it's run,
like this.


204
00:09:25,865 --> 00:09:28,835
Opening the app by is controlled
by the static property,


205
00:09:28,835 --> 00:09:30,837
openAppWhenRun.


206
00:09:30,837 --> 00:09:33,940
It defaults to false,
which is great for most intents.


207
00:09:33,940 --> 00:09:36,176
But for intents that open
something in the UI


208
00:09:36,176 --> 00:09:40,213
like this one,
I'll need to set it to true.


209
00:09:40,213 --> 00:09:43,082
I just created an intent
to open shelves.


210
00:09:43,082 --> 00:09:47,187
This is super simple because
the set of shelves is fixed.


211
00:09:47,187 --> 00:09:50,256
But what if I wanted to build
an intent that opens Books,


212
00:09:50,256 --> 00:09:53,193
the set of which is dynamic,
not fixed?


213
00:09:53,193 --> 00:09:55,728
For that, I'll need entities.


214
00:09:55,728 --> 00:09:59,666
An entity is a concept that
your app exposes to App Intents.


215
00:09:59,666 --> 00:10:02,202
You should use an entity
instead of an enum


216
00:10:02,202 --> 00:10:05,071
when the values are dynamic,
or user-defined,


217
00:10:05,071 --> 00:10:09,209
like a note in Notes
or a photo or album in Photos.


218
00:10:09,209 --> 00:10:11,511
To provide instances
of entities,


219
00:10:11,511 --> 00:10:13,513
your app can implement queries,


220
00:10:13,513 --> 00:10:17,817
and return entities
as results from intents.


221
00:10:17,817 --> 00:10:21,321
I'll start by making an intent
to open a book in the app.


222
00:10:21,321 --> 00:10:25,158
In the Shortcuts editor,
it should look like this.


223
00:10:25,158 --> 00:10:27,260
When people tap
on the Book parameter,


224
00:10:27,260 --> 00:10:29,262
they'll get a picker
to choose a book,


225
00:10:29,262 --> 00:10:30,964
including a set
of suggested entities


226
00:10:30,964 --> 00:10:34,400
that my app has provided.


227
00:10:34,400 --> 00:10:36,703
They can also find
any book in their library


228
00:10:36,703 --> 00:10:41,374
with this search field
at the top of the picker.


229
00:10:41,374 --> 00:10:43,343
Before I build
the intent itself,


230
00:10:43,343 --> 00:10:45,311
I'll need to create
a book entity


231
00:10:45,311 --> 00:10:47,614
and the corresponding query.


232
00:10:47,614 --> 00:10:50,483
An entity contains
at least three things:


233
00:10:50,483 --> 00:10:53,152
an identifier,
a display representation,


234
00:10:53,152 --> 00:10:56,189
and an entity type name.


235
00:10:56,189 --> 00:10:58,925
To add an entity,
start by conforming a struct


236
00:10:58,925 --> 00:11:01,528
to the AppEntity protocol.


237
00:11:01,528 --> 00:11:03,997
Here, I'll define a new struct
for the BookEntity,


238
00:11:03,997 --> 00:11:08,568
but I could also conform
an existing type from my model.


239
00:11:08,568 --> 00:11:11,371
You provide an identifier
by conforming your entity


240
00:11:11,371 --> 00:11:14,040
to the Identifiable protocol.


241
00:11:14,040 --> 00:11:17,110
App Intents uses this identifier
to refer to your entity


242
00:11:17,110 --> 00:11:20,880
as it's passed between your app
and other parts of the system.


243
00:11:20,880 --> 00:11:23,716
The identifier should be
stable and persistent,


244
00:11:23,716 --> 00:11:25,752
since it might be saved
in a shortcut


245
00:11:25,752 --> 00:11:29,155
created by your customers.


246
00:11:29,155 --> 00:11:31,057
The display representation
is used


247
00:11:31,057 --> 00:11:33,560
to show this entity to the user.


248
00:11:33,560 --> 00:11:35,595
This can be as simple
as a string of text,


249
00:11:35,595 --> 00:11:37,530
like a book title.


250
00:11:37,530 --> 00:11:41,634
You could also provide
a subtitle and an image.


251
00:11:41,634 --> 00:11:44,070
The typeDisplayName
is a human-readable string


252
00:11:44,070 --> 00:11:46,439
representing
the type of an entity.


253
00:11:46,439 --> 00:11:49,208
In this example,
it's "Book."


254
00:11:49,208 --> 00:11:51,544
Now, to round out
the book entity,


255
00:11:51,544 --> 00:11:54,180
I need to add a query.


256
00:11:54,180 --> 00:11:56,616
A query gives the system
an interface


257
00:11:56,616 --> 00:12:00,019
for retrieving entities
from your app.


258
00:12:00,019 --> 00:12:03,156
Queries can look up entities
in a few ways.


259
00:12:03,156 --> 00:12:05,291
All queries need to be able
to look up entities


260
00:12:05,291 --> 00:12:07,360
based on an identifier.


261
00:12:07,360 --> 00:12:09,796
String queries support search.


262
00:12:09,796 --> 00:12:11,898
And later, you'll run into
property queries,


263
00:12:11,898 --> 00:12:13,933
which are more flexible.


264
00:12:13,933 --> 00:12:17,337
All queries can also provide
suggested entities,


265
00:12:17,337 --> 00:12:21,708
which allow the users
to pick from a list.


266
00:12:21,708 --> 00:12:24,611
Every entity should be
associated with a query


267
00:12:24,611 --> 00:12:29,015
so the system can look up
instances of that entity.


268
00:12:29,015 --> 00:12:31,584
You provide a query
by making a Swift struct


269
00:12:31,584 --> 00:12:35,221
that conforms to
the EntityQuery protocol.


270
00:12:35,221 --> 00:12:38,291
The basic query has only
one required method,


271
00:12:38,291 --> 00:12:39,959
which you implement
to resolve entities


272
00:12:39,959 --> 00:12:42,862
given an array of identifiers.


273
00:12:42,862 --> 00:12:45,665
I've implemented this
by going to my model database


274
00:12:45,665 --> 00:12:49,969
and finding any books
matching those identifiers.


275
00:12:49,969 --> 00:12:53,373
Now, I need to hook up
the query to the entity.


276
00:12:53,373 --> 00:12:56,409
I do this by implementing
the defaultQuery static property


277
00:12:56,409 --> 00:12:58,277
on the BookEntity type


278
00:12:58,277 --> 00:13:03,182
and returning an instance
of my BookQuery.


279
00:13:03,182 --> 00:13:05,151
When the user picks a book,


280
00:13:05,151 --> 00:13:08,121
its identifier will be saved
into the shortcut.


281
00:13:08,121 --> 00:13:09,555
When the shortcut is run,


282
00:13:09,555 --> 00:13:12,492
App Intents will pass
the identifier to my query


283
00:13:12,492 --> 00:13:16,796
to retrieve
the BookEntity instance.


284
00:13:16,796 --> 00:13:18,197
Now that the BookEntity type


285
00:13:18,197 --> 00:13:20,667
conforms to
the AppEntity protocol,


286
00:13:20,667 --> 00:13:24,671
I can use it as a parameter
in my OpenBook intent.


287
00:13:24,671 --> 00:13:26,939
The perform method
uses my Navigator


288
00:13:26,939 --> 00:13:28,941
to navigate to the book.


289
00:13:32,545 --> 00:13:34,647
In order to support
the book picker,


290
00:13:34,647 --> 00:13:38,484
my query also needs
to provide suggested results.


291
00:13:38,484 --> 00:13:42,021
To do that, I need to implement
one more method on query,


292
00:13:42,021 --> 00:13:45,091
returning all the books
added to my Library app.


293
00:13:45,091 --> 00:13:49,996
Shortcuts will fill the picker
with these results.


294
00:13:49,996 --> 00:13:53,700
Notice that the Shortcuts UI
has a search field on top.


295
00:13:53,700 --> 00:13:55,668
My app could have
a lot of book entities,


296
00:13:55,668 --> 00:13:58,738
so I should really run
the search in my app process,


297
00:13:58,738 --> 00:14:00,907
against my database directly.


298
00:14:00,907 --> 00:14:04,410
The StringQuery API
lets me do that.


299
00:14:04,410 --> 00:14:06,813
Adopting the StringQuery
subprotocol gives me


300
00:14:06,813 --> 00:14:08,514
one more method to implement,


301
00:14:08,514 --> 00:14:10,717
called
entities (matching string:),


302
00:14:10,717 --> 00:14:13,286
to return results
given a string.


303
00:14:13,286 --> 00:14:16,689
Here, I've implemented it as
a simple case-insensitive match


304
00:14:16,689 --> 00:14:18,391
against the title of the book,


305
00:14:18,391 --> 00:14:19,959
but I could have done
fancier stuff


306
00:14:19,959 --> 00:14:22,395
like searching through
the author or series name,


307
00:14:22,395 --> 00:14:24,597
for example.


308
00:14:24,597 --> 00:14:28,167
If I have a huge list of books,
and a smaller list of favorites,


309
00:14:28,167 --> 00:14:31,237
I could return just the
favorites in suggestedEntities,


310
00:14:31,237 --> 00:14:33,573
and rely on
entities (matching string:)


311
00:14:33,573 --> 00:14:38,911
to allow my users to search
across the longer list.


312
00:14:38,911 --> 00:14:41,881
Now I've exposed a way
to open books in my app,


313
00:14:41,881 --> 00:14:45,485
and built a book entity
and book query in the process.


314
00:14:45,485 --> 00:14:49,322
I can use the same entity and
query to create more intents.


315
00:14:49,322 --> 00:14:51,758
My next task
is to build an intent


316
00:14:51,758 --> 00:14:53,893
to add books to the library.


317
00:14:53,893 --> 00:14:56,629
Customers can quickly add books
while browsing online


318
00:14:56,629 --> 00:14:58,231
using a share sheet shortcut,


319
00:14:58,231 --> 00:15:00,533
or they can tell Siri on HomePod
to add a book


320
00:15:00,533 --> 00:15:03,002
without even looking
at a screen.


321
00:15:03,002 --> 00:15:06,672
Building intents like this that
manipulate your model directly


322
00:15:06,672 --> 00:15:11,878
without showing your UI
can really empower your users.


323
00:15:11,878 --> 00:15:14,714
Here's the implementation
of my AddBook intent,


324
00:15:14,714 --> 00:15:16,816
taking as parameters
the title of the book


325
00:15:16,816 --> 00:15:19,519
and an optional
name of the author.


326
00:15:19,519 --> 00:15:21,621
It also includes
an optional note


327
00:15:21,621 --> 00:15:24,791
to record which friend
recommended the book.


328
00:15:24,791 --> 00:15:27,727
The perform method
will add the book to the library


329
00:15:27,727 --> 00:15:31,764
by looking it up with
an API call using async/await.


330
00:15:31,764 --> 00:15:36,669
It will throw an error
if it can't find a match.


331
00:15:36,669 --> 00:15:39,472
To localize this error,
I conform my error type to


332
00:15:39,472 --> 00:15:43,943
the CustomLocalizedString
ResourceConvertible protocol.


333
00:15:43,943 --> 00:15:47,213
I'll return a localized
string key from this property,


334
00:15:47,213 --> 00:15:50,950
and add the key
to my strings files.


335
00:15:50,950 --> 00:15:54,287
This Add Book intent
is incredibly useful as is,


336
00:15:54,287 --> 00:15:56,856
with Siri, widgets,
and more.


337
00:15:56,856 --> 00:15:58,758
But it gets even more flexible


338
00:15:58,758 --> 00:16:01,627
if it can be combined
with other intents.


339
00:16:01,627 --> 00:16:02,895
With a little bit of work,


340
00:16:02,895 --> 00:16:05,164
I can allow combining
my Add Book intent


341
00:16:05,164 --> 00:16:07,633
with the Open Book intent
I built earlier,


342
00:16:07,633 --> 00:16:10,937
passing the result
from one to the other.


343
00:16:10,937 --> 00:16:13,806
To do so, I'll have
the Add Book intent


344
00:16:13,806 --> 00:16:17,109
return a value
as part of its result.


345
00:16:17,109 --> 00:16:19,212
Notice that my perform method's
return type


346
00:16:19,212 --> 00:16:20,980
has picked up a new protocol


347
00:16:20,980 --> 00:16:23,950
to represent the value
I'm returning.


348
00:16:23,950 --> 00:16:27,420
Now, users can connect
the result value of this intent


349
00:16:27,420 --> 00:16:31,858
to other intents that take
a book entity as a parameter.


350
00:16:31,858 --> 00:16:34,927
The Add Book intent
and the Open Book intent


351
00:16:34,927 --> 00:16:36,395
pair quite naturally together,


352
00:16:36,395 --> 00:16:38,865
so you can make a shortcut
that adds a book


353
00:16:38,865 --> 00:16:41,434
and then immediately
opens it in the library.


354
00:16:41,434 --> 00:16:44,503
It's a common pattern to return
a result from an intent


355
00:16:44,503 --> 00:16:46,873
and open it in the app.


356
00:16:46,873 --> 00:16:49,342
App intents have a built-in way
to express this


357
00:16:49,342 --> 00:16:51,577
called the openIntent.


358
00:16:51,577 --> 00:16:53,880
If I add an openIntent,
customers will get


359
00:16:53,880 --> 00:16:57,483
a new switch in Shortcuts
called "Open When Run."


360
00:16:57,483 --> 00:16:59,085
If they turn the switch off,


361
00:16:59,085 --> 00:17:00,253
they'll be able
to use this intent


362
00:17:00,253 --> 00:17:04,624
as part of a shortcut in the
background without interruption.


363
00:17:04,624 --> 00:17:07,526
If they leave the switch on,
the newly added book


364
00:17:07,526 --> 00:17:12,398
will be immediately opened
in my Library app.


365
00:17:12,398 --> 00:17:15,268
Adopting openIntent
is as easy


366
00:17:15,268 --> 00:17:17,670
as creating an instance
of the Open Book intent


367
00:17:17,670 --> 00:17:20,907
and returning it
as part of the result.


368
00:17:20,907 --> 00:17:22,308
When this intent is run,


369
00:17:22,308 --> 00:17:24,277
if the Open When Run switch
is on,


370
00:17:24,277 --> 00:17:27,146
the Open Book intent
will automatically be performed


371
00:17:27,146 --> 00:17:31,350
after the Add Book intent
finishes.


372
00:17:31,350 --> 00:17:35,054
There's a lot more you can do
with entities and queries.


373
00:17:35,054 --> 00:17:36,622
With the next set of APIs,


374
00:17:36,622 --> 00:17:39,325
AppIntents opens up
some powerful abilities


375
00:17:39,325 --> 00:17:43,496
you never had before with
the SiriKit Intents framework.


376
00:17:43,496 --> 00:17:45,998
Let's take a look at how
you can expose more information


377
00:17:45,998 --> 00:17:47,300
from your entities,


378
00:17:47,300 --> 00:17:52,305
and allow customers to find
and filter based on that.


379
00:17:52,305 --> 00:17:55,174
So far, I've added
all the basic requirements


380
00:17:55,174 --> 00:17:56,676
to my book entity.


381
00:17:56,676 --> 00:17:58,144
But to let people
integrate books


382
00:17:58,144 --> 00:18:00,246
more deeply
into their shortcuts,


383
00:18:00,246 --> 00:18:05,084
I'm going to need to expose
a bit more about my books.


384
00:18:05,084 --> 00:18:07,119
Entities support properties,


385
00:18:07,119 --> 00:18:09,422
which hold additional
information on the entity


386
00:18:09,422 --> 00:18:11,991
that you want to expose
to users.


387
00:18:11,991 --> 00:18:13,993
In this case,
I'll add the book's author,


388
00:18:13,993 --> 00:18:16,996
publishing date, read date,
and who recommended it,


389
00:18:16,996 --> 00:18:22,068
so that people can use those
properties in their shortcuts.


390
00:18:22,068 --> 00:18:24,070
I add properties
to my BookEntity


391
00:18:24,070 --> 00:18:27,340
using a property wrapper
called @Property.


392
00:18:27,340 --> 00:18:30,242
Properties support all the same
types that parameters do,


393
00:18:30,242 --> 00:18:35,514
and each one
takes a localized title.


394
00:18:35,514 --> 00:18:37,249
With these new properties,


395
00:18:37,249 --> 00:18:40,386
my customers can now use
magic variables in Shortcuts


396
00:18:40,386 --> 00:18:42,688
to pull out each new
piece of information


397
00:18:42,688 --> 00:18:45,291
when working with
a book entity


398
00:18:45,291 --> 00:18:47,660
When using
the earlier Add Book intent,


399
00:18:47,660 --> 00:18:49,996
they can use the author
or publishing date


400
00:18:49,996 --> 00:18:52,999
of a newly added book
in their shortcuts.


401
00:18:55,134 --> 00:18:57,670
When you combine properties
with queries,


402
00:18:57,670 --> 00:19:00,606
your app automatically
gets these incredibly powerful


403
00:19:00,606 --> 00:19:03,075
Find and Filter actions
in Shortcuts,


404
00:19:03,075 --> 00:19:06,545
with this flexible
predicate editor UI.


405
00:19:06,545 --> 00:19:09,315
Now, my customers will be
able to find and filter books


406
00:19:09,315 --> 00:19:13,052
based on date read, title,
author, and more.


407
00:19:13,052 --> 00:19:14,553
It's a piece of cake to find


408
00:19:14,553 --> 00:19:18,758
all the books by Delia Owens,
for example.


409
00:19:18,758 --> 00:19:20,659
Using the Sort by
and Limit options,


410
00:19:20,659 --> 00:19:22,728
you can support even more
advanced queries,


411
00:19:22,728 --> 00:19:25,064
like find the three
most recently published books


412
00:19:25,064 --> 00:19:27,867
by Delia Owens.


413
00:19:27,867 --> 00:19:30,002
A customer can use
these building blocks


414
00:19:30,002 --> 00:19:32,371
to do some pretty cool stuff,
like finding


415
00:19:32,371 --> 00:19:36,042
the three most common authors
in their collection.


416
00:19:36,042 --> 00:19:37,276
To enable all this,


417
00:19:37,276 --> 00:19:39,678
I'll need to adopt
another kind of query


418
00:19:39,678 --> 00:19:41,914
called a property query.


419
00:19:41,914 --> 00:19:44,917
Property queries find entities
not based on a string,


420
00:19:44,917 --> 00:19:50,389
or an identifier, but on the
properties within the entity.


421
00:19:50,389 --> 00:19:53,592
There are three steps to
implementing property queries.


422
00:19:53,592 --> 00:19:55,928
First, you declare
query properties,


423
00:19:55,928 --> 00:19:58,364
which specify how your entity
can be searched


424
00:19:58,364 --> 00:20:00,633
using its properties.


425
00:20:00,633 --> 00:20:02,468
Then, you add sorting options,


426
00:20:02,468 --> 00:20:06,372
which define how query results
can be sorted.


427
00:20:06,372 --> 00:20:09,475
And finally, you implement
entities(matching:)


428
00:20:09,475 --> 00:20:12,211
to run the search.


429
00:20:12,211 --> 00:20:13,446
The query properties


430
00:20:13,446 --> 00:20:16,215
declare every way
AppIntents can search


431
00:20:16,215 --> 00:20:19,518
on the entity associated
with this query.


432
00:20:19,518 --> 00:20:21,987
Each one lists
a property of my entity,


433
00:20:21,987 --> 00:20:23,789
and the comparison operators --


434
00:20:23,789 --> 00:20:26,125
like contains, equal to,
or less than --


435
00:20:26,125 --> 00:20:28,527
that are available for it.


436
00:20:28,527 --> 00:20:31,530
Here, I list "less than"
and "greater than" comparators


437
00:20:31,530 --> 00:20:33,332
for my date properties,


438
00:20:33,332 --> 00:20:38,671
and "contains" and "equal to"
for my title property.


439
00:20:38,671 --> 00:20:41,507
Query properties
map each combination


440
00:20:41,507 --> 00:20:45,544
of property and comparator
into a type of your choice,


441
00:20:45,544 --> 00:20:48,047
called
the comparator mapping type.


442
00:20:48,047 --> 00:20:51,951
Here, I am using CoreData,
so I'll use an NSPredicate.


443
00:20:51,951 --> 00:20:55,221
If I was using a custom database
or a REST API,


444
00:20:55,221 --> 00:20:57,523
I could design
my own comparator type


445
00:20:57,523 --> 00:21:00,593
and use that instead.


446
00:21:00,593 --> 00:21:04,196
Here's the code to set up the
query properties for my books.


447
00:21:04,196 --> 00:21:08,667
I conform BooksQuery to the
EntityPropertyQuery protocol.


448
00:21:08,667 --> 00:21:11,570
Then I implement
static var properties


449
00:21:11,570 --> 00:21:15,274
using the QueryProperties
result builder.


450
00:21:15,274 --> 00:21:18,144
Each entry specifies
a keyPath of a Property


451
00:21:18,144 --> 00:21:20,379
that can be queried,
and within it,


452
00:21:20,379 --> 00:21:24,183
each comparator that is
applicable to that property.


453
00:21:24,183 --> 00:21:26,685
For each comparator,
I provide an NSPredicate,


454
00:21:26,685 --> 00:21:31,457
because I've chosen NSPredicate
as my comparator mapping type.


455
00:21:31,457 --> 00:21:35,194
When the system asks my app
to return results for the query,


456
00:21:35,194 --> 00:21:37,096
it will provide back
the NSPredicates


457
00:21:37,096 --> 00:21:39,965
that I'm constructing here.


458
00:21:39,965 --> 00:21:42,701
There's a similar definition
for sorting.


459
00:21:42,701 --> 00:21:44,403
This is a list
of all the properties


460
00:21:44,403 --> 00:21:46,639
my model can sort books by.


461
00:21:46,639 --> 00:21:48,841
In this case,
I allow sorting by title,


462
00:21:48,841 --> 00:21:52,178
date read,
and date published.


463
00:21:52,178 --> 00:21:55,214
Finally, I implement
entities(matching:),


464
00:21:55,214 --> 00:21:59,151
which queries my database
and returns matching entities.


465
00:21:59,151 --> 00:22:02,521
This method takes an array
of the comparator mapping type


466
00:22:02,521 --> 00:22:05,925
I used in the previously defined
query parameters --


467
00:22:05,925 --> 00:22:07,893
in this case,
NSPredicate.


468
00:22:07,893 --> 00:22:11,030
These predicates
are describing what criteria


469
00:22:11,030 --> 00:22:15,034
on the properties of my entity
I want to query by.


470
00:22:15,034 --> 00:22:16,468
It also takes a mode,


471
00:22:16,468 --> 00:22:18,504
indicating whether
to combine the predicates


472
00:22:18,504 --> 00:22:22,541
with "and" or with "or,"
key paths to sort by,


473
00:22:22,541 --> 00:22:26,378
and an optional limit
for the number of results.


474
00:22:26,378 --> 00:22:28,647
My implementation
uses these parameters


475
00:22:28,647 --> 00:22:34,453
to perform a query against
my CoreData database.


476
00:22:34,453 --> 00:22:37,389
What can customers do
with this property query?


477
00:22:37,389 --> 00:22:40,960
They can pick a random book
from their library to read.


478
00:22:40,960 --> 00:22:42,494
They can find all their books


479
00:22:42,494 --> 00:22:45,831
published in the early part
of the twentieth century.


480
00:22:45,831 --> 00:22:48,267
They can leverage
the Shortcuts ecosystem


481
00:22:48,267 --> 00:22:51,570
and make my app more useful
by connecting it to others.


482
00:22:51,570 --> 00:22:53,572
For example, they can use
a spreadsheet app


483
00:22:53,572 --> 00:22:57,476
to export all the books they
read this year to a CSV file.


484
00:22:57,476 --> 00:22:59,778
Or, they can use a graphing app
to make a chart


485
00:22:59,778 --> 00:23:03,282
of how many books they've read
every year over the last 10.


486
00:23:03,282 --> 00:23:04,917
And that's just the beginning.


487
00:23:04,917 --> 00:23:07,319
This kind of deep
App Intents adoption


488
00:23:07,319 --> 00:23:09,255
really lets customers
use your app


489
00:23:09,255 --> 00:23:11,323
to do what they need it to do,


490
00:23:11,323 --> 00:23:14,326
making it a critical part
of their workflow.


491
00:23:14,326 --> 00:23:15,861
Each of these integrations --


492
00:23:15,861 --> 00:23:17,930
like making graphs,
for example --


493
00:23:17,930 --> 00:23:21,734
is a feature
you don't have to build.


494
00:23:21,734 --> 00:23:23,502
When your intents
are performed,


495
00:23:23,502 --> 00:23:25,771
your app may need
to interact with the user


496
00:23:25,771 --> 00:23:29,141
to show or speak a result,
or to resolve ambiguity,


497
00:23:29,141 --> 00:23:32,945
whether it's a Siri request
or a shortcut.


498
00:23:32,945 --> 00:23:36,515
App Intents supports
a number of these interactions:


499
00:23:36,515 --> 00:23:38,851
dialog for giving text
and voice feedback


500
00:23:38,851 --> 00:23:41,453
to your users
when an intent has completed,


501
00:23:41,453 --> 00:23:43,989
and snippets
for giving visual feedback.


502
00:23:43,989 --> 00:23:46,258
Request value and disambiguation


503
00:23:46,258 --> 00:23:50,362
for asking the user to clarify
values for intent parameters,


504
00:23:50,362 --> 00:23:53,732
and confirmation for verifying
parameter values


505
00:23:53,732 --> 00:23:55,167
or checking with the user


506
00:23:55,167 --> 00:23:59,438
on intents that are
transactional or destructive.


507
00:23:59,438 --> 00:24:02,541
Dialog provides
a spoken or textual response


508
00:24:02,541 --> 00:24:04,576
to the person
running an intent.


509
00:24:04,576 --> 00:24:06,712
It's really important
to provide dialog


510
00:24:06,712 --> 00:24:10,182
for intents to work well
in a voice experience.


511
00:24:10,182 --> 00:24:12,117
In my Add Book intent
from earlier,


512
00:24:12,117 --> 00:24:13,819
I'll add a needsValueDialog


513
00:24:13,819 --> 00:24:16,221
that's spoken
when asking for a book title


514
00:24:16,221 --> 00:24:20,025
and a result dialog returned
from my perform method.


515
00:24:20,025 --> 00:24:22,728
These will be read or shown
by Shortcuts or Siri


516
00:24:22,728 --> 00:24:25,864
across our many platforms.


517
00:24:25,864 --> 00:24:30,402
You can think of snippets as
the visual equivalent of dialog,


518
00:24:30,402 --> 00:24:32,538
letting you add
a visual representation


519
00:24:32,538 --> 00:24:34,940
to the result of your intent.


520
00:24:34,940 --> 00:24:38,210
To use a snippet, just add
the SwiftUI view of your choice


521
00:24:38,210 --> 00:24:42,348
as a trailing closure
to your intent result.


522
00:24:42,348 --> 00:24:46,018
Like with a widget, your SwiftUI
view will be archived


523
00:24:46,018 --> 00:24:51,256
and sent over
to Shortcuts or Siri.


524
00:24:51,256 --> 00:24:54,560
App Intents also supports
asking the user for a value


525
00:24:54,560 --> 00:24:56,729
by throwing requestValue.


526
00:24:56,729 --> 00:24:59,431
For example, this comes in handy
when you need a value


527
00:24:59,431 --> 00:25:02,768
for a parameter
that is sometimes optional.


528
00:25:02,768 --> 00:25:06,105
Here, requestValue helps me
when my string search


529
00:25:06,105 --> 00:25:08,273
returns more than one book.


530
00:25:08,273 --> 00:25:10,542
In this case,
I prompt and ask for an author


531
00:25:10,542 --> 00:25:12,778
to narrow the book search down.


532
00:25:12,778 --> 00:25:15,481
requestValue gives me
an error I can throw,


533
00:25:15,481 --> 00:25:17,015
which will prompt the user,


534
00:25:17,015 --> 00:25:21,954
and rerun the action
with the updated author name.


535
00:25:21,954 --> 00:25:24,022
Disambiguation,
meanwhile,


536
00:25:24,022 --> 00:25:25,924
is great when you need
the user to choose


537
00:25:25,924 --> 00:25:29,328
between a set of values
for a parameter.


538
00:25:29,328 --> 00:25:31,463
This gives me an even better
way to handle


539
00:25:31,463 --> 00:25:35,801
multiple possible results
in my Add Book action.


540
00:25:35,801 --> 00:25:39,204
Here, I get a list of author
names from the generated books,


541
00:25:39,204 --> 00:25:43,075
and request disambiguation
with those possible values.


542
00:25:43,075 --> 00:25:45,077
The user will be asked
to pick between them,


543
00:25:45,077 --> 00:25:49,148
and I'll get the result back.


544
00:25:49,148 --> 00:25:53,685
Lastly, App Intents supports two
different kinds of confirmation.


545
00:25:53,685 --> 00:25:57,623
The first kind is confirmation
of a parameter value.


546
00:25:57,623 --> 00:25:59,191
You might use this
when you have a guess


547
00:25:59,191 --> 00:26:02,161
at what that value should be
but you want to confirm,


548
00:26:02,161 --> 00:26:04,329
just to make sure.


549
00:26:04,329 --> 00:26:05,597
When adding a book,


550
00:26:05,597 --> 00:26:08,834
sometimes the web service I call
to look up books by title


551
00:26:08,834 --> 00:26:10,235
returns a couple matches,


552
00:26:10,235 --> 00:26:13,105
but one of them is by far
the more popular.


553
00:26:13,105 --> 00:26:15,274
In these cases,
I'm going to assume


554
00:26:15,274 --> 00:26:17,976
that the user meant
to add that popular book,


555
00:26:17,976 --> 00:26:21,380
but I'll add confirmation
to make sure I got it right.


556
00:26:21,380 --> 00:26:23,682
To do that,
I'll call requestConfirmation


557
00:26:23,682 --> 00:26:26,285
on the title parameter.


558
00:26:26,285 --> 00:26:28,854
The second kind
is a confirmation


559
00:26:28,854 --> 00:26:31,023
of the result of an intent.


560
00:26:31,023 --> 00:26:33,926
This is great for placing
orders, for example.


561
00:26:33,926 --> 00:26:35,961
If I wanted to monetize
my Library app


562
00:26:35,961 --> 00:26:38,263
and add ordering
through a bookstore,


563
00:26:38,263 --> 00:26:41,400
I'd want to make sure
that I have the order right.


564
00:26:41,400 --> 00:26:44,102
To do this, I could call
requestConfirmation


565
00:26:44,102 --> 00:26:47,706
on my intent, passing in
the order to be placed.


566
00:26:47,706 --> 00:26:52,344
I'll specify a snippet here too,
showing a preview of the order.


567
00:26:52,344 --> 00:26:55,047
I prefix the call with "try"
because requestConfirmation


568
00:26:55,047 --> 00:26:57,716
will throw an error
if the user cancels


569
00:26:57,716 --> 00:27:00,886
instead of confirming.


570
00:27:00,886 --> 00:27:02,955
Before I leave you,
there are a couple aspects


571
00:27:02,955 --> 00:27:05,824
of the App Intents
architecture I want to cover,


572
00:27:05,824 --> 00:27:09,628
which you should know
as you adopt the framework.


573
00:27:09,628 --> 00:27:12,731
There are actually two ways
to build your App Intents:


574
00:27:12,731 --> 00:27:16,034
within your app
or in a separate extension.


575
00:27:16,034 --> 00:27:18,804
Of these, implementing intents
directly in your app


576
00:27:18,804 --> 00:27:20,839
is the simplest.


577
00:27:20,839 --> 00:27:23,108
This is great because
you don't need a framework


578
00:27:23,108 --> 00:27:25,244
or to duplicate your code,


579
00:27:25,244 --> 00:27:28,647
and you don't need to coordinate
across processes.


580
00:27:28,647 --> 00:27:31,483
Using your app also gives
some higher memory limits,


581
00:27:31,483 --> 00:27:34,119
and it gives you the ability
to do some kinds of work


582
00:27:34,119 --> 00:27:36,021
that are harder
from an extension,


583
00:27:36,021 --> 00:27:39,625
like playing audio.


584
00:27:39,625 --> 00:27:41,493
Your app can be run
in the foreground


585
00:27:41,493 --> 00:27:45,631
if you implement openAppWhenRun
on your intent to return true.


586
00:27:45,631 --> 00:27:48,600
Otherwise, it will be run
in the background.


587
00:27:48,600 --> 00:27:50,168
When running in the background,


588
00:27:50,168 --> 00:27:52,070
your app will launch
in a special mode


589
00:27:52,070 --> 00:27:55,574
without scenes being brought up
to maximize performance.


590
00:27:55,574 --> 00:27:58,577
In fact, if you implement
background app intents


591
00:27:58,577 --> 00:27:59,678
in your app,


592
00:27:59,678 --> 00:28:05,450
we strongly encourage you
to also implement scene support.


593
00:28:05,450 --> 00:28:08,820
Or, you can build your
app intents in an extension.


594
00:28:08,820 --> 00:28:10,923
This has a couple advantages.


595
00:28:10,923 --> 00:28:11,823
It's lighter weight,


596
00:28:11,823 --> 00:28:15,260
because the extension process
only handles app intents


597
00:28:15,260 --> 00:28:18,363
and doesn't require
spinning up your app.


598
00:28:18,363 --> 00:28:20,732
If you are handling
Focus intents,


599
00:28:20,732 --> 00:28:23,201
using an extension also means
that you'll immediately


600
00:28:23,201 --> 00:28:25,837
get intents performed
on your extension


601
00:28:25,837 --> 00:28:28,140
when Focus changes,
without the requirement


602
00:28:28,140 --> 00:28:32,044
that your app is running
in the foreground first.


603
00:28:32,044 --> 00:28:33,645
An extension is a bit more work,


604
00:28:33,645 --> 00:28:35,747
since you'll need
to add a new target,


605
00:28:35,747 --> 00:28:37,249
move some code
into a framework,


606
00:28:37,249 --> 00:28:39,251
and handle coordination
between your app


607
00:28:39,251 --> 00:28:43,021
and the extension.


608
00:28:43,021 --> 00:28:45,057
To create an App Intents
extension,


609
00:28:45,057 --> 00:28:47,259
go to File > New Target
in Xcode


610
00:28:47,259 --> 00:28:52,064
and choose
App Intents Extension.


611
00:28:52,064 --> 00:28:56,735
With App Intents, your code
is the only source of truth.


612
00:28:56,735 --> 00:28:59,605
App Intents achieves this
elegant developer experience


613
00:28:59,605 --> 00:29:02,941
by statically extracting
information about your intents,


614
00:29:02,941 --> 00:29:06,912
entities, queries,
and parameters at build time.


615
00:29:06,912 --> 00:29:10,048
Xcode will generate
a metadata file inside your app


616
00:29:10,048 --> 00:29:12,651
or extension bundle
during your build process,


617
00:29:12,651 --> 00:29:15,787
containing information received
from the Swift compiler


618
00:29:15,787 --> 00:29:18,290
as it runs on your code.


619
00:29:18,290 --> 00:29:21,393
To make sure all of this works,
keep your App Intents types


620
00:29:21,393 --> 00:29:25,731
directly in the target or
extension, not in a framework.


621
00:29:25,731 --> 00:29:27,466
Similarly,
your localized strings


622
00:29:27,466 --> 00:29:29,401
should be found
in a strings file


623
00:29:29,401 --> 00:29:34,506
within the same bundle where
your App Intents types live.


624
00:29:34,506 --> 00:29:36,775
For those of you
who have existing apps


625
00:29:36,775 --> 00:29:39,778
with SiriKit Intents
that you want to upgrade,


626
00:29:39,778 --> 00:29:42,848
if you adopt intents
to integrate with widgets,


627
00:29:42,848 --> 00:29:45,317
or domains like messaging
or media,


628
00:29:45,317 --> 00:29:48,754
you should keep using
the SiriKit Intents framework.


629
00:29:48,754 --> 00:29:51,823
But if you add custom intents
for Siri and Shortcuts,


630
00:29:51,823 --> 00:29:55,160
you should go ahead and upgrade
to App Intents.


631
00:29:55,160 --> 00:29:57,162
You can start
the upgrade process by clicking


632
00:29:57,162 --> 00:29:59,398
the Convert to App Intent
button


633
00:29:59,398 --> 00:30:04,436
in your SiriKit Intents
definition file.


634
00:30:04,436 --> 00:30:06,938
Integrating your app into
Shortcuts with App Intents


635
00:30:06,938 --> 00:30:10,776
is a great way to maximize
your leverage as a developer,


636
00:30:10,776 --> 00:30:14,212
because by doing a small amount
of work to adopt App Intents,


637
00:30:14,212 --> 00:30:17,783
you create a large amount
of value for customers.


638
00:30:17,783 --> 00:30:18,884
Thank you for joining!


639
00:30:18,884 --> 00:30:21,753
I really hope that you'll
try out App Intents today


640
00:30:21,753 --> 00:30:23,321
and give us your feedback.


641
00:30:23,321 --> 00:30:25,190
I'm excited about
how this new framework


642
00:30:25,190 --> 00:30:27,993
can help you surprise,
delight, and empower folks


643
00:30:27,993 --> 00:30:29,494
using your apps!


644
00:30:29,494 --> 00:30:33,365
Happy reading and
hope your WWDC is epic!


645
00:30:33,365 --> 00:30:37,636 line:0 position:90% size:2%
♪

