2
00:00:00,501 --> 00:00:08,509 line:-1
â™ª â™ª


3
00:00:09.676 --> 00:00:13.180 line:-2 align:center
Nick Kledzik: Hi, I'm Nick Kledzik,
lead Engineer on Apple's Linker team.


4
00:00:13,213 --> 00:00:16,316 line:-2
Today, I'd like to share with you
how to link fast.


5
00:00:16.350 --> 00:00:18.752 line:-2 align:center
I'll tell you what Apple has done
to improve linking,


6
00:00:18.785 --> 00:00:21.622 line:-2 align:center
as well as help you understand
what actually happens during linking


7
00:00:21,655 --> 00:00:25,325 line:-2
so that you can improve
your app's link performance.


8
00:00:25.359 --> 00:00:27.394 line:-1 align:center
So what is linking?


9
00:00:27,427 --> 00:00:31,198 line:-2
You've written code, but you also use code
that someone else wrote


10
00:00:31,231 --> 00:00:33,734 line:-1
in the form of a library or a framework.


11
00:00:33.767 --> 00:00:38.172 line:-2 align:center
In order for your code to use
those libraries, a linker is needed.


12
00:00:38.205 --> 00:00:41.141 line:-2 align:center
Now, there are actually
two types of linking.


13
00:00:41.175 --> 00:00:44.711 line:-2 align:center
There is "static linking",
which happens when you build your app.


14
00:00:44,745 --> 00:00:47,214 line:-2
This can impact how long it takes
for your app to build


15
00:00:47,247 --> 00:00:50,350 line:-1
and how big your app ends up being.


16
00:00:50.384 --> 00:00:52.452 line:-1 align:center
And there is "dynamic linking".


17
00:00:52,486 --> 00:00:54,821 line:-1
This happens when your app is launched.


18
00:00:54.855 --> 00:00:59.393 line:-2 align:center
This can impact how long your customers
have to wait for your app to launch.


19
00:00:59,426 --> 00:01:04,464 line:-2
In this session I'll be talking about
both static and dynamic linking.


20
00:01:04.498 --> 00:01:08.101 line:-2 align:center
First, I'll define what static linking is
and where it came from,


21
00:01:08,135 --> 00:01:10,437 line:-1
with some examples.


22
00:01:10.470 --> 00:01:16.476 line:-2 align:center
Next, I'll unveil what is new
in ld64, Apple's static linker.


23
00:01:16,510 --> 00:01:18,779 line:-2
Then, with this background
on static linking,


24
00:01:18,812 --> 00:01:22,950 line:-2
I'll detail best practices
for static linking.


25
00:01:22.983 --> 00:01:26.286 line:-2 align:center
The second half of this talk
will cover dynamic linking.


26
00:01:26.320 --> 00:01:29.489 line:-2 align:center
I'll show what dynamic linking is
and where it came from,


27
00:01:29.523 --> 00:01:32.960 line:-1 align:center
and what happens during dynamic linking.


28
00:01:32.993 --> 00:01:37.998 line:-2 align:center
Next, I'll reveal what is new
in dyld this year.


29
00:01:38.031 --> 00:01:41.235 line:-2 align:center
Then, I'll talk about what you can do
to improve your app's


30
00:01:41.268 --> 00:01:44.738 line:-1 align:center
dynamic link time performance.


31
00:01:44.771 --> 00:01:47.908 line:-2 align:center
And lastly,
we'll wrap up with two new tools


32
00:01:47.941 --> 00:01:50.444 line:-2 align:center
that will help you
peek behind the curtains.


33
00:01:50.477 --> 00:01:53.280 line:-2 align:center
You'll be able to see
what is in your binaries,


34
00:01:53,313 --> 00:01:57,651 line:-2
and what is happening during
dynamic linking.


35
00:01:57.684 --> 00:01:59.553 line:-1 align:center
To understand static linking,


36
00:01:59,586 --> 00:02:02,589 line:-1
let's go way back to when it all started.


37
00:02:02,623 --> 00:02:06,927 line:-2
In the beginning, programs were simple
and there was just one source file.


38
00:02:06.960 --> 00:02:08.228 line:-1 align:center
Building was easy.


39
00:02:08,262 --> 00:02:10,664 line:-2
You just ran the compiler
on your one source file


40
00:02:10.697 --> 00:02:13.567 line:-1 align:center
and it produced the executable program.


41
00:02:13,600 --> 00:02:18,205 line:-2
But having all your source code
in one file did not scale.


42
00:02:18.238 --> 00:02:21.141 line:-2 align:center
How do you build
with multiple source files?


43
00:02:21.175 --> 00:02:24.745 line:-2 align:center
And this is not just because
you don't want to edit a large text file.


44
00:02:24.778 --> 00:02:27.581 line:-2 align:center
The real savings is
not re-compiling every function,


45
00:02:27,614 --> 00:02:29,583 line:-1
every time you build.


46
00:02:29.616 --> 00:02:33.387 line:-2 align:center
What they did was to split the compiler
into two parts.


47
00:02:33,420 --> 00:02:35,489 line:-1
The first part compiles source code


48
00:02:35,522 --> 00:02:39,793 line:-2
to a new intermediate
"relocatable object" file.


49
00:02:39.826 --> 00:02:42.863 line:-2 align:center
The second part reads
the relocatable .o file


50
00:02:42.896 --> 00:02:45.499 line:-1 align:center
and produces an executable program.


51
00:02:45,532 --> 00:02:49,369 line:-2
We now call the second part 'ld',
the static linker.


52
00:02:49.403 --> 00:02:52.873 line:-2 align:center
So now you know
where static linking came from.


53
00:02:52,906 --> 00:02:56,944 line:-2
As software evolved,
soon people were passing around .o files.


54
00:02:56,977 --> 00:02:58,879 line:-1
But that got cumbersome.


55
00:02:58.912 --> 00:03:01.248 line:-2 align:center
Someone thought, "Wouldn't it be great
if we could package up


56
00:03:01.281 --> 00:03:04.818 line:-1 align:center
a set of .o files into a 'library'?"


57
00:03:04,852 --> 00:03:07,120 line:-2
At the time the standard way
to bundle files together


58
00:03:07.154 --> 00:03:09.656 line:-1 align:center
was with the archiving tool 'ar'.


59
00:03:09,690 --> 00:03:12,226 line:-1
It was used for backups and distributions.


60
00:03:12.259 --> 00:03:15.629 line:-1 align:center
So the workflow became this.


61
00:03:15.662 --> 00:03:19.433 line:-2 align:center
You could 'ar' up multiple .o files
into an archive,


62
00:03:19.466 --> 00:03:22.870 line:-2 align:center
and the linker was enhanced
to know how to read .o files directly


63
00:03:22,903 --> 00:03:25,172 line:-1
out of an archive file.


64
00:03:25,205 --> 00:03:28,408 line:-2
This was a great improvement
for sharing common code.


65
00:03:28,442 --> 00:03:32,212 line:-2
At the time it was just called a library
or an archive.


66
00:03:32,246 --> 00:03:35,382 line:-1
Today, we call it a static library.


67
00:03:35.415 --> 00:03:39.253 line:-2 align:center
But now the final program was getting big
because thousands of functions


68
00:03:39.286 --> 00:03:41.488 line:-1 align:center
from these libraries were copied into it,


69
00:03:41.522 --> 00:03:44.658 line:-2 align:center
even if only a few of those functions
were used.


70
00:03:44,691 --> 00:03:46,894 line:-1
So a clever optimization was added.


71
00:03:46.927 --> 00:03:51.131 line:-2 align:center
Instead of having the linker use
all the .o files from the static library,


72
00:03:51,164 --> 00:03:54,468 line:-2
the linker would only pull
.o files from a static library


73
00:03:54.501 --> 00:03:57.838 line:-2 align:center
if doing so would resolve
some undefined symbol.


74
00:03:57.871 --> 00:04:01.675 line:-2 align:center
That meant someone could build
a big libc.a static library,


75
00:04:01.708 --> 00:04:05.078 line:-2 align:center
which contained
all the C standard library functions.


76
00:04:05,112 --> 00:04:08,215 line:-2
Every program
could link with the one libc.a,


77
00:04:08.248 --> 00:04:12.819 line:-2 align:center
but each program only got the parts
of libc that the program actually needed.


78
00:04:12,853 --> 00:04:15,022 line:-1
And we still have that model today.


79
00:04:15,055 --> 00:04:17,991 line:-2
But the selective loading from static
libraries is not obvious


80
00:04:18.025 --> 00:04:20.761 line:-1 align:center
and trips up many programmers.


81
00:04:20.794 --> 00:04:24.631 line:-2 align:center
To make the selective loading
of static libraries a little clearer,


82
00:04:24.665 --> 00:04:26.567 line:-1 align:center
I have a simple scenario.


83
00:04:26,600 --> 00:04:32,573 line:-2
In main.c, there's a function
called "main" that calls a function "foo".


84
00:04:32,606 --> 00:04:36,777 line:-1
In foo.c, there is foo which calls bar.


85
00:04:36,810 --> 00:04:39,713 line:-2
In bar.c,
there is the implementation of bar


86
00:04:39.746 --> 00:04:45.252 line:-2 align:center
but also an implementation of another
function which happens to be unused.


87
00:04:45,285 --> 00:04:51,592 line:-2
Lastly, in baz.c, there is a function baz
which calls a function named undef.


88
00:04:51.625 --> 00:04:56.363 line:-1 align:center
Now we compile each to its own .o file.


89
00:04:56,396 --> 00:05:00,501 line:0
You'll see foo, bar, and undef
don't have gray boxes


90
00:05:00,534 --> 00:05:02,469 line:0
because they are undefined.


91
00:05:02,503 --> 00:05:06,340 align:center
That is, a use of a symbol
and not a definition.


92
00:05:06,373 --> 00:05:12,746 align:center
Now, let's say you decide to combine
bar.o and baz.o into a static library.


93
00:05:12,779 --> 00:05:16,817 line:0
Next, you link the two .o files
and the static library.


94
00:05:16,850 --> 00:05:19,119 align:center
Let's step through what actually happens.


95
00:05:20.053 --> 00:05:23.757 line:-2 align:center
First, the linker works through the files
in command line order.


96
00:05:23.790 --> 00:05:26.560 line:-1 align:center
The first it finds is main.o.


97
00:05:26,593 --> 00:05:29,663 line:-2
It loads main.o
and finds a definition for "main",


98
00:05:29,696 --> 00:05:31,632 line:-1
shown here in the symbol table.


99
00:05:31.665 --> 00:05:36.370 line:-2 align:center
But also finds that main
has an undefined "foo".


100
00:05:36.403 --> 00:05:41.642 line:-2 align:center
The linker then parses the next file
on the command line which is foo.o.


101
00:05:41.675 --> 00:05:44.211 line:-1 align:center
This file adds a definition of "foo".


102
00:05:44.244 --> 00:05:47.214 line:-1 align:center
That means foo is no longer undefined.


103
00:05:47,247 --> 00:05:52,586 line:-2
But loading foo.o also adds
a new undefined symbol for "bar".


104
00:05:52,619 --> 00:05:55,989 line:-2
Now that all the .o files
on the command line have been loaded,


105
00:05:56.023 --> 00:05:59.593 line:-2 align:center
the linker checks if there are
any remaining undefined symbols.


106
00:05:59,626 --> 00:06:02,663 line:-1
In this case "bar" remains undefined,


107
00:06:02.696 --> 00:06:06.033 line:-2 align:center
so the linker starts looking at libraries
on the command line


108
00:06:06.066 --> 00:06:10.637 line:-2 align:center
to see if a library will satisfy
that missing undefined symbol "bar".


109
00:06:10,671 --> 00:06:16,276 line:-2
The linker finds that bar.o in the static
library defines the symbol "bar".


110
00:06:16,310 --> 00:06:20,147 line:-2
So the linker loads bar.o
out of the archive.


111
00:06:20,180 --> 00:06:23,250 line:-2
At that point there are no longer
any undefined symbols,


112
00:06:23.283 --> 00:06:26.920 line:-1 align:center
so the linker stops processing libraries.


113
00:06:26,954 --> 00:06:29,389 line:-1
The linker moves on to its next phase,


114
00:06:29,423 --> 00:06:31,625 line:-2
and assigns addresses to all the functions
and data


115
00:06:31.658 --> 00:06:33.794 line:-1 align:center
that will be in the program.


116
00:06:33,827 --> 00:06:38,198 line:-2
Then it copies all the functions
and data to the output file.


117
00:06:38,232 --> 00:06:40,801 line:-2
Et voila!
You have your output program.


118
00:06:40.834 --> 00:06:46.607 line:-2 align:center
Notice that baz.o was in the static
library but not loaded into the program.


119
00:06:46,640 --> 00:06:50,344 line:-2
It was not loaded because the way
the linker selectively loads


120
00:06:50,377 --> 00:06:52,179 line:-1
from static libraries.


121
00:06:52.212 --> 00:06:56.450 line:-2 align:center
This is non-obvious,
but the key aspect of static libraries.


122
00:06:56.483 --> 00:07:00.721 line:-2 align:center
Now you understand the basics
of static linking and static libraries.


123
00:07:00,754 --> 00:07:03,790 line:-2
Let's move on to recent improvements
on Apple's static linker,


124
00:07:03,824 --> 00:07:06,026 line:-1
known as ld64.


125
00:07:06.059 --> 00:07:10.297 line:-2 align:center
By popular demand, we spent some time
this year optimizing ld64.


126
00:07:10,330 --> 00:07:12,466 line:-1
And this year's linker is...


127
00:07:12.499 --> 00:07:15.269 line:-1 align:center
twice as fast for many projects.


128
00:07:15.302 --> 00:07:16.603 line:-1 align:center
How did we do this?


129
00:07:16.637 --> 00:07:21.008 line:-2 align:center
We now make better use of the cores
on your development machine.


130
00:07:21,041 --> 00:07:23,544 line:-2
We found a number of areas
where we could use multiple cores


131
00:07:23,577 --> 00:07:25,913 line:-1
to do linker work in parallel.


132
00:07:25.946 --> 00:07:30.918 line:-2 align:center
That includes copying content
from the input to the output file,


133
00:07:30.951 --> 00:07:34.454 line:-2 align:center
building the different parts
of LINKEDIT in parallel,


134
00:07:34.488 --> 00:07:37.291 line:-1 align:center
and changing the UUID computation


135
00:07:37.324 --> 00:07:40.527 line:-2 align:center
and codesigning hashes
to be done in parallel.


136
00:07:40.561 --> 00:07:44.064 line:-1 align:center
Next, we improved a number of algorithms.


137
00:07:44.097 --> 00:07:47.034 line:-2 align:center
Turns out the exports-trie builder
works really well


138
00:07:47,067 --> 00:07:49,870 line:-2
if you switch to use
C++ string_view objects


139
00:07:49.903 --> 00:07:53.273 line:-2 align:center
to represent the string slices
of each symbol.


140
00:07:53,307 --> 00:07:55,843 line:-1
We also used the latest crypto libraries


141
00:07:55.876 --> 00:07:58.178 line:-2 align:center
which take advantage
of hardware acceleration


142
00:07:58.212 --> 00:08:01.381 line:-1 align:center
when computing the UUID of a binary,


143
00:08:01,415 --> 00:08:03,884 line:-1
and we improved other algorithms too.


144
00:08:04,952 --> 00:08:07,521 line:-2
While working on
improving linker performance,


145
00:08:07.554 --> 00:08:12.526 line:-2 align:center
we noticed configuration issues
in some apps that impacted link time.


146
00:08:12,559 --> 00:08:17,331 line:-2
Next, I'll talk about what you can do
in your project to improve link time.


147
00:08:17.364 --> 00:08:19.333 line:-1 align:center
I'll cover five topics.


148
00:08:19,366 --> 00:08:22,202 line:-2
First,
whether you should use static libraries.


149
00:08:22,236 --> 00:08:27,040 line:-2
And then three little known options
that have a big effect on your link time.


150
00:08:27,074 --> 00:08:32,145 line:-2
Finally, I'll discuss some static linking
behavior that might surprise you.


151
00:08:32.179 --> 00:08:35.516 line:-2 align:center
The first topic is if you are
actively working on a source file


152
00:08:35.549 --> 00:08:37.618 line:-1 align:center
that builds into a static library,


153
00:08:37,651 --> 00:08:40,454 line:-2
you've introduced
a slowdown to your build time.


154
00:08:40,487 --> 00:08:42,322 line:-1
Because after the file is compiled,


155
00:08:42.356 --> 00:08:45.058 line:-2 align:center
the entire static library
has to be rebuilt,


156
00:08:45,092 --> 00:08:47,628 line:-1
including its table of contents.


157
00:08:47,661 --> 00:08:50,097 line:-1
This is just a lot of extra I/O.


158
00:08:50,130 --> 00:08:53,367 line:-2
Static libraries make
the most sense for stable code.


159
00:08:53.400 --> 00:08:56.537 line:-1 align:center
That is, code not being actively changed.


160
00:08:56.570 --> 00:08:59.239 line:-2 align:center
You should consider moving code
under active development


161
00:08:59.273 --> 00:09:02.976 line:-2 align:center
out of a static library
to reduce build time.


162
00:09:03.010 --> 00:09:06.914 line:-2 align:center
Earlier we showed
the selective loading from archives.


163
00:09:06.947 --> 00:09:10.450 line:-2 align:center
But a downside of that
is that it slows down the linker.


164
00:09:10,484 --> 00:09:13,587 line:-2
That is because
to make builds reproducible


165
00:09:13.620 --> 00:09:16.490 line:-2 align:center
and follow
traditional static library semantics,


166
00:09:16,523 --> 00:09:21,028 line:-2
the linker has to process static libraries
in a fixed, serial order.


167
00:09:21.061 --> 00:09:24.264 line:-2 align:center
That means some of the parallelization
wins of ld64


168
00:09:24,298 --> 00:09:26,800 line:-1
cannot be used with static libraries.


169
00:09:26.834 --> 00:09:29.870 line:-2 align:center
But if you don't really need
this historical behavior,


170
00:09:29.903 --> 00:09:33.540 line:-2 align:center
you can use a linker option
to speed up your build.


171
00:09:33,574 --> 00:09:36,977 line:-1
That linker option is called "all load".


172
00:09:37.010 --> 00:09:42.316 line:-2 align:center
It tells the linker to blindly load
all .o files from all static libraries.


173
00:09:42,349 --> 00:09:45,719 line:-2
This is helpful if your app is
going to wind up selectively loading


174
00:09:45.752 --> 00:09:49.690 line:-2 align:center
most of the content
from all the static libraries anyways.


175
00:09:49,723 --> 00:09:53,393 line:-2
Using -all_load will allow the linker
to parse all the static libraries


176
00:09:53.427 --> 00:09:55.729 line:-1 align:center
and their content in parallel.


177
00:09:55.762 --> 00:09:59.933 line:-2 align:center
But if your app does clever tricks
where it has multiple static libraries


178
00:09:59.967 --> 00:10:02.002 line:-1 align:center
implementing the same symbols,


179
00:10:02.035 --> 00:10:05.138 line:-2 align:center
and depends on the command line order
of the static libraries


180
00:10:05,172 --> 00:10:08,075 line:-1
to drive which implementation is used,


181
00:10:08,108 --> 00:10:10,210 line:-1
then this option is not for you.


182
00:10:10,244 --> 00:10:12,679 line:-2
Because the linker will load
all the implementations


183
00:10:12,713 --> 00:10:15,082 line:-2
and not necessarily
get the symbol semantics


184
00:10:15,115 --> 00:10:18,385 line:-2
that were found
in regular static linking mode.


185
00:10:18,418 --> 00:10:23,190 line:-2
The other downside of -all_load
is that it may make your program bigger


186
00:10:23.223 --> 00:10:26.593 line:-2 align:center
because "unused" code
is now being added in.


187
00:10:26,627 --> 00:10:28,629 line:-1
To compensate for that,


188
00:10:28,662 --> 00:10:30,998 line:-2
you can use the linker
option -dead_strip.


189
00:10:31.031 --> 00:10:36.236 line:-2 align:center
That option will cause the linker
to remove unreachable code and data.


190
00:10:36,270 --> 00:10:40,541 line:-2
Now, the dead stripping algorithm is fast
and usually pays for itself


191
00:10:40.574 --> 00:10:42.876 line:-1 align:center
by reducing the size of the output file.


192
00:10:42,910 --> 00:10:47,347 line:-2
But if you are interested
in using -all_load and -dead_strip,


193
00:10:47,381 --> 00:10:50,517 line:-2
you should time the linker
with and without those options


194
00:10:50,551 --> 00:10:54,421 line:-2
to see if it is a win
for your particular case.


195
00:10:54,454 --> 00:10:58,625 line:-2
The next linker option
is -no_exported_symbols.


196
00:10:58,659 --> 00:11:00,227 line:-1
A little background here.


197
00:11:00.260 --> 00:11:03.163 line:-2 align:center
One part of the LINKEDIT segment
that the linker generates


198
00:11:03.197 --> 00:11:06.333 line:-2 align:center
is an exports trie,
which is a prefix tree


199
00:11:06.366 --> 00:11:10.571 line:-2 align:center
that encodes all the exported symbol
names, addresses, and flags.


200
00:11:10,604 --> 00:11:13,841 line:-2
Whereas all dylibs need
to have exported symbols,


201
00:11:13.874 --> 00:11:18.812 line:-2 align:center
a main app binary usually
does not need any exported symbols.


202
00:11:18.846 --> 00:11:23.083 line:-2 align:center
That is, usually nothing ever looks up
symbols in the main executable.


203
00:11:23,116 --> 00:11:26,353 line:-2
If that is the case,
you can use -no_exported_symbols


204
00:11:26,386 --> 00:11:31,225 line:-2
for the app target to skip the creation
of the trie data structure in LINKEDIT,


205
00:11:31.258 --> 00:11:33.527 line:-1 align:center
which will improve link time.


206
00:11:33.560 --> 00:11:37.931 line:-2 align:center
But if your app loads plugins
which link back to the main executable,


207
00:11:37,965 --> 00:11:43,670 line:-2
or you use xctest with your app as the
host environment to run xctest bundles,


208
00:11:43.704 --> 00:11:46.006 line:-1 align:center
your app must have all its exports,


209
00:11:46,039 --> 00:11:48,809 line:-2
which means you cannot use
-no_exported_symbols


210
00:11:48.842 --> 00:11:50.978 line:-1 align:center
for that configuration.


211
00:11:51.011 --> 00:11:55.649 line:-2 align:center
Now, it only makes sense to try to
suppress the exports trie if it is large.


212
00:11:55,682 --> 00:11:58,118 line:-2
You can run the dyld_info command
shown here


213
00:11:58.151 --> 00:12:00.687 line:-1 align:center
to count the number of exported symbols.


214
00:12:00.721 --> 00:12:04.358 line:-2 align:center
One large app we saw had about
one million exported symbols.


215
00:12:04,391 --> 00:12:07,494 line:-2
And the linker took two to three seconds
to build the exports trie


216
00:12:07.528 --> 00:12:09.329 line:-1 align:center
for that many symbols.


217
00:12:09,363 --> 00:12:12,666 line:-2
So adding -no_exported_symbols
shaved two to three seconds


218
00:12:12.699 --> 00:12:14.701 line:-1 align:center
off the link time of that app.


219
00:12:14,735 --> 00:12:18,739 line:-2
I'll tell you more about
the dyld_info tool later in this talk.


220
00:12:18.772 --> 00:12:23.010 line:-1 align:center
The next option is: -no_deduplicate.


221
00:12:23,043 --> 00:12:26,413 line:-2
A few years back we added a new pass
to the linker to merge functions


222
00:12:26.446 --> 00:12:29.583 line:-2 align:center
that have the same instructions
but different names.


223
00:12:29.616 --> 00:12:33.687 line:-2 align:center
It turns out, with C++ template
expansions, you can get a lot of those.


224
00:12:33.720 --> 00:12:36.290 line:-1 align:center
But this is an expensive algorithm.


225
00:12:36.323 --> 00:12:40.160 line:-2 align:center
The linker has to recursively hash
the instructions of every function,


226
00:12:40.194 --> 00:12:42.362 line:-1 align:center
to help look for duplicates.


227
00:12:42.396 --> 00:12:44.932 line:-2 align:center
Because of the expense,
we limited the algorithm


228
00:12:44.965 --> 00:12:48.135 line:-2 align:center
so the linker only looks
at weak-def symbols.


229
00:12:48,168 --> 00:12:51,772 line:-2
Those are the ones the C++ compiler emits
for template expansions


230
00:12:51.805 --> 00:12:54.541 line:-1 align:center
that were not inlined.


231
00:12:54,575 --> 00:12:57,477 line:-1
Now, de-dup is a size optimization,


232
00:12:57.511 --> 00:13:01.415 line:-2 align:center
and Debug builds are about fast builds,
and not about size.


233
00:13:01.448 --> 00:13:05.586 line:-2 align:center
So by default, Xcode disables
the de-dup optimization


234
00:13:05.619 --> 00:13:11.258 line:-2 align:center
by passing -no_deduplicate to the linker
for Debug configurations.


235
00:13:11.291 --> 00:13:14.995 line:-2 align:center
And clang will also pass
the no-dedup option to the linker


236
00:13:15,028 --> 00:13:19,466 line:-1
if you run clang link line with -O0.


237
00:13:19.499 --> 00:13:24.304 line:-2 align:center
In summary, if you use C++
and have a custom build,


238
00:13:24.338 --> 00:13:28.041 line:-2 align:center
that is, either you use
a non-standard configuration in Xcode,


239
00:13:28.075 --> 00:13:30.210 line:-1 align:center
or you use some other build system,


240
00:13:30,244 --> 00:13:36,049 line:-2
you should ensure your debug builds add
-no_deduplicate to improve link time.


241
00:13:36.083 --> 00:13:39.987 line:-2 align:center
The options I just talked about are
the actual command line arguments to ld.


242
00:13:40.020 --> 00:13:44.057 line:-2 align:center
When using Xcode, you need to change
your product build settings.


243
00:13:44,091 --> 00:13:48,028 line:-2
Inside build settings,
look for "Other Linker Flags".


244
00:13:49.796 --> 00:13:52.599 line:-1 align:center
Here's what you would set for -all_load.


245
00:13:52.633 --> 00:13:56.303 line:-2 align:center
And notice the "Dead Code Stripping"
option is here as well.


246
00:13:56.336 --> 00:13:58.939 line:-1 align:center
And there's -no_exported_symbols.


247
00:13:58.972 --> 00:14:01.708 line:-1 align:center
And here's -no_deduplicate.


248
00:14:03.177 --> 00:14:05.546 line:-2 align:center
Now let's talk about some surprises
you may experience


249
00:14:05.579 --> 00:14:07.381 line:-1 align:center
when using static libraries.


250
00:14:07.414 --> 00:14:11.685 line:-2 align:center
The first surprise is when you have source
code that builds into a static library


251
00:14:11.718 --> 00:14:16.290 line:-2 align:center
which your app links with, and that code
does not end up in the final app.


252
00:14:16,323 --> 00:14:19,226 line:-2
For instance, you added
"attribute used" to some function,


253
00:14:19,259 --> 00:14:22,196 line:-1
or you have an Objective-C category.


254
00:14:22.229 --> 00:14:24.865 line:-2 align:center
Because of the selective loading
the linker does,


255
00:14:24.898 --> 00:14:27.267 line:-2 align:center
if those object files
in the static library


256
00:14:27.301 --> 00:14:30.871 line:-2 align:center
don't also define some symbol
that is needed during the link,


257
00:14:30.904 --> 00:14:34.975 line:-2 align:center
those object files won't get loaded
by the linker.


258
00:14:35.008 --> 00:14:40.113 line:-2 align:center
Another interesting interaction
is static libraries and dead stripping.


259
00:14:40.147 --> 00:14:44.751 line:-2 align:center
It turns out dead stripping can hide
many static library issues.


260
00:14:44.785 --> 00:14:47.788 line:-2 align:center
Normally,
missing symbols or duplicate symbols


261
00:14:47.821 --> 00:14:50.357 line:-1 align:center
will cause the linker to error out.


262
00:14:50,390 --> 00:14:54,328 line:-2
But dead stripping causes the linker
to run a reachability pass


263
00:14:54.361 --> 00:14:57.798 line:-2 align:center
across all the code and data,
starting from main,


264
00:14:57,831 --> 00:15:02,102 line:-2
and if it turns out the missing symbol
is from an unreachable code,


265
00:15:02.135 --> 00:15:05.305 line:-2 align:center
the linker will suppress
the missing symbol error.


266
00:15:05.339 --> 00:15:09.309 line:-2 align:center
Similarly, if there are
duplicate symbols from static libraries,


267
00:15:09.343 --> 00:15:13.046 line:-2 align:center
the linker will pick the first
and not error.


268
00:15:13.080 --> 00:15:16.083 line:-2 align:center
The last big surprise
with using static libraries,


269
00:15:16,116 --> 00:15:20,220 line:-2
is when a static library is incorporated
into multiple frameworks.


270
00:15:20.254 --> 00:15:23.457 line:-2 align:center
Each of those frameworks
runs fine in isolation,


271
00:15:23.490 --> 00:15:27.394 line:-2 align:center
but then at some point,
some app uses both frameworks, and boom,


272
00:15:27,427 --> 00:15:32,199 line:-2
you get weird runtime issues
because of the multiple definitions.


273
00:15:32,232 --> 00:15:35,302 line:-2
The most common case you will see
is the Objective-C runtime


274
00:15:35.335 --> 00:15:39.339 line:-2 align:center
warning about multiple instances
of the same class name.


275
00:15:39.373 --> 00:15:41.608 line:-1 align:center
Overall, static libraries are powerful,


276
00:15:41.642 --> 00:15:45.579 line:-2 align:center
but you need to understand them
to avoid the pitfalls.


277
00:15:45,612 --> 00:15:47,514 line:-1
That wraps up static linking.


278
00:15:47,548 --> 00:15:51,685 line:-1
Now, let's move on to dynamic linking.


279
00:15:51.718 --> 00:15:56.890 line:-2 align:center
First, let's look at the original diagram
for static linking with a static library.


280
00:15:56.924 --> 00:15:59.526 line:-2 align:center
Now think about
how this will scale over time,


281
00:15:59.560 --> 00:16:02.396 line:-1 align:center
as there is more and more source code.


282
00:16:02.429 --> 00:16:06.133 line:-2 align:center
It should be clear that as more and more
libraries are made available,


283
00:16:06,166 --> 00:16:08,969 line:-1
the end program may grow in size.


284
00:16:09.002 --> 00:16:13.340 line:-2 align:center
That means the static link time to build
that program will also increase over time.


285
00:16:14.975 --> 00:16:18.512 line:-2 align:center
Now let's look at how these libraries
are made.


286
00:16:18,545 --> 00:16:21,048 line:-1
What if we did this switch?


287
00:16:21.081 --> 00:16:24.151 line:-1 align:center
We change 'ar' to 'ld'


288
00:16:24.184 --> 00:16:27.821 line:-2 align:center
and the output library
is now an executable binary.


289
00:16:27.855 --> 00:16:31.191 line:-2 align:center
This was the start
of dynamic libraries in the '90s.


290
00:16:31,225 --> 00:16:34,394 line:-2
As a shorthand,
we call dynamic libraries "dylibs".


291
00:16:34.428 --> 00:16:38.732 line:-2 align:center
On other platforms
they are known as DSOs or DLLs.


292
00:16:38.765 --> 00:16:41.268 line:-1 align:center
So what exactly is going on here?


293
00:16:41.301 --> 00:16:43.604 line:-1 align:center
And how does that help the scalability?


294
00:16:44.671 --> 00:16:47.107 line:-2 align:center
The key is that
the static linker treats linking


295
00:16:47,140 --> 00:16:49,676 line:-1
with a dynamic library differently.


296
00:16:49.710 --> 00:16:53.814 line:-2 align:center
Instead of copying code out of the library
into the final program,


297
00:16:53.847 --> 00:16:56.450 line:-1 align:center
the linker just records a kind of promise.


298
00:16:56,483 --> 00:17:00,153 line:-2
That is, it records the symbol name
used from the dynamic library


299
00:17:00.187 --> 00:17:03.457 line:-2 align:center
and what the library's path
will be at runtime.


300
00:17:03,490 --> 00:17:05,559 line:-1
How is this an advantage?


301
00:17:05,592 --> 00:17:08,862 line:-2
It means your program file size
is under your control.


302
00:17:08.896 --> 00:17:10.797 line:-1 align:center
It just contains your code,


303
00:17:10,831 --> 00:17:13,567 line:-2
and a list of dynamic libraries
it needs at runtime.


304
00:17:13.600 --> 00:17:16.670 line:-2 align:center
You no longer get copies of library code
in your program.


305
00:17:16,703 --> 00:17:20,507 line:-2
Your program's static link time is
now proportional to the size of your code,


306
00:17:20,541 --> 00:17:24,244 line:-2
and independent of the number
of dylibs you link with.


307
00:17:24,278 --> 00:17:27,314 line:-2
Also, the Virtual Memory system
can now shine.


308
00:17:27,347 --> 00:17:31,385 line:-2
When it sees the same dynamic library
used in multiple processes,


309
00:17:31,418 --> 00:17:34,688 line:-2
the Virtual Memory system will re-use
the same physical pages of RAM


310
00:17:34.721 --> 00:17:37.958 line:-2 align:center
for that dylib in all processes
that use that dylib.


311
00:17:37.991 --> 00:17:42.596 line:-2 align:center
I've shown you how dynamic libraries
started and what problem they solve.


312
00:17:42,629 --> 00:17:46,099 line:-2
But what are the "costs"
for those "benefits"?


313
00:17:46,133 --> 00:17:48,902 line:-2
First,
a benefit of using dynamic libraries


314
00:17:48,936 --> 00:17:51,004 line:-1
is that we have sped up build time.


315
00:17:51.038 --> 00:17:54.107 line:-2 align:center
But the cost is that launching your app
is now slower.


316
00:17:54,141 --> 00:17:59,079 line:-2
This is because launching is no longer
just loading one program file.


317
00:17:59.112 --> 00:18:03.050 line:-2 align:center
Now all the dylibs also need to be loaded
and connected together.


318
00:18:03,083 --> 00:18:05,819 line:-2
In other words, you just deferred
some of the linking costs


319
00:18:05,853 --> 00:18:08,555 line:-1
from build time to launch time.


320
00:18:08,589 --> 00:18:13,360 line:-2
Second, a dynamic library based program
will have more dirty pages.


321
00:18:13,393 --> 00:18:17,064 line:-2
In the static library case,
the linker would co-locate all globals


322
00:18:17,097 --> 00:18:22,135 line:-2
from all static libraries into the same
DATA pages in the main executable.


323
00:18:22.169 --> 00:18:26.139 line:-2 align:center
But with dylibs,
each library has its DATA page.


324
00:18:26,173 --> 00:18:30,043 line:-2
Lastly, another cost of dynamic linking
is that it introduces the need


325
00:18:30.077 --> 00:18:33.580 line:-1 align:center
for something new: a dynamic linker!


326
00:18:33.614 --> 00:18:37.851 line:-2 align:center
Remember that promise that was recorded
in the executable at build time?


327
00:18:37,885 --> 00:18:44,024 line:-2
Now we need something at runtime that will
fulfill that promise to load our library.


328
00:18:44.057 --> 00:18:48.295 line:-2 align:center
That's what dyld,
the dynamic linker, is for.


329
00:18:48,328 --> 00:18:51,999 line:-2
Let's dive into how dynamic linking
works at runtime.


330
00:18:52,032 --> 00:18:55,202 line:-2
An executable binary is divided up
into segments,


331
00:18:55,235 --> 00:18:59,106 line:-1
usually at least TEXT, DATA, and LINKEDIT.


332
00:18:59.139 --> 00:19:03.243 line:-2 align:center
Segments are always a multiple
of the page size for the OS.


333
00:19:03.277 --> 00:19:05.846 line:-1 align:center
Each segment has a different permission.


334
00:19:05,879 --> 00:19:09,683 line:-2
For example, the TEXT segment
has "execute" permissions.


335
00:19:09,716 --> 00:19:14,855 line:-2
That means the CPU may treat the bytes
on the page as machine code instructions.


336
00:19:14.888 --> 00:19:19.026 line:-2 align:center
At runtime, dyld has to mmap()
the executables into memory


337
00:19:19.059 --> 00:19:22.629 line:-2 align:center
with each segments' permissions,
as show here.


338
00:19:22.663 --> 00:19:25.933 line:-2 align:center
Because the segments are page sized
and page aligned,


339
00:19:25.966 --> 00:19:28.302 line:-2 align:center
that makes it straightforward
for the virtual memory system


340
00:19:28,335 --> 00:19:33,707 line:-2
to just set up the program or dylib file
as backing store for a VM range.


341
00:19:33.740 --> 00:19:35.976 line:-1 align:center
That means nothing is loaded into RAM


342
00:19:36,009 --> 00:19:39,213 line:-2
until there is some memory access
on those pages,


343
00:19:39.246 --> 00:19:42.683 line:-2 align:center
which triggers a page fault,
which causes the VM system


344
00:19:42,716 --> 00:19:44,785 line:-1
to read the proper subrange of the file


345
00:19:44,818 --> 00:19:48,555 line:-2
and fill in the needed RAM page
with its content.


346
00:19:48.589 --> 00:19:50.791 line:-1 align:center
But just mapping is not enough.


347
00:19:50.824 --> 00:19:55.128 line:-2 align:center
Somehow the program needs to
be "wired up" or bound to the dylib.


348
00:19:55.162 --> 00:19:57.397 line:-2 align:center
For that we have a concept
called "fix ups".


349
00:19:58,398 --> 00:20:01,568 line:-2
In the diagram,
we see the program got pointers set up


350
00:20:01,602 --> 00:20:04,438 line:-2
that point to the parts of the dylib
it uses.


351
00:20:04.471 --> 00:20:07.107 line:-1 align:center
Let's dive into what fix-ups are.


352
00:20:07.140 --> 00:20:10.010 line:-1 align:center
Here is our friend, the mach-o file.


353
00:20:10.043 --> 00:20:11.812 line:-1 align:center
Now, TEXT is immutable.


354
00:20:11,845 --> 00:20:15,115 line:-2
And in fact, it has to be
in a system based on code signing.


355
00:20:15.148 --> 00:20:18.585 line:-2 align:center
So what if there is a function
that calls malloc()?


356
00:20:18.619 --> 00:20:20.287 line:-1 align:center
How can that work?


357
00:20:20.320 --> 00:20:24.791 line:-2 align:center
The relative address of _malloc
can't be known when the program was built.


358
00:20:24.825 --> 00:20:27.361 line:-2 align:center
Well, what happens is,
the static linker saw


359
00:20:27.394 --> 00:20:31.665 line:-2 align:center
that malloc was in a dylib
and transformed the call site.


360
00:20:31.698 --> 00:20:35.536 line:-2 align:center
The call site becomes a call to a stub
synthesized by the linker


361
00:20:35,569 --> 00:20:37,471 line:-1
in the same TEXT segment,


362
00:20:37.504 --> 00:20:40.607 line:-2 align:center
so the relative address is known
at build time,


363
00:20:40,641 --> 00:20:45,579 line:-2
which means the BL instruction
can be correctly formed.


364
00:20:45.612 --> 00:20:49.082 line:-2 align:center
How that helps
is that the stub loads a pointer from DATA


365
00:20:49.116 --> 00:20:51.251 line:-1 align:center
and jumps to that location.


366
00:20:51.285 --> 00:20:54.955 line:-2 align:center
Now, no changes to TEXT are needed
at runtimeâ€“


367
00:20:54,988 --> 00:20:57,858 line:-1
just DATA is changed by dyld.


368
00:20:57.891 --> 00:21:00.994 line:-1 align:center
In fact, the secret to understanding dyld


369
00:21:01,028 --> 00:21:06,266 line:-2
is that all fixups done by dyld
are just dyld setting a pointer in DATA.


370
00:21:07,267 --> 00:21:10,938 line:-2
So let's dig more
into the fixups that dyld does.


371
00:21:10,971 --> 00:21:16,643 line:-2
Somewhere in LINKEDIT is the information
dyld needs to drive what fixups are done.


372
00:21:16.677 --> 00:21:19.012 line:-1 align:center
There are two kinds of fixups.


373
00:21:19,046 --> 00:21:20,948 line:-1
The first are called rebases,


374
00:21:20,981 --> 00:21:25,586 line:-2
and they are when a dylib or app
has a pointer that points within itself.


375
00:21:25.619 --> 00:21:29.323 line:-2 align:center
Now there is a security feature
called ASLR,


376
00:21:29,356 --> 00:21:33,460 line:-2
which causes dyld to load dylibs
at random addresses.


377
00:21:33.493 --> 00:21:38.899 line:-2 align:center
And that means those interior pointers
cannot just be set at build time.


378
00:21:38.932 --> 00:21:44.505 line:-2 align:center
Instead, dyld needs to adjust
or "rebase" those pointers at launch.


379
00:21:44.538 --> 00:21:47.774 line:-2 align:center
On disk, those pointers contain
their target address,


380
00:21:47.808 --> 00:21:51.144 line:-2 align:center
if the dylib were to be loaded
at address zero.


381
00:21:51,178 --> 00:21:56,750 line:-2
That way, all the LINKEDIT needs to record
is the location of each rebase location.


382
00:21:56.783 --> 00:22:01.054 line:-2 align:center
Dyld can then just add
the actual load address of the dylib


383
00:22:01.088 --> 00:22:04.791 line:-2 align:center
to each of the rebase locations
to correctly fix them up.


384
00:22:06,226 --> 00:22:08,896 line:-1
The second kind of fixups are binds.


385
00:22:08.929 --> 00:22:11.431 line:-1 align:center
Binds are symbolic references.


386
00:22:11,465 --> 00:22:15,636 line:-2
That is, their target is a symbol name
and not a number.


387
00:22:15.669 --> 00:22:18.939 line:-2 align:center
For instance,
a pointer to the function "malloc".


388
00:22:18.972 --> 00:22:24.411 line:-2 align:center
The string "_malloc"
is actually stored in LINKEDIT,


389
00:22:24,444 --> 00:22:28,315 line:-2
and dyld uses that string
to look up the actual address of malloc


390
00:22:28.348 --> 00:22:31.385 line:-1 align:center
in the exports trie of libSystem.dylib.


391
00:22:31.418 --> 00:22:37.124 line:-2 align:center
Then, dyld stores that value
in the location specified by the bind.


392
00:22:37.157 --> 00:22:40.093 line:-2 align:center
This year we are announcing
a new way to encode fixups,


393
00:22:40,127 --> 00:22:42,362 line:-1
that we call "chained fixups".


394
00:22:44,097 --> 00:22:47,734 line:-2
The first advantage is that
is makes LINKEDIT smaller.


395
00:22:47.768 --> 00:22:52.105 line:-2 align:center
The LINKEDIT is smaller because instead
of storing all the fixup locations,


396
00:22:52.139 --> 00:22:57.344 line:-2 align:center
the new format just stores where the first
fixup location is in each DATA page,


397
00:22:57.377 --> 00:23:00.214 line:-1 align:center
as well as a list of the imported symbols.


398
00:23:00,247 --> 00:23:04,585 line:-2
Then the rest of the information
is encoded in the DATA segment itself,


399
00:23:04,618 --> 00:23:08,956 line:-2
in the place
where the fixups will ultimately be set.


400
00:23:08.989 --> 00:23:12.192 line:-2 align:center
This new format gets its name,
chained fixups,


401
00:23:12.226 --> 00:23:16.396 line:-2 align:center
from the fact that the fixup locations
are "chained" together.


402
00:23:16,430 --> 00:23:19,900 line:-2
The LINKEDIT just says
where the first fixup was,


403
00:23:19.933 --> 00:23:23.470 line:-2 align:center
then in the 64-bit pointer location
in DATA,


404
00:23:23,504 --> 00:23:28,308 line:-2
some of the bits contain the offset
to the next fixup location.


405
00:23:28.342 --> 00:23:33.413 line:-2 align:center
Also packed in there is a bit that says
if the fixup is a bind or a rebase.


406
00:23:33,447 --> 00:23:37,851 line:-2
If it is a bind, the rest of the bits
are the index of the symbol.


407
00:23:37.885 --> 00:23:41.822 line:-2 align:center
If it's a rebase, the rest of the bits
are the offset of the target


408
00:23:41.855 --> 00:23:44.324 line:-1 align:center
within the image.


409
00:23:44,358 --> 00:23:49,796 line:-2
Lastly, runtime support for chained fixups
already exists in iOS 13.4 and later.


410
00:23:49.830 --> 00:23:52.699 line:-2 align:center
Which means you can start using
this new format today,


411
00:23:52,733 --> 00:23:57,437 line:-2
as long as your deployment target
is iOS 13.4 or later.


412
00:23:57,471 --> 00:24:00,874 line:-2
And the chained fixup format enables
a new OS feature


413
00:24:00.908 --> 00:24:02.910 line:-1 align:center
we are announcing this year.


414
00:24:02,943 --> 00:24:06,813 line:-2
But to understand that,
I need to talk about how dyld works.


415
00:24:08.081 --> 00:24:11.752 line:-2 align:center
Dyld starts with the main executableâ€“
say your app.


416
00:24:11,785 --> 00:24:14,821 line:-2
Parses that mach-o to find
the dependent dylibs,


417
00:24:14.855 --> 00:24:18.292 line:-2 align:center
that is,
what promised dynamic libraries it needs.


418
00:24:18,325 --> 00:24:21,495 line:-1
It finds those dylibs and mmap()s them.


419
00:24:21.528 --> 00:24:25.966 line:-2 align:center
Then for each of those, it recurses
and parses their mach-o structures,


420
00:24:25.999 --> 00:24:29.970 line:-1 align:center
loading any additional dylibs as needed.


421
00:24:30.003 --> 00:24:31.839 line:-1 align:center
Once everything is loaded,


422
00:24:31.872 --> 00:24:34.241 line:-1 align:center
dyld looks up all the bind symbols needed


423
00:24:34.274 --> 00:24:37.811 line:-2 align:center
and uses those addresses
when doing fixups.


424
00:24:37.845 --> 00:24:40.647 line:-1 align:center
Lastly, once all the fixups are done,


425
00:24:40.681 --> 00:24:44.251 line:-1 align:center
dyld runs initializers, bottom up.


426
00:24:44.284 --> 00:24:47.921 line:-2 align:center
Five years ago
we announced a new dyld technology.


427
00:24:47,955 --> 00:24:53,260 line:-2
We realized the steps in green above were
the same every time your app was launched.


428
00:24:53.293 --> 00:24:56.096 line:-2 align:center
So as long as the program and dylibs
did not change,


429
00:24:56,129 --> 00:24:59,099 line:-2
all the steps in green
could be cached on first launch


430
00:24:59.132 --> 00:25:02.703 line:-1 align:center
and re-used on subsequent launches.


431
00:25:02,736 --> 00:25:07,741 line:-2
This year we are announcing
additional dyld performance improvements.


432
00:25:07.774 --> 00:25:12.946 line:-2 align:center
We are announcing a new dyld feature
called "page-in linking".


433
00:25:12.980 --> 00:25:17.451 line:-2 align:center
Instead of dyld applying all the fixups
to all dylibs at launch,


434
00:25:17.484 --> 00:25:23.023 line:-2 align:center
the kernel can now apply fixups
to your DATA pages lazily, on page-in.


435
00:25:23,056 --> 00:25:26,026 line:-2
It has always been the case
that the first use of some address


436
00:25:26,059 --> 00:25:31,765 line:-2
in some page of an mmap()ed region
triggered the kernel to read in that page.


437
00:25:31,798 --> 00:25:34,268 line:-1
But now, if it is a DATA page,


438
00:25:34.301 --> 00:25:38.705 line:-2 align:center
the kernel will also apply the fixup
that page needs.


439
00:25:38.739 --> 00:25:42.109 line:-2 align:center
We have had a special case
of page-in linking for over a decade


440
00:25:42,142 --> 00:25:45,412 line:-1
for OS dylibs in the dyld shared cache.


441
00:25:45,445 --> 00:25:49,616 line:-2
This year we generalized it
and made it available to everyone.


442
00:25:49.650 --> 00:25:53.687 line:-2 align:center
This mechanism reduces
dirty memory and launch time.


443
00:25:53.720 --> 00:25:56.523 line:-1 align:center
It also means DATA_CONST pages are clean,


444
00:25:56,557 --> 00:26:00,694 line:-2
which means they can be evicted
and recreated just like TEXT pages,


445
00:26:00.727 --> 00:26:02.896 line:-1 align:center
which reduces memory pressure.


446
00:26:02,930 --> 00:26:06,166 line:-2
This page-in linking feature
will be in the upcoming release of iOS,


447
00:26:06,200 --> 00:26:09,002 line:-1
macOS, and watchOS.


448
00:26:09,036 --> 00:26:13,373 line:-2
But page-in linking only works
for binaries built with chained fixups.


449
00:26:13,407 --> 00:26:15,409 line:-1
That is because with chained fixups,


450
00:26:15,442 --> 00:26:20,047 line:-2
most of the fixup information will be
encoded in the DATA segment on disk,


451
00:26:20.080 --> 00:26:23.717 line:-2 align:center
which means it is available
to the kernel during page-in.


452
00:26:23,750 --> 00:26:28,088 line:0
One caveat is that dyld only
uses this mechanism during launch.


453
00:26:28,121 --> 00:26:32,192 align:center
Any dylibs dlopen()ed later
do not get page-in linking.


454
00:26:32,226 --> 00:26:34,995 line:0
In that case,
dyld takes the traditional path


455
00:26:35,028 --> 00:26:38,932 align:center
and applies the fixups
during the dlopen call.


456
00:26:38.966 --> 00:26:43.003 line:-2 align:center
With that in mind, let's go back
to the dyld workflow diagram.


457
00:26:43.036 --> 00:26:46.940 line:-2 align:center
For five years now, dyld has been
optimizing the steps above in green


458
00:26:46.974 --> 00:26:52.446 line:-2 align:center
by caching that work on first launch
and reusing it on later launches.


459
00:26:52.479 --> 00:26:57.050 line:-2 align:center
Now, dyld can optimize
the "apply fixup" step


460
00:26:57.084 --> 00:26:59.253 line:-1 align:center
by not actually doing the fixups,


461
00:26:59,286 --> 00:27:03,857 line:-2
and letting the kernel do them lazily
on page-in.


462
00:27:03,891 --> 00:27:06,660 line:-2
Now that you have seen
what's new in dyld,


463
00:27:06,693 --> 00:27:11,164 line:-2
let's talk about best practices
for dynamic linking.


464
00:27:11.198 --> 00:27:14.668 line:-2 align:center
What can you do to help
improve dynamic link performance?


465
00:27:14,701 --> 00:27:17,237 line:-2
As I just showed,
dyld has already accelerated


466
00:27:17.271 --> 00:27:19.973 line:-1 align:center
most of the steps in dynamic linking.


467
00:27:20.007 --> 00:27:24.211 line:-2 align:center
One thing you can control
is how many dylibs you have.


468
00:27:24,244 --> 00:27:28,515 line:-2
The more dylibs there are,
the more work dyld has to do to load them.


469
00:27:28,549 --> 00:27:33,253 line:-2
Conversely, the fewer dylibs,
the less work dyld has to perform.


470
00:27:33.287 --> 00:27:36.356 line:-2 align:center
The next thing you can look at
are static initializers,


471
00:27:36,390 --> 00:27:39,459 line:-1
which is code that always runs, pre-main.


472
00:27:39,493 --> 00:27:44,131 line:-2
For instance, don't do I/O or networking
in a static initializer.


473
00:27:44,164 --> 00:27:46,700 line:-2
Anything that can take more
than a few milliseconds


474
00:27:46,733 --> 00:27:49,803 line:-1
should never be done in an initializer.


475
00:27:49.837 --> 00:27:52.272 line:-2 align:center
As we know,
the world is getting more complicated,


476
00:27:52.306 --> 00:27:54.708 line:-1 align:center
and your users want more functionality.


477
00:27:54.741 --> 00:27:59.413 line:-2 align:center
So it makes sense to use libraries
to manage all that functionality.


478
00:27:59,446 --> 00:28:04,551 line:-2
Your goal is to find your sweet spot
between dynamic and static libraries.


479
00:28:04.585 --> 00:28:06.086 line:-1 align:center
Too many static libraries


480
00:28:06,119 --> 00:28:09,756 line:-2
and your iterative build/debug cycle
is slowed down.


481
00:28:09,790 --> 00:28:12,292 line:-2
On the other hand,
too many dynamic libraries


482
00:28:12.326 --> 00:28:15.796 line:-2 align:center
and your launch time is slow
and your customers notice.


483
00:28:15,829 --> 00:28:18,432 line:-1
But we sped up ld64 this year,


484
00:28:18,465 --> 00:28:20,601 line:-1
so your sweet spot may have changed,


485
00:28:20.634 --> 00:28:23.203 line:-1 align:center
as you can now use more static libraries,


486
00:28:23.237 --> 00:28:25.672 line:-1 align:center
or more source files directly in your app,


487
00:28:25,706 --> 00:28:28,675 line:-2
and still build
in the same amount of time.


488
00:28:28.709 --> 00:28:31.678 line:-2 align:center
Lastly,
if it works for your installed base,


489
00:28:31.712 --> 00:28:34.081 line:-1 align:center
updating to a newer deployment target


490
00:28:34,114 --> 00:28:36,683 line:-2
can enable the tools
to generate chained fixups,


491
00:28:36.717 --> 00:28:39.920 line:-2 align:center
making your binaries smaller,
and improving launch time.


492
00:28:39.953 --> 00:28:42.689 line:-2 align:center
The last thing
I'd like you all to be aware of


493
00:28:42,723 --> 00:28:47,394 line:-2
is two new tools that will help you peek
inside the linking process.


494
00:28:47,427 --> 00:28:49,696 line:-1
The first tool is dyld_usage.


495
00:28:49.730 --> 00:28:53.333 line:-2 align:center
You can use it
to get a trace of what dyld is doing.


496
00:28:53.367 --> 00:28:55.736 line:-1 align:center
The tool is only on macOS,


497
00:28:55,769 --> 00:28:59,806 line:-2
but you can use it to trace your app
launching in the simulator,


498
00:28:59.840 --> 00:29:03.410 line:-1 align:center
or if your app built for Mac Catalyst.


499
00:29:03,443 --> 00:29:06,847 line:-2
Here is an example run
against TextEdit on macOS.


500
00:29:08.849 --> 00:29:13.820 line:-2 align:center
As you can tell by the top few lines,
the launch took 15ms overall,


501
00:29:13,854 --> 00:29:18,025 line:-2
but only 1ms for fixups,
thanks to page-in linking.


502
00:29:18,058 --> 00:29:22,129 line:-2
The vast majority of time is now spent
in static initializers.


503
00:29:23.697 --> 00:29:26.400 line:-1 align:center
The next tool is dyld_info.


504
00:29:26.433 --> 00:29:28.635 line:-1 align:center
You can use it to inspect binaries,


505
00:29:28.669 --> 00:29:31.772 line:-2 align:center
both on disk
and in the current dyld cache.


506
00:29:31.805 --> 00:29:36.877 line:-2 align:center
The tool has many options, but I'll show
you how to view exports and fixups.


507
00:29:36,910 --> 00:29:41,648 line:-2
Here the -fixup option shows
all the fixup locations dyld will process


508
00:29:41,682 --> 00:29:43,884 line:-1
and their targets.


509
00:29:43.917 --> 00:29:47.688 line:-2 align:center
The output is the same regardless
of if the file is old style fixups


510
00:29:47.721 --> 00:29:50.824 line:-1 align:center
or new chained fixups.


511
00:29:50.858 --> 00:29:56.730 line:-2 align:center
Here the -exports option will show
all the exported symbols in the dylib,


512
00:29:56.763 --> 00:30:00.567 line:-2 align:center
and the offset of each symbol
from the start of the dylib.


513
00:30:00,601 --> 00:30:04,238 line:-2
In this case, it is showing information
about Foundation.framework


514
00:30:04.271 --> 00:30:07.040 line:-1 align:center
which is the dylib in the dyld cache.


515
00:30:07,074 --> 00:30:08,775 line:-1
There is no file on disk,


516
00:30:08,809 --> 00:30:13,680 line:-2
but the dyld_info tool uses the same code
as dyld and can thus find it.


517
00:30:15.148 --> 00:30:17.484 line:-2 align:center
Now that you understand
the history and tradeoffs


518
00:30:17.518 --> 00:30:19.786 line:-1 align:center
of static versus dynamic libraries,


519
00:30:19,820 --> 00:30:22,089 line:-1
you should review what you app does


520
00:30:22.122 --> 00:30:25.225 line:-2 align:center
and determine
if you have found your sweet spot.


521
00:30:25,259 --> 00:30:27,628 line:-1
Next, if you have a large app


522
00:30:27.661 --> 00:30:30.831 line:-2 align:center
and have noticed
the build takes a while to link,


523
00:30:30.864 --> 00:30:35.435 line:-2 align:center
try out Xcode 14
which has the new faster linker.


524
00:30:35.469 --> 00:30:37.971 line:-2 align:center
If you still want to speed up
your static link more,


525
00:30:38,005 --> 00:30:40,674 line:-2
look into the three linker options
I detailed


526
00:30:40,707 --> 00:30:45,045 line:-2
and see if they make sense in your build,
and improve your link time.


527
00:30:45.078 --> 00:30:49.917 line:-2 align:center
Lastly, you can also try building
your app, and any embedded frameworks,


528
00:30:49.950 --> 00:30:54.021 line:-2 align:center
for iOS 13.4 or later
to enable chained fixups.


529
00:30:54,054 --> 00:30:58,759 line:0
Then see if your app is smaller
and launches faster on iOS 16.


530
00:30:58,792 --> 00:31:01,895 line:-2
Thanks for watching,
and have a great WWDC.

