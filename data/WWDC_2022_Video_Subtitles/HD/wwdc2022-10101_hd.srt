2
00:00:00.334 --> 00:00:06.340 line:-1 align:center
♪ instrumental hip hop music ♪


3
00:00:09.743 --> 00:00:10.911 line:-1 align:center
Hello and welcome.


4
00:00:10.944 --> 00:00:15.048 line:-2 align:center
My name is Alè Segovia Azapian
from the GPU Software team here at Apple.


5
00:00:15.082 --> 00:00:18.385 line:-2 align:center
And I’m Mayur,
also from the GPU Software team.


6
00:00:18,418 --> 00:00:21,755 line:-2
Alè: In this session we are going
to talk about bindless rendering.


7
00:00:21.788 --> 00:00:25.692 line:-2 align:center
The bindless binding model is a modern
way to provide resources to your shaders,


8
00:00:25.726 --> 00:00:29.096 line:-2 align:center
unlocking advanced rendering techniques,
such as ray tracing.


9
00:00:29,129 --> 00:00:34,201 line:-2
For today, I'll start with a brief recap
of how the bindless binding model works,


10
00:00:34.234 --> 00:00:39.339 line:-2 align:center
and how you can easily adopt bindless
in your games and apps with Metal 3.


11
00:00:40,440 --> 00:00:44,111 line:-2
Bindless rendering aggregates data,
which opens up new opportunities


12
00:00:44.144 --> 00:00:47.247 line:-1 align:center
to improve performance on the CPU and GPU.


13
00:00:47,281 --> 00:00:52,519 line:-2
I'll give you two specific tips today
to improve your CPU and GPU times.


14
00:00:53,387 --> 00:00:54,755 line:-1
Then I'll hand it over to Mayur,


15
00:00:54,788 --> 00:00:58,859 line:-2
and he’ll show you how the tools
can help you adopt a bindless model.


16
00:00:59,760 --> 00:01:02,129 line:-2
In the bindless model,
resources are aggregated


17
00:01:02.162 --> 00:01:04.998 line:-1 align:center
and linked together with argument buffers.


18
00:01:05,032 --> 00:01:07,501 line:-2
Conceptually,
this is what this looks like.


19
00:01:07,534 --> 00:01:12,005 line:-2
In this example, an array
aggregates all the meshes in a scene.


20
00:01:12.039 --> 00:01:15.676 line:-2 align:center
Unlike the traditional binding model,
where you bind each resource independently


21
00:01:15,709 --> 00:01:17,644 line:-1
to a specific slot in a pipeline,


22
00:01:17.678 --> 00:01:22.082 line:-2 align:center
in the bindless model, resources
are first linked together in memory.


23
00:01:22,115 --> 00:01:25,786 line:-2
This lets you bind a single buffer
that your shaders can freely navigate


24
00:01:25.819 --> 00:01:27.888 line:-1 align:center
and access the resources they need


25
00:01:27.921 --> 00:01:32.259 line:-2 align:center
to calculate elaborate surfaces
and lighting.


26
00:01:32.292 --> 00:01:34.261 line:-1 align:center
After the app goes bindless,


27
00:01:34.294 --> 00:01:36.997 line:-2 align:center
the ray tracing shaders can access
all the data they need


28
00:01:37.030 --> 00:01:39.800 line:-1 align:center
to beautifully shade the reflections.


29
00:01:39.833 --> 00:01:42.069 line:-1 align:center
The app makes the 3D models and textures,


30
00:01:42,102 --> 00:01:46,073 line:-2
including the floor, the trucks,
their materials, and even the sky,


31
00:01:46,106 --> 00:01:48,175 line:-1
available to the ray tracing shaders


32
00:01:48.208 --> 00:01:51.979 line:-2 align:center
by placing all its data
into argument buffers.


33
00:01:52,012 --> 00:01:54,815 line:-2
Even better,
when bindless rendering is paired with


34
00:01:54,848 --> 00:01:59,319 line:-2
other Metal features like Heaps,
apps and games enjoy better performance,


35
00:01:59,353 --> 00:02:02,489 line:-1
thanks to less pressure on the CPU.


36
00:02:02,523 --> 00:02:05,792 line:-2
I'll talk about four specific enhancements
in Metal 3


37
00:02:05.826 --> 00:02:08.929 line:-2 align:center
that you may find useful
for bindless rendering.


38
00:02:09.530 --> 00:02:12.833 line:-2 align:center
Argument buffers
are the fundamental Metal construct


39
00:02:12.866 --> 00:02:15.702 line:-2 align:center
that allows you to link
your resources together.


40
00:02:15,736 --> 00:02:20,007 line:-2
They reference resources
such as textures and other buffers.


41
00:02:20,040 --> 00:02:24,278 line:-2
Metal 3 makes writing
argument buffers easier than ever


42
00:02:24.311 --> 00:02:28.315 line:-2 align:center
because now you no longer need
an Argument encoder object.


43
00:02:28.348 --> 00:02:31.785 line:-1 align:center
And the same is true for unbounded arrays.


44
00:02:31.818 --> 00:02:34.254 line:-2 align:center
You can now allocate acceleration
structures


45
00:02:34,288 --> 00:02:36,223 line:-1
from a Metal Heap


46
00:02:36.256 --> 00:02:39.092 line:-1 align:center
and the Shader Validation Layer alerts you


47
00:02:39.126 --> 00:02:42.496 line:-2 align:center
when resources aren’t resident
in GPU memory.


48
00:02:42,529 --> 00:02:47,467 line:-2
Together, these four features
make it easier than ever to go bindless.


49
00:02:48,735 --> 00:02:54,107 line:-2
In particular, writing argument buffers
in Metal 3 is a joy.


50
00:02:54,141 --> 00:02:56,343 line:-1
To encode a scene into argument buffers,


51
00:02:56.376 --> 00:02:58.512 line:-2 align:center
you write into these buffers
the scene data,


52
00:02:58.545 --> 00:03:03.150 line:-2 align:center
such as instances, meshes,
materials, and textures.


53
00:03:03.183 --> 00:03:07.621 line:-2 align:center
In Metal 2, this is accomplished
with an argument encoder.


54
00:03:07.654 --> 00:03:10.858 line:-2 align:center
So first, I will recap
how these objects work,


55
00:03:10,891 --> 00:03:14,928 line:-2
and then I will show you
how Metal 3 helps simplify your code.


56
00:03:14.962 --> 00:03:19.299 line:-2 align:center
With argument encoders, the first step
is to create the encoder instance.


57
00:03:19,333 --> 00:03:21,568 line:-1
You do this via shader function reflection


58
00:03:21,602 --> 00:03:25,105 line:-2
or by describing
the struct members to Metal.


59
00:03:25.138 --> 00:03:29.309 line:-2 align:center
With the encoder instance,
set its recording destination and offset


60
00:03:29.343 --> 00:03:32.145 line:-1 align:center
to the target argument buffer.


61
00:03:32,179 --> 00:03:36,083 line:-2
And use its methods to
write data into the buffer.


62
00:03:36.116 --> 00:03:38.151 line:-2 align:center
Please check out the bindless session
from last year


63
00:03:38.185 --> 00:03:42.856 line:-2 align:center
for a detailed refresher on argument
buffers and argument encoders.


64
00:03:42,890 --> 00:03:44,725 line:-1
Now this mechanism is great,


65
00:03:44,758 --> 00:03:48,562 line:-2
but the encoder objects
can sometimes be challenging to manage.


66
00:03:48.595 --> 00:03:51.798 line:-2 align:center
Metal provides two mechanisms
for creating argument encoders.


67
00:03:51,832 --> 00:03:55,369 line:-2
It might not be clear
which one is appropriate for your app.


68
00:03:55.402 --> 00:04:00.507 line:-2 align:center
Additionally, using an argument encoder
from multiple threads requires care.


69
00:04:00,541 --> 00:04:04,111 line:-2
Developers, intuitively understand
how to write a C struct,


70
00:04:04,144 --> 00:04:09,316 line:-2
and with Metal 3, you can now do just that
for your argument buffers.


71
00:04:09.349 --> 00:04:12.319 line:-2 align:center
Metal 3 simplifies writing argument
buffers by allowing you


72
00:04:12,352 --> 00:04:16,857 line:-2
to directly write into them
like any other CPU-side structure.


73
00:04:16.890 --> 00:04:20.060 line:-2 align:center
You now have access
to the virtual GPU address


74
00:04:20,093 --> 00:04:23,797 line:-1
and Resource IDs of your resources.


75
00:04:23,830 --> 00:04:26,366 line:-2
When you write these directly
into your argument buffer,


76
00:04:26.400 --> 00:04:29.937 line:-2 align:center
Metal now understands
what resources you are referencing.


77
00:04:29,970 --> 00:04:32,873 line:-2
It is functionally the same
as previously encoding the reference


78
00:04:32,906 --> 00:04:37,678 line:-2
using an argument encoder,
except an encoder isn't needed anymore.


79
00:04:37.711 --> 00:04:41.915 line:-2 align:center
This capability is supported all devices
with argument buffers tier 2 support.


80
00:04:41,949 --> 00:04:45,452 line:-1
That is, any Mac from 2016 or newer,


81
00:04:45.485 --> 00:04:50.123 line:-2 align:center
and any iOS device with
the A13 bionic chip or newer.


82
00:04:51.892 --> 00:04:54.962 line:-2 align:center
If you are unsure whether
a device supports argument buffers tier 2,


83
00:04:54.995 --> 00:05:00.267 line:-2 align:center
there is a convenient feature query
in the MTLDevice object that you can use.


84
00:05:00.300 --> 00:05:03.904 line:-2 align:center
This is what the process
now looks like in Metal 3.


85
00:05:03,937 --> 00:05:09,376 line:-2
First, define your CPU-visible structs,
using a 64-bit type for buffer addresses,


86
00:05:09.409 --> 00:05:13.680 line:-1 align:center
and MTLResourceID for textures.


87
00:05:13.714 --> 00:05:16.550 line:-1 align:center
Then, allocate the argument buffer.


88
00:05:16,583 --> 00:05:23,056 line:-2
You allocate buffers either directly
from the MTLDevice, or from a MTLHeap.


89
00:05:23.090 --> 00:05:29.062 line:-2 align:center
You get the buffer's contents and cast it
to the argument buffer struct type.


90
00:05:29,096 --> 00:05:34,001 line:-2
And finally, write the addresses
and resource IDs to the struct members.


91
00:05:34,034 --> 00:05:37,938 line:-2
Take a look at how this is done
in the hybrid rendering demo.


92
00:05:37.971 --> 00:05:41.542 line:-2 align:center
Here is the code.
Notice how simple it is.


93
00:05:41.575 --> 00:05:46.880 line:-2 align:center
The host-side struct directly stores
the GPU address of the normals buffer.


94
00:05:46.914 --> 00:05:52.653 line:-2 align:center
This is a 64-bit unsigned integer
so I used uint64_t.


95
00:05:52.686 --> 00:05:54.488 line:-1 align:center
Now that there is no encoder object,


96
00:05:54,521 --> 00:05:59,459 line:-2
you simply use the size of the struct
for your argument buffer.


97
00:05:59.493 --> 00:06:03.697 line:-2 align:center
Metal guarantees that the size
and alignment of the GPU and CPU structs


98
00:06:03.730 --> 00:06:07.100 line:-2 align:center
match across clang
and the Metal shader compiler.


99
00:06:08,769 --> 00:06:13,273 line:-1
Next, allocate the buffer as usual.


100
00:06:13,307 --> 00:06:16,143 line:-2
And if a buffer’s storage mode
is Managed or Shared,


101
00:06:16.176 --> 00:06:21.648 line:-2 align:center
get a direct pointer to the buffer
and cast it to the struct type.


102
00:06:21.682 --> 00:06:25.185 line:-2 align:center
And finally, set the normals member
to the gpuAddress,


103
00:06:25,219 --> 00:06:29,623 line:-2
and optionally, an offset that you must
align to the GPU’s memory requirements.


104
00:06:32,359 --> 00:06:35,963 line:-2
One thing I want to highlight
is how the structure declaration changes


105
00:06:35,996 --> 00:06:39,833 line:-2
between the Metal Shading Language
and the C declaration.


106
00:06:39,867 --> 00:06:42,135 line:-1
In this example, these are kept separate,


107
00:06:42,169 --> 00:06:46,573 line:-2
but if you prefer, you can have a single
struct declaration in a shared header


108
00:06:46,607 --> 00:06:49,243 line:-2
and use conditional compilation
to distinguish between


109
00:06:49,276 --> 00:06:52,412 line:-1
the shader compiler types and the C types.


110
00:06:53.146 --> 00:06:56.149 line:-1 align:center
Here’s a unified declaration in C.


111
00:06:56,183 --> 00:07:00,254 line:-2
The __METAL_VERSION__ macro is only
defined when compiling shader code.


112
00:07:00,287 --> 00:07:05,692 line:-2
Use it to separate GPU and CPU code
in header declarations.


113
00:07:05.726 --> 00:07:09.062 line:-2 align:center
If your app targets C++,
you can take this further


114
00:07:09,096 --> 00:07:12,866 line:-2
and use templates to make
the declarations even more uniform.


115
00:07:13.867 --> 00:07:18.005 line:-2 align:center
Check out the argument buffer
sample code for the best practices.


116
00:07:18,038 --> 00:07:20,374 line:-1
Now that's how you write one struct,


117
00:07:20,407 --> 00:07:24,378 line:-2
but you can also write many structs
using unbounded arrays.


118
00:07:24.411 --> 00:07:28.315 line:-2 align:center
You could already implement unbounded
arrays in Metal using argument encoders,


119
00:07:28,348 --> 00:07:31,251 line:-2
but Metal 3 simplifies the process
even further


120
00:07:31,285 --> 00:07:35,122 line:-2
by bringing it closer to just filling out
an array of structs.


121
00:07:36.223 --> 00:07:40.160 line:-2 align:center
Here's what's different compared
to just writing one struct.


122
00:07:40,194 --> 00:07:46,400 line:-2
You now need to allocate enough storage
for all structs you want to store.


123
00:07:46,433 --> 00:07:52,539 line:-2
And then, iterate over the array,
writing the data for each struct.


124
00:07:53.540 --> 00:07:57.244 line:-2 align:center
Back to the code sample,
first, expand the size of the buffer


125
00:07:57.277 --> 00:08:01.615 line:-2 align:center
to store as many structs
as meshes in the scene.


126
00:08:01,648 --> 00:08:05,385 line:-2
Notice how this is exactly the same
you do for a CPU buffer:


127
00:08:05,419 --> 00:08:10,524 line:-2
multiply the size of the struct
times the mesh count.


128
00:08:10.557 --> 00:08:13.827 line:-2 align:center
I want to take a moment to note
how powerful this is.


129
00:08:13.861 --> 00:08:17.631 line:-2 align:center
This single variable completely controls
the size of the array.


130
00:08:17.664 --> 00:08:19.600 line:-2 align:center
The shader does not need
to declare this size


131
00:08:19,633 --> 00:08:21,835 line:-1
to the Metal shader compiler at any point


132
00:08:21,869 --> 00:08:24,771 line:-1
and it's free to index into any position.


133
00:08:24,805 --> 00:08:28,475 line:-2
This is part of the reason the bindless
model is so flexible in Metal,


134
00:08:28,509 --> 00:08:32,579 line:-2
because you write shaders that access
arrays of any size with no constraints.


135
00:08:32,613 --> 00:08:34,448 line:-1
It just works!


136
00:08:36.416 --> 00:08:40.187 line:-1 align:center
Next, allocate the buffer of this size


137
00:08:40.220 --> 00:08:44.892 line:-2 align:center
and cast the pointer to the contents
to the correct mesh struct type.


138
00:08:46,860 --> 00:08:50,397 line:-2
Now that the buffer is large enough,
walk it with a simple for loop,


139
00:08:50.430 --> 00:08:55.102 line:-1 align:center
straddling the size of the mesh struct.


140
00:08:55,135 --> 00:08:59,706 line:-2
And finally, directly set the GPUAddress
of each struct in the array,


141
00:08:59.740 --> 00:09:02.309 line:-1 align:center
and optionally, an aligned offset.


142
00:09:04,144 --> 00:09:06,613 line:-1
From the GPU side in the shader,


143
00:09:06,647 --> 00:09:09,650 line:-2
this is one way
to represent the unbounded array.


144
00:09:09,683 --> 00:09:14,955 line:-2
Here, I declare it as a mesh pointer
parameter that I pass to the shader.


145
00:09:16,657 --> 00:09:19,893 line:-2
This makes it possible to freely access
the contents directly,


146
00:09:19.927 --> 00:09:22.529 line:-1 align:center
just as you would for any C array.


147
00:09:25,365 --> 00:09:30,370 line:-2
Another option is to pull
all the unbounded arrays into a struct.


148
00:09:30.404 --> 00:09:35.275 line:-2 align:center
This helps keep shaders neat
by aggregating data in a single place.


149
00:09:35.309 --> 00:09:37.377 line:-2 align:center
In this example,
all the meshes and materials


150
00:09:37.411 --> 00:09:40.347 line:-1 align:center
are brought together in a scene struct.


151
00:09:42,549 --> 00:09:45,719 line:-2
Using the scene struct,
the scene is passed directly to the shader


152
00:09:45.752 --> 00:09:47.421 line:-1 align:center
by binding a single buffer,


153
00:09:47.454 --> 00:09:50.691 line:-2 align:center
instead of passing every unbounded array
separately.


154
00:09:52.459 --> 00:09:54.394 line:-1 align:center
And access is just like before,


155
00:09:54.428 --> 00:09:58.832 line:-2 align:center
but now, the mesh array is reached
through the scene struct.


156
00:09:59.666 --> 00:10:04.371 line:-2 align:center
And that’s how to write argument buffers
and unbounded arrays in Metal 3.


157
00:10:04,404 --> 00:10:07,241 line:-2
The completely revamped API
now makes it more intuitive


158
00:10:07.274 --> 00:10:12.212 line:-2 align:center
and matches what you do for CPU structs,
or arrays of structs.


159
00:10:12,246 --> 00:10:14,114 line:-1
With this year's ray tracing update,


160
00:10:14.147 --> 00:10:17.284 line:-2 align:center
ray tracing acceleration structures
can be allocated from Metal Heaps,


161
00:10:17.317 --> 00:10:19.786 line:-1 align:center
along with your buffers and textures.


162
00:10:21.722 --> 00:10:24.491 line:-2 align:center
This means they can be aggregated
together amongst themselves


163
00:10:24.525 --> 00:10:26.960 line:-1 align:center
and with other resource types.


164
00:10:26,994 --> 00:10:30,864 line:-2
This is great, because when you aggregate
all acceleration structures into heaps,


165
00:10:30.898 --> 00:10:35.269 line:-2 align:center
you can flag them all resident
in a single call to useHeap.


166
00:10:35.302 --> 00:10:38.438 line:-2 align:center
This is a huge opportunity
for significant CPU savings


167
00:10:38.472 --> 00:10:41.041 line:-1 align:center
in your application's render thread.


168
00:10:42.476 --> 00:10:46.113 line:-2 align:center
Here are some tips for working with
acceleration structures in heaps.


169
00:10:46.146 --> 00:10:49.349 line:-2 align:center
First, when allocated from heaps,
acceleration structures have


170
00:10:49,383 --> 00:10:53,787 line:-2
alignment and size requirements
that vary per device.


171
00:10:53,820 --> 00:10:56,790 line:-2
There is a new query to check
for the size and alignment


172
00:10:56.823 --> 00:11:00.227 line:-2 align:center
of an acceleration structure
for heap allocation.


173
00:11:00,260 --> 00:11:03,864 line:-2
Use the heapAccelerationStructureSize
andAlignWithDescriptor method


174
00:11:03.897 --> 00:11:06.834 line:-2 align:center
of the MTLDevice to determine
the SizeAndAlignment


175
00:11:06.867 --> 00:11:09.803 line:-1 align:center
for structure descriptors.


176
00:11:09.837 --> 00:11:11.705 line:-1 align:center
Keep in mind, this is different


177
00:11:11,738 --> 00:11:14,408 line:-2
from the accelerationStructureSizes
WithDescriptor method


178
00:11:14.441 --> 00:11:16.443 line:-1 align:center
in MTLDevice.


179
00:11:18.612 --> 00:11:22.015 line:-2 align:center
Now that acceleration structures
are in a MTLHeap object,


180
00:11:22,049 --> 00:11:25,652 line:-2
call useHeap: to make them
all resident in a single call.


181
00:11:25,686 --> 00:11:31,758 line:-2
This is faster than calling
useResource on each individual resource.


182
00:11:31,792 --> 00:11:35,095 line:-2
And keep in mind that unless
you opt your heap into hazard tracking,


183
00:11:35.128 --> 00:11:38.999 line:-2 align:center
Metal does not prevent race conditions
for resources allocated from them,


184
00:11:39,032 --> 00:11:41,768 line:-2
so you will need to synchronize
the acceleration structure builds


185
00:11:41,802 --> 00:11:44,938 line:-2
between one another
and with ray tracing work.


186
00:11:44,972 --> 00:11:47,441 line:-2
Don't worry though,
I will talk more about this in a moment.


187
00:11:48,942 --> 00:11:50,310 line:-1
For more details on this


188
00:11:50,344 --> 00:11:53,180 line:-2
and other ray tracing performance
advances in Metal 3,


189
00:11:53.213 --> 00:11:54.081 line:-1 align:center
make sure to check out


190
00:11:54.114 --> 00:11:58.118 line:-2 align:center
the "Maximize your Metal ray tracing
performance" talk this year.


191
00:11:58.151 --> 00:12:02.122 line:-2 align:center
Using heap-allocated acceleration
structures provides an opportunity


192
00:12:02,155 --> 00:12:06,059 line:-2
to reduce your app's CPU usage
when it matters the most.


193
00:12:06,093 --> 00:12:09,763 line:-2
Last but not least, here's one of my
favorite features this year:


194
00:12:09,796 --> 00:12:12,866 line:-1
Shader validation enhancements.


195
00:12:13,867 --> 00:12:16,436 line:-1
On the topic of useResource and useHeap,


196
00:12:16.470 --> 00:12:18.972 line:-2 align:center
it is very important that
apps flag residency to Metal


197
00:12:19.006 --> 00:12:22.075 line:-1 align:center
for all indirectly accessed resources.


198
00:12:22.109 --> 00:12:25.712 line:-2 align:center
Forgetting to do it means that the memory
pages backing those resources


199
00:12:25.746 --> 00:12:28.582 line:-1 align:center
may not be present at rendering time.


200
00:12:28,615 --> 00:12:34,188 line:-2
This can cause command buffer failures,
GPU restarts, or even image corruption.


201
00:12:34,221 --> 00:12:37,457 line:-2
Unfortunately, it is very common
to run into these problems


202
00:12:37.491 --> 00:12:40.494 line:-2 align:center
when starting the bindless journey,
because in bindless,


203
00:12:40,527 --> 00:12:43,864 line:-2
the majority of scene resources
are accessed indirectly,


204
00:12:43.897 --> 00:12:48.769 line:-2 align:center
and shaders make pointer navigation
decisions at runtime.


205
00:12:48.802 --> 00:12:51.705 line:-2 align:center
This year, Metal 3 introduces
new functionality


206
00:12:51,738 --> 00:12:54,908 line:-2
in the shader validation layer
that will help you track down


207
00:12:54.942 --> 00:12:58.712 line:-2 align:center
missing residency of resources
during command buffer execution.


208
00:12:58.745 --> 00:13:01.181 line:-1 align:center
I'll show you a concrete example.


209
00:13:01.215 --> 00:13:03.951 line:-2 align:center
During the update process
of the Hybrid Rendering app,


210
00:13:03.984 --> 00:13:09.356 line:-2 align:center
we encountered a real problem where
reflections sometimes looked incorrect.


211
00:13:09.389 --> 00:13:14.127 line:-2 align:center
I'll show you how the validation layer
helped diagnose and fix this problem.


212
00:13:15,362 --> 00:13:19,533 line:-2
To flag residency to Metal, the app stores
all individual resources


213
00:13:19.566 --> 00:13:24.538 line:-2 align:center
not backed by heaps
into a mutable set at load time.


214
00:13:24,571 --> 00:13:28,809 line:-1
The app adds buffers and it adds textures.


215
00:13:28.842 --> 00:13:32.779 line:-2 align:center
At rendering time, before the app
dispatches the ray tracing kernel,


216
00:13:32.813 --> 00:13:37.050 line:-2 align:center
it indicates to Metal that it uses
all resources in the set.


217
00:13:37,084 --> 00:13:39,953 line:-2
This is a simple process where
the app iterates over the set


218
00:13:39,987 --> 00:13:43,190 line:-1
and calls useResource on each element.


219
00:13:43,223 --> 00:13:46,026 line:-2
Metal then makes
all these resources resident


220
00:13:46,059 --> 00:13:49,263 line:-1
before starting the ray tracing work.


221
00:13:49.296 --> 00:13:53.800 line:-2 align:center
Here's part of the code where the app
collects the resources into this set.


222
00:13:53.834 --> 00:13:58.772 line:-2 align:center
The app does this as part of
its argument buffer writing process.


223
00:13:58,805 --> 00:14:03,810 line:-2
The app's loading function
iterates over each submesh.


224
00:14:03,844 --> 00:14:06,346 line:-2
It nabs the data it needs
to write to the argument buffer--


225
00:14:06.380 --> 00:14:11.151 line:-2 align:center
that is, index data and
texture data for materials--


226
00:14:11.185 --> 00:14:16.123 line:-2 align:center
then it stores the index buffer's
address in the argument buffer.


227
00:14:16.156 --> 00:14:18.959 line:-2 align:center
For materials,
it then loops over the texture array,


228
00:14:18.992 --> 00:14:24.865 line:-2 align:center
writing the texture GPU resource IDs
into the argument buffer.


229
00:14:24.898 --> 00:14:27.935 line:-2 align:center
And at the end,
it adds all individual textures


230
00:14:27,968 --> 00:14:31,138 line:-2
from the submesh materials
to the sceneResources set,


231
00:14:31,171 --> 00:14:34,174 line:-2
so it can flag them resident
at dispatch time.


232
00:14:35,976 --> 00:14:39,713 line:-1
Unfortunately, there is a subtle bug here.


233
00:14:39,746 --> 00:14:41,648 line:-1
The app would run the command buffer,


234
00:14:41,682 --> 00:14:45,285 line:-2
and in some cases,
reflections would be missing.


235
00:14:45.319 --> 00:14:49.556 line:-2 align:center
Previously,
it was hard to track this down.


236
00:14:49.590 --> 00:14:53.827 line:-2 align:center
Now in Metal 3, the shader
validation layer comes to the rescue.


237
00:14:53.861 --> 00:14:57.865 line:-2 align:center
These kinds of problems now produce
an error during command buffer execution,


238
00:14:57.898 --> 00:15:01.768 line:-1 align:center
indicating what the problem is.


239
00:15:01.802 --> 00:15:03.604 line:-1 align:center
The error message indicates


240
00:15:03,637 --> 00:15:07,007 line:-2
the name of the shader function
that triggered the problem,


241
00:15:07.040 --> 00:15:09.409 line:-1 align:center
the name of the pass,


242
00:15:09.443 --> 00:15:14.181 line:-2 align:center
the metal file and line of code where it
detected the access,


243
00:15:14.214 --> 00:15:17.317 line:-2 align:center
and even the label
of the buffer, its size,


244
00:15:17.351 --> 00:15:20.554 line:-1 align:center
and the fact that it was not resident.


245
00:15:20,587 --> 00:15:24,825 line:-2
As a pro tip, this is why it's always
a good practice to label Metal objects.


246
00:15:24.858 --> 00:15:27.694 line:-2 align:center
The tools use the labels, which is helpful
when trying to identify


247
00:15:27.728 --> 00:15:30.831 line:-2 align:center
which object is which
while debugging your app.


248
00:15:30,864 --> 00:15:32,799 line:-2
With all this
detailed information in hand,


249
00:15:32.833 --> 00:15:36.770 line:-2 align:center
it's now easy to find the missing resource
in the shader code.


250
00:15:36.803 --> 00:15:40.340 line:-2 align:center
What's even better is that
when the debug breakpoint is enabled,


251
00:15:40.374 --> 00:15:44.011 line:-2 align:center
Xcode conveniently shows
the exact line in the shader code


252
00:15:44,044 --> 00:15:47,447 line:-2
where shader validation
detects the problem.


253
00:15:47.481 --> 00:15:51.852 line:-2 align:center
In the case of the demo app, it is
the indices buffer that is not resident.


254
00:15:51,885 --> 00:15:55,422 line:-1
The fix is now straightforward.


255
00:15:55.455 --> 00:15:57.658 line:-1 align:center
Going back to the code,


256
00:15:57,691 --> 00:15:59,960 line:-2
the app now stores
the missing index buffer


257
00:15:59,993 --> 00:16:02,829 line:-1
into the resident resource set.


258
00:16:02.863 --> 00:16:05.532 line:-2 align:center
With these changes,
later at ray tracing time,


259
00:16:05.566 --> 00:16:10.838 line:-2 align:center
Metal knows to make the index buffers
available to the GPU, solving the issue.


260
00:16:10.871 --> 00:16:13.841 line:-2 align:center
This is an essential tool,
and a complete game changer,


261
00:16:13,874 --> 00:16:19,079 line:-2
that will potentially save you hours of
debugging time in your bindless journey.


262
00:16:19,112 --> 00:16:22,349 line:-2
So those are the enhancements
Metal 3 brings to help you organize


263
00:16:22,382 --> 00:16:24,685 line:-1
and refer to bindless resources.


264
00:16:24,718 --> 00:16:27,321 line:-2
Now I'm going to switch gears
and talk about how to maximize


265
00:16:27,354 --> 00:16:30,190 line:-2
your game's performance
when going bindless.


266
00:16:30.224 --> 00:16:32.793 line:-1 align:center
In this section, I will cover two topics:


267
00:16:32.826 --> 00:16:36.597 line:-2 align:center
unretained resources,
and untracked resources.


268
00:16:36.630 --> 00:16:40.133 line:-2 align:center
These tips will help you get
more performance out of both your CPU


269
00:16:40,167 --> 00:16:44,638 line:-2
and your GPU when you have
long-lived and aggregate resources.


270
00:16:44,671 --> 00:16:48,509 line:-2
Now, to talk about how to improve
CPU performance with long-lived resources,


271
00:16:48.542 --> 00:16:51.678 line:-2 align:center
I will first recap
the Metal resource lifecycle.


272
00:16:51,712 --> 00:16:56,884 line:-2
Objective-C and Swift handle
object lifecycles via reference counting.


273
00:16:56.917 --> 00:16:59.319 line:-1 align:center
Metal resources follow this model.


274
00:16:59.353 --> 00:17:02.222 line:-1 align:center
Resources start with a retainCount of 1


275
00:17:02.256 --> 00:17:07.461 line:-2 align:center
and the runtime deallocates them
when all strong references disappear.


276
00:17:07,494 --> 00:17:10,998 line:-2
Because the CPU
and GPU operate in parallel,


277
00:17:11,031 --> 00:17:14,401 line:-2
it would be a problem if
the CPU deallocated a resource


278
00:17:14.434 --> 00:17:18.672 line:-2 align:center
by allowing its retainCount to reach 0
while the GPU is still using it.


279
00:17:19.706 --> 00:17:23.377 line:-2 align:center
To prevent this, Metal command buffers
create strong references


280
00:17:23,410 --> 00:17:25,179 line:-1
to all resources they use,


281
00:17:25.212 --> 00:17:30.284 line:-2 align:center
ensuring their retainCount
is always at least 1.


282
00:17:30.317 --> 00:17:33.120 line:-1 align:center
Metal creates strong references for


283
00:17:33,153 --> 00:17:35,222 line:-1
resources you directly bind to a pipeline


284
00:17:35,255 --> 00:17:39,693 line:-2
with functions such as
setVertexBuffer or setFragmentTexture--


285
00:17:39.726 --> 00:17:42.896 line:-2 align:center
and this also includes render
attachments--


286
00:17:42,930 --> 00:17:48,168 line:-2
Metal heap objects you flag resident
via the useHeap API,


287
00:17:48.202 --> 00:17:50.637 line:-2 align:center
and indirect resources
that you make resident


288
00:17:50.671 --> 00:17:55.475 line:-2 align:center
via the useResource API,
even if they are part of a heap.


289
00:17:55,509 --> 00:17:58,078 line:-2
For more details
on Metal object lifecycles,


290
00:17:58,111 --> 00:18:03,317 line:-2
please check out the "Program Metal
in C++ with metal-cpp" talk this year.


291
00:18:03,350 --> 00:18:06,486 line:-2
Now, it's very useful that
Metal creates these references,


292
00:18:06.520 --> 00:18:08.722 line:-2 align:center
because as a programmer,
you never have to worry


293
00:18:08,755 --> 00:18:13,393 line:-2
that you might be deallocating an object
while the GPU is still using it.


294
00:18:13,427 --> 00:18:17,264 line:-2
This safety guarantee Metal gives you
is very fast to execute,


295
00:18:17.297 --> 00:18:20.534 line:-1 align:center
but it does comes with a small CPU cost.


296
00:18:20,567 --> 00:18:25,305 line:-2
Now, in the bindless model,
apps aggregate resources into heaps


297
00:18:25.339 --> 00:18:28.842 line:-2 align:center
and these tend to be long lived,
matching the application's domain.


298
00:18:28.876 --> 00:18:34.214 line:-2 align:center
For example, in a game, resources are
alive for the duration of a whole level.


299
00:18:34,248 --> 00:18:36,917 line:-2
When this is the case, it becomes
unnecessary for Metal


300
00:18:36.950 --> 00:18:40.587 line:-2 align:center
to provide additional guarantees
about resource lifecycles.


301
00:18:41.288 --> 00:18:44.324 line:-2 align:center
What you can do then
is recoup this CPU cost


302
00:18:44.358 --> 00:18:49.329 line:-2 align:center
by asking Metal command buffers
not to retain resources they reference.


303
00:18:50,564 --> 00:18:53,133 line:-2
To turn off Metal's
automatic resource retaining,


304
00:18:53.166 --> 00:18:57.271 line:-2 align:center
simply create a command buffer
with unretained references.


305
00:18:57,304 --> 00:19:00,040 line:-2
You do this directly
from the MTLCommandQueue,


306
00:19:00.073 --> 00:19:03.143 line:-2 align:center
just like you create
any regular command buffer.


307
00:19:03.177 --> 00:19:05.479 line:-2 align:center
You don't need to make
any other changes to your app,


308
00:19:05,512 --> 00:19:08,815 line:-2
as long as you are already guaranteeing
your resource lifecycles.


309
00:19:09.783 --> 00:19:12.519 line:-2 align:center
Keep in mind that
the granularity level for this setting


310
00:19:12.553 --> 00:19:14.454 line:-1 align:center
is the entire command buffer.


311
00:19:14,488 --> 00:19:18,825 line:-2
It will either retain all referenced
resources or none of them.


312
00:19:19,826 --> 00:19:21,361 line:-1
In a small microbenchmark,


313
00:19:21,395 --> 00:19:26,099 line:-2
we measured a CPU usage reduction of 2% in
the command buffer's lifecycle


314
00:19:26,133 --> 00:19:29,403 line:-2
just by switching to command buffers
with unretained references.


315
00:19:29.436 --> 00:19:32.172 line:-2 align:center
but this time was spent entirely


316
00:19:32,206 --> 00:19:36,043 line:-2
creating and destroying
unnecessary strong references.


317
00:19:37.044 --> 00:19:42.216 line:-2 align:center
In summary, unretained resources provides
an opportunity for some extra CPU savings


318
00:19:42.249 --> 00:19:46.220 line:-2 align:center
when you are already guaranteeing
resource lifecycles.


319
00:19:46.253 --> 00:19:49.456 line:-2 align:center
Similar to unretained resources,
untracked resources


320
00:19:49.489 --> 00:19:52.359 line:-2 align:center
provides an opportunity to disable
a safety feature


321
00:19:52,392 --> 00:19:55,095 line:-1
to obtain more performance.


322
00:19:55.128 --> 00:19:58.599 line:-2 align:center
Many visual techniques consist in
rendering to intermediate textures


323
00:19:58.632 --> 00:20:02.803 line:-2 align:center
and writing into buffers and then
consuming them in later passes.


324
00:20:02.836 --> 00:20:07.674 line:-2 align:center
Shadow mapping, skinning, and
post-processing are good examples of this.


325
00:20:07.708 --> 00:20:11.378 line:-2 align:center
Now, producing
and immediately consuming resources


326
00:20:11,411 --> 00:20:15,115 line:-1
introduces read-after-write hazards.


327
00:20:15,148 --> 00:20:18,318 line:-2
Additionally, when several passes
write to the same resource,


328
00:20:18,352 --> 00:20:19,520 line:-1
such as two render passes


329
00:20:19,553 --> 00:20:22,956 line:-2
drawing into the same attachment,
one after the other,


330
00:20:22.990 --> 00:20:26.226 line:-2 align:center
or two blit encoders
write into the same resource,


331
00:20:26.260 --> 00:20:28.662 line:-1 align:center
it produces write-after-write hazards


332
00:20:28,695 --> 00:20:33,133 line:-2
because of the way Metal schedules work
on the GPU.


333
00:20:33.166 --> 00:20:36.436 line:-2 align:center
When you use tracked resources,
Metal automatically uses


334
00:20:36,470 --> 00:20:41,375 line:-2
synchronization primitives to
avoid hazards on the GPU timeline.


335
00:20:41.408 --> 00:20:43.810 line:-1 align:center
For example, Metal makes the GPU wait


336
00:20:43,844 --> 00:20:46,547 line:-2
for a compute skinning pass
to finish writing into a buffer


337
00:20:46.580 --> 00:20:50.617 line:-2 align:center
before starting a scene rendering pass
that reads from the same buffer.


338
00:20:51.652 --> 00:20:52.819 line:-1 align:center
This is great,


339
00:20:52,853 --> 00:20:57,090 line:-2
and it's a big part of why Metal is
such an approachable graphics API,


340
00:20:57,124 --> 00:20:59,193 line:-2
but there are some performance
considerations for apps


341
00:20:59.226 --> 00:21:02.229 line:-1 align:center
that aggregate resources into heaps.


342
00:21:03,230 --> 00:21:05,265 line:-1
Consider this example.


343
00:21:05.299 --> 00:21:06.867 line:-1 align:center
Here, the GPU is busy,


344
00:21:06,900 --> 00:21:09,036 line:-2
drawing two frames
that do vertex skinning,


345
00:21:09,069 --> 00:21:13,640 line:-2
render the scene, and apply tone mapping,
one after the other.


346
00:21:13.674 --> 00:21:17.578 line:-2 align:center
As the app keeps the GPU busy,
Metal identifies opportunities


347
00:21:17,611 --> 00:21:22,850 line:-2
where render and compute work can overlap,
based on resource dependencies.


348
00:21:22.883 --> 00:21:26.019 line:-2 align:center
When there are no dependencies,
and the conditions are right,


349
00:21:26.053 --> 00:21:29.756 line:-2 align:center
Metal schedules work to overlap
and run in parallel.


350
00:21:29.790 --> 00:21:33.293 line:-2 align:center
This saturates the GPU and allows it
to get more work done


351
00:21:33,327 --> 00:21:36,296 line:-1
in the same amount of wall-clock time.


352
00:21:38,298 --> 00:21:41,568 line:-2
Now, when the app aggregates
resources together in a heap,


353
00:21:41,602 --> 00:21:45,606 line:-2
all of its subresources appear
as a single one to Metal.


354
00:21:45.639 --> 00:21:48.642 line:-2 align:center
This is what makes heaps
so efficient to work with.


355
00:21:48.675 --> 00:21:52.779 line:-2 align:center
But this means that Metal sees
read and write work on the same resource


356
00:21:52,813 --> 00:21:56,950 line:-2
and must conservatively schedule work
to avoid any race conditions,


357
00:21:56,984 --> 00:22:00,087 line:-1
even when no actual hazard exists.


358
00:22:02,823 --> 00:22:06,393 line:-2
This situation is called "false sharing"
and, as you might expect,


359
00:22:06.426 --> 00:22:10.464 line:-2 align:center
it increases the execution
wall-clock time of the GPU work.


360
00:22:10.497 --> 00:22:12.232 line:-1 align:center
So here's the performance tip.


361
00:22:12,266 --> 00:22:15,969 line:-2
If you know there are no dependencies
between the resources in the heap,


362
00:22:16.003 --> 00:22:17.938 line:-1 align:center
then you can avoid this behavior.


363
00:22:18.939 --> 00:22:23.310 line:-2 align:center
To avoid false sharing, you can opt
resources out of hazard tracking


364
00:22:23.343 --> 00:22:27.681 line:-2 align:center
and directly signal
fine-grained dependencies to Metal.


365
00:22:27.714 --> 00:22:29.383 line:-1 align:center
You opt out of resource tracking


366
00:22:29,416 --> 00:22:34,121 line:-2
by setting a resource descriptor's
hazardTracking property to Untracked.


367
00:22:34.154 --> 00:22:37.591 line:-2 align:center
Because this is so important,
it is the default behavior for heaps,


368
00:22:37.624 --> 00:22:40.494 line:-2 align:center
as it allows you to unlock more
opportunities for the GPU


369
00:22:40.527 --> 00:22:43.397 line:-2 align:center
to run your work in parallel
right out of the gate.


370
00:22:43,430 --> 00:22:45,499 line:-1
Once you start using untracked resources,


371
00:22:45.532 --> 00:22:48.969 line:-2 align:center
you express dependencies
using the following primitives.


372
00:22:49.002 --> 00:22:54.675 line:-2 align:center
Depending on the situation,
use Fences, Events,


373
00:22:54,708 --> 00:22:58,946 line:-1
Shared events, or Memory barriers.


374
00:22:58.979 --> 00:23:02.282 line:-2 align:center
Metal Fences synchronize access
to one or more resources


375
00:23:02.316 --> 00:23:04.585 line:-2 align:center
across different render
and compute passes,


376
00:23:04.618 --> 00:23:07.921 line:-2 align:center
within the context
of a single command queue.


377
00:23:07,955 --> 00:23:10,290 line:-1
This is a split barrier kind-of primitive,


378
00:23:10,324 --> 00:23:15,195 line:-2
so the consumer pass waits
until the producer signals the Fence.


379
00:23:18.966 --> 00:23:22.202 line:-2 align:center
The only requirement you need to
keep in mind when using Fences


380
00:23:22.236 --> 00:23:26.006 line:-2 align:center
is to commit or enqueue
your producer command buffers


381
00:23:26.039 --> 00:23:29.643 line:-1 align:center
before your consuming command buffers.


382
00:23:29,676 --> 00:23:31,378 line:-1
When you can't guarantee this order,


383
00:23:31.411 --> 00:23:34.615 line:-2 align:center
or need to synchronize across
multiple queues on the same device,


384
00:23:34,648 --> 00:23:37,150 line:-1
use MTL Events.


385
00:23:37.184 --> 00:23:41.622 line:-2 align:center
Using Events, the consumer command buffer
waits for the producer command buffer


386
00:23:41,655 --> 00:23:44,992 line:-1
to signal the Event with a given value.


387
00:23:45.025 --> 00:23:48.829 line:-2 align:center
After it signals the value,
it is safe to read the resource.


388
00:23:48,862 --> 00:23:54,568 line:-2
Use Events to tell a GPU to pause work
until a command signals an Event.


389
00:23:54,601 --> 00:23:58,372 line:-2
MTLSharedEvents behave very similarly
to regular Events,


390
00:23:58.405 --> 00:24:02.743 line:-2 align:center
but work at larger scope
that goes beyond a single GPU.


391
00:24:02.776 --> 00:24:04.945 line:-2 align:center
Use these to synchronize
access to resources


392
00:24:04.978 --> 00:24:08.815 line:-2 align:center
across different Metal devices
and even with the CPU.


393
00:24:08.849 --> 00:24:11.185 line:-2 align:center
For example, use Shared Events
to process the results


394
00:24:11,218 --> 00:24:14,188 line:-1
of a GPU calculation from the CPU.


395
00:24:14,221 --> 00:24:16,123 line:-1
Here is an example.


396
00:24:16,156 --> 00:24:19,526 line:-2
The GPU in this case
skins a mesh in a compute pass


397
00:24:19,560 --> 00:24:23,530 line:-1
and the CPU stores the pose to disk.


398
00:24:23.564 --> 00:24:25.899 line:-1 align:center
Because these two are independent devices,


399
00:24:25,933 --> 00:24:31,471 line:-2
use a Shared Event to have the CPU wait
until the GPU produces the resource.


400
00:24:31.505 --> 00:24:34.107 line:-2 align:center
In the beginning,
the CPU unconditionally starts to wait


401
00:24:34.141 --> 00:24:38.846 line:-1 align:center
for the GPU to signal the Shared Event.


402
00:24:38.879 --> 00:24:42.482 line:-2 align:center
When the GPU produces the resource
and places it into unified memory,


403
00:24:42.516 --> 00:24:44.518 line:-1 align:center
it signals the Shared Event.


404
00:24:44.551 --> 00:24:47.921 line:-2 align:center
At this point, the waiting thread
on the CPU wakes up


405
00:24:47.955 --> 00:24:50.424 line:-1 align:center
and safely consumes the resource.


406
00:24:52,426 --> 00:24:55,462 line:-2
The last primitive type
is Memory Barriers.


407
00:24:55.495 --> 00:24:58.765 line:-2 align:center
A Memory Barrier forces all subsequent
commands within a single render


408
00:24:58,799 --> 00:25:02,936 line:-2
or compute pass to wait
until all the previous commands finish.


409
00:25:02,970 --> 00:25:08,208 line:-2
The cost of a barrier is similar to the
cost of a Fence in almost all cases.


410
00:25:08.242 --> 00:25:10.944 line:-1 align:center
There is, however, one exception.


411
00:25:14.348 --> 00:25:19.186 line:-2 align:center
That exception is barriers after
the fragment stage in a render pass.


412
00:25:19,219 --> 00:25:21,622 line:-1
These barriers have a very high cost


413
00:25:21.655 --> 00:25:24.525 line:-2 align:center
that’s similar to splitting
the render pass.


414
00:25:24,558 --> 00:25:28,462 line:-2
Metal disables barriers after
the fragment stage on Apple GPUs


415
00:25:28.495 --> 00:25:32.199 line:-2 align:center
to help your apps
stay on the fastest driver path.


416
00:25:32.232 --> 00:25:35.469 line:-2 align:center
The Metal debug layer even
generates a validation error


417
00:25:35.502 --> 00:25:39.940 line:-2 align:center
if you add an after-fragment barrier
on Apple GPUs.


418
00:25:39,973 --> 00:25:43,110 line:-2
It is recommended to use a Fence
to synchronize resources


419
00:25:43,143 --> 00:25:45,345 line:-1
after the fragment stage.


420
00:25:46,413 --> 00:25:48,916 line:-2
Here's a short summary
of the synchronization primitives


421
00:25:48,949 --> 00:25:51,185 line:-1
and when to use them.


422
00:25:51.218 --> 00:25:53.987 line:-2 align:center
Prefer using Fences
for the lowest overhead


423
00:25:54,021 --> 00:25:55,789 line:-1
when committing or enqueueing work


424
00:25:55.822 --> 00:25:59.793 line:-2 align:center
to a single command queue
in producer, then consumer order.


425
00:25:59.826 --> 00:26:04.298 line:-2 align:center
Fences are great
for the majority of common cases.


426
00:26:04,331 --> 00:26:06,500 line:-2
When the submission order
can't be guaranteed,


427
00:26:06.533 --> 00:26:11.138 line:-2 align:center
or there are multiple command queues,
use Metal Events.


428
00:26:11.171 --> 00:26:14.107 line:-2 align:center
Shared Events allows synchronization
of multiple GPUs


429
00:26:14.141 --> 00:26:16.243 line:-1 align:center
between themselves and with the CPU.


430
00:26:16,276 --> 00:26:20,948 line:-2
Use them only in these specific
multi-device cases.


431
00:26:20.981 --> 00:26:25.586 line:-2 align:center
Use Memory Barriers for cases where
it's desired to synchronize within a pass.


432
00:26:25,619 --> 00:26:28,255 line:-2
Barriers are a fast primitive
in most cases,


433
00:26:28.288 --> 00:26:32.226 line:-2 align:center
such as concurrent compute passes,
and vertex stages between draw calls.


434
00:26:32,259 --> 00:26:36,230 line:-2
But friendly reminder, use a Fence
between passes instead of a barrier


435
00:26:36,263 --> 00:26:38,765 line:-2
for synchronizing
after the fragment stages,


436
00:26:38,799 --> 00:26:42,936 line:-2
because these barriers are very expensive
and Apple GPUs don't allow it.


437
00:26:44.071 --> 00:26:47.741 line:-2 align:center
Using untracked resources
and manual fine-grained tracking,


438
00:26:47.774 --> 00:26:51.712 line:-2 align:center
you can now have
all the advantages of data aggregation,


439
00:26:51.745 --> 00:26:55.782 line:-1 align:center
while maximizing GPU parallelism.


440
00:26:55.816 --> 00:26:59.186 line:-2 align:center
And those are the performance tips
to get the most out of the CPU


441
00:26:59.219 --> 00:27:02.923 line:-1 align:center
and GPU when going bindless.


442
00:27:02.956 --> 00:27:05.359 line:-2 align:center
I've talked a lot about how Metal 3
unlocks simplified


443
00:27:05,392 --> 00:27:07,194 line:-1
and efficient bindless workflows.


444
00:27:07,227 --> 00:27:09,429 line:-2
But writing code is only half
the equation.


445
00:27:09,463 --> 00:27:12,266 line:-2
The other half is how the available tools
can help you verify


446
00:27:12,299 --> 00:27:15,002 line:-1
how the GPU sees and executes work.


447
00:27:15,035 --> 00:27:16,570 line:-1
I am now going to hand it over to Mayur


448
00:27:16,603 --> 00:27:19,806 line:-2
to talk about what's new
with Metal 3 tooling for bindless.


449
00:27:19.840 --> 00:27:22.576 line:-1 align:center
Mayur: Thank you Alè.


450
00:27:22.609 --> 00:27:26.046 line:-2 align:center
Today, I'm excited to show you
some of the great new features


451
00:27:26,079 --> 00:27:31,752 line:-2
in the Metal Debugger that will help you
debug and optimize your bindless Apps.


452
00:27:31,785 --> 00:27:34,788 line:-2
I just took a frame capture
of the HybridRendering app


453
00:27:34,821 --> 00:27:37,191 line:-1
that Alè just showed you.


454
00:27:37,224 --> 00:27:39,660 line:-2
When you capture a frame in
the Metal Debugger,


455
00:27:39,693 --> 00:27:41,795 line:-1
you'll arrive to the Summary page,


456
00:27:41,828 --> 00:27:44,698 line:-2
which provides you
with an overview of your frame


457
00:27:44.731 --> 00:27:50.037 line:-2 align:center
alongside helpful insights on how
to improve your app's performance.


458
00:27:50,070 --> 00:27:54,308 line:-2
But today, I’m excited to show you
the new dependency viewer.


459
00:27:54,341 --> 00:28:00,347 line:-2
To open it, just click on
Dependencies here on the left.


460
00:28:00.380 --> 00:28:02.683 line:-1 align:center
Here is the new dependency viewer


461
00:28:02.716 --> 00:28:08.088 line:-2 align:center
and it features a brand new design
that’s packed with powerful new features.


462
00:28:08.121 --> 00:28:12.593 line:-2 align:center
The dependency viewer shows you
a graph-based representation


463
00:28:12.626 --> 00:28:14.928 line:-1 align:center
of your workload.


464
00:28:14.962 --> 00:28:18.866 line:-1 align:center
Each node in the graph represents a pass,


465
00:28:18.899 --> 00:28:25.439 line:-2 align:center
which is encoded by a command encoder,
and its output resources.


466
00:28:25.472 --> 00:28:31.245 line:-2 align:center
The edges represent resource dependencies
between passes.


467
00:28:31,278 --> 00:28:34,381 line:-2
New this year,
you can analyze your workload


468
00:28:34,414 --> 00:28:37,751 line:-1
by focusing on two types of dependencies.


469
00:28:37,784 --> 00:28:40,387 line:-1
data flow and synchronization.


470
00:28:40.420 --> 00:28:43.690 line:-1 align:center
The solid lines represent data flow


471
00:28:43.724 --> 00:28:47.294 line:-2 align:center
and they show you
how data flows in your app.


472
00:28:47,327 --> 00:28:52,199 line:-2
The dotted lines represent synchronization
and they show you dependencies


473
00:28:52.232 --> 00:28:57.738 line:-2 align:center
that introduce GPU synchronization
between passes.


474
00:28:57.771 --> 00:29:03.343 line:-2 align:center
To learn more, you can click on
any encoder, resource, or edge,


475
00:29:03.377 --> 00:29:09.283 line:-2 align:center
and the debugger will show you a lot of
detailed information in the new sidebar.


476
00:29:09,316 --> 00:29:12,886 line:-2
For example,
this edge adds synchronization


477
00:29:12,920 --> 00:29:17,391 line:-2
and also has data flow
between these passes.


478
00:29:17,424 --> 00:29:21,295 line:-2
By default, the dependency viewer
shows both data flow


479
00:29:21,328 --> 00:29:23,964 line:-1
and synchronization dependencies,


480
00:29:23.997 --> 00:29:27.501 line:-2 align:center
but you can use this menu
down here at the bottom


481
00:29:27.534 --> 00:29:31.238 line:-2 align:center
to focus on
just one of the dependency types.


482
00:29:31.271 --> 00:29:36.977 line:-2 align:center
Here, I will focus on just
synchronization.


483
00:29:37.010 --> 00:29:41.281 line:-2 align:center
As Alè said earlier,
false sharing is a common problem


484
00:29:41.315 --> 00:29:45.853 line:-2 align:center
when reading and writing
different resources from a tracked heap.


485
00:29:45,886 --> 00:29:50,424 line:-2
The dependency viewer makes it easy
to catch these issues.


486
00:29:50,457 --> 00:29:54,027 line:-2
This demo I captured is from
an early development version


487
00:29:54,061 --> 00:29:57,097 line:-1
that has this issue.


488
00:29:57,130 --> 00:30:02,069 line:-2
If I click on this heap,
the dependency viewer shows me


489
00:30:02,102 --> 00:30:04,438 line:-1
that this heap is tracked


490
00:30:04.471 --> 00:30:09.910 line:-2 align:center
and therefore adds synchronization
between these two passes.


491
00:30:09,943 --> 00:30:16,016 line:-2
The dependency viewer also highlights
the resources allocated inside the heap,


492
00:30:16,049 --> 00:30:21,054 line:-2
such as this render target texture
that the render encoder stores,


493
00:30:21,088 --> 00:30:26,593 line:-2
and a buffer that the compute encoder
reads and writes to.


494
00:30:26,627 --> 00:30:32,633 line:-2
The problem is this synchronization
between these two passes is not needed


495
00:30:32.666 --> 00:30:39.139 line:-2 align:center
because the compute encoder is not using
any resources from previous encoders.


496
00:30:39,173 --> 00:30:44,545 line:-2
To remove this dependency, I can modify
the app to use an untracked heap


497
00:30:44.578 --> 00:30:48.615 line:-2 align:center
and insert Fences
where synchronization is needed.


498
00:30:48.649 --> 00:30:55.022 line:-2 align:center
With that change,
these two passes can now run in parallel.


499
00:30:55,055 --> 00:30:58,192 line:-1
Another great improvement in Xcode 14


500
00:30:58.225 --> 00:31:02.729 line:-2 align:center
to help debug your bindless apps
is the new resource list.


501
00:31:02.763 --> 00:31:09.002 line:-2 align:center
I can navigate to a draw call
that I want to debug and open it.


502
00:31:09.036 --> 00:31:13.373 line:-2 align:center
When using bindless,
hundreds or even thousands of resources


503
00:31:13.407 --> 00:31:17.144 line:-1 align:center
are available to the GPU at any time.


504
00:31:17.177 --> 00:31:20.714 line:-2 align:center
This year, the Metal debugger gives you
the ability


505
00:31:20,747 --> 00:31:24,585 line:-2
to check which of these resources
a draw call accessed,


506
00:31:24.618 --> 00:31:29.189 line:-2 align:center
just by clicking on the
"Accessed" mode at the top.


507
00:31:29.223 --> 00:31:33.594 line:-2 align:center
Now the debugger shows me
only the handful of resources


508
00:31:33.627 --> 00:31:40.267 line:-2 align:center
that this draw call accesses
and the type of each access.


509
00:31:40,300 --> 00:31:46,173 line:-2
This is really useful for understanding
what resources your shader has accessed


510
00:31:46,206 --> 00:31:48,675 line:-1
from argument buffers.


511
00:31:48,709 --> 00:31:53,213 line:-2
Knowing what resources
your draw call uses is great,


512
00:31:53.247 --> 00:31:56.550 line:-2 align:center
but if it shows resources
that you weren’t expecting,


513
00:31:56.583 --> 00:32:01.321 line:-2 align:center
you can use the shader debugger
to figure out what’s going on.


514
00:32:01.355 --> 00:32:03.223 line:-1 align:center
To start the shader debugger,


515
00:32:03.257 --> 00:32:07.694 line:-2 align:center
just click on the debug button here
in the bottom bar,


516
00:32:07.728 --> 00:32:11.465 line:-1 align:center
select the pixel that you want to debug,


517
00:32:11,498 --> 00:32:15,102 line:-1
and hit the Debug button.


518
00:32:15.135 --> 00:32:19.072 line:-1 align:center
And now you are in the shader debugger.


519
00:32:19,106 --> 00:32:24,912 line:-2
The shader debugger shows
how your code was executed line by line,


520
00:32:24.945 --> 00:32:29.149 line:-1 align:center
including which resources were accessed.


521
00:32:29,183 --> 00:32:35,122 line:-2
For these lines, this shader reads
textures from an argument buffer.


522
00:32:35,155 --> 00:32:39,026 line:-2
I can expand the detailed views
on the right sidebar


523
00:32:39.059 --> 00:32:43.730 line:-1 align:center
to check which resources were read.


524
00:32:43.764 --> 00:32:47.835 line:-2 align:center
This can help identify issues
where your shader accesses


525
00:32:47.868 --> 00:32:51.605 line:-1 align:center
the wrong argument buffer element.


526
00:32:51.638 --> 00:32:56.009 line:-2 align:center
In this demo, I’ve shown you
how to use the new dependency viewer


527
00:32:56,043 --> 00:32:59,446 line:-2
to analyze and validate
resource dependencies,


528
00:32:59,479 --> 00:33:03,717 line:-2
how to use the new resource list
to understand what resources


529
00:33:03,750 --> 00:33:05,686 line:-1
a draw call accessed,


530
00:33:05,719 --> 00:33:09,690 line:-2
and how to use the shader debugger
to analyze, line by line,


531
00:33:09,723 --> 00:33:12,159 line:-1
how a shader was executed.


532
00:33:12,192 --> 00:33:15,262 line:-2
I can’t wait to see how you use
these new features


533
00:33:15.295 --> 00:33:17.931 line:-1 align:center
to create great Metal bindless apps.


534
00:33:17,965 --> 00:33:19,666 line:-1
Back to you Alè.


535
00:33:19.700 --> 00:33:23.003 line:-2 align:center
Alè: Thank you, Mayur.
That was an awesome demo.


536
00:33:23.036 --> 00:33:27.474 line:-2 align:center
To wrap up, Metal 3 brings a lot
to the table for going bindless.


537
00:33:27.508 --> 00:33:29.743 line:-1 align:center
With simplified argument buffer encoding,


538
00:33:29,776 --> 00:33:31,812 line:-1
acceleration structures from heaps,


539
00:33:31,845 --> 00:33:34,715 line:-2
improvements to the validation layer
and tools,


540
00:33:34,748 --> 00:33:36,650 line:-1
Metal 3 is an excellent API


541
00:33:36,683 --> 00:33:40,654 line:-2
to bring effective and performant bindless
to your games and apps.


542
00:33:40,687 --> 00:33:45,225 line:-2
With this year's enhancements, the hybrid
rendering app is looking better than ever.


543
00:33:45.259 --> 00:33:47.461 line:-2 align:center
We are releasing
this updated version of the app


544
00:33:47,494 --> 00:33:51,098 line:-2
with full source code
in the Metal sample code gallery.


545
00:33:51,131 --> 00:33:53,367 line:-1
You can download, study, and modify it,


546
00:33:53.400 --> 00:33:56.103 line:-2 align:center
and as an exercise, I challenge you to
take it even further


547
00:33:56.136 --> 00:33:59.306 line:-2 align:center
and add recursive reflections
to the mirror surfaces.


548
00:33:59.339 --> 00:34:01.074 line:-1 align:center
I can't wait to see what you do with it.


549
00:34:01,108 --> 00:34:04,845 line:-2
There has never been a better time
to go bindless with Metal 3.


550
00:34:04,878 --> 00:34:06,914 line:-1
Thank you for watching.


551
00:34:06,947 --> 00:34:09,950 line:-1
♪ instrumental hip hop music ♪

