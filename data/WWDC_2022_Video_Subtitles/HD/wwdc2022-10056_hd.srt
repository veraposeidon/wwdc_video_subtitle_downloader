2
00:00:00,501 --> 00:00:08,509 line:-1
♪ ♪


3
00:00:09,843 --> 00:00:13,514 line:-2
Paul: Hello, and welcome to
Compose Custom Layouts with SwiftUI.


4
00:00:13,547 --> 00:00:16,183 line:-2
I'm Paul, and I work
on developer documentation.


5
00:00:16.216 --> 00:00:18.919 line:-2 align:center
SwiftUI provides
a rich set of building blocks


6
00:00:18.952 --> 00:00:22.489 line:-2 align:center
that you use to compose
your app's interface.


7
00:00:22,523 --> 00:00:27,761 line:-2
You can combine built-in views
that display elements like text, images,


8
00:00:27.794 --> 00:00:31.932 line:-2 align:center
and graphics to create
custom, composite views.


9
00:00:31.965 --> 00:00:35.769 line:-2 align:center
To arrange all these elements
in ever more sophisticated groupings


10
00:00:35.802 --> 00:00:37.804 line:-1 align:center
SwiftUI provides layout tools.


11
00:00:39.139 --> 00:00:42.709 line:-2 align:center
Containers like horizontal and
vertical stacks let you tell SwiftUI


12
00:00:42.743 --> 00:00:45.112 line:-2 align:center
where to put views
relative to one another,


13
00:00:45,145 --> 00:00:47,581 line:-2
while view modifiers give you
additional control


14
00:00:47,614 --> 00:00:50,484 line:-1
over things like spacing and alignment.


15
00:00:51.218 --> 00:00:53.487 line:-2 align:center
In this talk,
I'm going to introduce some new tools


16
00:00:53,520 --> 00:00:56,590 line:-2
that will make some common layouts
even easier to build,


17
00:00:56,623 --> 00:00:59,560 line:-2
and will make
more complicated layouts possible.


18
00:00:59,593 --> 00:01:04,364 line:-2
Along the way, I'll give you some tips
for working with layout in SwiftUI.


19
00:01:04.398 --> 00:01:06.967 line:-2 align:center
I'll start by showing you a new member
of the grid family


20
00:01:07,000 --> 00:01:09,269 line:-1
that's perfect for two-dimensional layouts


21
00:01:09,303 --> 00:01:12,372 line:-2
when you have a static set of views
to display.


22
00:01:12,406 --> 00:01:16,176 line:-2
Next I'll talk about how you can create
a custom view container type


23
00:01:16,210 --> 00:01:18,979 line:-2
that lets you interact directly
with the layout engine,


24
00:01:19,012 --> 00:01:21,949 line:-1
using the new layout protocol.


25
00:01:21.982 --> 00:01:24.318 line:-1 align:center
Then I'll talk about ViewThatFits,


26
00:01:24,351 --> 00:01:27,621 line:-2
a container type that automatically
selects from a collection of views


27
00:01:27,654 --> 00:01:31,792 line:-2
for the one that,
well, fits in the available space.


28
00:01:31.825 --> 00:01:34.862 line:-2 align:center
And finally, I'll show you how to add
seamless transitions


29
00:01:34,895 --> 00:01:38,232 line:-1
between layout types using AnyLayout.


30
00:01:38,265 --> 00:01:40,334 line:-1
To see all these new features in action,


31
00:01:40.367 --> 00:01:42.703 line:-2 align:center
let's take a look at an app
I've been working on.


32
00:01:44,204 --> 00:01:45,906 line:-2
In recent years,
there's been some debate


33
00:01:45.939 --> 00:01:50.410 line:-2 align:center
among some of my colleagues about
who makes the best furry companion.


34
00:01:50.444 --> 00:01:54.781 line:-2 align:center
I have my own opinion, but I was curious
to see if we could come to some consensus,


35
00:01:54.815 --> 00:01:58.452 line:-2 align:center
so I decided
to make an app to take a poll.


36
00:01:58.485 --> 00:02:00.754 line:-2 align:center
And I want to include folks
with fur allergies, too,


37
00:02:00.787 --> 00:02:03.357 line:-1 align:center
so I'm throwing in one extra option.


38
00:02:03,390 --> 00:02:07,160 line:-2
Now, I like to do most of
my interface design in SwiftUI,


39
00:02:07,194 --> 00:02:09,997 line:-2
because it's so easy to prototype
using previews,


40
00:02:10,030 --> 00:02:14,334 align:center
but as a starting point, I drew
a quick sketch of what I'm aiming for.


41
00:02:14,368 --> 00:02:16,737 line:0
I expect the voting to go on
over a period of time,


42
00:02:16,770 --> 00:02:20,774 line:0
so I want a leaderboard in
the middle showing the current standings.


43
00:02:20,807 --> 00:02:22,676 line:0
I'll put buttons for voting at the bottom.


44
00:02:22,709 --> 00:02:26,647 align:center
And at the top, I'll display some images
of what folks are voting for.


45
00:02:28.482 --> 00:02:30.751 line:-2 align:center
Okay, the first thing I want to do
is to build the leaderboard.


46
00:02:30,784 --> 00:02:33,554 line:-1
So let's take a closer look at that.


47
00:02:33,587 --> 00:02:38,559 line:-2
The leaderboard is a two-dimensional grid
of elements with rows for each contender,


48
00:02:38.592 --> 00:02:43.197 line:-2 align:center
and columns that show names,
percentages, and a vote count.


49
00:02:43,230 --> 00:02:47,367 line:-2
I have a couple of specific things
I want to achieve here.


50
00:02:47.401 --> 00:02:51.104 line:-2 align:center
First, I want the two text columns
to be only as wide as they need to be


51
00:02:51,138 --> 00:02:54,074 line:-2
to accommodate the widest cell
in each case


52
00:02:54.107 --> 00:02:56.610 line:-2 align:center
because I want the progress views
that represent percentages


53
00:02:56,643 --> 00:02:58,812 line:-1
to get as much space as they can.


54
00:02:58.846 --> 00:03:02.349 line:-2 align:center
And this needs to be true
no matter how big the counts get


55
00:03:02.382 --> 00:03:05.018 line:-1 align:center
for my friends that speak other languages


56
00:03:05,052 --> 00:03:09,022 line:-2
or for anyone who uses
different text sizes on their devices.


57
00:03:09,056 --> 00:03:11,792 line:-2
Second, I want the names
to be leading edge aligned,


58
00:03:11.825 --> 00:03:14.728 line:-2 align:center
but the amounts to be
trailing edge aligned.


59
00:03:14.761 --> 00:03:20.167 line:-2 align:center
Now, SwiftUI already has lazy grids,
which are great for scrollable content.


60
00:03:20,200 --> 00:03:23,704 line:-2
These containers are very efficient
when you have a lot of views,


61
00:03:23.737 --> 00:03:27.774 line:-2 align:center
because they only load views
that are visible, or about to be visible.


62
00:03:27,808 --> 00:03:29,776 line:-2
On the other hand,
that means the container


63
00:03:29.810 --> 00:03:33.080 line:-2 align:center
can't automatically size
its cells in both dimensions.


64
00:03:34.515 --> 00:03:38.118 line:-2 align:center
For example, the LazyHGrid can figure out
how wide to make each column,


65
00:03:38,151 --> 00:03:42,823 line:-2
because it can measure all the views
in a column before drawing them.


66
00:03:42.856 --> 00:03:46.827 line:-2 align:center
But it can't measure every view in a row
to figure out the row's height.


67
00:03:46.860 --> 00:03:48.795 line:-2 align:center
To make this work,
the lazy grids need you


68
00:03:48,829 --> 00:03:52,366 line:-2
to provide information about one
of their dimensions at initialization time.


69
00:03:53,867 --> 00:03:58,305 line:0
For a closer look at lazy grids and other
existing SwiftUI layout container types,


70
00:03:58,338 --> 00:04:02,176 align:center
see the Stacks, grids,
and outlines talk from 2020.


71
00:04:02.209 --> 00:04:06.079 line:-2 align:center
But in my case, I don't need scrolling,
and I'd like to let SwiftUI


72
00:04:06,113 --> 00:04:09,616 line:-2
figure out both the height
and the width for each cell.


73
00:04:09.650 --> 00:04:14.421 line:-2 align:center
For this kind of layout,
SwiftUI now offers a Grid view.


74
00:04:14,454 --> 00:04:17,891 line:-2
Unlike the lazy grid,
the grid loads all of its views at once,


75
00:04:17.925 --> 00:04:21.161 line:-2 align:center
so it can automatically size
and align its cells


76
00:04:21.195 --> 00:04:25.265 line:-1 align:center
across both its columns and rows.


77
00:04:25.299 --> 00:04:27.201 line:-1 align:center
Let's take a look at the code for this.


78
00:04:28.135 --> 00:04:31.438 line:-2 align:center
Here's a basic version
of my leaderboard written as a Grid.


79
00:04:31.471 --> 00:04:35.142 line:-2 align:center
This particular grid view
contains three GridRow instances.


80
00:04:35,175 --> 00:04:38,512 line:-2
Within a row,
each view corresponds to a column.


81
00:04:38.545 --> 00:04:41.815 line:-2 align:center
So in this example,
the first text view in each row


82
00:04:41,849 --> 00:04:43,684 line:-1
corresponds to the first column,


83
00:04:43,717 --> 00:04:45,919 line:-1
the progress view is in the second column,


84
00:04:45.953 --> 00:04:49.623 line:-2 align:center
and the last text view
is the third column.


85
00:04:49.656 --> 00:04:53.393 line:-2 align:center
Notice that the grid allocates
as much space to each row and column


86
00:04:53.427 --> 00:04:55.696 line:-1 align:center
as it needs to hold its largest view.


87
00:04:55.729 --> 00:05:00.234 line:-2 align:center
So the first text column is wide enough
for the longest name, but no wider.


88
00:05:00.267 --> 00:05:04.104 line:-2 align:center
Flexible views like the progress indicator
take as much space as the grid offers,


89
00:05:04.137 --> 00:05:06.139 line:-2 align:center
which in this case
is whatever is left over


90
00:05:06,173 --> 00:05:09,343 line:-2
after allocating space
for the text columns.


91
00:05:09,376 --> 00:05:13,247 line:-2
I want to adjust this a bit, but first,
let me create a basic data model


92
00:05:13.280 --> 00:05:15.382 line:-2 align:center
to give me somewhere
to store vote counts.


93
00:05:16,683 --> 00:05:20,354 line:-2
I'll need more logic to manage
and share the data across the network,


94
00:05:20.387 --> 00:05:24.892 line:-2 align:center
but while I'm prototyping the interface,
I just need a simple structure like this.


95
00:05:24.925 --> 00:05:28.195 line:-2 align:center
I'll include Identifiable conformance,
because that'll make it easier


96
00:05:28.228 --> 00:05:30.497 line:-1 align:center
to use this type in a ForEach,


97
00:05:30,531 --> 00:05:34,368 line:-2
and Equatable conformance
to make it possible to animate changes.


98
00:05:35,869 --> 00:05:41,475 line:-2
And I'll create a set of example data
to use in my previews while I prototype.


99
00:05:41,508 --> 00:05:44,578 line:-2
Going back to my grid,
I can create a state variable


100
00:05:44.611 --> 00:05:46.947 line:-1 align:center
and initialize it with my example data.


101
00:05:46.980 --> 00:05:51.218 line:-2 align:center
And using that data,
I can now create rows with a ForEach.


102
00:05:51,251 --> 00:05:53,453 line:-2
Notice that the rendered output
hasn't changed


103
00:05:53,487 --> 00:05:56,757 line:-2
because it's still displaying
the same data.


104
00:05:56.790 --> 00:06:00.460 line:-2 align:center
That's already pretty close,
but I need to fix the cell alignment.


105
00:06:00,494 --> 00:06:02,529 line:-2
Right now,
all the cells are center aligned,


106
00:06:02.563 --> 00:06:05.399 line:-2 align:center
which is the default for a grid,
but if you remember,


107
00:06:05,432 --> 00:06:07,568 line:-2
I want the names
to be leading edge aligned,


108
00:06:07,601 --> 00:06:09,970 line:-2
and the values
to be trailing edge aligned.


109
00:06:10.804 --> 00:06:14.808 line:-2 align:center
To do that, I'll initialize the grid
with leading edge alignment.


110
00:06:14.842 --> 00:06:18.512 line:-2 align:center
The value I use here
applies to all the cells in the grid.


111
00:06:18,545 --> 00:06:23,183 line:-2
That works fine for my first two columns,
but what about the last?


112
00:06:23,217 --> 00:06:25,385 line:-2
To affect the alignment
of a single column,


113
00:06:25.419 --> 00:06:31.091 line:-2 align:center
I can apply the gridColumnAlignment view
modifier to any one cell in that column.


114
00:06:31,124 --> 00:06:34,862 line:-2
So I'll do that with the text view
in the last column.


115
00:06:34.895 --> 00:06:37.764 line:-2 align:center
Okay, it's getting there,
but now that I'm looking at it,


116
00:06:37,798 --> 00:06:41,835 line:-2
I feel like it would be better
with a divider between each row.


117
00:06:41,869 --> 00:06:45,272 line:-2
If I just add a new row
to the ForEach with a divider,


118
00:06:45,305 --> 00:06:47,407 line:-1
this isn't exactly what I want,


119
00:06:47,441 --> 00:06:50,677 line:-2
but notice that this shows
a couple of interesting things.


120
00:06:50,711 --> 00:06:53,814 line:-2
First, because
the divider is a flexible view,


121
00:06:53,847 --> 00:06:56,550 line:-2
it's causing the first column
to take more space.


122
00:06:56.583 --> 00:06:59.586 line:-2 align:center
Basically, the grid is now giving
the last column what it needs,


123
00:06:59.620 --> 00:07:03.824 line:-2 align:center
and dividing the remaining space
between the first two columns.


124
00:07:03.857 --> 00:07:08.028 line:-2 align:center
Second, for a grid row that doesn't
have as many views as other grid rows,


125
00:07:08.061 --> 00:07:11.965 line:-2 align:center
the missing views just create empty cells
in the later columns.


126
00:07:11,999 --> 00:07:16,670 line:-2
But what I really want is to have the
divider span all the columns of the grid,


127
00:07:16.703 --> 00:07:20.440 line:-2 align:center
and SwiftUI has a new view modifier
that lets me do that.


128
00:07:23.744 --> 00:07:27.014 line:-2 align:center
By adding the gridCellColumns
modifier to a view,


129
00:07:27,047 --> 00:07:30,017 line:-2
I can tell a single view to span
some number of columns;


130
00:07:30.050 --> 00:07:32.719 line:-1 align:center
in this case, all three.


131
00:07:32.753 --> 00:07:35.923 line:-2 align:center
And actually, for the case where
the view should span the entire grid,


132
00:07:35.956 --> 00:07:40.994 line:-2 align:center
I can simplify this by just writing
the view by itself, outside of a grid row.


133
00:07:41,028 --> 00:07:44,264 line:0
Okay, my leaderboard is in
pretty good shape


134
00:07:44,298 --> 00:07:47,668 line:0
so let me take a look at the buttons
used for voting next.


135
00:07:48,836 --> 00:07:51,338 line:-2
At first glance,
there's nothing too fancy here.


136
00:07:51.371 --> 00:07:54.641 line:-2 align:center
However,
I do have one special requirement.


137
00:07:54,675 --> 00:07:57,077 line:-2
On the one hand,
I don't want to bias my participants


138
00:07:57.110 --> 00:08:00.013 line:-1 align:center
with smaller buttons for certain choices.


139
00:08:00,047 --> 00:08:03,050 line:-2
But I also don't want the buttons
to grow as large as their container,


140
00:08:03,083 --> 00:08:06,386 line:-1
which could be very large on iPad or Mac.


141
00:08:06.420 --> 00:08:11.825 line:-2 align:center
Instead, the buttons should all have
widths equal to the widest button text.


142
00:08:11,859 --> 00:08:15,462 line:-2
So what happens
if I try to build this with an Hstack?


143
00:08:15,495 --> 00:08:19,666 line:-2
What I find is that each button
sizes itself to fit its text label,


144
00:08:19.700 --> 00:08:23.203 line:-2 align:center
and the HStack
packs these together horizontally.


145
00:08:23,237 --> 00:08:27,508 line:-2
This default stack behavior is exactly
what you want in a lot of cases,


146
00:08:27,541 --> 00:08:30,177 line:-2
but it doesn't quite meet
my spec for this project.


147
00:08:31,778 --> 00:08:34,781 align:center
For a refresher
on layout fundamentals in SwiftUI,


148
00:08:34,815 --> 00:08:39,019 align:center
see the Building custom views
with SwiftUI talk from 2019.


149
00:08:39.052 --> 00:08:42.789 line:-2 align:center
Using concepts from that talk,
let's take a look at this view hierarchy


150
00:08:42.823 --> 00:08:45.659 line:-2 align:center
to see what I can change
to get the behavior I want.


151
00:08:47.694 --> 00:08:52.132 line:-2 align:center
First, the stack's container
proposes a size to the stack.


152
00:08:52.165 --> 00:08:56.069 line:-2 align:center
Based on this, the stack proposes a size
to its three buttons,


153
00:08:56.103 --> 00:09:00.674 line:-2 align:center
and then each button passes that size
through to its text label.


154
00:09:00.707 --> 00:09:03.377 line:-2 align:center
The text views calculate the size
they actually want,


155
00:09:03.410 --> 00:09:05.746 line:-1 align:center
which depends on the string they contain


156
00:09:05,779 --> 00:09:08,115 line:-1
and report this to the button.


157
00:09:08.148 --> 00:09:10.884 line:-2 align:center
The button passes the information
back through.


158
00:09:10.918 --> 00:09:13.387 line:-2 align:center
The stack sizes itself
with this information,


159
00:09:13.420 --> 00:09:18.425 line:-2 align:center
places the buttons in its space, and then
reports its own size to its container.


160
00:09:18,458 --> 00:09:21,028 line:-2
Okay, so if the buttons
take the size of their text,


161
00:09:21,061 --> 00:09:26,133 line:-2
what if I wrap each text view in
a flexible frame and allow it to grow?


162
00:09:26,166 --> 00:09:29,770 line:-2
The text hasn't changed,
but the button sees a flexible subview,


163
00:09:29.803 --> 00:09:33.607 line:-2 align:center
which takes as much space
as the HStack offers.


164
00:09:33,640 --> 00:09:38,178 line:-2
The stack then distributes its space
equally among the views that it contains.


165
00:09:38.212 --> 00:09:40.714 line:-2 align:center
So the buttons are all the same size now,
which is great,


166
00:09:40,747 --> 00:09:44,117 line:-2
but their actual size depends
on the stack's container.


167
00:09:44.151 --> 00:09:47.921 line:-2 align:center
The stack will expand to fill
whatever space the container offers,


168
00:09:47.955 --> 00:09:49.590 line:-1 align:center
and that's not what I want.


169
00:09:49.623 --> 00:09:52.793 line:-1 align:center
What I really want is a custom stack type


170
00:09:52,826 --> 00:09:55,562 line:-2
that asks for the ideal size
of each button,


171
00:09:55,596 --> 00:09:59,800 line:-2
finds the widest, and then offers
that amount of space to each one.


172
00:09:59,833 --> 00:10:04,471 line:-2
Fortunately, SwiftUI has a new tool
that lets me do just that.


173
00:10:04.505 --> 00:10:07.841 line:-2 align:center
Using the Layout protocol,
I can define a custom layout container


174
00:10:07.875 --> 00:10:10.777 line:-2 align:center
that participates directly
in the layout process


175
00:10:10.811 --> 00:10:13.981 line:-2 align:center
with behavior
that's tailored to my use case.


176
00:10:14.014 --> 00:10:15.682 line:-1 align:center
Let's see how this works.


177
00:10:16.583 --> 00:10:21.788 line:-2 align:center
Looking at the HStack again,
let me change it to an EqualWidthHStack


178
00:10:21.822 --> 00:10:26.093 line:-2 align:center
a type that I'm going to define
to solve my specific problem.


179
00:10:26.126 --> 00:10:29.129 line:-2 align:center
This type is going to allocate width
to the buttons equally,


180
00:10:29,162 --> 00:10:33,500 line:-2
in an amount that's as wide
as the widest button's ideal width.


181
00:10:33.534 --> 00:10:36.970 line:-2 align:center
I'll keep the flexible frames
so that buttons with narrower text


182
00:10:37.004 --> 00:10:40.174 line:-2 align:center
can expand to fill the space
that the stack offers.


183
00:10:40,207 --> 00:10:43,310 line:-2
But the buttons will still have
an ideal size that I can measure,


184
00:10:43.343 --> 00:10:45.779 line:-1 align:center
which is the width of their text.


185
00:10:45,812 --> 00:10:49,316 line:-2
So let's see how I can implement
MyEqualWidthHStack.


186
00:10:52.052 --> 00:10:56.290 line:-2 align:center
I start by creating a type
that conforms to the Layout protocol.


187
00:10:56,323 --> 00:10:59,693 line:-2
For a basic layout,
all I need are the two required methods.


188
00:10:59,726 --> 00:11:02,462 line:-1
Let's add stubs for those.


189
00:11:02.496 --> 00:11:04.831 line:-1 align:center
The first method is sizeThatFits,


190
00:11:04.865 --> 00:11:08.669 line:-2 align:center
where I'll calculate and report
how large my layout container is.


191
00:11:10,571 --> 00:11:12,739 line:-1
I get a proposed view size input,


192
00:11:12.773 --> 00:11:16.677 line:-2 align:center
which is a size proposal from
my layout's own container view.


193
00:11:16,710 --> 00:11:21,648 line:-2
And I can propose sizes to my layout's
subviews using the Subviews parameter.


194
00:11:22.883 --> 00:11:25.953 line:-2 align:center
Notice that I can't access
the subviews directly.


195
00:11:25,986 --> 00:11:28,789 line:-2
Instead, the subviews input
is a collection of proxies


196
00:11:28,822 --> 00:11:32,059 line:-2
that let me interact in specific ways
with the subviews,


197
00:11:32,092 --> 00:11:34,761 line:-1
like proposing a size.


198
00:11:34.795 --> 00:11:39.132 line:-2 align:center
Each proxy returns a concrete size
based on the proposal that I’ve made.


199
00:11:39.166 --> 00:11:43.437 line:-2 align:center
I'll collect all those responses
and use them to do some calculations


200
00:11:43.470 --> 00:11:48.041 line:-2 align:center
and then return a concrete size for
the EqualWidthHStack to its container.


201
00:11:49,209 --> 00:11:52,846 line:-2
The second method that I have to
implement is placeSubviews.


202
00:11:52,880 --> 00:11:56,850 line:-2
I'll use this to tell my layout's subviews
where to appear.


203
00:11:56.884 --> 00:12:01.054 line:-2 align:center
This method takes the same size proposal
and subviews inputs,


204
00:12:01.088 --> 00:12:04.157 line:-2 align:center
and it also takes a bounds input
that represents the region


205
00:12:04.191 --> 00:12:07.060 line:-1 align:center
that I need to place my subviews into.


206
00:12:07,094 --> 00:12:10,097 line:-2
Bounds is a rectangle
that has the size that I asked for


207
00:12:10.130 --> 00:12:12.666 line:-1 align:center
in my sizeThatFits implementation.


208
00:12:12.699 --> 00:12:15.202 line:-2 align:center
Remember,
views pick their own size in SwiftUI,


209
00:12:15,235 --> 00:12:19,673 line:-2
so my layout container
will get the size that it asks for.


210
00:12:19,706 --> 00:12:22,309 line:-2
The origin of the region
is at the top left,


211
00:12:22.342 --> 00:12:25.812 line:-2 align:center
with positive X to the right,
and positive Y down.


212
00:12:25,846 --> 00:12:28,515 line:-2
You can assume this for all
your placement calculations,


213
00:12:28.549 --> 00:12:30.851 line:-2 align:center
even in right to left
language environments,


214
00:12:30,884 --> 00:12:34,655 line:-2
because the framework automatically flips
the x position of each view


215
00:12:34.688 --> 00:12:37.457 line:-1 align:center
when laying out views in that direction.


216
00:12:37,491 --> 00:12:42,596 line:-2
However, don't assume that the rectangle's
origin has the value (0,0).


217
00:12:42,629 --> 00:12:45,299 line:-2
Among other things,
allowing for a non-zero origin


218
00:12:45.332 --> 00:12:47.334 line:-1 align:center
enables layout composition,


219
00:12:47,367 --> 00:12:49,536 line:-2
where the placeSubviews method
of one layout


220
00:12:49.570 --> 00:12:52.206 line:-1 align:center
calls into the same method of another.


221
00:12:52,239 --> 00:12:55,442 line:-2
To make it a little easier to work with,
the rectangle provides properties


222
00:12:55,475 --> 00:12:57,945 line:-2
for accessing important parts
of the region,


223
00:12:57.978 --> 00:12:59.980 line:-1 align:center
like the minimum,


224
00:13:00.013 --> 00:13:03.884 line:-2 align:center
center,
and maximum points in each dimension.


225
00:13:05.152 --> 00:13:07.421 line:-2 align:center
Now, before I move on,
notice one other parameter


226
00:13:07.454 --> 00:13:09.356 line:-1 align:center
that these methods both have:


227
00:13:09,389 --> 00:13:11,458 line:-1
a bidirectional cache that I could use


228
00:13:11,491 --> 00:13:16,363 line:-2
to share the results of intermediate
calculations across method calls.


229
00:13:16,396 --> 00:13:18,899 line:-2
For many simple layouts,
you won't need this,


230
00:13:18.932 --> 00:13:22.035 line:-2 align:center
and I'm just going to
ignore the cache for now.


231
00:13:22.069 --> 00:13:25.772 line:-2 align:center
However, if profiling your app with
Instruments shows that you need to improve


232
00:13:25.806 --> 00:13:27.908 line:-1 align:center
the efficiency of your layout code,


233
00:13:27,941 --> 00:13:29,877 line:-1
you can look into adding one.


234
00:13:29,910 --> 00:13:32,513 line:-2
Check out the documentation
for more information about that.


235
00:13:34.715 --> 00:13:37.084 line:-1 align:center
Okay, let's implement sizeThatFits.


236
00:13:37.117 --> 00:13:39.419 line:-2 align:center
Remember, I want to return
a size for my container


237
00:13:39,453 --> 00:13:44,825 line:-2
that fits all of the buttons arranged
horizontally, all at the same width.


238
00:13:44,858 --> 00:13:47,761 line:-2
So first,
I'll ask each button for its size,


239
00:13:47,794 --> 00:13:51,565 line:-2
which I do by proposing a size
and seeing what comes back.


240
00:13:51.598 --> 00:13:53.567 line:-1 align:center
To measure the flexibility of a subview,


241
00:13:53.600 --> 00:13:57.137 line:-2 align:center
I can make multiple measurements
using special proposals for minimum,


242
00:13:57.171 --> 00:13:59.406 line:-1 align:center
maximum, and ideal sizes,


243
00:13:59.439 --> 00:14:01.875 line:-1 align:center
or I can propose a specific size.


244
00:14:01,909 --> 00:14:07,347 line:-2
In this case, I use the unspecified
size proposal to ask for the ideal size.


245
00:14:08.582 --> 00:14:11.318 line:-2 align:center
Then I'll find the largest value
in each dimension


246
00:14:11,351 --> 00:14:13,487 line:-1
for all the sizes that I get back.


247
00:14:13.520 --> 00:14:15.789 line:-2 align:center
In this case,
the goldfish button sets the width,


248
00:14:15.822 --> 00:14:18.625 line:-1 align:center
and the heights are all the same.


249
00:14:18.659 --> 00:14:20.360 line:-1 align:center
Now let me refactor that into a method,


250
00:14:20.394 --> 00:14:23.964 line:-2 align:center
because I'll need it again
when I place my subviews.


251
00:14:23,997 --> 00:14:27,401 line:-2
Next, I need to account
for the spacing between views.


252
00:14:27.434 --> 00:14:30.604 line:-2 align:center
I could just use a constant spacing,
like 10 points,


253
00:14:30,637 --> 00:14:33,440 line:-1
but the layout protocol lets me do better.


254
00:14:33,473 --> 00:14:37,377 line:-2
In SwiftUI, all views have spacing
preferences that indicate


255
00:14:37,411 --> 00:14:42,015 line:-2
the amount of space the view prefers
to have between itself and the next view.


256
00:14:42.049 --> 00:14:45.219 line:-2 align:center
These preferences are stored
in a ViewSpacing instance


257
00:14:45.252 --> 00:14:48.488 line:-1 align:center
that's available to layout containers.


258
00:14:48.522 --> 00:14:51.024 line:-2 align:center
The view might prefer different values
on different edges,


259
00:14:51.058 --> 00:14:54.928 line:-2 align:center
and even different values for
different kinds of adjacent views.


260
00:14:54.962 --> 00:14:57.497 line:-2 align:center
For example,
a view might want more or less space


261
00:14:57,531 --> 00:15:02,803 line:-2
between itself and a text view
than it wants between itself and an image.


262
00:15:02.836 --> 00:15:06.206 line:-2 align:center
And the values can vary
by platform as well.


263
00:15:06,240 --> 00:15:09,743 line:-2
You can ignore these preferences
if it makes sense for your layout,


264
00:15:09,776 --> 00:15:13,380 line:-2
which is essentially what's happening
when you initialize a built-in stack


265
00:15:13,413 --> 00:15:15,415 line:-1
with a custom spacing,


266
00:15:15,449 --> 00:15:17,584 line:-2
but respecting these preferences
in your own layouts


267
00:15:17,618 --> 00:15:20,487 line:-2
is a good way to get results
that automatically follow


268
00:15:20.521 --> 00:15:22.489 line:-1 align:center
Apple's interface guidelines,


269
00:15:22.523 --> 00:15:26.527 line:-2 align:center
and as a result,
match the look of the rest of the system.


270
00:15:26,560 --> 00:15:29,796 line:-2
Now, every view
has preferences on all edges,


271
00:15:29.830 --> 00:15:31.532 line:-1 align:center
and when I bring two views together,


272
00:15:31,565 --> 00:15:35,068 line:-2
the preferences on a common edge
might not match.


273
00:15:35,102 --> 00:15:37,204 line:-2
To resolve this,
a built-in layout container


274
00:15:37.237 --> 00:15:39.740 line:-1 align:center
uses the larger of the two preferences.


275
00:15:39,773 --> 00:15:41,942 line:-2
And I can do the same thing
in my own layout.


276
00:15:43.443 --> 00:15:47.314 line:-2 align:center
The subview proxies give me a way
to ask for each button's preferred spacing


277
00:15:47.347 --> 00:15:50.651 line:-1 align:center
to some other button along a given axis.


278
00:15:50,684 --> 00:15:54,688 line:-2
So let me create an array of values by
scanning through the subviews


279
00:15:54,721 --> 00:15:59,493 line:-2
and calling the distance method
on each proxy's spacing instance


280
00:15:59,526 --> 00:16:02,930 line:-2
to get the spacing
to the next view's spacing instance


281
00:16:02.963 --> 00:16:05.599 line:-1 align:center
along the horizontal axis.


282
00:16:05.632 --> 00:16:07.601 line:-2 align:center
This call takes into account
the preferences


283
00:16:07,634 --> 00:16:11,004 line:-1
of both views on their common edge.


284
00:16:11.038 --> 00:16:13.407 line:-2 align:center
The first element in this array
tells me how much space


285
00:16:13.440 --> 00:16:17.611 line:-2 align:center
the cat button wants horizontally
to the goldfish button,


286
00:16:17.644 --> 00:16:22.216 line:-2 align:center
and the next tells me how much the
goldfish button wants to the dog button.


287
00:16:22.249 --> 00:16:24.952 line:-2 align:center
I'll force the last element in the array
to be zero


288
00:16:24,985 --> 00:16:28,622 line:-2
because there aren't any more buttons
to compare against.


289
00:16:28,655 --> 00:16:32,626 line:-2
Okay, let me refactor that
into a method for later too.


290
00:16:32,659 --> 00:16:36,597 line:-2
Now I can combine the spacing values
to find the total spacing


291
00:16:36.630 --> 00:16:39.132 line:-2 align:center
and use that that with the width
and height measurements


292
00:16:39,166 --> 00:16:41,168 line:-1
to return a size value.


293
00:16:41.201 --> 00:16:43.070 line:-1 align:center
This is the size that my layout needs,


294
00:16:43,103 --> 00:16:45,439 line:-1
given the ideal sizes of its subviews


295
00:16:45,472 --> 00:16:49,376 line:-1
and each subview's preferred spacing.


296
00:16:49.409 --> 00:16:52.946 line:-2 align:center
The other method that I need
to implement is placeSubviews.


297
00:16:52,980 --> 00:16:55,983 line:-2
As I mentioned before,
I get both the bounds of the container,


298
00:16:56,016 --> 00:17:01,021 line:-2
and the collection of subview proxies
that I can use to direct the buttons.


299
00:17:01.054 --> 00:17:04.291 line:-2 align:center
First, I calculate maxSize
and the spacing array


300
00:17:04.324 --> 00:17:06.593 line:-1 align:center
just like I did in sizeThatFits method,


301
00:17:06.627 --> 00:17:10.030 line:-1 align:center
because I'll need those values here too.


302
00:17:10.063 --> 00:17:13.967 line:-2 align:center
Then I'll create a size proposal
that I can use for each of my subviews,


303
00:17:14.001 --> 00:17:16.537 line:-2 align:center
this time based on the size
that I want them to have,


304
00:17:16.570 --> 00:17:18.639 line:-1 align:center
rather than their ideal size.


305
00:17:18,672 --> 00:17:23,443 line:-2
I only need one proposal, because I want
all the buttons to the be the same size.


306
00:17:23,477 --> 00:17:26,313 line:-2
And I'll find a starting position
in the horizontal dimension


307
00:17:26.346 --> 00:17:30.250 line:-2 align:center
for my first subview, calculated as
the leading edge of my bounds,


308
00:17:30,284 --> 00:17:32,553 line:-1
plus half the width of a button.


309
00:17:32,586 --> 00:17:34,955 line:-2
Notice I'm not relying
on the origin to be zero,


310
00:17:34,988 --> 00:17:39,159 line:-2
but instead starting
with the minX value instead.


311
00:17:39,193 --> 00:17:42,296 line:-2
Finally, I can go through
each of the subview proxies


312
00:17:42,329 --> 00:17:45,532 line:-1
and call its place method with a point,


313
00:17:45.566 --> 00:17:49.036 line:-2 align:center
a statement of what that point represents
in terms of the button,


314
00:17:49,069 --> 00:17:52,105 line:-1
and the size proposal.


315
00:17:52.139 --> 00:17:55.075 line:-2 align:center
Each time through the loop,
I update the horizontal position


316
00:17:55.108 --> 00:17:58.545 line:-2 align:center
by the width of a view,
plus the spacing for the next view pair,


317
00:17:58,579 --> 00:18:01,114 line:-1
to get ready for the next iteration.


318
00:18:01.148 --> 00:18:02.549 line:-1 align:center
And that's it.


319
00:18:02.583 --> 00:18:06.053 line:-2 align:center
Now let's see what happens
when I use this new view layout type.


320
00:18:07.454 --> 00:18:08.655 line:-1 align:center
And there it is.


321
00:18:08,689 --> 00:18:11,058 line:-2
I instantiate my own
custom layout container


322
00:18:11.091 --> 00:18:13.527 line:-1 align:center
just like I would a built-in HStack,


323
00:18:13,560 --> 00:18:18,532 line:-2
and the buttons are arranged horizontally,
all at the same width.


324
00:18:18.565 --> 00:18:20.467 line:-1 align:center
Now, I want to pause here for a moment


325
00:18:20.501 --> 00:18:22.970 line:-2 align:center
and talk about how the Layout protocol
solves a problem


326
00:18:23.003 --> 00:18:27.040 line:-2 align:center
that you might have tried to use
geometry reader for in the past.


327
00:18:27.074 --> 00:18:31.378 line:-2 align:center
Geometry reader is, after all,
a tool for measuring view sizes.


328
00:18:31.411 --> 00:18:35.015 line:-2 align:center
However,
it's not the best choice in this case.


329
00:18:35,048 --> 00:18:38,919 line:-2
And that's because a geometry reader
is designed to measure its container view,


330
00:18:38,952 --> 00:18:41,288 line:-1
and report the that size to its subview.


331
00:18:41.321 --> 00:18:45.792 line:-2 align:center
The subview then uses the information
to draw its own content.


332
00:18:45,826 --> 00:18:48,428 line:-2
Notice that for the intended use
of a geometry reader,


333
00:18:48.462 --> 00:18:50.330 line:-1 align:center
the information flows downward.


334
00:18:50,364 --> 00:18:52,432 line:-2
The measurement that the reader makes
has no effect


335
00:18:52,466 --> 00:18:54,701 line:-1
on the layout of its own container.


336
00:18:55.836 --> 00:18:59.439 line:-2 align:center
This is great for things like drawing
a path that scales with its container.


337
00:18:59,473 --> 00:19:03,143 line:-2
The geometry reader tells the path logic
how much space it has to work with,


338
00:19:03.177 --> 00:19:07.714 line:-2 align:center
and the path logic inside the subview
adjusts accordingly.


339
00:19:07.748 --> 00:19:10.984 line:-2 align:center
If the container changes size,
so does the path,


340
00:19:11.018 --> 00:19:14.755 line:-2 align:center
because the geometry reader
passes along the new size.


341
00:19:14.788 --> 00:19:17.591 line:-2 align:center
However, for my buttons,
and I'll just focus on one here


342
00:19:17,624 --> 00:19:21,528 line:-2
to make it easier to see,
I need to measure the text view,


343
00:19:21.562 --> 00:19:26.967 line:-2 align:center
and then use that to decide how to set
a frame that's the text view's container.


344
00:19:27,000 --> 00:19:30,938 line:-2
So I could add a geometry reader
in an overlay to the text view–


345
00:19:30,971 --> 00:19:33,173 line:-1
remember, it measures its container–


346
00:19:33.207 --> 00:19:36.343 line:-2 align:center
and then somehow send the measurement data
back up to the frame,


347
00:19:36.376 --> 00:19:38.645 line:-1 align:center
outside of the normal flow.


348
00:19:38,679 --> 00:19:41,548 line:-2
But notice that if I do this,
I'm bypassing the layout engine,


349
00:19:41.582 --> 00:19:43.784 line:-1 align:center
which might result in a loop.


350
00:19:43.817 --> 00:19:46.887 line:-2 align:center
The reader measures the layout
and changes the frame,


351
00:19:46,920 --> 00:19:51,925 line:-2
which might change the layout, which could
require another measurement, and so on.


352
00:19:51.959 --> 00:19:54.394 line:-1 align:center
Now it is possible to make this work,


353
00:19:54,428 --> 00:19:57,931 line:-2
but if I'm not careful,
I could end up crashing my app.


354
00:19:57.965 --> 00:20:00.868 line:-2 align:center
As a result,
this strategy isn't recommended.


355
00:20:00.901 --> 00:20:04.238 line:-2 align:center
Fortunately, the layout protocol gives you
a better way to solve this problem,


356
00:20:04,271 --> 00:20:07,140 line:-2
by letting you work
within the layout engine.


357
00:20:08.108 --> 00:20:10.711 line:-1 align:center
Okay, let's look at the buttons again.


358
00:20:10.744 --> 00:20:13.013 line:-1 align:center
There's something else I want to do here.


359
00:20:13.046 --> 00:20:14.882 line:-2 align:center
First, to make this
a little easier to read,


360
00:20:14.915 --> 00:20:18.519 line:-2 align:center
I'll refactor the buttons
into their own subview.


361
00:20:18,552 --> 00:20:21,321 line:-2
Now, I happen to know that one
of my colleagues uses larger type


362
00:20:21.355 --> 00:20:22.990 line:-1 align:center
on their device.


363
00:20:23.023 --> 00:20:27.461 line:-2 align:center
My app automatically supports Dynamic Type
because I've used default fonts,


364
00:20:27.494 --> 00:20:30.898 line:-2 align:center
so I should mostly get
the right behavior for free.


365
00:20:30,931 --> 00:20:35,235 line:-2
Let's see what happens
if I increase the type size.


366
00:20:35.269 --> 00:20:37.437 line:-1 align:center
Uh-oh, the buttons don't fit anymore.


367
00:20:37.471 --> 00:20:41.041 line:-2 align:center
Remember that my custom stack
doesn't constrain the button widths,


368
00:20:41.074 --> 00:20:43.644 line:-1 align:center
but just lets them have their ideal size,


369
00:20:43,677 --> 00:20:47,080 line:-2
which in this case
exceeds the width of the display.


370
00:20:47.114 --> 00:20:48.582 line:-1 align:center
So what can I do?


371
00:20:48,615 --> 00:20:51,318 line:-2
Well, I could modify the layout
to do something more complicated


372
00:20:51.351 --> 00:20:54.421 line:-2 align:center
when the views don't fit,
taking into account the size proposal


373
00:20:54.454 --> 00:20:56.323 line:-1 align:center
from the layout's container.


374
00:20:56,356 --> 00:20:59,626 line:-2
But for this case,
I can use the new ViewThatFits container


375
00:20:59.660 --> 00:21:01.828 line:-1 align:center
to do most of the work for me.


376
00:21:01,862 --> 00:21:05,499 line:-2
This new type picks the first view
that fits in the available space


377
00:21:05.532 --> 00:21:07.901 line:-1 align:center
from a list of views that I give it.


378
00:21:09,336 --> 00:21:13,006 line:-2
By wrapping my custom stack
in a ViewThatFits structure,


379
00:21:13.040 --> 00:21:16.076 line:-2 align:center
and then adding a vertical stack version
of the same content,


380
00:21:16.109 --> 00:21:20.747 line:-2 align:center
I can let SwiftUI figure out when the
buttons need to be arranged differently.


381
00:21:20,781 --> 00:21:24,284 line:-2
Of course, the built-in VStack
doesn't have the equal width property


382
00:21:24.318 --> 00:21:27.521 line:-1 align:center
that my custom horizontal stack does,


383
00:21:27,554 --> 00:21:31,725 line:-2
so I've gone ahead and implemented a
vertical version of the custom stack too.


384
00:21:31.758 --> 00:21:34.061 line:-2 align:center
It's very similar to the one
I already described,


385
00:21:34.094 --> 00:21:37.564 line:-2 align:center
except that it places equal width items
along the vertical axis


386
00:21:37,598 --> 00:21:40,067 line:-1
instead of the horizontal axis.


387
00:21:41.668 --> 00:21:44.771 line:-2 align:center
And of course, when I remove
the dynamic type size override,


388
00:21:44.805 --> 00:21:47.574 line:-1 align:center
it goes back to the horizontal layout.


389
00:21:47,608 --> 00:21:50,010 line:-2
Now, there's one last piece of the app
I need to build,


390
00:21:50,043 --> 00:21:52,846 line:-1
and that's the images at the top.


391
00:21:52.880 --> 00:21:56.483 line:-2 align:center
I could do something simple, like
just show a group of profile pictures,


392
00:21:56,517 --> 00:21:59,186 line:-2
but I thought I'd have a little fun
with it.


393
00:21:59.219 --> 00:22:01.321 line:-1 align:center
So I made another custom layout type


394
00:22:01,355 --> 00:22:04,458 line:-1
that draws views in a circular arrangement


395
00:22:04,491 --> 00:22:08,028 line:-2
and then rotates the arrangement
according to rankings.


396
00:22:08.061 --> 00:22:11.031 line:-2 align:center
So this configuration shows
goldfish in first place,


397
00:22:11.064 --> 00:22:13.500 line:-1 align:center
and the other two tied for second.


398
00:22:13.534 --> 00:22:17.070 line:-2 align:center
And then if dog pulls ahead of cat,
I can rotate a bit to show that.


399
00:22:17.104 --> 00:22:19.740 line:-2 align:center
Or I can show
a slightly more realistic result,


400
00:22:19.773 --> 00:22:23.110 line:-1 align:center
all by rotating a radial layout.


401
00:22:23.143 --> 00:22:27.014 line:-2 align:center
Creating this layout is actually quite
straightforward with the layout protocol.


402
00:22:27,047 --> 00:22:30,317 line:-1
Like before, I just need two methods.


403
00:22:30,350 --> 00:22:33,687 line:-2
For size that fits, I want my view
to fill the available space,


404
00:22:33.720 --> 00:22:37.724 line:-2 align:center
so I'll return whatever size
the container view proposes.


405
00:22:37.758 --> 00:22:40.360 line:-2 align:center
I'll convert the proposal
into a concrete size


406
00:22:40.394 --> 00:22:44.031 line:-2 align:center
using the replacing-unspecified-dimensions
method.


407
00:22:44.064 --> 00:22:47.234 line:-2 align:center
That method automatically handles
nil values that could be present


408
00:22:47.267 --> 00:22:50.737 line:-1 align:center
if the container asks for an ideal size.


409
00:22:50.771 --> 00:22:53.340 line:-1 align:center
Then inside place subviews method,


410
00:22:53.373 --> 00:22:55.609 line:-1 align:center
I'll offset each subview from the middle


411
00:22:55.642 --> 00:22:59.213 line:-2 align:center
by some radius that's based
on the size of the layout region,


412
00:22:59,246 --> 00:23:03,350 line:-2
and apply a rotation that depends
on the index of the view.


413
00:23:03,383 --> 00:23:07,588 line:-2
As a baseline,
this places the views at 0, 1,


414
00:23:07.621 --> 00:23:12.459 line:-1 align:center
and two-thirds of the way around a circle.


415
00:23:12,492 --> 00:23:14,161 line:-1
To reflect the current rankings,


416
00:23:14.194 --> 00:23:18.365 line:-2 align:center
I'll also apply an offset
that affects all the views equally.


417
00:23:18,398 --> 00:23:20,033 line:-1
But where do I get the rankings?


418
00:23:20.067 --> 00:23:23.537 line:-2 align:center
Remember, my layout can only access
the subview proxies,


419
00:23:23.570 --> 00:23:27.107 line:-2 align:center
and not the views,
let alone my data model.


420
00:23:27.140 --> 00:23:31.044 line:-2 align:center
Well, it turns out that the layout
protocol has another trick up its sleeve.


421
00:23:31.078 --> 00:23:33.380 line:-1 align:center
It lets you store values on each subview,


422
00:23:33,413 --> 00:23:37,384 line:-2
and read the values from inside
the layout protocol methods.


423
00:23:37.417 --> 00:23:41.822 line:-2 align:center
Let's see how I can use that
to communicate the rank information.


424
00:23:41,855 --> 00:23:46,593 line:-2
First, I declare a new type that conforms
to the LayoutValueKey protocol,


425
00:23:46,627 --> 00:23:48,829 line:-1
and give it a default value.


426
00:23:48,862 --> 00:23:53,166 line:-2
In addition to providing a value for
a view when you don't explicitly set one,


427
00:23:53,200 --> 00:23:56,303 line:-2
the default value establishes
the associated value's type,


428
00:23:56.336 --> 00:23:59.339 line:-1 align:center
which is an integer in this case.


429
00:23:59.373 --> 00:24:03.410 line:-2 align:center
Then, I create a convenience method
on View to set the value


430
00:24:03.443 --> 00:24:07.114 line:-1 align:center
using the layoutValue view modifier.


431
00:24:07.147 --> 00:24:08.882 line:-1 align:center
Now in my view hierarchy,


432
00:24:08,916 --> 00:24:13,187 line:-2
I can apply my convenience rank modifier
to the views in my layout.


433
00:24:13,220 --> 00:24:15,322 line:-1
Here, I calculate the rank of each pet


434
00:24:15.355 --> 00:24:20.894 line:-2 align:center
and add it to the pet's corresponding
avatar view inside my radial layout.


435
00:24:20.928 --> 00:24:23.597 line:-1 align:center
Finally, back in my place subviews method,


436
00:24:23.630 --> 00:24:27.167 line:-2 align:center
I can add some code to read the values
from each subview


437
00:24:27.201 --> 00:24:31.371 line:-1 align:center
by using the layout value key as an index.


438
00:24:31.405 --> 00:24:34.675 line:-2 align:center
And I can use the ranks
to calculate an offset.


439
00:24:34.708 --> 00:24:37.511 line:-2 align:center
I won't go through that logic here,
but it basically produces


440
00:24:37.544 --> 00:24:40.914 line:-2 align:center
an appropriate angle
for any possible set of rankings.


441
00:24:40.948 --> 00:24:43.283 line:-1 align:center
Well, all except one.


442
00:24:43.317 --> 00:24:45.752 line:-1 align:center
What happens if there's a three-way tie?


443
00:24:45.786 --> 00:24:48.856 line:-2 align:center
There's no way to rotate
the layout to get all the views in a line,


444
00:24:48.889 --> 00:24:53.393 line:-2 align:center
so I'd have to substitute completely
different layout logic for that case.


445
00:24:53,427 --> 00:24:56,330 line:-2
However, there is already
a layout type that does this,


446
00:24:56.363 --> 00:24:58.498 line:-1 align:center
and that's the built-in HStack.


447
00:24:58,532 --> 00:25:01,168 line:-2
So what I'd really like
is to transition to an HStack


448
00:25:01.201 --> 00:25:03.604 line:-1 align:center
when I detect a three-way tie.


449
00:25:03.637 --> 00:25:07.107 line:-2 align:center
And it turns out that
there's a new tool for that, too.


450
00:25:07,140 --> 00:25:09,476 line:-2
The AnyLayout type lets you
apply different layouts


451
00:25:09,510 --> 00:25:12,513 line:-2
to a single view hierarchy,
so that you maintain the identity


452
00:25:12,546 --> 00:25:16,517 line:-2
of the views as you transition
from one layout type to another.


453
00:25:17,451 --> 00:25:20,988 line:-2
So here I have the radial layout
that we saw before,


454
00:25:21.021 --> 00:25:24.057 line:-2 align:center
and all I have to do is replace that
with a new layout type


455
00:25:24,091 --> 00:25:27,528 line:-2
that depends on whether
there's a three-way tie.


456
00:25:27.561 --> 00:25:31.465 line:-2 align:center
Because the isThreeWayTie property
is derived from state,


457
00:25:31,498 --> 00:25:33,333 line:-1
SwiftUI notices when it changes


458
00:25:33.367 --> 00:25:36.370 line:-2 align:center
and recognizes
that it needs to redraw this view.


459
00:25:36.403 --> 00:25:39.540 line:-2 align:center
But because the structural identity
of the view hierarchy


460
00:25:39.573 --> 00:25:43.844 line:-2 align:center
always remains the same,
SwiftUI sees this as a view that changes,


461
00:25:43.877 --> 00:25:46.213 line:-1 align:center
rather than as a new view.


462
00:25:46.246 --> 00:25:48.949 line:-2 align:center
As a result,
with only one more line,


463
00:25:48,982 --> 00:25:52,553 line:-2
I can create smooth transitions
between layout types.


464
00:25:52.586 --> 00:25:55.155 line:-2 align:center
And in fact,
by adding the animation view modifier,


465
00:25:55,189 --> 00:25:59,726 line:-2
I also get animations between all
the different states of the radial layout,


466
00:25:59,760 --> 00:26:03,931 line:-2
because the configuration of the radial
layout depends on the same data.


467
00:26:03,964 --> 00:26:06,733 line:-2
And here's what
all that looks like in action.


468
00:26:06.767 --> 00:26:09.403 line:-2 align:center
As I tap on different buttons
to change the vote counts,


469
00:26:09.436 --> 00:26:13.540 line:-2 align:center
you can see how the avatars move around
smoothly to reflect the current standings.


470
00:26:17.845 --> 00:26:20.447 line:-2 align:center
So those are some of the new tools
that SwiftUI has


471
00:26:20.480 --> 00:26:23.083 line:-1 align:center
for composing your app's view layouts.


472
00:26:23.116 --> 00:26:25.719 line:-2 align:center
You can use the Grid type
to build highly customizable,


473
00:26:25.752 --> 00:26:28.589 line:-2 align:center
two-dimensional layouts
of static information.


474
00:26:28.622 --> 00:26:31.859 line:-2 align:center
You can use the Layout protocol
to define your own general purpose,


475
00:26:31,892 --> 00:26:36,730 line:-2
reusable layouts, or layouts that are
highly targeted to a particular use case.


476
00:26:36.763 --> 00:26:40.734 line:-2 align:center
You can use ViewThatFits when you want
to let SwiftUI pick from a group of views


477
00:26:40,767 --> 00:26:43,303 line:-1
to best fit in the available space.


478
00:26:43,337 --> 00:26:48,442 line:-2
And you can seamlessly transition
between layout types using AnyLayout.


479
00:26:48.475 --> 00:26:51.411 line:-2 align:center
Thanks for joining me today,
and I hope you have as much fun


480
00:26:51.445 --> 00:26:54.214 line:-2 align:center
playing with these new layout tools
as I have.

