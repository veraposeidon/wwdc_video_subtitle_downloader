2
00:00:00.334 --> 00:00:07.341 line:-1 align:center
♪ ♪


3
00:00:09,309 --> 00:00:11,545 line:-1
Hi, my name is Yi.


4
00:00:11.578 --> 00:00:13.814 line:-1 align:center
Hi, my name is Dominik.


5
00:00:13.847 --> 00:00:16.283 line:-1 align:center
And we are GPU software engineers.


6
00:00:16.316 --> 00:00:20.287 line:-2 align:center
Today, Dominik and I are going to talk
about the performance enhancements


7
00:00:20.320 --> 00:00:23.690 line:-2 align:center
and features we've added
to the Metal Ray Tracing API this year


8
00:00:23.724 --> 00:00:27.060 line:-2 align:center
to help you maximize the performance
of your ray tracing applications.


9
00:00:27,094 --> 00:00:30,731 line:-2
Ray tracing applications simulate
individual rays of light


10
00:00:30,764 --> 00:00:33,000 line:-1
bouncing around a scene.


11
00:00:33.033 --> 00:00:36.570 line:-2 align:center
This is used in games
and offline rendering to produce


12
00:00:36,603 --> 00:00:41,975 line:-2
photorealistic reflections,
shadows, global illumination, and more.


13
00:00:42,009 --> 00:00:44,545 line:-1
This requires simulating a lot of rays,


14
00:00:44,578 --> 00:00:47,814 line:-2
so performance is critical
for these applications.


15
00:00:47,848 --> 00:00:51,585 line:-2
Fortunately, Metal has
built-in support for ray tracing


16
00:00:51.618 --> 00:00:54.388 line:-1 align:center
optimized for all Apple devices.


17
00:00:54.421 --> 00:00:57.357 line:-2 align:center
Let's briefly review
how ray tracing works in Metal.


18
00:00:57,391 --> 00:01:01,662 line:-2
The Metal ray tracing API
is available from within shader functions


19
00:01:01,695 --> 00:01:05,265 line:-1
such as compute or fragment functions.


20
00:01:05.299 --> 00:01:09.503 line:-2 align:center
We start by generating some rays
which are emitted into the scene.


21
00:01:09,536 --> 00:01:13,473 line:-2
Next, we create an intersector object
and use it to check


22
00:01:13,507 --> 00:01:18,011 line:-2
for intersections between our rays
and the geometry in the scene.


23
00:01:18,045 --> 00:01:21,114 line:-2
A bit later,
I will describe some of the new features


24
00:01:21.148 --> 00:01:24.418 line:-2 align:center
we've added this year
to speed up the intersection search.


25
00:01:24.451 --> 00:01:26.920 line:-2 align:center
This process depends
on a special data structure


26
00:01:26,954 --> 00:01:29,056 line:-1
called an acceleration structure,


27
00:01:29,089 --> 00:01:32,292 line:-2
which also represents
the geometry in the scene.


28
00:01:32.326 --> 00:01:36.129 line:-2 align:center
I will also talk about several new
features and performance improvements


29
00:01:36.163 --> 00:01:38.732 line:-1 align:center
focused on acceleration structures today.


30
00:01:38,765 --> 00:01:41,835 line:-2
The intersector returns
an intersection result object


31
00:01:41.869 --> 00:01:45.038 line:-1 align:center
describing the primitive each ray hit.


32
00:01:45,072 --> 00:01:50,711 line:-2
The intersection result is used to produce
a color to write into the output image.


33
00:01:50,744 --> 00:01:53,514 line:-2
It can also be used
to produce additional rays


34
00:01:53,547 --> 00:01:55,749 line:-1
which go through the process again.


35
00:01:55.782 --> 00:01:58.485 line:-2 align:center
We can repeat this process
as many times as we'd like


36
00:01:58.519 --> 00:02:01.054 line:-2 align:center
to simulate light
bouncing around the scene.


37
00:02:01,088 --> 00:02:05,392 line:0
If you want to learn more about
the basics of the Metal ray tracing API,


38
00:02:05,425 --> 00:02:09,796 line:0
I recommend you review
our previous WWDC sessions.


39
00:02:09,830 --> 00:02:14,334 align:center
We first introduced the Metal
ray tracing API at WWDC20,


40
00:02:14,368 --> 00:02:19,139 align:center
and last year, we introduced new features
including support for motion blur.


41
00:02:19.173 --> 00:02:22.576 line:-2 align:center
Today, I'm going to talk
about three things.


42
00:02:22,609 --> 00:02:26,680 line:-2
First, I will tell you about new features
which enable you to improve


43
00:02:26,713 --> 00:02:29,082 line:-2
ray tracing performance
in your applications.


44
00:02:30,817 --> 00:02:33,954 line:-2
Next, I will talk about
improvements and features


45
00:02:33,987 --> 00:02:36,323 line:-2
we've added
to the acceleration structure API.


46
00:02:38,258 --> 00:02:40,994 line:-2
Finally, Dominik will tell you
about improvements


47
00:02:41.028 --> 00:02:43.897 line:-1 align:center
to our GPU tools for ray tracing.


48
00:02:43,931 --> 00:02:46,266 line:-1
This year, we've added three new features


49
00:02:46,300 --> 00:02:48,802 line:-2
aimed at either improving
ray tracing performance


50
00:02:48.836 --> 00:02:51.004 line:-1 align:center
or simplifying your code.


51
00:02:51,038 --> 00:02:54,708 line:-2
They are per-primitive data,
the ability to retrieve buffers


52
00:02:54,741 --> 00:02:56,844 line:-1
from intersection function tables,


53
00:02:56,877 --> 00:02:59,980 line:-2
and support for ray tracing
from indirect command buffers.


54
00:03:01.949 --> 00:03:04.484 line:-1 align:center
Let's start with per-primitive data.


55
00:03:04.518 --> 00:03:08.956 line:-2 align:center
Applications usually have data associated
with the primitive in their scene


56
00:03:08.989 --> 00:03:12.559 line:-2 align:center
such as vertex colors, normals,
and texture coordinates.


57
00:03:13.894 --> 00:03:16.296 line:-2 align:center
This year,
we've added the ability to store


58
00:03:16.330 --> 00:03:21.235 line:-2 align:center
small amounts of data for each primitive
directly in the acceleration structure.


59
00:03:21,268 --> 00:03:25,305 line:-2
This data can be accessed with fewer
memory indirections and cache misses,


60
00:03:25,339 --> 00:03:27,374 line:-1
improving performance.


61
00:03:27,407 --> 00:03:31,645 line:-2
This also reduces the need to store
complicated auxiliary data structure


62
00:03:31,678 --> 00:03:35,883 line:-2
which are typically required to look up
the data associated with your primitives.


63
00:03:37,184 --> 00:03:38,785 line:-1
Let's look at an example.


64
00:03:39.853 --> 00:03:42.823 line:-2 align:center
Alpha testing is a technique
used to add complexity


65
00:03:42.856 --> 00:03:47.127 line:-2 align:center
to transparent geometry
without increasing the triangle count.


66
00:03:47,160 --> 00:03:51,064 line:-2
In this technique, the alpha channel
of a texture mapped onto a triangle


67
00:03:51,098 --> 00:03:55,435 line:-2
is used to determine if the ray should
hit the triangle or continue further.


68
00:03:56.670 --> 00:03:59.573 line:-2 align:center
To achieve this,
you need to configure the intersector


69
00:03:59,606 --> 00:04:03,477 line:-2
to call your custom intersection function
when a triangle is hit by the ray.


70
00:04:04,645 --> 00:04:08,982 line:0
The ultimate goal is to sample from
the texture associated with the triangle


71
00:04:09,016 --> 00:04:13,187 line:0
and test if the alpha value allows the ray
to continue through the primitive.


72
00:04:13,220 --> 00:04:16,757 line:0
To get there,
you need two pieces of information:


73
00:04:16,790 --> 00:04:20,093 line:0
the texture object and the UV coordinates.


74
00:04:20,127 --> 00:04:22,829 line:0
In a typical implementation
of alpha testing,


75
00:04:22,863 --> 00:04:25,832 line:-2
you would need to access
a number of intermediate buffers


76
00:04:25,866 --> 00:04:29,002 line:-2
in Metal device memory
in order to get this information.


77
00:04:30,370 --> 00:04:34,341 line:-2
First, you would store the texture
associated with the primitive


78
00:04:34.374 --> 00:04:36.410 line:-1 align:center
in some kind of material structure.


79
00:04:37.878 --> 00:04:41.081 line:-2 align:center
Several materials would be
packed into a buffer.


80
00:04:41,114 --> 00:04:45,052 line:-2
It would be impractical to store
material structure for every primitive,


81
00:04:45.085 --> 00:04:48.856 line:-2 align:center
as they may be pretty big
and there may be a lot of primitives.


82
00:04:48,889 --> 00:04:52,125 line:-2
Instead, you would want to store
just the material IDs


83
00:04:52.159 --> 00:04:56.630 line:-2 align:center
for each primitive in a buffer
and use them to look up the materials.


84
00:04:56.663 --> 00:05:00.200 line:-2 align:center
Next, to calculate UVs,
you need to load the UVs


85
00:05:00,234 --> 00:05:04,104 line:-2
for each vertex from another buffer
and interpolate them.


86
00:05:04.137 --> 00:05:07.875 line:-2 align:center
Finally, let's say you are
using instanced geometry.


87
00:05:07.908 --> 00:05:12.279 line:-2 align:center
You may want each instance
to have its own materials and UV mappings.


88
00:05:12.312 --> 00:05:14.848 line:-1 align:center
To support that, you would store pointers


89
00:05:14.882 --> 00:05:19.119 line:-2 align:center
to UV and Material ID buffers
in an Instance Data buffer,


90
00:05:19,152 --> 00:05:22,556 line:-2
adding yet another level
of indirection to your function.


91
00:05:22,589 --> 00:05:26,827 line:-2
This approach requires you to maintain
a fairly complex buffer setup


92
00:05:26.860 --> 00:05:31.798 line:-2 align:center
and involves many layers of indirection
to get to the data that you need.


93
00:05:31.832 --> 00:05:33.901 line:-1 align:center
This may also lead to cache misses


94
00:05:33,934 --> 00:05:37,371 line:-2
that would negatively affect
the performance.


95
00:05:37,404 --> 00:05:40,908 line:-2
Let's look at the code needed
to implement this diagram.


96
00:05:40,941 --> 00:05:44,278 line:-2
Then I will show you
how you can simplify it step-by-step


97
00:05:44.311 --> 00:05:46.180 line:-1 align:center
using per-primitive data.


98
00:05:46.213 --> 00:05:50.817 line:-2 align:center
This is the original implementation of
the alpha testing intersection function.


99
00:05:50.851 --> 00:05:54.922 line:-2 align:center
This function is invoked when
the ray hits an alpha tested triangle.


100
00:05:54.955 --> 00:05:58.859 line:-2 align:center
The function starts by loading
the instance data from the memory.


101
00:05:58.892 --> 00:06:02.896 line:-2 align:center
This is the buffer that contains pointers
to UV and material buffers


102
00:06:02,930 --> 00:06:04,464 line:-1
used by the instance.


103
00:06:04,498 --> 00:06:07,267 line:-2
Next, the function loads
the UV coordinates


104
00:06:07,301 --> 00:06:10,237 line:-1
from the UV buffer and interpolates them.


105
00:06:10,270 --> 00:06:12,105 line:-1
This is another memory load.


106
00:06:12,139 --> 00:06:15,976 align:center
Then, the function loads
the material index from another buffer.


107
00:06:16,009 --> 00:06:18,445 line:0
And finally,
the function loads the material


108
00:06:18,478 --> 00:06:20,681 line:0
and samples the corresponding texture.


109
00:06:20,714 --> 00:06:24,051 line:0
At this point, the function has
the alpha value it needs


110
00:06:24,084 --> 00:06:26,086 line:0
and can compare it to the threshold.


111
00:06:26.119 --> 00:06:29.656 line:-2 align:center
Now, I will show you
how you can simplify this code


112
00:06:29.690 --> 00:06:33.327 line:-2 align:center
and improve its performance
using per-primitive data.


113
00:06:33.360 --> 00:06:35.829 line:-2 align:center
Instead of using
a complicated buffer setup


114
00:06:35,863 --> 00:06:38,198 line:-1
with multiple layers of indirection,


115
00:06:38.232 --> 00:06:41.702 line:-2 align:center
you can simply store only the data
the intersection function will need


116
00:06:41.735 --> 00:06:45.405 line:-2 align:center
for each primitive
directly in the acceleration structure.


117
00:06:45.439 --> 00:06:47.941 line:-1 align:center
In this example, you can create a struct


118
00:06:47,975 --> 00:06:51,645 line:-2
containing the texture and UV coordinates
for each primitive.


119
00:06:51.678 --> 00:06:54.815 line:-2 align:center
You provide this data when building
the acceleration structure


120
00:06:54,848 --> 00:06:57,384 line:-2
and the intersection function
simply receives a pointer


121
00:06:57,417 --> 00:07:00,254 line:-2
to that data
when a ray hits the primitive.


122
00:07:00.287 --> 00:07:03.190 line:-2 align:center
You can store anything you like
in the per-primitive data,


123
00:07:03,223 --> 00:07:07,327 line:-2
but keeping the size small will
help achieve the best performance.


124
00:07:07.361 --> 00:07:10.597 line:-2 align:center
I will start with the inputs
to the intersection function.


125
00:07:10.631 --> 00:07:13.901 line:-2 align:center
Having access to all of them gives you
a lot of flexibility


126
00:07:13,934 --> 00:07:15,869 line:-1
when it comes to the implementation,


127
00:07:15.903 --> 00:07:19.406 line:-2 align:center
but it can also increase
the register usage on the GPU.


128
00:07:19.439 --> 00:07:22.676 line:-2 align:center
With per-primitive data,
instead of all the buffers,


129
00:07:22.709 --> 00:07:26.146 line:-2 align:center
you only need to access
the primitive data pointer.


130
00:07:26,180 --> 00:07:30,317 line:-2
This is the data you store
directly in the acceleration structure.


131
00:07:30,350 --> 00:07:34,354 line:-2
In this case, each primitive has
its own texture object and UVs


132
00:07:34.388 --> 00:07:36.757 line:-1 align:center
for all of its vertices.


133
00:07:36,790 --> 00:07:41,461 line:-2
Next up are the loads from the global
material buffer and instance data buffer.


134
00:07:41,495 --> 00:07:43,063 line:-1
You won't need either of them.


135
00:07:43,096 --> 00:07:47,467 line:-2
Instead, you can do one load
from the per-primitive data pointer.


136
00:07:47.501 --> 00:07:51.004 line:-2 align:center
This is the only device memory access
needed in this function.


137
00:07:51,038 --> 00:07:52,606 line:-1
Next up are the UVs.


138
00:07:52,639 --> 00:07:56,343 line:-2
Instead of dereferencing a pointer
retrieved from the instance data,


139
00:07:56,376 --> 00:08:01,014 line:-2
you can simply access the data embedded
in the per-primitive data structure.


140
00:08:01,048 --> 00:08:04,785 line:-2
The change in the code is subtle,
but is important for performance,


141
00:08:04.818 --> 00:08:07.721 line:-2 align:center
as no additional
memory loads are involved.


142
00:08:07,754 --> 00:08:10,424 line:-2
Finally, there are
the material properties.


143
00:08:10,457 --> 00:08:13,794 line:-2
Since the only part of the material
needed is the texture,


144
00:08:13,827 --> 00:08:15,729 line:-1
you can encode the primitive's texture


145
00:08:15,762 --> 00:08:18,098 line:-2
directly in the per-primitive
data structure.


146
00:08:18.131 --> 00:08:20.767 line:-2 align:center
This means you don't need to access
the material


147
00:08:20,801 --> 00:08:22,936 line:-1
and material index buffers anymore.


148
00:08:22.970 --> 00:08:24.972 line:-1 align:center
You can simply use the texture directly


149
00:08:25.005 --> 00:08:28.442 line:-2 align:center
without paying the cost
of additional memory dereferences.


150
00:08:28.475 --> 00:08:31.178 line:-2 align:center
This is how much simpler
your intersection code can be


151
00:08:31,211 --> 00:08:33,313 line:-1
when using per-primitive data.


152
00:08:33,347 --> 00:08:35,916 line:-2
All the costly memory accesses
are replaced


153
00:08:35,949 --> 00:08:39,486 line:-2
with just one load
from the primitive data pointer.


154
00:08:39,520 --> 00:08:43,524 line:-2
On top of that, the code is
much simpler and easier to follow.


155
00:08:44.224 --> 00:08:47.160 line:-2 align:center
Next, I will show you
how to store the primitive data


156
00:08:47.194 --> 00:08:49.363 line:-1 align:center
in the acceleration structure.


157
00:08:49.396 --> 00:08:53.233 line:-2 align:center
You will need to do this before you can
access it from an intersection function.


158
00:08:53,267 --> 00:08:55,369 line:-1
You will need to set a few fields


159
00:08:55.402 --> 00:08:57.804 line:-2 align:center
in the acceleration structure
geometry descriptor.


160
00:08:57,838 --> 00:09:01,008 line:-2
First, set the Metal buffer
where all the data is stored.


161
00:09:01,041 --> 00:09:05,345 line:-2
Next, specify the size of the data
that will be stored for each primitive.


162
00:09:05.379 --> 00:09:07.814 line:-2 align:center
If your data is not tightly packed
in the buffer


163
00:09:07,848 --> 00:09:10,284 line:-2
or doesn't start
at the beginning of the buffer,


164
00:09:10,317 --> 00:09:13,287 line:-2
you can also specify
the stride and the offset.


165
00:09:13.320 --> 00:09:17.591 line:-2 align:center
Otherwise, these values default to 0
so you don't need to set them.


166
00:09:17.624 --> 00:09:20.527 line:-2 align:center
You have already seen
how you can use per-primitive data


167
00:09:20.561 --> 00:09:21.828 line:-1 align:center
in an intersection function.


168
00:09:21,862 --> 00:09:24,398 line:-2
It's simply passed
into the function as a pointer.


169
00:09:24.431 --> 00:09:28.402 line:-2 align:center
But that's not all–you have access
to this data wherever you need it.


170
00:09:28.435 --> 00:09:32.306 line:-2 align:center
That includes the final intersection
result returned by the intersector.


171
00:09:32,339 --> 00:09:36,844 line:0
And if you are using intersection query,
the primitive data is also available


172
00:09:36,877 --> 00:09:39,746 line:0
for both candidate
and committed intersections.


173
00:09:39,780 --> 00:09:43,116 line:0
This means you can use per-primitive data
for shading


174
00:09:43,150 --> 00:09:45,319 line:0
in addition to intersection testing.


175
00:09:45.352 --> 00:09:48.021 line:-2 align:center
Per-primitive data can
improve the performance


176
00:09:48,055 --> 00:09:50,657 line:-2
of both your intersection code
and your shading code


177
00:09:50,691 --> 00:09:54,828 line:-2
by reducing the number
of memory accesses and indirections.


178
00:09:54.862 --> 00:09:58.265 line:-2 align:center
In fact, we found
in one of our own test applications


179
00:09:58.298 --> 00:10:03.704 line:-2 align:center
that using per-primitive data resulted
in a 10% to 16% performance improvement.


180
00:10:03.737 --> 00:10:05.472 line:-1 align:center
We can't wait for you to try it out


181
00:10:05.506 --> 00:10:08.008 line:-2 align:center
and see what kinds of improvements
you can get


182
00:10:08.041 --> 00:10:11.712 line:-1 align:center
in performance and code quality.


183
00:10:11.745 --> 00:10:14.748 line:-2 align:center
This year, we've also added
another convenience feature


184
00:10:14,781 --> 00:10:18,952 line:-2
to the Metal shading language to help you
simplify your ray tracing kernels.


185
00:10:18,986 --> 00:10:22,322 line:-2
Applications often pass
the same set of bindings


186
00:10:22,356 --> 00:10:26,593 line:-2
to both their intersection functions
and their main ray tracing kernel.


187
00:10:26,627 --> 00:10:29,530 line:-2
For example,
our ray tracing sample code uses


188
00:10:29.563 --> 00:10:32.065 line:-2 align:center
an intersection function
to render spheres.


189
00:10:32.099 --> 00:10:35.068 line:-2 align:center
This intersection function
accesses a resource buffer


190
00:10:35.102 --> 00:10:37.471 line:-1 align:center
containing information about each sphere.


191
00:10:37,504 --> 00:10:40,174 line:-2
In order to pass this buffer
into the intersection function,


192
00:10:40.207 --> 00:10:43.477 line:-2 align:center
the app binds the buffer
to the intersection function table.


193
00:10:43,510 --> 00:10:48,315 align:center
However, the main ray tracing kernel
also needs access to the resource buffer,


194
00:10:48,348 --> 00:10:50,851 align:center
so the app binds the buffer there as well.


195
00:10:50,884 --> 00:10:53,554 align:center
This year,
the Metal shading language allows you


196
00:10:53,587 --> 00:10:57,191 align:center
to access the buffers
bound to intersection function tables.


197
00:10:57,224 --> 00:10:59,726 align:center
With this new feature,
you can save the effort


198
00:10:59,760 --> 00:11:03,797 align:center
of binding the buffer for the kernel,
and instead access it directly


199
00:11:03,830 --> 00:11:05,699 line:0
from the intersection function table.


200
00:11:05,732 --> 00:11:08,468 line:-2
You can do this by calling
the get_buffer method


201
00:11:08,502 --> 00:11:11,839 line:-2
on the intersection function table,
providing its pointer type.


202
00:11:11.872 --> 00:11:15.642 line:-2 align:center
You can also access visible
function tables by their function type.


203
00:11:15.676 --> 00:11:20.180 line:-2 align:center
Indirect command buffers allow you to
encode GPU work independently on the GPU


204
00:11:20,214 --> 00:11:24,618 line:-2
and represent a fundamental element
of GPU driven pipelines.


205
00:11:24,651 --> 00:11:26,653 line:-3
To learn more about
indirect command buffers


206
00:11:26,687 --> 00:11:29,756 line:-3
and GPU-driven rendering,
we recommend you review


207
00:11:29.790 --> 00:11:33.894 line:-3 align:center
the "Modern rendering with Metal"
session from WWDC 2019.


208
00:11:33.927 --> 00:11:37.464 line:-3 align:center
Enabling ray tracing support
in an indirect command buffer is easy.


209
00:11:37,497 --> 00:11:40,601 line:-3
All you have to do is to set
the supportRayTracing flag


210
00:11:40,634 --> 00:11:42,069 line:-2
on the descriptor.


211
00:11:42.102 --> 00:11:46.139 line:-3 align:center
Indirect command buffers
dispatch graphics and compute functions,


212
00:11:46,173 --> 00:11:50,344 line:-3
so you can simply use ray tracing
from those functions as usual.


213
00:11:50,377 --> 00:11:53,881 line:-2
That's a rundown of all
the new features we've added this year


214
00:11:53,914 --> 00:11:58,218 line:-2
to help you get improved ray tracing
performance in your applications.


215
00:11:58,252 --> 00:12:01,755 line:-2
Next, let's talk
about acceleration structures.


216
00:12:01.788 --> 00:12:04.424 line:-2 align:center
We've implemented several
performance improvements


217
00:12:04,458 --> 00:12:08,228 line:-2
and added features focused
on building acceleration structures.


218
00:12:08,262 --> 00:12:10,631 line:-1
Let's recap what they are used for.


219
00:12:10,664 --> 00:12:13,033 line:-2
Acceleration structures
are data structures


220
00:12:13.066 --> 00:12:15.802 line:-1 align:center
which accelerate the ray tracing process.


221
00:12:15,836 --> 00:12:18,805 line:-2
They do this
by recursively partitioning space


222
00:12:18,839 --> 00:12:23,343 line:-2
so we can quickly find which triangles
are likely to intersect a ray.


223
00:12:23,377 --> 00:12:25,412 line:-1
To support building complex scenes,


224
00:12:25,445 --> 00:12:28,549 line:-2
Metal supports two types
of acceleration structures:


225
00:12:28.582 --> 00:12:31.518 line:-2 align:center
primitive and instance
acceleration structures.


226
00:12:31,552 --> 00:12:34,221 line:-2
Individual pieces of geometry
are represented


227
00:12:34.254 --> 00:12:36.690 line:-1 align:center
using primitive acceleration structures.


228
00:12:36,723 --> 00:12:40,194 line:-2
They can be something simple
like a plane or a cube,


229
00:12:40,227 --> 00:12:44,398 line:-2
or something more complex
like a sphere or a triangle mesh.


230
00:12:44,431 --> 00:12:48,635 align:center
You can create more complex scenes
using an instance acceleration structure.


231
00:12:48,669 --> 00:12:51,338 align:center
Instance acceleration structures
create copies


232
00:12:51,371 --> 00:12:53,140 align:center
of primitive acceleration structures.


233
00:12:53,173 --> 00:12:58,078 align:center
First, define transformation matrices
for each object in your scene.


234
00:12:58,111 --> 00:13:01,014 line:0
Then, use the array
of transformation matrices


235
00:13:01,048 --> 00:13:02,916 align:center
and primitive acceleration structures


236
00:13:02,950 --> 00:13:05,619 align:center
to build
an instance acceleration structure.


237
00:13:05.652 --> 00:13:09.823 line:-2 align:center
That's how you can build a static scene
using acceleration structures.


238
00:13:09,857 --> 00:13:12,659 line:-1
Next, let's see how dynamic applications


239
00:13:12.693 --> 00:13:15.128 line:-2 align:center
like a game would use
acceleration structures.


240
00:13:16.196 --> 00:13:18.131 line:-1 align:center
Let's start at the beginning:


241
00:13:18,165 --> 00:13:19,933 line:-1
there are several tasks you need to do


242
00:13:19.967 --> 00:13:22.970 line:-2 align:center
when first launching a game
or loading a new level.


243
00:13:23.003 --> 00:13:27.674 line:-2 align:center
This includes the normal tasks
like loading models and textures.


244
00:13:27.708 --> 00:13:31.612 line:-2 align:center
With ray tracing, you also need to build
primitive acceleration structures


245
00:13:31.645 --> 00:13:34.515 line:-1 align:center
for all of the models which will be used.


246
00:13:34,548 --> 00:13:37,951 line:-2
We recommend that you build as many
of your primitive acceleration structures


247
00:13:37.985 --> 00:13:42.189 line:-2 align:center
as possible at load time
to save time in your main rendering loop.


248
00:13:42,222 --> 00:13:44,391 line:-2
You can use
an instance acceleration structure


249
00:13:44.424 --> 00:13:48.529 line:-2 align:center
to add or remove these objects
from the scene as needed.


250
00:13:48.562 --> 00:13:51.765 line:-2 align:center
Once your app is done loading,
it enters the main loop.


251
00:13:51,798 --> 00:13:54,868 line:0
Every frame,
it renders the scene using a combination


252
00:13:54,902 --> 00:13:58,438 align:center
of rasterization, ray tracing,
and post-processing.


253
00:13:58,472 --> 00:14:01,041 align:center
However, since games are very dynamic,


254
00:14:01,074 --> 00:14:05,045 align:center
you will probably need to update
some of the acceleration structures.


255
00:14:05,078 --> 00:14:08,348 align:center
This typically includes refitting
a handful of deforming


256
00:14:08,382 --> 00:14:11,518 align:center
or animated models
such as skinned characters.


257
00:14:11,552 --> 00:14:14,688 align:center
Refitting an existing
acceleration structure is much faster


258
00:14:14,721 --> 00:14:18,859 align:center
than a full rebuild, so we recommend
using it for cases like this.


259
00:14:18,892 --> 00:14:22,563 line:0
You should also do a full rebuild
of the instance acceleration structure.


260
00:14:22,596 --> 00:14:26,500 line:0
This is necessary since objects may have
been added or removed


261
00:14:26,533 --> 00:14:30,504 align:center
from the scene since the last frame,
or they may have moved significantly.


262
00:14:30,537 --> 00:14:33,974 line:0
Doing a full rebuild is fine in this case
since there's only one


263
00:14:34,007 --> 00:14:35,576 align:center
instance acceleration structure


264
00:14:35,609 --> 00:14:39,246 line:0
and it usually only contains at most
a few thousand objects.


265
00:14:39,279 --> 00:14:43,483 line:-2
This year, we've improved performance
for all of these cases.


266
00:14:43,517 --> 00:14:46,253 line:-1
First, acceleration structure builds


267
00:14:46,286 --> 00:14:49,957 line:-2
are now up to 2.3 times faster
on Apple Silicon.


268
00:14:49.990 --> 00:14:53.427 line:-2 align:center
Second, refitting is also
up to 38% faster.


269
00:14:54,428 --> 00:14:58,832 line:0
This means that both load times
and per-frame overhead are reduced.


270
00:14:58,866 --> 00:15:00,534 line:0
But it gets even better.


271
00:15:00,567 --> 00:15:03,370 line:0
Some applications build hundreds
or even thousands


272
00:15:03.403 --> 00:15:05.606 line:-2 align:center
of small primitive
acceleration structures.


273
00:15:05.639 --> 00:15:08.475 line:-2 align:center
These small builds
don't do enough work individually


274
00:15:08.509 --> 00:15:13.547 line:-2 align:center
to fill up the GPU, resulting in
long periods of low GPU utilization.


275
00:15:13,580 --> 00:15:16,450 line:-2
Therefore, multiple builds are
now automatically performed


276
00:15:16,483 --> 00:15:19,520 line:-2
in parallel whenever possible
on Apple Silicon.


277
00:15:19,553 --> 00:15:22,322 line:0
This results
in up to 2.8 times faster builds


278
00:15:22,356 --> 00:15:24,224 align:center
when they run in parallel.


279
00:15:24,258 --> 00:15:26,426 align:center
This further reduces load times.


280
00:15:26,460 --> 00:15:28,395 align:center
And this doesn't just apply to builds:


281
00:15:28,428 --> 00:15:31,365 line:0
it applies to all
of the acceleration structure operations


282
00:15:31,398 --> 00:15:34,134 align:center
including compacting and refitting,


283
00:15:34,168 --> 00:15:37,504 line:0
so your per-frame overhead
is reduced as well.


284
00:15:37,538 --> 00:15:39,840 align:center
There are a few guidelines
you will need to follow


285
00:15:39,873 --> 00:15:43,043 line:0
to ensure that you can benefit
from this optimization.


286
00:15:43,076 --> 00:15:46,780 line:-2
Here is an example that builds
an array of acceleration structures.


287
00:15:46,813 --> 00:15:49,850 line:-2
To build them in parallel,
you will need to ensure that you use


288
00:15:49.883 --> 00:15:53.387 line:-2 align:center
the same acceleration structure
command encoder for many builds.


289
00:15:53,420 --> 00:15:58,492 line:-2
Additionally, builds which use the same
scratch buffer can't run in parallel.


290
00:15:58.525 --> 00:16:02.396 line:-2 align:center
Therefore, you will want to ensure
that you are looping through a small pool


291
00:16:02,429 --> 00:16:06,033 line:-2
of scratch buffers rather than using
the same scratch buffer for each build.


292
00:16:07.234 --> 00:16:09.369 line:-1 align:center
Those are all the performance improvements


293
00:16:09,403 --> 00:16:12,606 line:-2
we've made to building
acceleration structures.


294
00:16:12.639 --> 00:16:14.675 line:-1 align:center
We've also added three new features


295
00:16:14,708 --> 00:16:18,212 line:-2
to make building acceleration structures
easier and more efficient.


296
00:16:19,546 --> 00:16:24,284 line:-2
They are support for additional
vertex formats, transformation matrices,


297
00:16:24.318 --> 00:16:26.954 line:-2 align:center
and acceleration structure allocation
from heaps.


298
00:16:29.089 --> 00:16:32.326 line:-1 align:center
Let's start with vertex formats.


299
00:16:32.359 --> 00:16:35.596 line:-2 align:center
A common performance optimization
is to use quantized


300
00:16:35.629 --> 00:16:39.166 line:-2 align:center
or reduced precision formats
for vertex data,


301
00:16:39.199 --> 00:16:41.468 line:-1 align:center
resulting in lower memory usage.


302
00:16:41.502 --> 00:16:44.137 line:-2 align:center
This year, you can build
acceleration structures


303
00:16:44.171 --> 00:16:46.607 line:-1 align:center
from a wide range of vertex formats.


304
00:16:46,640 --> 00:16:50,577 align:center
This includes half precision
floating point formats,


305
00:16:50,611 --> 00:16:53,981 line:0
two component vertex formats
for planar geometry,


306
00:16:54,014 --> 00:16:57,584 line:0
and all the usual
normalized integer formats.


307
00:16:57,618 --> 00:17:00,687 align:center
Previously,
acceleration structures have required


308
00:17:00,721 --> 00:17:04,191 align:center
three component,
full-precision floating point vertex data.


309
00:17:04,224 --> 00:17:07,427 align:center
In this example,
the application has vertex data


310
00:17:07,461 --> 00:17:10,097 align:center
in a half precision vertex format.


311
00:17:10,130 --> 00:17:14,067 line:0
This data needs to be unpacked
and copied into a temporary buffer


312
00:17:14,101 --> 00:17:16,537 align:center
just to build the acceleration structure.


313
00:17:16,570 --> 00:17:18,605 line:0
With the new vertex formats feature,


314
00:17:18,639 --> 00:17:21,808 line:0
acceleration structure builds
can now consume vertex data


315
00:17:21,842 --> 00:17:24,111 align:center
in any of the supported formats,


316
00:17:24,144 --> 00:17:27,281 align:center
eliminating the need to create
a temporary copy.


317
00:17:27,314 --> 00:17:29,850 align:center
Setting the vertex format
couldn't be simpler.


318
00:17:29,883 --> 00:17:34,121 line:-2
All you need to do is set the property
on your geometry descriptor.


319
00:17:34,154 --> 00:17:37,357 line:-2
Next, let's talk about
transformation matrices.


320
00:17:37.391 --> 00:17:40.227 line:-2 align:center
This feature complements
the new vertex formats,


321
00:17:40,260 --> 00:17:42,629 line:-2
so that you can pre-transform
your vertex data


322
00:17:42.663 --> 00:17:45.199 line:-2 align:center
before building
the acceleration structure.


323
00:17:45.232 --> 00:17:47.701 line:-1 align:center
For example, you might want to use them


324
00:17:47.734 --> 00:17:51.505 line:-2 align:center
to unpack complex meshes
stored in a normalized format.


325
00:17:51,538 --> 00:17:54,808 line:-2
Let's consider
the Red Panda model in this scene.


326
00:17:54,842 --> 00:17:58,712 line:-2
To normalize the geometry to use
one of our compressed formats,


327
00:17:58.745 --> 00:18:01.715 line:-1 align:center
you take the mesh, calculate its bounds,


328
00:18:01,748 --> 00:18:04,952 line:-2
and then scale them
to a zero to one range.


329
00:18:04,985 --> 00:18:09,189 line:-2
You can then use one of the normalized
integer vertex formats to store the mesh,


330
00:18:09,223 --> 00:18:13,760 line:-2
reducing the amount of space
it takes up on disk and in memory.


331
00:18:13.794 --> 00:18:17.598 line:-2 align:center
At runtime,
you provide a matrix that will scale


332
00:18:17,631 --> 00:18:21,134 line:-2
and offset each vertex
to the final position.


333
00:18:21,168 --> 00:18:25,038 line:-2
Applying that matrix
retrieves the original model.


334
00:18:25,072 --> 00:18:28,509 align:center
Now let's walk through
how to set up acceleration structure


335
00:18:28,542 --> 00:18:30,611 line:0
passing a transformation matrix.


336
00:18:30,644 --> 00:18:33,714 line:0
You start by creating
the transform buffer.


337
00:18:33,747 --> 00:18:38,519 line:0
One way of doing this is to create
an MTLPackedFloat4x3 object


338
00:18:38,552 --> 00:18:41,889 align:center
containing the scale
and offset transformation matrix.


339
00:18:41,922 --> 00:18:46,193 align:center
Then, create a Metal Buffer
big enough to hold the matrix.


340
00:18:46,226 --> 00:18:49,796 align:center
And finally,
copy the matrix to the Buffer.


341
00:18:49,830 --> 00:18:52,666 align:center
Next, set up the acceleration structure.


342
00:18:52.699 --> 00:18:55.536 line:-2 align:center
First, create
a triangle geometry descriptor.


343
00:18:55.569 --> 00:18:58.705 line:-2 align:center
Then, specify
the transformation Matrix Buffer.


344
00:18:58,739 --> 00:19:01,575 line:-1
And finally the Buffer Offset.


345
00:19:01,608 --> 00:19:05,179 line:-2
That's all you need to do to set up
the transformation matrix.


346
00:19:05.212 --> 00:19:09.550 line:-2 align:center
These matrices can also be used
to combine simple acceleration structures


347
00:19:09,583 --> 00:19:11,985 line:-1
to improve ray tracing performance.


348
00:19:12,019 --> 00:19:14,188 align:center
Let's see an example scene.


349
00:19:14,221 --> 00:19:19,092 align:center
Here, the boxes and the spheres
are all relatively simple meshes.


350
00:19:19,126 --> 00:19:22,729 line:0
This presents an opportunity
to optimize the acceleration structure


351
00:19:22,763 --> 00:19:25,566 align:center
for this group at the front of the scene.


352
00:19:25,599 --> 00:19:28,535 align:center
Focusing on
the instance acceleration structure,


353
00:19:28,569 --> 00:19:32,272 line:0
there is an overhead for each instance
that your rays hit.


354
00:19:32,306 --> 00:19:34,441 line:0
There is a cost for transforming the ray


355
00:19:34,474 --> 00:19:38,412 line:0
and then switching from the instance
to the primitive acceleration structure.


356
00:19:38,445 --> 00:19:42,316 align:center
This occurs more often
with overlapping instances.


357
00:19:42,349 --> 00:19:44,151 line:0
To reduce the instance count,


358
00:19:44,184 --> 00:19:46,954 line:0
you can generate
a single primitive acceleration structure


359
00:19:46,987 --> 00:19:50,591 line:0
that contains
both the boxes and the sphere.


360
00:19:50,624 --> 00:19:53,427 align:center
To do this,
you can create a geometry descriptor


361
00:19:53,460 --> 00:19:57,397 align:center
for each object,
each with its own transformation matrix.


362
00:19:57,431 --> 00:20:00,834 align:center
The resulting primitive acceleration
structure is a single instance


363
00:20:00,868 --> 00:20:05,606 align:center
in the instance acceleration structure
and contains the boxes and sphere.


364
00:20:05,639 --> 00:20:09,309 align:center
This should result in a better
performing acceleration structure.


365
00:20:09,343 --> 00:20:11,378 align:center
Let's see how to set this up in code.


366
00:20:12,779 --> 00:20:16,416 line:-2
You start with the descriptor
that defines the sphere geometry.


367
00:20:16,450 --> 00:20:20,721 line:-2
Next, set the vertex buffer,
index buffer, and other properties


368
00:20:20,754 --> 00:20:24,024 line:-2
as usual
for a primitive acceleration structure.


369
00:20:24,057 --> 00:20:26,927 line:-2
The difference is, you also specify
the transform buffer


370
00:20:26.960 --> 00:20:30.797 line:-2 align:center
that contains the transformation matrix
used for the copy of the sphere.


371
00:20:32.466 --> 00:20:35.502 line:-2 align:center
For the boxes,
you have multiple geometry descriptors


372
00:20:35,536 --> 00:20:38,372 line:-1
sharing a vertex and index buffer.


373
00:20:38,405 --> 00:20:42,609 line:-2
You just need to specify different
transform buffers for each copy.


374
00:20:42,643 --> 00:20:47,114 line:-2
Finally, when creating the descriptor
for the primitive acceleration structure,


375
00:20:47.147 --> 00:20:49.750 line:-1 align:center
add all the geometry descriptors.


376
00:20:49.783 --> 00:20:52.419 line:-2 align:center
This will result
in a primitive acceleration structure


377
00:20:52.452 --> 00:20:56.123 line:-2 align:center
that you can instance into the scene
with an identity transform.


378
00:20:56.156 --> 00:20:59.393 line:-2 align:center
This primitive acceleration structure
will take less time to build


379
00:20:59,426 --> 00:21:03,330 line:-2
than separate acceleration structures
and will be faster to intersect.


380
00:21:04.998 --> 00:21:08.502 line:-2 align:center
Finally, heap allocation
of acceleration structures has been


381
00:21:08.535 --> 00:21:11.605 line:-1 align:center
one of our most requested features.


382
00:21:11.638 --> 00:21:14.041 line:-2 align:center
With this feature,
you now have more control


383
00:21:14,074 --> 00:21:16,577 line:-1
over acceleration structure allocation.


384
00:21:16.610 --> 00:21:20.047 line:-2 align:center
It also allows you to reuse
heap memory between allocations,


385
00:21:20,080 --> 00:21:23,250 line:-1
avoiding expensive buffer allocations.


386
00:21:23,283 --> 00:21:27,054 line:-2
Heaps can also help improve performance
by reducing calls


387
00:21:27,087 --> 00:21:31,525 line:-2
to the useResource: method when using
instance acceleration structures.


388
00:21:31,558 --> 00:21:33,794 align:center
Going back to the example scene,


389
00:21:33,827 --> 00:21:36,430 line:0
the instance acceleration structure
references


390
00:21:36,463 --> 00:21:39,132 line:0
primitive acceleration structures
indirectly.


391
00:21:39,166 --> 00:21:42,870 align:center
This means that each time you want to use
an instance acceleration structure


392
00:21:42,903 --> 00:21:46,507 line:0
with a command encoder,
you need to call useResource: method


393
00:21:46,540 --> 00:21:49,243 line:0
for each primitive acceleration structure.


394
00:21:49,276 --> 00:21:52,346 align:center
For large scenes,
this could require thousands of calls


395
00:21:52,379 --> 00:21:56,116 line:0
to useResource: each time you use
the instance acceleration structure.


396
00:21:56,149 --> 00:21:58,852 line:0
Knowing that you have
so many useResource: calls,


397
00:21:58,886 --> 00:22:02,656 line:0
you could call useResources:
to reduce the number of API calls,


398
00:22:02,689 --> 00:22:06,260 line:0
but you still need to maintain
an array of your acceleration structures


399
00:22:06,293 --> 00:22:09,062 line:0
and Metal still needs to loop
through the array.


400
00:22:09,096 --> 00:22:11,064 align:center
Instead, you can allocate


401
00:22:11,098 --> 00:22:14,668 line:0
all of these primitive acceleration
structures from the same heap.


402
00:22:14,701 --> 00:22:17,704 line:0
When you want to use
the instance acceleration structure,


403
00:22:17,738 --> 00:22:20,874 align:center
you can simply make a single call
to the useHeap: method


404
00:22:20,908 --> 00:22:24,077 line:0
to reference all
of the primitive acceleration structures.


405
00:22:24,111 --> 00:22:27,147 align:center
We saw a small performance improvement
in one application


406
00:22:27,181 --> 00:22:29,816 line:0
simply by replacing the calls
to useResource:


407
00:22:29,850 --> 00:22:32,186 line:0
with a single call to useHeap:.


408
00:22:32,219 --> 00:22:35,455 line:0
Let's see how you can allocate
an acceleration structure from a heap.


409
00:22:35,489 --> 00:22:39,793 line:0
You can directly allocate an acceleration
structure by calling a method on the heap


410
00:22:39,826 --> 00:22:43,197 line:0
that takes the acceleration structure
descriptor as the input.


411
00:22:43,230 --> 00:22:46,066 line:0
If you are not allocating
using the descriptor,


412
00:22:46,099 --> 00:22:49,703 align:center
the Metal device determines
the size and alignment requirement


413
00:22:49,736 --> 00:22:52,606 align:center
for allocating
the acceleration structure from a heap.


414
00:22:52,639 --> 00:22:55,309 align:center
You can get this information
from the Metal device


415
00:22:55,342 --> 00:22:59,012 line:0
by providing the descriptor
or acceleration structure size.


416
00:22:59,046 --> 00:23:01,148 align:center
Once the final size is determined,


417
00:23:01,181 --> 00:23:04,351 line:0
you can allocate the acceleration
structure from the heap.


418
00:23:04,384 --> 00:23:07,621 line:-2
There are a few things to remember
when using heaps.


419
00:23:07,654 --> 00:23:12,025 line:-2
First, remember to call useHeap:
to make all of the acceleration structures


420
00:23:12.059 --> 00:23:15.596 line:-2 align:center
in the heap resident
for the duration of the ray tracing pass.


421
00:23:15.629 --> 00:23:20.734 line:-2 align:center
Second, by default, Metal doesn't track
resources you allocate from a heap.


422
00:23:20,767 --> 00:23:23,570 line:-2
You can either opt-in
to resource hazard tracking,


423
00:23:23.604 --> 00:23:27.407 line:-2 align:center
or you can manually manage
your own synchronization.


424
00:23:27.441 --> 00:23:31.512 line:-2 align:center
You can use MTLFences to synchronize
across command encoders


425
00:23:31,545 --> 00:23:35,215 line:-2
and MTLEvents to synchronize
across command buffers.


426
00:23:35.249 --> 00:23:38.352 line:-2 align:center
Those are the new features
and performance improvements


427
00:23:38,385 --> 00:23:40,921 line:-1
in the Metal ray tracing API this year.


428
00:23:40.954 --> 00:23:43.991 line:-1 align:center
Next, Dominik will talk about improvements


429
00:23:44,024 --> 00:23:47,294 line:-2
to Xcode's Metal tools
that will boost your productivity


430
00:23:47.327 --> 00:23:49.196 line:-1 align:center
when developing ray tracing applications.


431
00:23:49,229 --> 00:23:50,964 line:-1
Dominik: Thanks, Yi.


432
00:23:50.998 --> 00:23:54.401 line:-2 align:center
There are a lot of enhancements
to the Metal tools in Xcode 14,


433
00:23:54.434 --> 00:23:57.104 line:-2 align:center
but here, I would like to highlight
just a few


434
00:23:57.137 --> 00:24:00.674 line:-2 align:center
that are especially useful
when developing ray tracing applications


435
00:24:01.642 --> 00:24:04.678 line:-2 align:center
Starting with the Metal debugger,
I'll talk about improvements


436
00:24:04.711 --> 00:24:09.583 line:-2 align:center
to the Acceleration Structure Viewer,
Shader Profiler, and Shader Debugger.


437
00:24:10.551 --> 00:24:14.388 line:-2 align:center
Then I'll round it up
with the runtime Shader Validation.


438
00:24:16.523 --> 00:24:21.161 line:-2 align:center
First, let's take a look
at the Acceleration Structure Viewer.


439
00:24:21.195 --> 00:24:25.999 line:-2 align:center
The Acceleration Structure Viewer in
the Metal Debugger enables you to inspect,


440
00:24:26.033 --> 00:24:29.169 line:-2 align:center
in great detail,
all of the geometries and instances


441
00:24:29.203 --> 00:24:32.573 line:-2 align:center
of all the meshes that make up
your acceleration structure.


442
00:24:34.141 --> 00:24:37.744 line:-2 align:center
Xcode 14 now supports
debugging acceleration structures


443
00:24:37,778 --> 00:24:41,982 line:-2
with primitive or instanced motion
and a new highlight mode


444
00:24:42.015 --> 00:24:46.954 line:-2 align:center
for visualizing primitives
with an inspector for per-primitive data.


445
00:24:46,987 --> 00:24:48,722 line:-1
Let's see them in action.


446
00:24:49,523 --> 00:24:52,593 align:center
If you are using
acceleration structures with motion,


447
00:24:52,626 --> 00:24:55,095 align:center
you now have a scrubber in the bottom bar


448
00:24:55,128 --> 00:24:58,899 align:center
for viewing your acceleration structure
at different points in time.


449
00:24:58,932 --> 00:25:02,135 align:center
On the right of the scrubber
is a "play" button.


450
00:25:02,169 --> 00:25:05,339 align:center
You can use it to play the animation
back and forth in a loop.


451
00:25:05,372 --> 00:25:08,976 line:-2
Now let me show you
how to inspect individual primitives


452
00:25:09.009 --> 00:25:11.144 line:-1 align:center
in your acceleration structure.


453
00:25:11,178 --> 00:25:15,516 line:-2
This is especially useful if you are
using the new per-primitive data API.


454
00:25:15,549 --> 00:25:19,853 align:center
And so there's a new highlight mode
just for this.


455
00:25:19,887 --> 00:25:23,790 align:center
Primitive highlight mode gives you access
to all primitive data...


456
00:25:25,292 --> 00:25:29,296 line:0
And allows you to select specific
primitives for detailed inspection.


457
00:25:30,631 --> 00:25:34,468 line:0
In the left sidebar,
you can find arrows next to the data rows.


458
00:25:35,736 --> 00:25:38,438 align:center
Clicking on an arrow will reveal a popover


459
00:25:38,472 --> 00:25:41,308 align:center
that displays the corresponding data
for the primitive.


460
00:25:41.341 --> 00:25:44.178 line:-2 align:center
These additions
to the acceleration structure viewer


461
00:25:44,211 --> 00:25:47,581 line:-2
ensure you have full access,
down to each primitive,


462
00:25:47.614 --> 00:25:51.952 line:-2 align:center
to all of the components
that make up your acceleration structure.


463
00:25:51.985 --> 00:25:55.522 line:-2 align:center
Next, let's talk about improvements
to the Shader Profiler.


464
00:25:55,556 --> 00:26:00,160 line:-2
The Shader Profiler gives you insights
into the performance of your shader,


465
00:26:00,194 --> 00:26:03,297 line:-2
providing per-pipeline
execution timing costs,


466
00:26:03.330 --> 00:26:07.968 line:-2 align:center
and on Apple GPUs, it provides
more granularity at the source level,


467
00:26:08.001 --> 00:26:13.240 line:-2 align:center
showing the execution costs per-line
distributed across instruction categories.


468
00:26:13,273 --> 00:26:17,477 line:-2
In Xcode 14,
profiling GPU captures has been updated


469
00:26:17.511 --> 00:26:22.516 line:-2 align:center
to support intersection functions,
visible functions, and dynamic libraries.


470
00:26:23,884 --> 00:26:28,388 align:center
Here we have a ray tracing kernel
using an intersection function.


471
00:26:28,422 --> 00:26:31,091 align:center
You can now view
the per-line profiling results


472
00:26:31,124 --> 00:26:33,861 align:center
inside of the intersection function.


473
00:26:33.894 --> 00:26:36.496 line:-2 align:center
This includes a breakdown
of the instruction categories


474
00:26:36.530 --> 00:26:38.365 line:-1 align:center
that contribute to the cost.


475
00:26:41.969 --> 00:26:45.005 line:-2 align:center
Profiling visible functions
works the same way.


476
00:26:46.306 --> 00:26:49.409 line:-2 align:center
And similarly,
detailed profiling information


477
00:26:49,443 --> 00:26:53,180 line:-2
is now available for shader code
from linked dynamic libraries.


478
00:26:53,213 --> 00:26:56,283 line:-2
With these additions,
you now have the full breakdown


479
00:26:56.316 --> 00:26:59.953 line:-2 align:center
of the performance of your pipeline,
down to each line of code.


480
00:27:02.122 --> 00:27:04.024 line:-1 align:center
Moving on to the Shader Debugger.


481
00:27:04,057 --> 00:27:05,158 line:-1
The Shader Debugger provides


482
00:27:05.192 --> 00:27:07.528 line:-2 align:center
a unique
and incredibly productive workflow


483
00:27:07,561 --> 00:27:10,397 line:-2
for debugging the correctness
of your shader code.


484
00:27:10.430 --> 00:27:13.634 line:-2 align:center
Just like with the Shader Profiler,
we've also extended support


485
00:27:13,667 --> 00:27:17,271 line:-2
to enable debugging of Linked functions
and Dynamic libraries.


486
00:27:17.304 --> 00:27:19.806 line:-2 align:center
Here we have a ray tracing kernel
that calls out


487
00:27:19,840 --> 00:27:24,011 line:-2
to a linked visible function passed in
through a visible function table.


488
00:27:27.247 --> 00:27:30.250 line:-2 align:center
You are now able to follow
the execution of a kernel


489
00:27:30,284 --> 00:27:32,920 line:-2
all the way
into your visible function code


490
00:27:32,953 --> 00:27:36,123 line:-2
to verify that the code behaves
as you expect it to.


491
00:27:37.257 --> 00:27:41.195 line:-2 align:center
Again, the same applies
to debugging dynamic libraries.


492
00:27:41.228 --> 00:27:45.265 line:-2 align:center
You are also able to jump into
and out of any executed dynamic libraries


493
00:27:45.299 --> 00:27:47.134 line:-1 align:center
that are linked to your pipeline.


494
00:27:47.167 --> 00:27:48.802 line:-1 align:center
With these additions, you now have


495
00:27:48,836 --> 00:27:51,104 line:-2
a complete picture
of your shader execution


496
00:27:51.138 --> 00:27:54.141 line:-2 align:center
across linked functions
and libraries in your pipeline.


497
00:27:55.943 --> 00:27:59.379 line:-2 align:center
Now, before you capture
and jump into the Shader Debugger,


498
00:27:59,413 --> 00:28:03,050 line:-2
it is often a good idea to enable
Shader Validation at runtime.


499
00:28:05.686 --> 00:28:10.324 line:-2 align:center
Shader validation is a great way
to diagnose runtime errors on the GPU,


500
00:28:10.357 --> 00:28:14.027 line:-2 align:center
catching issues
such as out-of-bound memory accesses,


501
00:28:14.061 --> 00:28:16.463 line:-1 align:center
null texture reads, and more.


502
00:28:16,496 --> 00:28:20,534 line:-2
To enable Shader Validation in Xcode,
all you need to do is to go


503
00:28:20.567 --> 00:28:24.037 line:-2 align:center
to the "Edit Scheme" dialog,
select the "Run" action,


504
00:28:24.071 --> 00:28:28.775 line:-2 align:center
and under the "diagnostics" tab
tick the "Shader Validation" checkbox.


505
00:28:28.809 --> 00:28:31.044 line:-1 align:center
And you are all set to go.


506
00:28:31,078 --> 00:28:34,748 line:-2
In Metal 3, we have added
Stack Overflow detection


507
00:28:34.781 --> 00:28:36.350 line:-1 align:center
which will help you quickly find issues


508
00:28:36.383 --> 00:28:40.220 line:-2 align:center
that would otherwise result
in undefined behavior.


509
00:28:40.254 --> 00:28:43.524 line:-2 align:center
I'll quickly elaborate
on the function stack in Metal shaders


510
00:28:43,557 --> 00:28:45,726 line:-1
and the problem of Stack Overflow.


511
00:28:45,759 --> 00:28:48,795 line:-2
The call stack is a region
in device memory


512
00:28:48,829 --> 00:28:53,267 line:-2
where Metal stores the values of local
data used in your shader functions.


513
00:28:53,300 --> 00:28:56,103 line:-2
If the called function is
not known at compile time,


514
00:28:56.136 --> 00:28:58.405 line:-1 align:center
Metal needs your help in estimating


515
00:28:58.438 --> 00:29:01.642 line:-2 align:center
the amount of memory required
for the stack.


516
00:29:01,675 --> 00:29:05,345 line:-2
An example of a call to a function
that is unknown at compile time


517
00:29:05.379 --> 00:29:08.448 line:-2 align:center
may be a ray tracing
intersection function.


518
00:29:08.482 --> 00:29:11.051 line:-2 align:center
If you are using
custom intersection functions,


519
00:29:11.084 --> 00:29:16.123 line:-2 align:center
maximum call stack depth should be
set to 1, to allocate space for it.


520
00:29:16.156 --> 00:29:19.826 line:-2 align:center
This is the default value, so there is
nothing more that you need to do.


521
00:29:19,860 --> 00:29:24,231 line:-2
However, if you are using Function Tables
to call into a Visible function,


522
00:29:24,264 --> 00:29:28,302 line:-2
this is another example of a function call
unknown at compile time.


523
00:29:28,335 --> 00:29:31,038 line:-2
If you perform such a call
from an intersection function,


524
00:29:31.071 --> 00:29:34.708 line:-2 align:center
like in this example,
your call stack will be two levels deep.


525
00:29:36,376 --> 00:29:39,813 line:-2
Another example are calls
to dynamic libraries


526
00:29:39.847 --> 00:29:43.250 line:-2 align:center
and calling a local function
using a function pointer.


527
00:29:43.283 --> 00:29:47.020 line:-2 align:center
In this example, our call stack has
four levels with nested calls


528
00:29:47.054 --> 00:29:48.789 line:-1 align:center
to different types of functions


529
00:29:48,822 --> 00:29:51,625 line:-2
that cannot be resolved
when the shader is compiled.


530
00:29:51,658 --> 00:29:55,095 line:-2
To properly configure Metal
to allocate the right amount of memory,


531
00:29:55,128 --> 00:29:59,633 align:center
you need to specify a maximum
call stack depth of 4 yourself.


532
00:29:59,666 --> 00:30:02,469 align:center
The important thing to remember
is that when the value


533
00:30:02,503 --> 00:30:05,772 line:0
of the max Call Stack Depth is set
too low for your program,


534
00:30:05,806 --> 00:30:09,843 line:0
Stack Overflow can happen,
resulting in undefined behavior.


535
00:30:09,877 --> 00:30:13,313 line:0
But if you are running
with Shader Validation enabled,


536
00:30:13,347 --> 00:30:15,582 align:center
such situations will be caught early,


537
00:30:15,616 --> 00:30:20,254 align:center
and you will see information in Xcode
about where the Stack Overflow occurred.


538
00:30:20,287 --> 00:30:22,856 align:center
You can then go and fix your shader code,


539
00:30:22,890 --> 00:30:26,560 line:0
or adjust your maximum call stack depth
in the pipeline descriptor.


540
00:30:26.593 --> 00:30:30.297 line:-2 align:center
All of these new improvements
to the Metal tools in Xcode 14


541
00:30:30,330 --> 00:30:33,133 line:-2
ensure you have an even more
complete picture and insight


542
00:30:33.166 --> 00:30:37.304 line:-2 align:center
into the performance and correctness
of your ray tracing applications.


543
00:30:37,337 --> 00:30:40,340 line:0
For more on how to get the most
out of the Metal tools for debugging


544
00:30:40,374 --> 00:30:43,243 line:0
and profiling,
check out these other sessions


545
00:30:45,412 --> 00:30:48,782 line:-2
This session has been all about
maximizing Metal ray tracing performance


546
00:30:48,815 --> 00:30:50,284 line:-1
for your applications.


547
00:30:50,317 --> 00:30:52,953 line:-2
We talked about
how you can squeeze out more performance


548
00:30:52.986 --> 00:30:57.558 line:-2 align:center
and simplify your code using new features
such as per-primitive data.


549
00:30:57,591 --> 00:31:00,627 line:-2
We also described
optimization techniques and features


550
00:31:00,661 --> 00:31:04,097 line:-2
that make building accelerations
structures faster and more convenient


551
00:31:04,131 --> 00:31:05,832 line:-1
than ever before.


552
00:31:05,866 --> 00:31:09,236 line:-2
Finally, we covered all the new
enhancements to the Metal tools


553
00:31:09.269 --> 00:31:11.405 line:-1 align:center
in Xcode 14 that will provide you


554
00:31:11.438 --> 00:31:14.107 line:-2 align:center
with deeper insight
during your development.


555
00:31:14.141 --> 00:31:15.809 line:-1 align:center
Thanks for watching.

