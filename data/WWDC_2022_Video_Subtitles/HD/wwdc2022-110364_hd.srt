2
00:00:00.501 --> 00:00:08.509 line:-1 align:center
♪ ♪


3
00:00:09,309 --> 00:00:12,579 line:-2
Hello, and welcome to WWDC 2022.


4
00:00:12.613 --> 00:00:15.749 line:-2 align:center
My name is Ben, and I'm an engineer
on the Xcode build system team.


5
00:00:15,782 --> 00:00:19,152 line:-2
Hi, my name is Artem, and I'm
an engineer on the Swift Compiler team.


6
00:00:19.186 --> 00:00:22.489 line:-2 align:center
In this talk we're gonna give you
a deep dive into Xcode's build process


7
00:00:22.523 --> 00:00:25.959 line:-2 align:center
to demystify parallelization
inside builds.


8
00:00:25.993 --> 00:00:29.062 line:-2 align:center
Ben is going to start with an introduction
of the core concepts about builds


9
00:00:29.096 --> 00:00:31.565 line:-2 align:center
and look at the available tools
that Xcode offers


10
00:00:31,598 --> 00:00:34,301 line:-2
to help investigate
build performance issues.


11
00:00:34,334 --> 00:00:39,006 line:-2
He will then explain how Xcode increases
parallelization while building a target.


12
00:00:39.039 --> 00:00:40.240 line:-1 align:center
Building on top of that,


13
00:00:40.274 --> 00:00:43.610 line:-2 align:center
I will explain how Xcode
parallelizes a build holistically


14
00:00:43.644 --> 00:00:46.280 line:-2 align:center
while building projects
consisting of many targets


15
00:00:46,313 --> 00:00:48,415 line:-1
and summarize the takeaways in the end.


16
00:00:48,448 --> 00:00:50,551 line:-1
Ben?


17
00:00:50,584 --> 00:00:55,355 line:-2
Let's re-iterate on what happens when
pressing CMD+B in Xcode to build an app.


18
00:00:55,389 --> 00:00:57,691 line:-1
The build system, as part of Xcode,


19
00:00:57,724 --> 00:01:00,661 line:-2
gets invoked with a representation
of the whole project,


20
00:01:00,694 --> 00:01:02,996 line:-1
including all source files, assets,


21
00:01:03,030 --> 00:01:07,267 line:-2
build settings, and other configurations
like the run destination.


22
00:01:07.301 --> 00:01:11.205 line:-2 align:center
The build system is the single source
of truth about how an app should be built.


23
00:01:11,238 --> 00:01:14,141 line:-2
It knows which tools to invoke
using which settings


24
00:01:14,174 --> 00:01:18,078 line:-2
and which intermediate files to produce
to eventually create an app.


25
00:01:18.111 --> 00:01:20.881 line:-2 align:center
In the next step,
the build system invokes the tools


26
00:01:20,914 --> 00:01:24,852 line:-2
to process the project's input files,
for example, the compilers.


27
00:01:26.253 --> 00:01:29.857 line:-2 align:center
Both compilers, Clang and Swift,
will produce object files


28
00:01:29,890 --> 00:01:32,693 line:-2
that the linker needs
to link the executable program


29
00:01:32.726 --> 00:01:34.728 line:-1 align:center
that represents the app.


30
00:01:34,761 --> 00:01:37,831 line:-2
While this order makes sense,
it's not obvious where it comes from.


31
00:01:37.865 --> 00:01:40.133 line:-2 align:center
So let's take a look
at one example of that process


32
00:01:40,167 --> 00:01:44,238 line:-2
and how the build system decides
in which order to execute all tasks.


33
00:01:46,273 --> 00:01:49,343 line:-2
Using the input source-files,
the Swift compiler captures


34
00:01:49.376 --> 00:01:53.113 line:-2 align:center
the programmer's intent and translates it
into a machine-executable binary,


35
00:01:53,146 --> 00:01:55,949 line:-2
checking the source code
for errors along the way.


36
00:01:55.983 --> 00:01:58.418 line:-2 align:center
This process can fail,
which would cancel the build,


37
00:01:58,452 --> 00:02:02,789 line:-2
but if it succeeds,
it creates an object file for each input.


38
00:02:02.823 --> 00:02:05.592 line:-2 align:center
Those object files are used
to invoke the linker


39
00:02:05.626 --> 00:02:08.862 line:-2 align:center
which combines them and adds references
to externally linked libraries


40
00:02:08,896 --> 00:02:11,265 line:-1
to produce the executable.


41
00:02:11,298 --> 00:02:15,002 line:-2
The two tasks have a dependency
based on what they consume and produce.


42
00:02:15,035 --> 00:02:19,840 line:-2
The object files produced by the compiler
get consumed by the linker.


43
00:02:19.873 --> 00:02:22.676 line:-2 align:center
This creates a dependency
on the build system graph.


44
00:02:22,709 --> 00:02:25,879 line:-2
The file contents itself
are not of interest to the build system,


45
00:02:25,913 --> 00:02:28,749 line:-1
but the dependency between the tasks is.


46
00:02:28.782 --> 00:02:30.784 line:-2 align:center
While executing the build,
it needs to make sure


47
00:02:30.817 --> 00:02:35.923 line:-2 align:center
that a task that produces another task's
input finishes before said task can start.


48
00:02:35,956 --> 00:02:39,159 line:-2
And since this core concept
is valid for all kind of tasks,


49
00:02:39.193 --> 00:02:41.328 line:-2 align:center
let's switch to
a more generic visualization


50
00:02:41,361 --> 00:02:44,498 line:-2
that shows a dependency
between Task A and Task B.


51
00:02:44.531 --> 00:02:48.635 line:-2 align:center
In this case,
A produces some or all of B's inputs.


52
00:02:49.937 --> 00:02:53.106 line:-2 align:center
Compiling and Linking are only
a few of many different task types


53
00:02:53,140 --> 00:02:56,043 line:-2
that need to be executed
to build a whole target,


54
00:02:56,076 --> 00:02:58,145 line:-2
so let's add some more generic tasks
to the graph


55
00:02:58,178 --> 00:03:00,914 line:-2
that represent other types
like compiling assets,


56
00:03:00.948 --> 00:03:03.650 line:-1 align:center
copying files or codesigning.


57
00:03:03.684 --> 00:03:07.454 line:-2 align:center
Together, they represent
building a Framework target.


58
00:03:07,487 --> 00:03:10,224 line:-2
Again,
those tasks have defined dependencies


59
00:03:10,257 --> 00:03:12,426 line:-1
based on their inputs and outputs.


60
00:03:12.459 --> 00:03:16.897 line:-2 align:center
So completing executing task A
unblocks running task B and C,


61
00:03:16,930 --> 00:03:21,168 line:-2
while finishing task B
unblocks task D and E.


62
00:03:21.201 --> 00:03:24.204 line:-2 align:center
Tasks that get unblocked
are called 'downstream'


63
00:03:24.238 --> 00:03:27.274 line:-1 align:center
and tasks that block 'upstream'.


64
00:03:27,307 --> 00:03:30,143 line:-2
Many projects contain
more than one framework target,


65
00:03:30.177 --> 00:03:34.481 line:-2 align:center
so let's add two more targets representing
an app and an app extension.


66
00:03:34.515 --> 00:03:37.551 line:-2 align:center
Targets define dependencies
between each other in the project


67
00:03:37,584 --> 00:03:39,820 line:-1
via explicit or implicit dependencies.


68
00:03:39,853 --> 00:03:44,157 line:-2
For example, by getting added to the
'Link Binary with Libraries' build phase.


69
00:03:45.993 --> 00:03:48.662 line:-2 align:center
In this case,
the app embeds the app extension


70
00:03:48.695 --> 00:03:50.631 line:-1 align:center
and links against the Framework.


71
00:03:50,664 --> 00:03:52,900 line:-2
The app extension
is not using the Framework,


72
00:03:52.933 --> 00:03:55.068 line:-2 align:center
so they don't have
a dependency relationship.


73
00:03:56.470 --> 00:04:00.741 line:-2 align:center
When executing the build graph, different
tasks take a different amount of time.


74
00:04:00,774 --> 00:04:05,045 line:-2
This comes down to the level of complexity
that is necessary to complete the work,


75
00:04:05.078 --> 00:04:10.517 line:-2 align:center
depending on the computation that's needed
as well as the size of the input.


76
00:04:10,551 --> 00:04:15,389 line:-2
Compiling many files takes usually much
more time than copying a few header files,


77
00:04:15,422 --> 00:04:19,526 line:-2
and taking this into consideration
will end up with something like this.


78
00:04:19.560 --> 00:04:21.762 line:-1 align:center
When the build system executes this build,


79
00:04:21,795 --> 00:04:25,432 line:-2
it starts by running tasks
that don't have dependencies.


80
00:04:25,465 --> 00:04:29,570 line:-2
And once those completed,
they unblock downstream tasks and so on,


81
00:04:29.603 --> 00:04:32.906 line:-2 align:center
following this process
until all planned tasks finished.


82
00:04:35.142 --> 00:04:38.312 line:-2 align:center
On following builds,
the build system is able to skip tasks


83
00:04:38,345 --> 00:04:43,050 line:-2
for which inputs haven't changed
while the output is still up to date.


84
00:04:43,083 --> 00:04:46,019 line:-2
If a task needs to re-run
due to a changed input,


85
00:04:46.053 --> 00:04:48.355 line:-1 align:center
like B of the App target in this case,


86
00:04:48,388 --> 00:04:52,159 line:-2
downstream tasks have to re-run too
if its output changed.


87
00:04:52.192 --> 00:04:55.762 line:-2 align:center
Skipping all other tasks allows
for very fast turnaround times


88
00:04:55,796 --> 00:04:58,432 line:-1
when iteratively working on the project.


89
00:04:58,465 --> 00:05:02,035 line:-2
This is called an incremental build,
but let's stick to full builds for now.


90
00:05:03.704 --> 00:05:06.640 line:-2 align:center
The dependencies and duration
of the task execution


91
00:05:06.673 --> 00:05:10.177 line:-2 align:center
defines the first possible time
a downstream task can start.


92
00:05:10,210 --> 00:05:13,480 line:-2
With this information it's possible
to calculate the critical path


93
00:05:13,514 --> 00:05:16,049 line:-2
which is the shortest time
the build needs to run


94
00:05:16.083 --> 00:05:18.952 line:-1 align:center
with theoretical unlimited resources.


95
00:05:18,986 --> 00:05:22,456 line:-2
A common pattern throughout this talk
will be to shorten this path


96
00:05:22,489 --> 00:05:25,826 line:-2
to create a highly parallelizable
and scalable build graph.


97
00:05:25.859 --> 00:05:29.263 line:-2 align:center
A shorter critical path
does not necessarily result


98
00:05:29,296 --> 00:05:30,931 line:-1
in a shorter overall build time,


99
00:05:30,964 --> 00:05:34,268 line:-2
but it ensures that the build scales
with the hardware.


100
00:05:34,301 --> 00:05:36,870 line:-2
The critical build path
defines the limiting factor


101
00:05:36.904 --> 00:05:38.772 line:-1 align:center
of how fast a build can be–


102
00:05:38.805 --> 00:05:43.310 line:-2 align:center
it cannot complete faster,
even if the hardware would allow it.


103
00:05:43,343 --> 00:05:47,881 line:-2
Shortening the critical path is done by
breaking up dependencies within it.


104
00:05:47,915 --> 00:05:51,652 line:-2
When looking at how a build performed and
to understand more about its execution,


105
00:05:51.685 --> 00:05:55.589 line:-2 align:center
the data needs to be plotted
based on the time they executed.


106
00:05:55.622 --> 00:05:58.492 line:-2 align:center
The width still indicates
the length of tasks.


107
00:05:58,525 --> 00:06:01,929 line:-2
Wide elements like these two
indicate a long running task


108
00:06:01,962 --> 00:06:05,899 line:-2
while narrow elements like these
represent fast finishing tasks.


109
00:06:07,534 --> 00:06:11,004 line:-2
The height of the graph shows the number
of parallel executing tasks


110
00:06:11,038 --> 00:06:12,439 line:-1
at a given time.


111
00:06:12.472 --> 00:06:17.144 line:-2 align:center
Be aware that this does not directly map
to CPU or memory utilization.


112
00:06:18,512 --> 00:06:22,082 line:-2
Empty space originates by tasks blocking
its downstream tasks


113
00:06:22,115 --> 00:06:24,451 line:-1
like in those two scenarios.


114
00:06:24,484 --> 00:06:29,423 line:-2
And finally, the color of the elements
represent their associated target.


115
00:06:29,456 --> 00:06:33,527 line:-2
I'm very excited to announce that
this visualization is new in Xcode 14


116
00:06:33,560 --> 00:06:37,297 line:-2
and will help understand
a build's performance after it finished.


117
00:06:37,331 --> 00:06:40,367 line:-2
The Xcode Build Timeline is
a great new addition to the build log.


118
00:06:40.400 --> 00:06:42.736 line:-2 align:center
It visualizes based on
parallelization,


119
00:06:42,769 --> 00:06:46,139 line:-2
rather than hierarchy
to understand the build's performance.


120
00:06:46.173 --> 00:06:49.910 line:-2 align:center
The number of rows at given time
represents the level of parallelism


121
00:06:49,943 --> 00:06:51,411 line:-1
during that time.


122
00:06:51,445 --> 00:06:54,248 line:-1
The horizontal length of individual tasks


123
00:06:54.281 --> 00:06:57.584 line:-2 align:center
represent the duration they needed
to finish their work.


124
00:06:57.618 --> 00:07:00.387 line:-2 align:center
Empty space in the graph
shows where unfinished tasks


125
00:07:00.420 --> 00:07:04.057 line:-2 align:center
blocked downstream tasks
from starting to execute.


126
00:07:04,091 --> 00:07:06,560 line:-2
Different colors applied
to the timeline elements


127
00:07:06.593 --> 00:07:10.531 line:-2 align:center
help distinguish the different targets
that were part of the build.


128
00:07:10,564 --> 00:07:13,800 line:-2
And on incremental builds,
the timeline will only contain tasks


129
00:07:13.834 --> 00:07:15.903 line:-1 align:center
that got actually executed,


130
00:07:15.936 --> 00:07:17.738 line:-1 align:center
allowing to spot long-running tasks,


131
00:07:17.771 --> 00:07:21.842 line:-2 align:center
especially ones which might not have
been expected to run during this build.


132
00:07:22.843 --> 00:07:25.712 line:-2 align:center
Here's a demo of the Build Timeline
in Xcode 14.


133
00:07:25.746 --> 00:07:29.550 line:-2 align:center
In this window I opened a copy
of the swift-docc project from Github


134
00:07:29.583 --> 00:07:31.785 line:-1 align:center
which builds the documentation compiler.


135
00:07:31,818 --> 00:07:34,655 line:-2
To get an overview about the targets
that are built for the scheme,


136
00:07:34,688 --> 00:07:36,590 line:-1
let's check out the scheme editor.


137
00:07:36,623 --> 00:07:39,426 line:-2
To open that I click on the scheme
and select "Edit scheme".


138
00:07:40.427 --> 00:07:43.197 line:-2 align:center
The 'build' tab contains a list
of all targets.


139
00:07:43.230 --> 00:07:45.632 line:-2 align:center
Targets can explicitly get added
to the scheme


140
00:07:45,666 --> 00:07:48,268 line:-2
or implicitly
by being a dependency of a target


141
00:07:48.302 --> 00:07:50.270 line:-1 align:center
that is already part of the scheme.


142
00:07:50.304 --> 00:07:54.007 line:-2 align:center
In this case I'm using a Swift package
with an automatically generated scheme


143
00:07:54.041 --> 00:07:58.612 line:-2 align:center
for the package, so all targets
from the manifest are explicitly defined.


144
00:08:00.881 --> 00:08:04.451 line:-2 align:center
This log represents a build of that scheme
that I executed earlier.


145
00:08:04,484 --> 00:08:08,188 line:-2
In contains entries for all tasks
that the build system executed.


146
00:08:08,222 --> 00:08:10,557 line:-1
The entries are organized in a hierarchy


147
00:08:10,591 --> 00:08:14,761 line:-2
based on the targets they belong to,
like the 'docc' target here.


148
00:08:14,795 --> 00:08:17,397 line:-2
To successfully build the executable
of that target,


149
00:08:17,431 --> 00:08:21,568 line:-2
Xcode ran all tasks that are represented
by the children of this node.


150
00:08:21,602 --> 00:08:23,904 line:-2
Since the build log is currently
in its 'All' state,


151
00:08:23.937 --> 00:08:26.073 line:-1 align:center
it also shows tasks from previous builds


152
00:08:26,106 --> 00:08:28,709 line:-2
that didn't need to re-run
in an incremental build.


153
00:08:28.742 --> 00:08:32.246 line:-2 align:center
Selecting 'Recent' only shows tasks
that got actually executed,


154
00:08:32,279 --> 00:08:34,848 line:-1
hiding all skipped tasks.


155
00:08:34.882 --> 00:08:37.718 line:-2 align:center
In addition to that,
the build log also supports filters


156
00:08:37.751 --> 00:08:40.754 line:-2 align:center
to only show tasks
that had issues or even failed.


157
00:08:43,924 --> 00:08:45,859 line:-1
To open the build timeline for this build,


158
00:08:45.893 --> 00:08:49.696 line:-2 align:center
I go to the editor options
and open the assistant.


159
00:08:49.730 --> 00:08:52.399 line:-2 align:center
The build timeline
opens next to the build log.


160
00:08:52,432 --> 00:08:55,736 line:-2
Like usual, the editor options
provide settings to show the assistant


161
00:08:55,769 --> 00:08:57,271 line:-1
on the right or bottom.


162
00:08:57,304 --> 00:08:59,473 line:-1
I'll stay with bottom for now.


163
00:08:59,506 --> 00:09:02,576 line:-2
The timeline visualizes the same data
as the 'recent' build log


164
00:09:02,609 --> 00:09:05,179 line:-1
based on the parallelization of the build.


165
00:09:05.212 --> 00:09:08.715 line:-2 align:center
Selecting an element in one
also selects it in the other.


166
00:09:08,749 --> 00:09:12,920 line:-2
This enables to see
a task's execution in context.


167
00:09:12.953 --> 00:09:15.088 line:-2 align:center
The timeline here gives a sense
about the tasks


168
00:09:15,122 --> 00:09:18,091 line:-2
that executed in parallel
to the selected task.


169
00:09:18.125 --> 00:09:21.662 line:-2 align:center
I'm using a pinch gesture
on the trackpad to zoom out again.


170
00:09:26.233 --> 00:09:30.470 line:-2 align:center
Selecting an element in the timeline
shows it in the build log.


171
00:09:30.504 --> 00:09:34.007 line:-2 align:center
And since the build log visualizes
based on the hierarchical structure,


172
00:09:34,041 --> 00:09:36,476 line:-2
it enables to view
which files were compiled


173
00:09:36,510 --> 00:09:38,579 line:-1
as part of this compiler invocation.


174
00:09:38.612 --> 00:09:42.482 line:-2 align:center
It also enables to view the whole
command line of that invocation.


175
00:09:46,954 --> 00:09:49,890 line:-2
Holding down Option while selecting
an area in the build timeline


176
00:09:49,923 --> 00:09:52,960 line:-2
adjusts the view port
to fit this timeframe.


177
00:09:52,993 --> 00:09:56,463 line:-2
Here we can verify
that linking of the target ArgumentParser


178
00:09:56.496 --> 00:09:59.499 line:-2 align:center
is in fact waiting for compilation
of the same target.


179
00:09:59.533 --> 00:10:03.504 line:-2 align:center
Holding Option while scrolling up
allows me to zoom out quickly.


180
00:10:03,537 --> 00:10:06,507 line:-2
The number of rows in the timeline
represents the number of tasks


181
00:10:06.540 --> 00:10:08.609 line:-1 align:center
that ran in parallel at that time.


182
00:10:08.642 --> 00:10:14.081 line:-2 align:center
An empty space like this indicates tasks
waiting for un-produced inputs.


183
00:10:14,114 --> 00:10:18,418 line:-2
Ideally, the timeline is vertically filled
and has as little empty space as possible.


184
00:10:18,452 --> 00:10:21,388 line:-2
This scales the build graph the best
and makes builds faster,


185
00:10:21.421 --> 00:10:23.123 line:-1 align:center
the faster the hardware.


186
00:10:23,156 --> 00:10:26,126 line:-2
To achieve this, Xcode comes with
many improvements this year


187
00:10:26.159 --> 00:10:28.695 line:-1 align:center
to shorten the critical path.


188
00:10:28,729 --> 00:10:32,633 line:-2
Next, let's check out how Xcode defines
and builds individual targets


189
00:10:32.666 --> 00:10:35.636 line:-2 align:center
as well as how
it can increase parallelization.


190
00:10:35,669 --> 00:10:38,639 line:-2
When configuring a target,
build phases describe the work


191
00:10:38.672 --> 00:10:41.808 line:-2 align:center
that needs to be done
to produce that target's product.


192
00:10:41,842 --> 00:10:45,312 line:-2
They are defined in the project editor
and can contain a set of source code files


193
00:10:45,345 --> 00:10:46,813 line:-1
and assets to compile,


194
00:10:46.847 --> 00:10:49.583 line:-2 align:center
files that need to be copied
like headers or resources,


195
00:10:49.616 --> 00:10:54.221 line:-2 align:center
as well as libraries that should be linked
or scripts that should be executed.


196
00:10:54.254 --> 00:10:57.090 line:-2 align:center
Many build phases describe
tasks with inputs or outputs


197
00:10:57,124 --> 00:11:00,260 line:-2
from other build phases,
creating dependencies between them.


198
00:11:00.294 --> 00:11:04.865 line:-2 align:center
For example, a target's source files
must be compiled before it is linked.


199
00:11:04.898 --> 00:11:08.602 line:-2 align:center
However,
this doesn't apply to all build phases.


200
00:11:08,635 --> 00:11:11,672 line:-2
Instead of running tasks from
each build phase in a linear order,


201
00:11:11,705 --> 00:11:15,042 line:-2
the build system will consider the inputs
and outputs of build phases


202
00:11:15,075 --> 00:11:17,744 line:-1
to determine if they can run in parallel.


203
00:11:17.778 --> 00:11:21.548 line:-2 align:center
For example, Compilation
and Resource copying can run in parallel


204
00:11:21,582 --> 00:11:24,785 line:-2
because neither depends
on any outputs of the other.


205
00:11:24,818 --> 00:11:27,654 line:-2
However,
linking must still follow compilation


206
00:11:27,688 --> 00:11:30,958 line:-2
because it depends on the object files
produced by that phase.


207
00:11:30,991 --> 00:11:35,028 line:-2
Now, let's consider a different target
which contains 'Run Script' build phases.


208
00:11:35,062 --> 00:11:38,732 line:-2
Unlike other build phases,
the inputs and outputs of script phases


209
00:11:38.765 --> 00:11:41.802 line:-2 align:center
must be manually configured
in the target editor.


210
00:11:41.835 --> 00:11:45.305 line:-2 align:center
As a result, the build system
will run consecutive script phases


211
00:11:45.339 --> 00:11:49.443 line:-2 align:center
one at a time to avoid introducing
a data race in the build process.


212
00:11:49,476 --> 00:11:51,445 line:-2
If the scripts in a target
are configured to run


213
00:11:51,478 --> 00:11:53,247 line:-1
based on dependency analysis


214
00:11:53,280 --> 00:11:55,983 line:-2
and specify their complete list
of inputs and outputs,


215
00:11:56.016 --> 00:11:58.285 line:-2 align:center
then the build setting
FUSE_BUILD_SCRIPT_PHASES


216
00:11:58,318 --> 00:11:59,553 line:-1
can be set to YES


217
00:11:59.586 --> 00:12:03.457 line:-2 align:center
to indicate the build system
should attempt to run them in parallel.


218
00:12:03,490 --> 00:12:06,293 line:-2
However,
when running script phases in parallel,


219
00:12:06,326 --> 00:12:09,897 line:-2
the build system has to rely
on the specified inputs and outputs.


220
00:12:09,930 --> 00:12:14,134 line:-2
So be aware that an incomplete list
of the inputs or outputs of a script phase


221
00:12:14,168 --> 00:12:17,437 line:-2
can lead to data races
which are very hard to debug.


222
00:12:17,471 --> 00:12:20,707 line:0
To mitigate this, Xcode supports
user script sandboxing


223
00:12:20,741 --> 00:12:24,044 line:0
to precisely declare the dependencies
of each script phase.


224
00:12:24,077 --> 00:12:27,114 line:0
Sandboxing is an opt-in feature
that blocks shell scripts


225
00:12:27,147 --> 00:12:30,617 line:0
from accidentally accessing source files
and intermediate build objects,


226
00:12:30,651 --> 00:12:35,122 line:0
unless those are explicitly declared
as an input or output for the phase.


227
00:12:35,155 --> 00:12:38,425 align:center
In this example,
neither input nor output.txt


228
00:12:38,458 --> 00:12:41,028 line:0
are declared as a dependency
for that script phase.


229
00:12:41,061 --> 00:12:43,630 line:0
The sandbox will block the script
from reading and writing


230
00:12:43,664 --> 00:12:46,867 align:center
to both files when building the project.


231
00:12:46,900 --> 00:12:48,702 align:center
When the script violates the sandbox,


232
00:12:48,735 --> 00:12:52,506 line:0
it will fail with a non-zero exit code
causing the build to fail.


233
00:12:52,539 --> 00:12:55,209 line:0
In addition to that,
Xcode will list all the paths


234
00:12:55,242 --> 00:13:00,180 line:0
that the script phase was trying to access
without properly declaring them.


235
00:13:00,214 --> 00:13:03,383 line:-2
Adding both files as dependency
information to this script phase


236
00:13:03,417 --> 00:13:04,885 line:-1
fixes this issue.


237
00:13:04.918 --> 00:13:08.188 line:-2 align:center
This way the sandbox ensures
that the script is not mistakenly


238
00:13:08.222 --> 00:13:12.426 line:-2 align:center
accessing any file other than
its declared inputs and outputs.


239
00:13:12.459 --> 00:13:15.562 line:-2 align:center
Now, let's explore an example
with more than one script phase


240
00:13:15.596 --> 00:13:19.766 line:-2 align:center
and see how sandboxing prevents
data races and incorrect builds.


241
00:13:19,800 --> 00:13:21,635 line:-1
There are two script phases.


242
00:13:21.668 --> 00:13:25.906 line:-2 align:center
The first one reads a text file,
calculates a checksum of its content,


243
00:13:25.939 --> 00:13:30.277 line:-2 align:center
and writes that value to an intermediate
file in DERIVED_FILE_DIR.


244
00:13:30,310 --> 00:13:32,813 line:-1
The other script reads the same text file


245
00:13:32.846 --> 00:13:34.648 line:-1 align:center
as well as the produced checksum


246
00:13:34,681 --> 00:13:38,819 line:-2
and injects them into an html file
for later display in the app.


247
00:13:38,852 --> 00:13:42,256 line:-2
If the precise set of input
and output dependencies for these phases


248
00:13:42,289 --> 00:13:45,792 line:-2
is not declared,
Xcode will run the two scripts in parallel


249
00:13:45,826 --> 00:13:48,495 line:-2
when FUSE_BUILD_SCRIPT_PHASES
is on.


250
00:13:48,529 --> 00:13:51,765 line:-2
Let's inspect this problematic scenario
in detail.


251
00:13:51,798 --> 00:13:55,369 line:-2
Let's assume "Generate HTML"
is missing the input declaration


252
00:13:55,402 --> 00:13:59,373 line:-2
of "checksum.txt", but all other inputs
and outputs of both scripts


253
00:13:59.406 --> 00:14:01.375 line:-1 align:center
have been correctly declared.


254
00:14:01,408 --> 00:14:04,878 line:-2
Without sandboxing, this misconfiguration
might stay unnoticed,


255
00:14:04,912 --> 00:14:07,514 line:-1
causing problems in the build.


256
00:14:07,548 --> 00:14:10,551 line:-2
It means Xcode will fail to infer
the dependency relation


257
00:14:10.584 --> 00:14:13.554 line:-2 align:center
between both phases,
and schedule to run them in parallel


258
00:14:13,587 --> 00:14:16,657 line:-2
when FUSE_BUILD_SCRIPT_PHASES
is switched on.


259
00:14:16.690 --> 00:14:18.225 line:-1 align:center
There are a few hazards here.


260
00:14:18,258 --> 00:14:23,297 line:-2
Since checksum.txt is not listed as an
input dependency for "Generate HTML"


261
00:14:23,330 --> 00:14:25,999 line:-2
during a clean build
the script will attempt to read the file


262
00:14:26.033 --> 00:14:29.036 line:-2 align:center
without it being available
on the filesystem.


263
00:14:29.069 --> 00:14:32.573 line:-2 align:center
The other hazard is if checksum.txt
is available on disk


264
00:14:32,606 --> 00:14:34,942 line:-2
because of previous runs
of "Calculate Checksum",


265
00:14:34,975 --> 00:14:37,744 line:-2
"Generate HTML"
may pick up the outdated file


266
00:14:37,778 --> 00:14:40,681 line:-1
when the two scripts run in parallel.


267
00:14:40,714 --> 00:14:43,550 line:0
This is a user error,
and executing the scripts in a sandbox


268
00:14:43,584 --> 00:14:45,652 line:0
helps preventing this issue.


269
00:14:45,686 --> 00:14:49,323 align:center
With sandboxing switched on,
"Generate HTML" will fail immediately


270
00:14:49,356 --> 00:14:51,658 align:center
when it attempts to read "checksum.txt".


271
00:14:51,692 --> 00:14:56,363 line:0
The error message will guide adding
the missing input for that build phase.


272
00:14:56.396 --> 00:14:58.699 line:-2 align:center
Having the inputs and outputs
correctly defined


273
00:14:58,732 --> 00:15:02,069 line:-2
guides Xcode to respect the dependency
relation between both phases


274
00:15:02,102 --> 00:15:05,706 line:-2
so that "calculate checksum"
runs before "Generate HTML".


275
00:15:05.739 --> 00:15:09.743 line:-2 align:center
While unrelated build phases
can still execute in parallel.


276
00:15:09,776 --> 00:15:12,079 line:-2
To enable Sandboxed Shell Scripts
for a target,


277
00:15:12.112 --> 00:15:15.649 line:-2 align:center
set ENABLE_USER_SCRIPT_SANDBOXING
to YES in the build settings editor


278
00:15:15.682 --> 00:15:17.918 line:-1 align:center
or an xcconfig file.


279
00:15:17,951 --> 00:15:22,122 line:-2
In summary, sandboxed shell scripts allow
having correct dependency information


280
00:15:22,155 --> 00:15:25,292 line:-2
to enable faster
and more robust incremental builds


281
00:15:25.325 --> 00:15:28.362 line:-2 align:center
since the build system has the confidence
to skip script phases


282
00:15:28.395 --> 00:15:31.365 line:-2 align:center
if the inputs haven't changed
and the outputs are still valid,


283
00:15:31.398 --> 00:15:34.134 line:-1 align:center
while re-running the script otherwise.


284
00:15:34.168 --> 00:15:37.704 line:-2 align:center
Enabling the build setting for
a script's target blocks access to files


285
00:15:37,738 --> 00:15:41,141 line:-2
inside the source root of the project
as well as the derived data directory


286
00:15:41,175 --> 00:15:44,678 line:-2
if they are not explicitly defined
as inputs or outputs of the script


287
00:15:44.711 --> 00:15:46.146 line:-1 align:center
in the project.


288
00:15:46,180 --> 00:15:49,750 line:-2
The sandbox will not prevent unauthorized
access to any other directory,


289
00:15:49.783 --> 00:15:52.953 line:-1 align:center
so don't consider this a security feature.


290
00:15:52,986 --> 00:15:55,722 line:-2
Using this feature helps to debug
missing inputs or outputs


291
00:15:55.756 --> 00:15:59.626 line:-2 align:center
of existing script phases
to ensure a valid configuration


292
00:15:59,660 --> 00:16:02,229 line:-2
And in combination with
the previously explained build setting


293
00:16:02,262 --> 00:16:03,897 line:-1
FUSE_BUILD_SCRIPT_PHASES,


294
00:16:03,931 --> 00:16:07,367 line:-2
script phases with correctly defined
dependency edges through sandboxing


295
00:16:07.401 --> 00:16:11.705 line:-2 align:center
can execute in parallel
to reduce the critical path of the build.


296
00:16:11,738 --> 00:16:14,808 line:-2
That's it for parallelizing
the steps of building a target.


297
00:16:14.842 --> 00:16:17.144 line:-2 align:center
Now Artem is going to
demystify parallelization


298
00:16:17,177 --> 00:16:18,812 line:-1
hen building many targets.


299
00:16:18.846 --> 00:16:20.214 line:-1 align:center
Artem: Thanks, Ben.


300
00:16:20.247 --> 00:16:22.649 line:-2 align:center
Now that we've covered the basics
of build system tasks


301
00:16:22.683 --> 00:16:25.452 line:-2 align:center
and phases that may go into building
a target in your project,


302
00:16:25,485 --> 00:16:27,054 line:-1
let's take a more global view


303
00:16:27,087 --> 00:16:30,424 line:-2
and explore how Xcode uses dependencies
between Swift targets


304
00:16:30,457 --> 00:16:33,493 line:-2
to extract the maximum amount
of parallelism out of your builds


305
00:16:33.527 --> 00:16:38.131 line:-2 align:center
and how the structure and organization
of your project can affect build times.


306
00:16:38,165 --> 00:16:41,602 line:-2
There are likely to be several levels
of hierarchy composing your project.


307
00:16:41.635 --> 00:16:45.172 line:-2 align:center
For example, an App target depending
on a collection of local libraries


308
00:16:45.205 --> 00:16:47.975 line:-2 align:center
broken up into targets
along semantic boundaries,


309
00:16:48.008 --> 00:16:49.943 line:-1 align:center
and in several frameworks.


310
00:16:49,977 --> 00:16:52,713 line:-2
Each target containing
many different build phases and steps,


311
00:16:52,746 --> 00:16:55,182 line:-1
producing and consuming file dependencies


312
00:16:55.215 --> 00:16:57.784 line:-1 align:center
to and from build phases in other targets.


313
00:16:57,818 --> 00:16:59,586 line:-1
As the size of your project grows,


314
00:16:59.620 --> 00:17:04.024 line:-2 align:center
these task graphs tend to increase in size
and complexity.


315
00:17:04,057 --> 00:17:06,360 line:-2
While the Xcode Build System
flattens these hierarchies,


316
00:17:06,393 --> 00:17:08,762 line:-2
breaking down the build
into a sea of tasks


317
00:17:08.795 --> 00:17:11.164 line:-2 align:center
that correspond to build phases
of all targets.


318
00:17:11,198 --> 00:17:15,769 line:-2
One kind of task that is special
for a Swift target is compilation.


319
00:17:15,802 --> 00:17:18,872 line:-2
Building a Swift target's source code
into binary product's


320
00:17:18,906 --> 00:17:22,409 line:-2
is a complex operation
that typically consists of many sub-tasks


321
00:17:22.442 --> 00:17:26.180 line:-2 align:center
for build planning,
compilation, and linking.


322
00:17:26,213 --> 00:17:29,216 line:-2
Coordination of these
tasks is delegated to a specialized tool


323
00:17:29.249 --> 00:17:32.152 line:-2 align:center
in the Xcode toolchain–
the Swift Driver.


324
00:17:32.186 --> 00:17:35.222 line:-2 align:center
The Driver has specialized knowledge
on when and how to construct


325
00:17:35,255 --> 00:17:39,092 line:-2
the required compiler and linker
invocations for the target's source code.


326
00:17:39.126 --> 00:17:41.328 line:-1 align:center
Any target that includes Swift code


327
00:17:41.361 --> 00:17:45.332 line:-2 align:center
also corresponds to a unit
of code distribution: a module.


328
00:17:45.365 --> 00:17:48.802 line:-2 align:center
A binary module file capturing
the public interface of this target


329
00:17:48.836 --> 00:17:52.873 line:-2 align:center
is a build product that is required for
downstream targets to begin a compilation.


330
00:17:52,906 --> 00:17:55,843 line:-2
Let's take a closer look at an example
of what Swift Driver does


331
00:17:55,876 --> 00:17:58,846 line:-1
to build one of the targets.


332
00:17:58.879 --> 00:18:02.249 line:-2 align:center
Your target probably consists of
a collection of several source files.


333
00:18:02,282 --> 00:18:05,919 line:-2
In release or optimized builds
the driver will schedule one compiler task


334
00:18:05,953 --> 00:18:10,257 line:-2
including all source files to maximize
opportunities for optimization.


335
00:18:10,290 --> 00:18:15,395 line:-2
This single compile task will also produce
the target's Swift module.


336
00:18:15,429 --> 00:18:17,698 line:-1
In debug or incremental compilation modes,


337
00:18:17.731 --> 00:18:20.234 line:-2 align:center
the Swift Driver breaks down
the required compilation effort


338
00:18:20.267 --> 00:18:22.970 line:-2 align:center
into smaller sub-tasks
which can run in parallel,


339
00:18:23.003 --> 00:18:26.673 line:-2 align:center
some of which may not need to re-run
on an incremental build.


340
00:18:26.707 --> 00:18:29.843 line:-2 align:center
Producing a Swift module then requires
an additional step


341
00:18:29,877 --> 00:18:33,947 line:-2
to merge together partial intermediate
products of each compile task.


342
00:18:33.981 --> 00:18:35.816 line:-1 align:center
If, like in this example,


343
00:18:35,849 --> 00:18:38,385 line:-2
the number of source files
in your target is high,


344
00:18:38.418 --> 00:18:42.389 line:-2 align:center
individual files may also be assigned
to batch compilation sub-tasks,


345
00:18:42,422 --> 00:18:45,192 line:-2
according to
the build-system's heuristics.


346
00:18:45,225 --> 00:18:47,828 line:0
The build log highlights
which source files get assigned


347
00:18:47,861 --> 00:18:49,596 line:0
to batch compilation jobs,


348
00:18:49,630 --> 00:18:52,566 line:0
with a separate entry
for each file's diagnostics.


349
00:18:52,599 --> 00:18:56,670 align:center
Being able to parallelize a target's build
across different source files is crucial


350
00:18:56,703 --> 00:18:59,339 align:center
for both faster
and smaller incremental builds,


351
00:18:59,373 --> 00:19:04,244 align:center
so make sure your Debug builds are using
the Incremental Compilation Mode setting.


352
00:19:04,278 --> 00:19:06,713 line:-2
Before Xcode 14,
because of the boundary


353
00:19:06,747 --> 00:19:09,449 line:-2
between the Xcode Build System
and Swift Driver,


354
00:19:09.483 --> 00:19:11.552 line:-1 align:center
orchestration of target build phases,


355
00:19:11.585 --> 00:19:15.789 line:-2 align:center
and compilation sub-tasks spawned by each
target's instance of the Driver


356
00:19:15,822 --> 00:19:17,658 line:-1
happened independently of each other,


357
00:19:17.691 --> 00:19:19.493 line:-1 align:center
with each component doing its best


358
00:19:19.526 --> 00:19:22.496 line:-2 align:center
to make the most
of available system resources.


359
00:19:22.529 --> 00:19:24.998 line:-2 align:center
Let's take this example build graph
and dive deeper


360
00:19:25.032 --> 00:19:27.301 line:-2 align:center
into what goes into scheduling
its compilation phases


361
00:19:27,334 --> 00:19:29,970 line:-1
with respect to each other.


362
00:19:30,003 --> 00:19:33,307 line:-2
As we've learned earlier,
Swift target dependencies are resolved


363
00:19:33.340 --> 00:19:36.610 line:-2 align:center
by having their dependents provide
a binary module file


364
00:19:36,643 --> 00:19:39,780 line:-2
that captures the dependent's
public interface.


365
00:19:39,813 --> 00:19:43,383 line:-2
Resolving these dependency relationships
leads us to the following ordering,


366
00:19:43,417 --> 00:19:46,386 line:-2
captured in a timeline showing
the top-level Swift Driver tasks


367
00:19:46,420 --> 00:19:49,990 line:-2
for each target,
as well as their individual sub-tasks.


368
00:19:50,023 --> 00:19:53,827 line:-2
With Xcode 14, thanks to an entirely new
implementation of Swift Driver–


369
00:19:53,861 --> 00:19:55,562 line:-1
itself now written in Swift–


370
00:19:55,596 --> 00:19:58,832 line:-2
the build system
and the compiler are fully integrated.


371
00:19:58,866 --> 00:20:01,902 line:-2
The Xcode Build System acts
as the central scheduler


372
00:20:01.935 --> 00:20:05.305 line:-2 align:center
for all tasks that must be performed
to compile your code.


373
00:20:05.339 --> 00:20:07.508 line:-2 align:center
This central planning mechanism
allows Xcode


374
00:20:07,541 --> 00:20:09,610 line:-1
to make fine-grained scheduling decisions


375
00:20:09.643 --> 00:20:12.246 line:-2 align:center
providing better guarantees
that building your project


376
00:20:12,279 --> 00:20:15,115 line:-2
will use only as much resources
as available,


377
00:20:15.148 --> 00:20:18.952 line:-2 align:center
without oversubscribing your CPU
and reducing overall system performance.


378
00:20:20.387 --> 00:20:23.090 line:-2 align:center
And what was previously a collection
of islands of sub-tasks


379
00:20:23,123 --> 00:20:25,559 line:-1
outside of Xcode Build System's purview


380
00:20:25.592 --> 00:20:28.662 line:-2 align:center
are now fully in a domain
of the build-system's scheduler.


381
00:20:30,564 --> 00:20:33,834 line:-2
With all the individual sub-tasks
in a central task pool,


382
00:20:33.867 --> 00:20:37.871 line:-2 align:center
it is important to consider the trade-offs
made by the build scheduler.


383
00:20:37.905 --> 00:20:40.073 line:-1 align:center
For example, on an 8-core machine


384
00:20:40.107 --> 00:20:43.510 line:-2 align:center
the scheduler's default
is to assign available tasks–


385
00:20:43,544 --> 00:20:46,947 line:-2
those tasks whose dependencies have been
satisfied and are ready to go–


386
00:20:46.980 --> 00:20:49.750 line:-1 align:center
to one of eight available execution slots.


387
00:20:49,783 --> 00:20:51,685 line:-1
As soon as one of the slots frees up,


388
00:20:51.718 --> 00:20:55.689 line:-2 align:center
the Build System attempts to fill it
with more outstanding work.


389
00:20:55,722 --> 00:20:57,658 line:-1
On a higher-core-count machine,


390
00:20:57,691 --> 00:20:59,893 line:-2
we're able to perform
more concurrent work.


391
00:20:59.927 --> 00:21:02.829 line:-2 align:center
But that means we're also more likely
to have idle cores


392
00:21:02.863 --> 00:21:04.932 line:-1 align:center
which are available to perform more work,


393
00:21:04,965 --> 00:21:08,035 line:-2
but all of the outstanding tasks
are still awaiting their inputs,


394
00:21:08.068 --> 00:21:11.738 line:-2 align:center
as produced by other tasks
that are currently in-flight or waiting.


395
00:21:11,772 --> 00:21:14,541 line:-2
The new integrated build system
allows the scheduler


396
00:21:14,575 --> 00:21:17,244 line:-1
to significantly reduce this idle time.


397
00:21:17.277 --> 00:21:20.848 line:-2 align:center
To see how, let's revisit how
a target's dependencies for compilation,


398
00:21:20.881 --> 00:21:23.183 line:-1 align:center
binary module files, are resolved.


399
00:21:25.485 --> 00:21:26.787 line:-1 align:center
As we've covered earlier,


400
00:21:26.820 --> 00:21:28.989 line:-2 align:center
the partial results
of compilation sub-tasks


401
00:21:29,022 --> 00:21:32,025 line:-2
are merged into a target's
final module product.


402
00:21:32,059 --> 00:21:36,797 line:-2
Once this product is available,
downstream targets may begin compilation.


403
00:21:36,830 --> 00:21:41,368 line:-2
New in Xcode 14 and Swift 5.7,
construction of a target's module


404
00:21:41,401 --> 00:21:43,604 line:-1
is done in a separate emit-module task


405
00:21:43,637 --> 00:21:46,240 line:-1
directly from all program source files.


406
00:21:46,273 --> 00:21:48,709 line:-2
This means a target's dependencies
can begin compilation


407
00:21:48.742 --> 00:21:50.878 line:-2 align:center
as soon as the emit-module task
is complete


408
00:21:50.911 --> 00:21:55.115 line:-2 align:center
without waiting for all of the other
compiler tasks of the dependency target.


409
00:21:55.148 --> 00:21:59.253 line:-2 align:center
Being able to unblock downstream
target compilation this much sooner


410
00:21:59,286 --> 00:22:03,423 line:-2
cuts down on the time spent waiting
for available work with idle CPU cores–


411
00:22:03.457 --> 00:22:07.094 line:-2 align:center
that empty space in between
spurs of activity in the build timeline.


412
00:22:08,495 --> 00:22:10,564 line:-1
Extending this to the rest of our project


413
00:22:10,597 --> 00:22:14,268 line:-2
shows that although we are performing
a similar amount of overall work,


414
00:22:14,301 --> 00:22:18,005 line:-2
the build system is able to use
the computer's resources more efficiently,


415
00:22:18.038 --> 00:22:21.141 line:-2 align:center
often completing
the build significantly faster.


416
00:22:22,276 --> 00:22:24,811 line:-2
Now, let's take a look at
a second cross-target optimization


417
00:22:24,845 --> 00:22:27,214 line:-2
the build system can perform
when building Swift–


418
00:22:27.247 --> 00:22:28.782 line:-1 align:center
Eager Linking.


419
00:22:28,815 --> 00:22:30,350 line:-1
Building on the previous example,


420
00:22:30,384 --> 00:22:32,553 line:-2
we've added the linker tasks
for each target,


421
00:22:32,586 --> 00:22:34,955 line:-2
which are both
on the build's critical path.


422
00:22:34.988 --> 00:22:38.292 line:-2 align:center
In this case,
because Target B links Target A,


423
00:22:38,325 --> 00:22:42,863 line:-2
Target B's link task must wait for
Target A's linked output to be produced


424
00:22:42,896 --> 00:22:46,900 line:-2
and its own compilation tasks
to complete before it can run.


425
00:22:46,934 --> 00:22:48,769 line:-1
However, with eager linking,


426
00:22:48,802 --> 00:22:53,640 line:-2
Target B's link task can depend on
Target A's emit-module task instead.


427
00:22:53,674 --> 00:22:57,044 line:-2
As a result, Target B can begin
linking earlier in the build,


428
00:22:57.077 --> 00:23:01.281 line:-2 align:center
running in parallel with linking Target A
and shortening the critical path.


429
00:23:01.315 --> 00:23:03.217 line:-1 align:center
How does this work?


430
00:23:03,250 --> 00:23:05,285 line:-2
Normally,
the dependency graph of two targets


431
00:23:05,319 --> 00:23:09,289 line:-2
with a linked product dependency
looks something like this.


432
00:23:09,323 --> 00:23:13,560 line:-2
Linking the dependent target requires
the linked product of its dependencies


433
00:23:13.594 --> 00:23:16.730 line:-2 align:center
in addition to the target's
own compilation outputs.


434
00:23:16.763 --> 00:23:19.600 line:-2 align:center
When linking eagerly,
this dependency is broken,


435
00:23:19,633 --> 00:23:23,470 line:-2
allowing the dependent target
to start linking earlier.


436
00:23:23,504 --> 00:23:26,373 line:-2
Instead of depending on a linked
product of the dependency,


437
00:23:26,406 --> 00:23:29,309 line:-2
it now depends on a text-based
dynamic library stub


438
00:23:29.343 --> 00:23:32.980 line:-2 align:center
produced earlier in the build process
by the emit-module task.


439
00:23:33,013 --> 00:23:35,282 line:-2
This stub contains a list of symbols
which will appear


440
00:23:35,315 --> 00:23:38,051 line:-2
in the linked product
for use by dependents.


441
00:23:38,085 --> 00:23:42,322 line:-2
You can enable this optimization using
the Xcode build setting shown on screen.


442
00:23:42,356 --> 00:23:44,658 line:-2
Eager Linking applies
to all pure Swift targets


443
00:23:44,691 --> 00:23:47,694 line:-2
that are dynamically linked
by their dependents.


444
00:23:47.728 --> 00:23:52.032 line:-2 align:center
To summarize, the Xcode Build System
is a sophisticated scheduling engine


445
00:23:52,065 --> 00:23:54,768 line:-2
that seeks to extract
as much parallelism as possible


446
00:23:54,801 --> 00:23:57,004 line:-1
by running build phases in parallel.


447
00:23:57,037 --> 00:23:59,940 line:-2
And features like Script Sandboxing
allow you to ensure your builds


448
00:23:59,973 --> 00:24:03,110 line:-1
are both maximally parallel and reliable.


449
00:24:03.143 --> 00:24:06.180 line:-2 align:center
Xcode and Swift are more integrated
than ever.


450
00:24:06.213 --> 00:24:10.083 line:-2 align:center
And project structure: its modularization,
the overall shape of the graph


451
00:24:10,117 --> 00:24:12,252 line:-2
made up of dependencies
between target products


452
00:24:12,286 --> 00:24:15,789 line:-2
and the number and complexity
of build phases within them,


453
00:24:15.822 --> 00:24:19.493 line:-2 align:center
combined with the available computational
resources of your machine–


454
00:24:19,526 --> 00:24:23,664 line:-2
all these are contributing factors
to the degree Xcode is able to parallelize


455
00:24:23,697 --> 00:24:25,766 line:-1
and speed up your builds.


456
00:24:25,799 --> 00:24:29,036 line:-2
With this knowledge, and powerful
new tools like the build timeline,


457
00:24:29,069 --> 00:24:33,574 line:-2
you are well equipped to examine your
project and gain insight into your builds.


458
00:24:33.607 --> 00:24:34.908 line:-1 align:center
And if you're curious to learn even more


459
00:24:34.942 --> 00:24:36.944 line:-2 align:center
of the behind-the-scenes
technical details,


460
00:24:36.977 --> 00:24:39.780 line:-2 align:center
many of the technologies we described
that are used by Xcode


461
00:24:39,813 --> 00:24:41,381 align:center
are developed in the open-source.


462
00:24:41,415 --> 00:24:45,986 align:center
You can find the repository for
Swift Driver on GitHub at the link below.


463
00:24:46,019 --> 00:24:47,621 line:0
For more great sessions about Xcode,


464
00:24:47,654 --> 00:24:50,057 line:0
check out all new features
and improvements from this year


465
00:24:50,090 --> 00:24:51,892 align:center
in "What's new in Xcode".


466
00:24:51,925 --> 00:24:55,295 line:0
And learn how Xcode 14's linker
improves link times up to two times


467
00:24:55,329 --> 00:24:59,166 line:0
in the session "Link fast:
Improve build and launch times".


468
00:24:59.199 --> 00:25:00.767 line:-1 align:center
Thanks for following along.


469
00:25:00.801 --> 00:25:03.804 line:-2 align:center
We hope you learned some new insights
about Xcode builds.


470
00:25:03.837 --> 00:25:06.006 line:-2 align:center
We can't wait to see
what you're going to create.


471
00:25:06,039 --> 00:25:07,841 line:-1
Have a great rest of the conference.

