2
00:00:00,501 --> 00:00:08,509 line:-1
♪ ♪


3
00:00:09,810 --> 00:00:12,779 line:-2
Welcome to Visualize and Optimize
Swift Concurrency.


4
00:00:12,813 --> 00:00:16,016 line:-2
My name is Mike,
and I work on the Swift runtime library.


5
00:00:16,049 --> 00:00:18,919 line:-2
Hi, I'm Harjas,
and I work on Instruments.


6
00:00:18.952 --> 00:00:21.421 line:-2 align:center
Together, we're going to
discuss ways to better understand


7
00:00:21,455 --> 00:00:24,124 line:-2
your Swift Concurrency code
and make it go faster,


8
00:00:24,157 --> 00:00:28,395 line:-2
including a new visualization tool
available in Instruments 14.


9
00:00:28,428 --> 00:00:32,299 line:-2
Let's start off with a really quick recap
of the various parts of Swift Concurrency


10
00:00:32,332 --> 00:00:35,969 line:-2
and how they work together,
to make sure you're up to speed.


11
00:00:36.003 --> 00:00:38.906 line:-2 align:center
After that, we'll demo
the new concurrency instrument.


12
00:00:38,939 --> 00:00:41,775 line:-2
We'll show you how we use it
to solve some real performance issues


13
00:00:41.808 --> 00:00:44.778 line:-1 align:center
with an app using Swift Concurrency.


14
00:00:44.811 --> 00:00:48.115 line:-2 align:center
Finally, we'll discuss the potential
problems of thread pool exhaustion


15
00:00:48.148 --> 00:00:51.552 line:-2 align:center
and continuation misuse
and how to avoid them.


16
00:00:51,585 --> 00:00:54,321 line:-2
Last year,
we introduced Swift Concurrency.


17
00:00:54,354 --> 00:00:58,258 line:-2
This was a new language feature
that includes async/await,


18
00:00:58,292 --> 00:01:01,195 line:-1
structured concurrency, and Actors.


19
00:01:01,228 --> 00:01:04,498 line:-2
We've been pleased to see a great deal
of adoption of these features since then,


20
00:01:04.531 --> 00:01:07.634 line:-1 align:center
both inside and outside Apple.


21
00:01:07,668 --> 00:01:10,103 line:-2
Swift concurrency adds
several new features to the language


22
00:01:10,137 --> 00:01:14,875 line:-2
which work together to make concurrent
programming easier and safer.


23
00:01:14,908 --> 00:01:19,012 line:-2
Async/await are basic syntactic
building blocks for concurrent code.


24
00:01:19,046 --> 00:01:22,449 line:-2
They allow you to create and call
functions that can suspend their work


25
00:01:22,482 --> 00:01:25,352 line:-2
in the middle of execution,
then resume that work later,


26
00:01:25,385 --> 00:01:27,988 line:-1
without blocking an execution thread.


27
00:01:29.256 --> 00:01:32.960 line:-2 align:center
Tasks are the basic unit of work
in concurrent code.


28
00:01:32,993 --> 00:01:37,531 line:-2
Tasks execute concurrent code
and manage its state and associated data.


29
00:01:37,564 --> 00:01:40,267 line:-2
They contain local variables,
handle cancellation,


30
00:01:40.300 --> 00:01:44.471 line:-2 align:center
and begin and suspend execution
of async code.


31
00:01:44.505 --> 00:01:47.307 line:-2 align:center
Structured concurrency makes it easy
to spawn child tasks


32
00:01:47.341 --> 00:01:50.310 line:-2 align:center
to run in parallel
and wait for them to complete.


33
00:01:50,344 --> 00:01:53,614 line:-2
The language provides syntax
which keeps the work grouped together


34
00:01:53,647 --> 00:01:59,019 line:-2
and ensures that tasks are awaited
or automatically canceled if not used.


35
00:01:59,052 --> 00:02:03,290 line:-2
Actors coordinate multiple tasks
that need to access shared data.


36
00:02:03.323 --> 00:02:05.492 line:-1 align:center
They isolate data from the outside,


37
00:02:05,526 --> 00:02:09,296 line:-2
and allow only one task at a time
to manipulate their internal state,


38
00:02:09.329 --> 00:02:12.733 line:-2 align:center
avoiding data races
from concurrent mutation.


39
00:02:12,766 --> 00:02:16,003 line:-2
New in Instruments 14,
we're introducing a set of instruments


40
00:02:16.036 --> 00:02:19.506 line:-2 align:center
that can capture and visualize
all of this activity in your app,


41
00:02:19.540 --> 00:02:21.842 line:-2 align:center
helping you to understand
what your app is doing,


42
00:02:21,875 --> 00:02:24,645 line:-1
locate problems, and improve performance.


43
00:02:24.678 --> 00:02:28.515 line:-2 align:center
For a more in-depth discussion
of the fundamentals of Swift Concurrency,


44
00:02:28,549 --> 00:02:30,417 line:-2
we have several videos
about these features


45
00:02:30,450 --> 00:02:32,819 line:-1
linked in the Related Videos section.


46
00:02:34.288 --> 00:02:38.559 line:-2 align:center
Let's take a look at optimizing an app
using Swift Concurrency code.


47
00:02:38,592 --> 00:02:41,628 line:-2
Swift concurrency makes it easy to
to write correct concurrent


48
00:02:41.662 --> 00:02:43.330 line:-1 align:center
and parallel code.


49
00:02:43,363 --> 00:02:48,235 line:-2
However, it's still possible to write code
that misuses concurrency constructs.


50
00:02:48,268 --> 00:02:50,237 line:-1
It's also possible to use them correctly


51
00:02:50,270 --> 00:02:52,606 line:-2
but in a way that doesn't get the
performance benefits you were aiming for.


52
00:02:54.875 --> 00:02:57.778 line:-2 align:center
There are a few common problems
that can arise when writing code


53
00:02:57,811 --> 00:03:02,349 line:-2
using Swift concurrency that can cause
poor performance or bugs.


54
00:03:02.382 --> 00:03:06.353 line:-2 align:center
Main Actor blocking
can cause your app to hang.


55
00:03:06.386 --> 00:03:10.324 line:-2 align:center
Actor contention and thread pool
exhaustion hurt performance


56
00:03:10.357 --> 00:03:13.594 line:-1 align:center
by reducing parallel execution.


57
00:03:13.627 --> 00:03:17.164 line:-2 align:center
Continuation misuse
causes leaks or crashes.


58
00:03:17,197 --> 00:03:22,135 line:-2
The new Swift Concurrency instrument can
help you discover and fix these problems.


59
00:03:22.169 --> 00:03:26.073 line:-2 align:center
Let's take a look at each of these,
starting with main Actor blocking.


60
00:03:26.106 --> 00:03:28.876 line:-2 align:center
Main Actor blocking occurs
when a long-running task


61
00:03:28,909 --> 00:03:31,378 line:-1
runs on the main Actor.


62
00:03:31,411 --> 00:03:34,581 line:-2
The main Actor is a special Actor
which executes all of its work


63
00:03:34,615 --> 00:03:36,483 line:-1
on the main thread.


64
00:03:36.517 --> 00:03:39.052 line:-1 align:center
UI work must be done on the main thread,


65
00:03:39,086 --> 00:03:43,357 line:-2
and the main Actor allows you to integrate
UI code into Swift Concurrency.


66
00:03:43,390 --> 00:03:46,293 line:-2
However, because the main thread
is so important for UI,


67
00:03:46.326 --> 00:03:50.964 line:-2 align:center
it needs to be available and can't be
occupied by a long-running unit of work.


68
00:03:50,998 --> 00:03:55,903 line:-2
When this happens, your app appears
to lock up and becomes unresponsive.


69
00:03:55,936 --> 00:03:58,772 line:-2
Code running on the main Actor
must finish quickly,


70
00:03:58.805 --> 00:04:01.208 line:-2 align:center
and either complete its work
or move computation


71
00:04:01.241 --> 00:04:04.011 line:-2 align:center
off of the main Actor
and into the background.


72
00:04:04,044 --> 00:04:07,447 line:-2
Work can be moved into the background
by putting it in a normal Actor


73
00:04:07,481 --> 00:04:09,550 line:-1
or in a detached task.


74
00:04:09,583 --> 00:04:13,353 line:-2
Small units of work can be executed
on the main Actor to update UI


75
00:04:13.387 --> 00:04:16.723 line:-2 align:center
or perform other tasks
that must be done on the main thread.


76
00:04:16.757 --> 00:04:18.825 line:-1 align:center
Let's see a demo of this in action.


77
00:04:18,859 --> 00:04:19,993 line:-1
Thanks, Mike.


78
00:04:20.027 --> 00:04:22.496 line:-2 align:center
Here we have
our File Squeezer application.


79
00:04:22.529 --> 00:04:25.499 line:-2 align:center
We built this application
to be able to quickly compress


80
00:04:25.532 --> 00:04:27.434 line:-1 align:center
all the files in a folder.


81
00:04:27.467 --> 00:04:30.304 line:-1 align:center
It seems to work alright for small files.


82
00:04:30,337 --> 00:04:34,675 line:-2
However, when I use larger files,
it takes much longer than expected


83
00:04:34,708 --> 00:04:39,379 line:-2
and the UI is completely frozen
and does not respond to any interactions.


84
00:04:39,413 --> 00:04:42,349 line:-1
This behavior is very off-putting to users


85
00:04:42.382 --> 00:04:45.252 line:-2 align:center
and may make them think
that the application has crashed


86
00:04:45,285 --> 00:04:46,587 line:-1
or will never finish.


87
00:04:46,620 --> 00:04:50,057 line:-2
We should strive to ensure
that our UI is always responsive


88
00:04:50,090 --> 00:04:51,892 line:-1
for the best user experience.


89
00:04:51.925 --> 00:04:54.328 line:-1 align:center
To investigate this performance problem,


90
00:04:54,361 --> 00:04:58,131 line:-2
we can use the new Swift Concurrency
template in Instruments.


91
00:04:58,165 --> 00:05:02,369 line:-2
The Swift Tasks and Swift Actors
instruments provide a full suite of tools


92
00:05:02.402 --> 00:05:06.139 line:-2 align:center
to help you visualize
and optimize your concurrency code.


93
00:05:06,173 --> 00:05:08,909 line:-2
When you're just starting
to investigate a performance problem


94
00:05:08,942 --> 00:05:12,379 line:-2
you should first take a look
at the top-level statistics


95
00:05:12,412 --> 00:05:15,215 line:-2
provided to you
by the Swift Tasks instrument.


96
00:05:15,249 --> 00:05:18,085 line:-1
The first of these is Running Tasks,


97
00:05:18.118 --> 00:05:22.055 line:-2 align:center
which show you how many tasks
are executing simultaneously.


98
00:05:22,089 --> 00:05:24,191 line:-1
Next, we have Alive Tasks,


99
00:05:24.224 --> 00:05:28.529 line:-2 align:center
which show how many tasks are present
at a given point in time.


100
00:05:28.562 --> 00:05:30.998 line:-1 align:center
And finally, Total Tasks;


101
00:05:31,031 --> 00:05:33,834 line:-2
graph the total number of tasks
that have been created


102
00:05:33,867 --> 00:05:36,270 line:-1
up until that point in time.


103
00:05:36,303 --> 00:05:39,540 line:-2
When you're attempting to reduce
your application memory footprint,


104
00:05:39.573 --> 00:05:44.178 line:-2 align:center
you should take a close look at
the Alive and Total Tasks statistics.


105
00:05:44,211 --> 00:05:47,047 line:-1
The combination of all of these statistics


106
00:05:47.080 --> 00:05:50.617 line:-2 align:center
give you a good picture of how well your
code is parallelizing


107
00:05:50.651 --> 00:05:53.854 line:-1 align:center
and how many resources you are consuming.


108
00:05:53,887 --> 00:05:57,991 line:-2
One of the many detail views
for this instrument is the Task Forest;


109
00:05:58.025 --> 00:06:02.729 line:-2 align:center
shown in the bottom half of this window,
it provides a graphical representation


110
00:06:02,763 --> 00:06:05,599 line:-1
of the parent-child relationships


111
00:06:05.632 --> 00:06:09.269 line:-2 align:center
between Tasks
in structured concurrency code.


112
00:06:09.303 --> 00:06:12.005 line:-1 align:center
Next, we have our Task Summary view.


113
00:06:12.039 --> 00:06:17.277 line:-2 align:center
This shows how much time
each Task spends in different states.


114
00:06:17.311 --> 00:06:21.348 line:-2 align:center
We have super-charged the view by allowing
you to right-click on a Task


115
00:06:21,381 --> 00:06:25,152 line:-2
to be able to pin a Track
containing all the information


116
00:06:25,185 --> 00:06:27,588 line:-1
about the selected Task to the timeline.


117
00:06:27,621 --> 00:06:31,992 line:-2
This allows you to quickly find and learn
about Tasks of interest


118
00:06:32.025 --> 00:06:34.494 line:-1 align:center
that may be running for a very long time


119
00:06:34,528 --> 00:06:38,966 line:-2
or stuck waiting to get access
to an Actor.


120
00:06:38,999 --> 00:06:43,237 line:-2
Once you pin a Swift Task to the timeline,
you get four key features.


121
00:06:43,270 --> 00:06:48,275 line:-2
First, is the track that shows you
what state your Swift Task is in.


122
00:06:48,308 --> 00:06:53,113 line:-2
Second, is the Task creation backtrace
in the extended detail view.


123
00:06:53,146 --> 00:06:56,583 line:-2
Third, is the narrative view
that provides more context


124
00:06:56,617 --> 00:06:58,385 line:-1
about the state a Swift Task is in.


125
00:06:58.418 --> 00:07:00.988 line:-1 align:center
Such as, if it's waiting on a Task,


126
00:07:01,021 --> 00:07:04,324 line:-2
it will inform you
which Task you are waiting on.


127
00:07:04.358 --> 00:07:08.428 line:-2 align:center
Lastly, you have access to
the same pin action in the narrative view


128
00:07:08.462 --> 00:07:10.364 line:-1 align:center
as you did in the summary view.


129
00:07:10,397 --> 00:07:13,467 line:-1
So, you can pin a child Task, a thread,


130
00:07:13,500 --> 00:07:16,370 line:-1
or even a Swift Actor to the timeline.


131
00:07:16.403 --> 00:07:21.808 line:-2 align:center
This narrative view will be instrumental
in finding how a Swift Task is related


132
00:07:21.842 --> 00:07:25.979 line:-2 align:center
to your other concurrency primitives
and the CPU.


133
00:07:26,013 --> 00:07:28,348 line:-1
Now that we have seen a brief overview


134
00:07:28.382 --> 00:07:30.717 line:-2 align:center
of some of the features
in the new instrument,


135
00:07:30.751 --> 00:07:33.787 line:-2 align:center
let's profile our application
and optimize our code.


136
00:07:33,820 --> 00:07:38,025 line:-2
We can do this by pulling up our project
in Xcode and pressing Command-I.


137
00:07:38,058 --> 00:07:40,894 line:-2
This will compile our application,
open up instruments,


138
00:07:40,928 --> 00:07:44,364 line:-2
and pre-select the target
to the File Squeezer application.


139
00:07:44,398 --> 00:07:48,068 line:-2
From here you can pick the Swift
Concurrency option in the template picker


140
00:07:48,101 --> 00:07:49,603 line:-1
and start recording.


141
00:07:52,005 --> 00:07:54,942 line:-2
Once again,
I'll drop the large files onto the app.


142
00:07:56.844 --> 00:08:01.415 line:-2 align:center
Again, we see that the app starts spinning
and the UI is not responsive.


143
00:08:01,448 --> 00:08:03,650 line:-2
We will let this run
for a few more seconds


144
00:08:03.684 --> 00:08:07.287 line:-2 align:center
so that Instruments can capture
all the information about our application.


145
00:08:08.922 --> 00:08:11.925 line:-2 align:center
Now that we have a trace,
we can start investigating.


146
00:08:11.959 --> 00:08:15.095 line:-2 align:center
I'm going to fullscreen this trace
to better see all the information.


147
00:08:17.798 --> 00:08:21.935 line:-2 align:center
We can use option-drag
to zoom in on our area of interest.


148
00:08:24.304 --> 00:08:26.573 line:-1 align:center
In the process track,


149
00:08:26,607 --> 00:08:31,111 line:-2
Instruments shows us exactly
where this UI hang was occurring.


150
00:08:31,144 --> 00:08:34,581 line:-2
This can be useful for cases
when it is not clear


151
00:08:34,615 --> 00:08:37,451 line:-2
when the hang occurred
or how long it lasted.


152
00:08:37.484 --> 00:08:39.820 line:-2 align:center
As I mentioned earlier,
a good place to start


153
00:08:39,853 --> 00:08:42,589 line:-1
is the top-level Swift Task statistics.


154
00:08:42.623 --> 00:08:46.593 line:-2 align:center
What catches my eye right away
is the Running Tasks count.


155
00:08:46.627 --> 00:08:49.696 line:-2 align:center
For most of the time,
only one Task is running.


156
00:08:49.730 --> 00:08:51.832 line:-1 align:center
This tells us part of the problem is that


157
00:08:51.865 --> 00:08:55.002 line:-2 align:center
all of our work is being forced
to serialize.


158
00:08:55,035 --> 00:08:59,039 line:-2
We can use the Task State summary
to find our longest running Task


159
00:08:59.072 --> 00:09:02.009 line:-2 align:center
and use the pin action
to pin it to the timeline.


160
00:09:03,544 --> 00:09:08,115 line:-2
The narrative view for this Task tells us
that it ran on a background thread


161
00:09:08,148 --> 00:09:09,917 line:-1
for a short amount of time,


162
00:09:09,950 --> 00:09:14,321 line:-2
and then ran on the Main Thread
for a long time.


163
00:09:14,354 --> 00:09:18,358 line:-2
To further investigate, we can pin
the Main Thread to the timeline.


164
00:09:23.864 --> 00:09:27.668 line:-2 align:center
The Main Thread is being blocked
by several long running Tasks.


165
00:09:27.701 --> 00:09:31.872 line:-2 align:center
This demonstrates the issue of
Main Actor blocking that Mike spoke about.


166
00:09:31.905 --> 00:09:34.842 line:-2 align:center
So the questions
we have to ask ourselves are,


167
00:09:34,875 --> 00:09:38,111 line:-2
"What is this Task doing?"
and "Where did this Task come from?"


168
00:09:38.145 --> 00:09:43.217 line:-2 align:center
We can switch back to the narrative view
to answer both of these questions.


169
00:09:43,250 --> 00:09:45,853 line:-2
The creation backtrace in
the extended detail view


170
00:09:45,886 --> 00:09:50,457 line:-2
shows that the task was created
in the compressAllFiles function.


171
00:09:50.490 --> 00:09:55.095 line:-2 align:center
The narrative shows that
the Task is executing closure number one


172
00:09:55,128 --> 00:09:56,964 line:-1
in compressAllFiles.


173
00:09:56,997 --> 00:10:01,268 line:-2
By right-clicking on this symbol,
we can open this in the source viewer.


174
00:10:03.837 --> 00:10:08.041 line:-2 align:center
Closure number one inside this function
is calling our compression work.


175
00:10:08.075 --> 00:10:12.112 line:-2 align:center
Now that we know where this Task
was created and what it is doing,


176
00:10:12.145 --> 00:10:14.581 line:-1 align:center
we can open our code in Xcode and adapt it


177
00:10:14,615 --> 00:10:16,917 line:-2
so that we don't run
these heavy computations


178
00:10:16,950 --> 00:10:18,185 line:-1
on the Main Thread.


179
00:10:18.218 --> 00:10:24.024 line:-2 align:center
The compress file function is located
within the CompressionState class.


180
00:10:24.057 --> 00:10:29.129 line:-2 align:center
The entire CompressionState class
is annotated to run on the @MainActor.


181
00:10:29.162 --> 00:10:32.432 line:-2 align:center
This explains why the Task also ran
on the Main Thread.


182
00:10:32.466 --> 00:10:35.903 line:-1 align:center
We need this entire class to be on the MainActor


183
00:10:35,936 --> 00:10:38,505 line:-1
because the @Published property here


184
00:10:38,539 --> 00:10:40,908 line:-1
must only be updated from the Main Thread,


185
00:10:40.941 --> 00:10:44.378 line:-2 align:center
otherwise,
we could run into runtime issues.


186
00:10:44,411 --> 00:10:49,917 line:-2
So, instead we could try to convert
this class into its own Actor.


187
00:10:49.950 --> 00:10:53.187 line:-2 align:center
However, the compiler will tell us
that we can't do this


188
00:10:53,220 --> 00:10:57,891 line:-2
because essentially we would be saying
that this shared mutable state


189
00:10:57,925 --> 00:11:01,361 line:-2
needs to be protected
by two different Actors.


190
00:11:01.395 --> 00:11:04.898 line:-2 align:center
But that does give us a hint
for what the real solution is.


191
00:11:04.932 --> 00:11:09.136 line:-2 align:center
We have two different pieces
of mutable state here within this class.


192
00:11:09.169 --> 00:11:11.471 line:-2 align:center
One piece of state,
the 'files' property,


193
00:11:11,505 --> 00:11:16,677 line:-2
needs to be isolated to the MainActor
because it is observed by SwiftUI.


194
00:11:16.710 --> 00:11:19.413 line:-2 align:center
But access to the other piece of state,
the logs,


195
00:11:19.446 --> 00:11:22.482 line:-2 align:center
needs to be protected
from concurrent access,


196
00:11:22.516 --> 00:11:27.054 line:-2 align:center
but which thread accesses logs
at any given point doesn't matter.


197
00:11:27.087 --> 00:11:32.092 line:-2 align:center
Thus, it doesn't actually need
to be on the Main Actor.


198
00:11:32.125 --> 00:11:35.229 line:-2 align:center
We still want to protect it
from concurrent access, though,


199
00:11:35,262 --> 00:11:38,799 line:-1
so we wrap it in its own Actor.


200
00:11:38,832 --> 00:11:45,672 line:-2
All we need now is add a way for Tasks
to hop between the two as needed.


201
00:11:45,706 --> 00:11:50,644 line:-2
We can create a new Actor
and call it ParallelCompressor.


202
00:11:53,480 --> 00:11:59,419 line:-2
We can then copy the log state into the
new Actor,


203
00:11:59.453 --> 00:12:02.122 line:-1 align:center
and add some extra setup code.


204
00:12:04,324 --> 00:12:08,428 line:-2
From here, we need to make these Actors
communicate with each other.


205
00:12:08,462 --> 00:12:12,266 line:-2
First, let's remove the code
that referred to the logs variable


206
00:12:12,299 --> 00:12:18,472 line:-1
from the CompressionState class,


207
00:12:18,505 --> 00:12:22,543 line:-2
and add it
to our ParallelCompressor Actor.


208
00:12:27.681 --> 00:12:30.551 line:-2 align:center
Then finally,
we need to update CompressionState


209
00:12:30,584 --> 00:12:35,255 line:-2
to invoke compressFile
on the ParallelCompressor.


210
00:12:43,297 --> 00:12:48,702 line:-2
With these changes,
let's test our application again.


211
00:12:48,735 --> 00:12:52,773 line:-2
Once again, I'll drop the large files
onto our application.


212
00:12:55,375 --> 00:12:58,912 line:-2
The UI is no longer hung,
which is a great improvement,


213
00:12:58.946 --> 00:13:01.915 line:-2 align:center
but we aren't getting the speed
that we would expect.


214
00:13:01.949 --> 00:13:06.119 line:-2 align:center
We really want to take full advantage
of all the cores in the machine


215
00:13:06,153 --> 00:13:08,522 line:-1
to do this work as fast as possible.


216
00:13:08,555 --> 00:13:11,291 line:-2
Mike, what else
should we be watching out for?


217
00:13:12.926 --> 00:13:16.129 line:-2 align:center
Mike: We've solved our hang
by moving work off of the Main Actor,


218
00:13:16,163 --> 00:13:19,233 line:-2
but we're still not getting
the performance we want.


219
00:13:19.266 --> 00:13:22.402 line:-2 align:center
To see why,
we need to take a closer look at Actors.


220
00:13:22.436 --> 00:13:26.740 line:-2 align:center
Actors make it safe for multiple tasks
to manipulate shared state.


221
00:13:26,773 --> 00:13:31,078 line:-2
However, they do this by serializing
access to that shared state.


222
00:13:31.111 --> 00:13:34.781 line:-2 align:center
Only one task at a time
is allowed to occupy the Actor,


223
00:13:34,815 --> 00:13:38,519 line:-2
and other tasks
that need to use that Actor will wait.


224
00:13:38,552 --> 00:13:42,890 line:-2
Swift concurrency allows for parallel
computation using unstructured tasks,


225
00:13:42,923 --> 00:13:45,425 line:-1
task groups, and async let.


226
00:13:45.459 --> 00:13:49.563 line:-2 align:center
Ideally, these constructs are able
to use many CPU cores simultaneously.


227
00:13:49.596 --> 00:13:53.767 line:-2 align:center
When using Actors from such code,
beware of performing large amounts of work


228
00:13:53.800 --> 00:13:57.004 line:-2 align:center
on an Actor
that's shared among these tasks.


229
00:13:57.037 --> 00:14:00.474 line:-2 align:center
When multiple tasks attempt
to use the same Actor simultaneously,


230
00:14:00.507 --> 00:14:04.178 line:-2 align:center
the Actor serializes
execution of those tasks.


231
00:14:04,211 --> 00:14:08,448 line:-2
Because of this, we lose the performance
benefits of parallel computation.


232
00:14:11.151 --> 00:14:16.023 line:-2 align:center
This is because each task must wait
for the Actor to become available.


233
00:14:16.056 --> 00:14:19.693 line:-2 align:center
To fix this, we need make sure
that tasks only run on the Actor


234
00:14:19,726 --> 00:14:23,130 line:-2
when they really need exclusive access
to the Actor's data.


235
00:14:23.163 --> 00:14:25.632 line:-2 align:center
Everything else should run
off of the Actor.


236
00:14:25.666 --> 00:14:28.735 line:-1 align:center
We divide the task into chunks.


237
00:14:28,769 --> 00:14:32,239 line:-2
Some chunks must run on the Actor,
and the others don't.


238
00:14:32,272 --> 00:14:36,076 line:-2
The non-Actor isolated chunks
can be executed in parallel,


239
00:14:36,109 --> 00:14:39,446 line:-2
which means the computer
can finish the work much faster.


240
00:14:39,479 --> 00:14:41,248 line:-1
Let's see a demo of this in action.


241
00:14:41,281 --> 00:14:43,183 line:-1
Harjas: Thanks, Mike.


242
00:14:43.217 --> 00:14:47.154 line:-2 align:center
Let's take a look at the trace
of our updated "File Squeezer" application


243
00:14:47,187 --> 00:14:49,790 line:-2
and keep in mind
what Mike has just taught us.


244
00:14:49,823 --> 00:14:53,827 line:-2
The Task Summary view shows us
that our concurrency code


245
00:14:53,861 --> 00:14:57,197 line:-2
is spending an alarming amount of time
in the Enqueued state.


246
00:14:57,231 --> 00:15:02,336 line:-2
This means we have a lot of Tasks waiting
to get exclusive access to an Actor.


247
00:15:02,369 --> 00:15:05,072 line:-1
Let's pin one of these Tasks to learn why.


248
00:15:07.841 --> 00:15:11.278 line:-2 align:center
This Task spends quite a while
waiting to get onto


249
00:15:11,311 --> 00:15:16,016 line:-2
the ParallelCompressor Actor
before it runs the compression work.


250
00:15:16.049 --> 00:15:18.819 line:-2 align:center
Let's go ahead
and pin the Actor to our timeline.


251
00:15:23.090 --> 00:15:27.995 line:-2 align:center
Here we have some top-level data
for the ParallelCompressor Actor.


252
00:15:28,028 --> 00:15:33,267 line:-2
This Actor Queue seems to be getting
blocked by some long running Tasks.


253
00:15:33.300 --> 00:15:37.271 line:-2 align:center
Tasks should really only stay on an Actor
for as long as needed.


254
00:15:37,304 --> 00:15:39,673 line:-1
Let's go back to the Task narrative.


255
00:15:42.543 --> 00:15:45.345 line:-1 align:center
After the enqueue on ParallelCompressor,


256
00:15:45,379 --> 00:15:50,184 line:-2
the Task runs in closure number one
in compressAllFiles.


257
00:15:50.217 --> 00:15:52.653 line:-1 align:center
So let's start our investigation there.


258
00:15:52.686 --> 00:15:59.226 line:-2 align:center
The source code shows us that this closure
is primarily running our compression work.


259
00:15:59,259 --> 00:16:04,831 line:-2
Since the compressFile function
is part of the ParallelCompressor Actor,


260
00:16:04.865 --> 00:16:09.369 line:-2 align:center
the entire execution of this function
happens on the Actor;


261
00:16:09,403 --> 00:16:11,872 line:-1
blocking all other compression work.


262
00:16:11,905 --> 00:16:15,742 line:-2
To resolve this issue,
we need to pull the compressFile function


263
00:16:15.776 --> 00:16:20.047 line:-2 align:center
out of Actor-isolation
and into a detached task.


264
00:16:22.583 --> 00:16:27.054 line:-2 align:center
By doing this, we can have
the detached task only on an Actor


265
00:16:27,087 --> 00:16:31,859 line:-2
for as long as needed
to update the relevant mutable state.


266
00:16:31,892 --> 00:16:35,929 line:-2
So now the compress function
can be executed freely,


267
00:16:35,963 --> 00:16:38,031 line:-2
on any thread
in the thread pool,


268
00:16:38,065 --> 00:16:42,135 line:-2
until it needs to access
Actor-protected state.


269
00:16:42.169 --> 00:16:45.739 line:-2 align:center
For example, when it needs
to access the 'files' property,


270
00:16:45.772 --> 00:16:48.742 line:-1 align:center
it'll move onto the Main Actor.


271
00:16:48,775 --> 00:16:53,847 line:-2
But as soon as it's done there, it moves
into the "sea of concurrency" again,


272
00:16:53,881 --> 00:16:57,784 line:-2
until it needs to access
the logs property,


273
00:16:57.818 --> 00:17:01.488 line:-2 align:center
for which it moves on
to the ParallelCompressor Actor.


274
00:17:01.522 --> 00:17:03.590 line:-1 align:center
But again, as soon as it's done there,


275
00:17:03.624 --> 00:17:08.495 line:-2 align:center
it leaves the Actor again
to be executed on the thread pool.


276
00:17:08,529 --> 00:17:12,466 line:-2
But of course, we don't have just one task
doing compression work;


277
00:17:12,499 --> 00:17:14,034 line:-1
we have many.


278
00:17:14,067 --> 00:17:19,473 line:-2
And by not being constrained to an Actor,
they can all be executed concurrently,


279
00:17:19.506 --> 00:17:22.276 line:-1 align:center
only limited by the number of threads.


280
00:17:23,610 --> 00:17:28,982 line:-2
Of course, each Actor
can only execute one task at a time,


281
00:17:29,016 --> 00:17:33,620 line:-2
but most of the time,
our Tasks don't need to be on an Actor.


282
00:17:33,654 --> 00:17:37,724 line:-2
So like Mike explained,
this allows our compression tasks


283
00:17:37.758 --> 00:17:43.463 line:-2 align:center
to executed in parallel
and utilize all available CPU cores.


284
00:17:43.497 --> 00:17:45.532 line:-1 align:center
So let's make this change now.


285
00:17:47.134 --> 00:17:50.971 line:-2 align:center
We can mark the compressFile function
as nonisolated.


286
00:17:53,006 --> 00:17:56,176 line:-1
This does result in a few compiler errors.


287
00:17:56,210 --> 00:18:00,314 line:-2
By marking it as nonisolated,
we told the Swift compiler


288
00:18:00,347 --> 00:18:04,251 line:-2
that we don't need access
to the shared state of this Actor.


289
00:18:04,284 --> 00:18:06,720 line:-1
But that isn't entirely true.


290
00:18:06.753 --> 00:18:13.727 line:-2 align:center
This log function is Actor-isolated and it
needs access to the shared mutable state.


291
00:18:13,760 --> 00:18:19,499 line:-2
In order to fix this,
we need to make this function async


292
00:18:19,533 --> 00:18:24,805 line:-2
and then mark all of our log invocations
with the await keyword.


293
00:18:29.376 --> 00:18:35.282 line:-2 align:center
Now we need to update our task creation
to create a detached task.


294
00:18:40,554 --> 00:18:43,690 line:-2
We do this to ensure
the Task does not inherit


295
00:18:43.724 --> 00:18:47.194 line:-1 align:center
the Actor-context that it was created in.


296
00:18:47,227 --> 00:18:51,632 line:-2
For detached tasks,
we need to explicitly capture self.


297
00:18:56.203 --> 00:18:58.005 line:-1 align:center
Let's test our application again.


298
00:19:05,546 --> 00:19:09,650 line:-2
The app is able to compress
all the files simultaneously


299
00:19:09,683 --> 00:19:12,219 line:-1
and the UI remains responsive.


300
00:19:12,252 --> 00:19:18,258 line:-2
To verify our improvements,
we can check the Swift Actors instrument.


301
00:19:18,292 --> 00:19:20,928 line:-1
Looking at the ParallelCompressor Actor,


302
00:19:20,961 --> 00:19:23,597 line:-1
most of the work executed on the Actor


303
00:19:23.630 --> 00:19:26.066 line:-1 align:center
is only for a short amount of time


304
00:19:26,099 --> 00:19:30,571 line:-1
and the queue size never gets out of hand.


305
00:19:30.604 --> 00:19:35.209 line:-2 align:center
To recap, we used the Instrument
to Isolate the cause of a UI hang,


306
00:19:35.242 --> 00:19:38.612 line:-2 align:center
we restructured our concurrency code
for better parallelism,


307
00:19:38.645 --> 00:19:42.382 line:-2 align:center
and verified performance improvements
using data.


308
00:19:42,416 --> 00:19:46,553 line:-2
Now Mike is gonna tell us about
some other potential performance issues.


309
00:19:46.587 --> 00:19:48.822 line:-2 align:center
Mike: There are two common problems
I'd like to cover


310
00:19:48.856 --> 00:19:50.624 line:-1 align:center
beyond what we've seen in the demo.


311
00:19:50.657 --> 00:19:53.527 line:-2 align:center
First, let's talk about
thread pool exhaustion.


312
00:19:53,560 --> 00:19:55,796 line:-2
Thread pool exhaustion
can hurt performance


313
00:19:55,829 --> 00:19:57,965 line:-1
or even deadlock an application.


314
00:19:57,998 --> 00:20:02,803 line:-2
Swift concurrency requires tasks to make
forward progress when they're running.


315
00:20:02.836 --> 00:20:06.807 line:-2 align:center
When a task waits for something,
it normally does so by suspending.


316
00:20:06.840 --> 00:20:10.911 line:-2 align:center
However, it's possible for code
within a task to perform a blocking call,


317
00:20:10.944 --> 00:20:15.949 line:-2 align:center
such as blocking file or network IO,
or acquiring locks, without suspending.


318
00:20:15.983 --> 00:20:20.354 line:-2 align:center
This breaks the requirement
for tasks to make forward progress.


319
00:20:20.387 --> 00:20:23.390 line:-2 align:center
When this happens,
the task continues to occupy the thread


320
00:20:23,423 --> 00:20:27,561 line:-2
where it's executing,
but it isn't actually using a CPU core.


321
00:20:27,594 --> 00:20:30,898 line:-2
Because the pool of threads is limited
and some of them are blocked,


322
00:20:30,931 --> 00:20:34,902 line:-2
the concurrency runtime is
unable to fully use all CPU cores.


323
00:20:34,935 --> 00:20:37,137 line:-2
This reduces the amount
of parallel computation


324
00:20:37.171 --> 00:20:40.974 line:-2 align:center
that can be done
and the maximum performance of your app.


325
00:20:41.008 --> 00:20:45.546 line:-2 align:center
In extreme cases, when the entire
thread pool is occupied by blocked tasks,


326
00:20:45.579 --> 00:20:48.115 line:-2 align:center
and they're waiting on something
that requires a new task


327
00:20:48.148 --> 00:20:52.586 line:-2 align:center
to run on the thread pool,
the concurrency runtime can deadlock.


328
00:20:52.619 --> 00:20:55.756 line:-1 align:center
Be sure to avoid blocking calls in tasks.


329
00:20:55,789 --> 00:21:00,160 line:-2
File and network IO must be performed
using async APIs.


330
00:21:00.194 --> 00:21:03.564 line:-2 align:center
Avoid waiting on condition variables
or semaphores.


331
00:21:03.597 --> 00:21:07.367 line:-2 align:center
Fine-grained, briefly-held locks
are acceptable if necessary,


332
00:21:07.401 --> 00:21:09.436 line:-2 align:center
but avoid locks
that have a lot of contention


333
00:21:09.469 --> 00:21:12.172 line:-1 align:center
or are held for long periods of time.


334
00:21:12,206 --> 00:21:14,641 line:-2
If you have code
that needs to do these things,


335
00:21:14,675 --> 00:21:17,611 line:-2
move that code
outside of the concurrency thread pool–


336
00:21:17.644 --> 00:21:20.113 line:-2 align:center
for example,
by running it on a Dispatch queue–


337
00:21:20,147 --> 00:21:23,951 line:-2
and bridge it to the concurrency world
using continuations.


338
00:21:23.984 --> 00:21:27.654 line:-2 align:center
Whenever possible,
use async APIs for blocking operations


339
00:21:27.688 --> 00:21:30.757 line:-1 align:center
to keep the system operating smoothly.


340
00:21:30,791 --> 00:21:35,562 line:-2
When you're using continuations,
you must be careful to use them correctly.


341
00:21:35,596 --> 00:21:40,667 line:0
Continuations are the bridge between Swift
concurrency and other forms of async code.


342
00:21:40,701 --> 00:21:43,270 line:0
A continuation suspends
the current task


343
00:21:43,303 --> 00:21:47,140 align:center
and provides a callback
which resumes the task when called.


344
00:21:47,174 --> 00:21:51,111 line:0
This can then be used
with callback-based async APIs.


345
00:21:51,144 --> 00:21:54,781 align:center
From the perspective of Swift concurrency,
the task suspends,


346
00:21:54,815 --> 00:21:58,252 line:0
and then it resumes
when the continuation is resumed.


347
00:21:58,285 --> 00:22:02,256 line:0
From the perspective of the callback-based
async API, the work begins,


348
00:22:02,289 --> 00:22:05,025 line:0
and then the callback is called
when the work completes.


349
00:22:05.058 --> 00:22:07.895 line:-2 align:center
The Swift Concurrency instrument
knows about continuations


350
00:22:07,928 --> 00:22:10,097 line:-2
and will mark
the time interval accordingly,


351
00:22:10.130 --> 00:22:14.101 line:-2 align:center
showing you that the task was waiting on
a continuation to be called.


352
00:22:14,134 --> 00:22:16,837 line:-2
Continuation callbacks have
a special requirement:


353
00:22:16.870 --> 00:22:20.574 line:-2 align:center
they must be called exactly once,
no more, no less.


354
00:22:20,607 --> 00:22:23,577 line:-2
This is a common requirement
in callback-based APIs,


355
00:22:23,610 --> 00:22:25,312 line:-1
but it tends to be an informal one


356
00:22:25,345 --> 00:22:27,814 line:-1
and is not enforced by the language,


357
00:22:27,848 --> 00:22:29,616 line:-1
and oversights are common.


358
00:22:29,650 --> 00:22:32,586 line:-2
Swift concurrency
makes this a hard requirement.


359
00:22:32,619 --> 00:22:36,890 line:-2
If the callback is called twice,
the program will crash or misbehave.


360
00:22:36,924 --> 00:22:40,761 line:-2
If the callback is never called,
the task will leak.


361
00:22:40,794 --> 00:22:43,497 line:-2
In this code snippet
we use withCheckedContinuation


362
00:22:43,530 --> 00:22:45,399 line:-1
to get a continuation.


363
00:22:45,432 --> 00:22:48,402 line:-1
We then invoke a callback-based API.


364
00:22:48,435 --> 00:22:51,205 line:-2
In the callback,
we resume the continuation.


365
00:22:51,238 --> 00:22:54,842 line:-2
This meets the requirement of calling it
exactly once.


366
00:22:54,875 --> 00:22:58,212 line:0
It's important to be careful
when the code is more complex.


367
00:22:58,245 --> 00:23:00,214 line:0
On the left, we've modified the callback


368
00:23:00,247 --> 00:23:02,950 align:center
to only resume the continuation
on success.


369
00:23:02,983 --> 00:23:04,618 line:0
This is a bug.


370
00:23:04,651 --> 00:23:07,287 line:0
On failure,
the continuation will not be resumed,


371
00:23:07,321 --> 00:23:10,224 align:center
and the task will be suspended forever.


372
00:23:10,257 --> 00:23:13,627 align:center
On the right,
we're resuming the continuation twice.


373
00:23:13,660 --> 00:23:17,598 line:0
This is also a bug,
and the app will misbehave or crash.


374
00:23:17,631 --> 00:23:19,867 align:center
Both of these snippets
violate the requirement


375
00:23:19,900 --> 00:23:23,036 align:center
to resume the continuation exactly once.


376
00:23:23,070 --> 00:23:27,908 align:center
Two kinds of continuations
are available: checked and unsafe.


377
00:23:27,941 --> 00:23:32,479 align:center
Always use the withCheckedContinuation API
for continuations


378
00:23:32,513 --> 00:23:35,849 align:center
unless performance is absolutely critical.


379
00:23:35,883 --> 00:23:40,254 line:0
Checked continuations automatically
detect misuse and flag an error.


380
00:23:40,287 --> 00:23:44,958 align:center
When a checked continuation
is called twice, the continuation traps.


381
00:23:44,992 --> 00:23:47,394 align:center
When the continuation
is never called at all,


382
00:23:47,427 --> 00:23:50,931 align:center
a message is printed to the console
when the continuation is destroyed


383
00:23:50,964 --> 00:23:53,567 line:0
warning you that the continuation leaked.


384
00:23:53,600 --> 00:23:56,703 line:0
The Swift Concurrency instrument
will show the corresponding task


385
00:23:56,737 --> 00:24:00,107 line:0
stuck indefinitely
in the continuation state.


386
00:24:00,140 --> 00:24:03,610 line:-2
There is much more to look into
for the new Swift Concurrency template


387
00:24:03,644 --> 00:24:04,912 line:-1
in Instruments.


388
00:24:04,945 --> 00:24:08,115 line:-2
You can get graphic visualization
of structured concurrency,


389
00:24:08,148 --> 00:24:12,119 line:-2
view task creation calltrees, and inspect
the exact assembly instructions


390
00:24:12.152 --> 00:24:15.255 line:-2 align:center
to get a full picture
of the Swift Concurrency runtime.


391
00:24:15,289 --> 00:24:18,292 line:-2
To learn more about how Swift Concurrency
works under the hood,


392
00:24:18,325 --> 00:24:22,162 line:0
watch last year's session on
"Swift Concurrency: Behind the Scenes."


393
00:24:22,196 --> 00:24:23,931 line:0
And to learn more about data races,


394
00:24:23,964 --> 00:24:27,100 align:center
watch "Eliminate data races
using Swift Concurrency."


395
00:24:27,134 --> 00:24:28,302 line:-1
Thanks for watching!


396
00:24:28.335 --> 00:24:31.405 line:-2 align:center
And have fun
debugging your concurrency code.

