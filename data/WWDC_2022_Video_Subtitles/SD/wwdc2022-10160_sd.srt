2
00:00:00,100 --> 00:00:03,003 line:-1
♪ Mellow instrumental
hip-hop music ♪


3
00:00:03,003 --> 00:00:09,676 align:right position:90% size:2%
♪


4
00:00:09.676 --> 00:00:11.311 line:-1 position:50%
Hi, my name is Keyi Yu,


5
00:00:11.311 --> 00:00:14.014 line:-1 position:50%
and I'm an engineer
from the Metal Ecosystem team.


6
00:00:14,014 --> 00:00:17,017 line:-1
Today, it's my pleasure
to introduce metal-cpp.


7
00:00:17.017 --> 00:00:21.955 line:-1 position:50%
We created metal-cpp for anyone
who uses C++ and wants to build


8
00:00:21.955 --> 00:00:25.058 line:-1 position:50%
Metal applications
for Apple platforms.


9
00:00:25,058 --> 00:00:27,594 line:-1
Metal-cpp is
a low-overhead library


10
00:00:27,594 --> 00:00:31,698 line:-1
that connects your C++
applications to Metal.


11
00:00:31,698 --> 00:00:35,702 line:-1
First, I'll start with
an overview of what metal-cpp is


12
00:00:35.702 --> 00:00:39.706 line:-1 position:50%
and how it works,
and then I'll cover some details


13
00:00:39.706 --> 00:00:43.310 line:-1 position:50%
about the lifecycles
for Objective-C objects.


14
00:00:43.310 --> 00:00:47.781 line:-1 position:50%
C++ and Objective-C handle
lifecycles a bit differently,


15
00:00:47,781 --> 00:00:52,219 line:-1
and I'll show you how to handle
those differences.


16
00:00:52.219 --> 00:00:55.756 line:-1 position:50%
Xcode and metal-cpp
have some great utilities


17
00:00:55,756 --> 00:00:58,392 line:-1
that can help you manage
the object lifecycles


18
00:00:58,392 --> 00:01:01,094 line:-1
in your apps.


19
00:01:01,094 --> 00:01:05,098 line:-1
And finally, I'll show you
how to integrate C++ code


20
00:01:05.098 --> 00:01:09.102 line:-1 position:50%
with Objective-C classes.


21
00:01:09,102 --> 00:01:13,340 line:-1
So here's a look at metal-cpp
and how it works.


22
00:01:13,340 --> 00:01:16,343 line:-1
Metal is the foundation
for accelerated graphics


23
00:01:16,343 --> 00:01:20,314 line:-1
and compute on Apple platforms,
enabling your apps and games


24
00:01:20,314 --> 00:01:23,317 line:-1
to tap into the incredible power
of the GPU.


25
00:01:23,317 --> 00:01:26,553 line:-1
It was originally designed
using the powerful features


26
00:01:26,553 --> 00:01:29,323 line:-1
and the conventions
offered by Objective-C.


27
00:01:29,323 --> 00:01:34,061 line:-1
But if your code base is in C++,
you may need something to bridge


28
00:01:34,061 --> 00:01:37,464 line:-1
between your code
and Metal's Objective-C code.


29
00:01:37,464 --> 00:01:39,999 line:-1
Introducing metal-cpp!


30
00:01:39.999 --> 00:01:43.337 line:-1 position:50%
It serves as a hub
between your C++ application


31
00:01:43,337 --> 00:01:45,605 line:-1
and Objective-C Metal.


32
00:01:45.605 --> 00:01:48.208 line:-1 position:50%
With metal-cpp
in your application,


33
00:01:48,208 --> 00:01:51,678 line:-1
you can use Metal classes
and functions in C++,


34
00:01:51.678 --> 00:01:54.915 line:-1 position:50%
and metal-cpp can help you
call Objective-C functions


35
00:01:54.915 --> 00:01:56.450 line:-1 position:50%
in runtime.


36
00:01:56,450 --> 00:02:00,520 line:-1
metal-cpp is a lightweight
Metal C++ wrapper.


37
00:02:00.520 --> 00:02:03.657 line:-1 position:50%
I say it's lightweight,
because it's implemented


38
00:02:03.657 --> 00:02:07.627 line:-1 position:50%
as a header-only library
with inline function calls.


39
00:02:07.627 --> 00:02:11.331 line:-1 position:50%
It provides 100 percent
coverage of the Metal API


40
00:02:11.331 --> 00:02:14.835 line:-1 position:50%
by implementing a one-to-one
mapping of C++ calls


41
00:02:14.835 --> 00:02:16.770 line:-1 position:50%
to Objective-C APIs.


42
00:02:16.770 --> 00:02:20.007 line:-1 position:50%
To do this, metal-cpp wraps
parts of the Foundation


43
00:02:20.007 --> 00:02:22.442 line:-1 position:50%
and CoreAnimation frameworks.


44
00:02:22.442 --> 00:02:24.711 line:-1 position:50%
It's open source
under Apache 2 License,


45
00:02:24.711 --> 00:02:27.214 line:-1 position:50%
so you can modify the library
and include it


46
00:02:27,214 --> 00:02:29,649 line:-1
to your applications, easily.


47
00:02:29.649 --> 00:02:32.853 line:-1 position:50%
metal-cpp uses C
to call directly


48
00:02:32.853 --> 00:02:35.622 line:-1 position:50%
into the Objective-C runtime.


49
00:02:35.622 --> 00:02:38.959 line:-1 position:50%
This is the exact same mechanism
that the Objective-C compiler


50
00:02:38.959 --> 00:02:42.963 line:-1 position:50%
uses to execute
Objective-C methods.


51
00:02:42,963 --> 00:02:47,167 line:-1
So this wrapper
introduces little overhead.


52
00:02:47,167 --> 00:02:51,438 line:-1
Since metal-cpp implements
a one-to-one mapping of C++


53
00:02:51.438 --> 00:02:53.440 line:-1 position:50%
to Objective-C calls,


54
00:02:53.440 --> 00:02:57.077 line:-1 position:50%
it follows the same Cocoa
memory-management rules.


55
00:02:57,077 --> 00:02:59,946 line:-1
I will discuss this
in more detail later.


56
00:02:59,946 --> 00:03:02,215 line:0
This one-to-one mapping
also allows


57
00:03:02,215 --> 00:03:05,318 position:50%
all of the developer tools
to work seamlessly,


58
00:03:05,318 --> 00:03:10,791 position:50%
including GPU Frame Capture
and the Xcode debugger.


59
00:03:10.791 --> 00:03:13.760 line:-1 position:50%
These are the series of calls
necessary to draw a triangle


60
00:03:13.760 --> 00:03:15.695 line:-1 position:50%
with metal-cpp.


61
00:03:15.695 --> 00:03:19.499 line:-1 position:50%
If you are familiar with C++,
it's a good time to learn Metal,


62
00:03:19.499 --> 00:03:22.869 line:-1 position:50%
because you don't need to worry
about language syntax.


63
00:03:22,869 --> 00:03:26,306 line:-1
If you've already used Metal
with Objective-C,


64
00:03:26.306 --> 00:03:29.443 line:-1 position:50%
in terms of function calls,
there's very little difference


65
00:03:29.443 --> 00:03:31.912 line:-1 position:50%
between the Objective-C
interface of Metal


66
00:03:31,912 --> 00:03:33,780 line:-1
and metal-cpp.


67
00:03:33.780 --> 00:03:38.852 line:-1 position:50%
I am going to demonstrate
how easy it is to use metal-cpp.


68
00:03:38.852 --> 00:03:41.555 line:-1 position:50%
First, I create
a command buffer,


69
00:03:41.555 --> 00:03:45.258 line:-1 position:50%
which I will fill with commands
for the GPU to execute.


70
00:03:45,258 --> 00:03:48,495 line:-1
I can simply use
the raw pointer in C++


71
00:03:48,495 --> 00:03:51,665 line:-1
as a mapping to ID
in Objective-C.


72
00:03:51.665 --> 00:03:54.234 line:-1 position:50%
I can create a render
command encoder


73
00:03:54.234 --> 00:03:57.504 line:-1 position:50%
and write render commands
with a command buffer.


74
00:03:57.504 --> 00:04:00.540 line:-1 position:50%
The C++ function
renderCommandEncoder


75
00:04:00.540 --> 00:04:02.642 line:-1 position:50%
and the Objective-C method


76
00:04:02,642 --> 00:04:06,980 line:-1
renderCommandEncoder
WithDescriptor are the same.


77
00:04:06,980 --> 00:04:09,749 line:-1
The only differences
are the name conventions


78
00:04:09.749 --> 00:04:11.551 line:-1 position:50%
of the languages.


79
00:04:11.551 --> 00:04:14.321 line:-1 position:50%
I then set a render pipeline
state object


80
00:04:14.321 --> 00:04:17.257 line:-1 position:50%
which contains the vertex
and fragment shaders


81
00:04:17,257 --> 00:04:19,860 line:-1
and various other
rendering states.


82
00:04:19.860 --> 00:04:24.631 line:-1 position:50%
Then I encode my draw call
to render a single triangle.


83
00:04:24,631 --> 00:04:25,999 line:0
Then I indicate that


84
00:04:25,999 --> 00:04:29,402 line:0
I've finished encoding
render commands.


85
00:04:29,402 --> 00:04:33,340 position:50%
I present the drawable, so the
triangle is displayed onscreen.


86
00:04:33,340 --> 00:04:36,409 position:50%
Finally, I commit
my command buffer.


87
00:04:36.409 --> 00:04:40.847 line:-1 position:50%
This tells the GPU that it can
begin executing my commands.


88
00:04:40.847 --> 00:04:43.783 line:-1 position:50%
Obviously, metal-cpp
and Objective-C Metal


89
00:04:43.783 --> 00:04:45.485 line:-1 position:50%
are almost the same.


90
00:04:45,485 --> 00:04:48,155 line:-1
You don't need to worry
about language syntax now


91
00:04:48,155 --> 00:04:49,956 line:-1
with metal-cpp,


92
00:04:49,956 --> 00:04:52,726 line:-1
you can directly look into
the Metal documentation


93
00:04:52,726 --> 00:04:56,463 line:-1
to learn the concepts
and usage of Metal.


94
00:04:56,463 --> 00:04:58,098 line:-1
You may have already played


95
00:04:58.098 --> 00:05:00.500 line:-1 position:50%
with this deferred lighting
sample before.


96
00:05:00.500 --> 00:05:03.703 line:-1 position:50%
We now provide a new version
of this deferred lighting sample


97
00:05:03.703 --> 00:05:06.206 line:-1 position:50%
which uses metal-cpp.


98
00:05:06,206 --> 00:05:09,509 line:-1
We hope this can help you learn
how to code with metal-cpp


99
00:05:09.509 --> 00:05:11.077 line:-1 position:50%
in practice.


100
00:05:11.077 --> 00:05:13.380 line:-1 position:50%
I'm also excited
to introduce a series


101
00:05:13,380 --> 00:05:17,851 line:-1
of incremental C++ samples
that introduces the Metal API


102
00:05:17.851 --> 00:05:21.488 line:-1 position:50%
and shows you how to accomplish
different tasks with it.


103
00:05:25,158 --> 00:05:28,695 line:-1
So now that you know
a little bit about metal-cpp,


104
00:05:28.695 --> 00:05:30.463 line:-1 position:50%
how do you actually use it?


105
00:05:30.463 --> 00:05:32.933 line:-1 position:50%
We published
metal-cpp last year.


106
00:05:32.933 --> 00:05:35.302 line:-1 position:50%
Here's the webpage where
you can find the downloads


107
00:05:35.302 --> 00:05:36.937 line:-1 position:50%
and instructions.


108
00:05:36.937 --> 00:05:39.906 line:-1 position:50%
Let me show you the steps
you will need to take.


109
00:05:39,906 --> 00:05:41,908 line:-1
After downloading metal-cpp,


110
00:05:41.908 --> 00:05:44.878 line:-1 position:50%
you should tell Xcode
where to find it.


111
00:05:44,878 --> 00:05:49,616 line:-1
Here, I put metal-cpp
under the current project.


112
00:05:49.616 --> 00:05:53.019 line:-1 position:50%
Then, you need to set
C++17 or higher


113
00:05:53.019 --> 00:05:56.990 line:-1 position:50%
as the C++ language dialect.


114
00:05:56,990 --> 00:05:59,859 line:-1
Next, add three frameworks
to the project:


115
00:05:59,859 --> 00:06:03,997 line:-1
Foundation, QuartzCore,
and Metal.


116
00:06:03,997 --> 00:06:05,532 line:-1
Now there's only one thing
left to do


117
00:06:05.532 --> 00:06:09.336 line:-1 position:50%
before using C++ interfaces
of those frameworks.


118
00:06:09.336 --> 00:06:12.138 line:-1 position:50%
There are three headers
in metal-cpp.


119
00:06:12.138 --> 00:06:14.841 line:-1 position:50%
Since metal-cpp is
a header-only library,


120
00:06:14,841 --> 00:06:17,444 line:-1
you need to generate
their implementations


121
00:06:17,444 --> 00:06:19,846 line:-1
before importing
the header files.


122
00:06:19,846 --> 00:06:24,985 line:-1
To do this, define three macros:
NS_PRIVATE_IMPLEMENTATION,


123
00:06:24.985 --> 00:06:29.656 line:-1 position:50%
CA_PRIVATE_IMPLEMENTATION,
AND MTL_PRIVATE_IMPLEMENTATION.


124
00:06:29,656 --> 00:06:32,692 line:-1
If you are interested in what
metal-cpp does with the macros


125
00:06:32.692 --> 00:06:33.994 line:-1 position:50%
under the hood,


126
00:06:33.994 --> 00:06:37.631 line:-1 position:50%
please check out header bridge
files in the metal-cpp folder.


127
00:06:37,631 --> 00:06:39,499 line:-1
You can use
the headers separately


128
00:06:39.499 --> 00:06:42.168 line:-1 position:50%
or put them in a single header.


129
00:06:42,168 --> 00:06:45,071 line:-1
You can import the header files
whenever you need them.


130
00:06:45.071 --> 00:06:48.908 line:-1 position:50%
But remember,
do not define the NS, CA,


131
00:06:48.908 --> 00:06:52.746 line:-1 position:50%
or MTL_PRIVATE_IMPLEMENTATION
macros more than once.


132
00:06:52.746 --> 00:06:56.950 line:-1 position:50%
Otherwise, you may cause
duplicate definition errors.


133
00:06:56,950 --> 00:06:59,286 line:-1
To use metal-cpp effectively,


134
00:06:59.286 --> 00:07:02.322 line:-1 position:50%
you'll need to know Cocoa's
memory management rules,


135
00:07:02,322 --> 00:07:05,425 line:-1
how to use the great utilities
that can help you


136
00:07:05.425 --> 00:07:07.994 line:-1 position:50%
manage object lifecycles,
and how to design


137
00:07:07.994 --> 00:07:10.497 line:-1 position:50%
your application architecture
when you interface


138
00:07:10,497 --> 00:07:12,732 line:-1
with other frameworks.


139
00:07:12,732 --> 00:07:16,336 line:-1
I'll start with object
lifecycle management.


140
00:07:16.336 --> 00:07:18.638 line:-1 position:50%
During your application's
operation,


141
00:07:18.638 --> 00:07:21.908 line:-1 position:50%
you typically need to allocate
and release memory.


142
00:07:21.908 --> 00:07:24.811 line:-1 position:50%
You also need to manage
command buffers,


143
00:07:24.811 --> 00:07:27.213 line:-1 position:50%
pipeline objects, and resources.


144
00:07:27.213 --> 00:07:29.182 line:-1 position:50%
To help manage this memory,


145
00:07:29.182 --> 00:07:33.019 line:-1 position:50%
Objective-C and Cocoa objects
include a reference count.


146
00:07:33,019 --> 00:07:36,089 line:-1
This is also present
in metal-cpp.


147
00:07:36.089 --> 00:07:39.025 line:-1 position:50%
Reference counting helps you
manage your memory.


148
00:07:39.025 --> 00:07:40.627 line:-1 position:50%
Using reference counting,


149
00:07:40.627 --> 00:07:43.596 line:-1 position:50%
all objects contain
a retainCount property.


150
00:07:43.596 --> 00:07:45.732 line:-1 position:50%
Components in an app
increase the count


151
00:07:45.732 --> 00:07:48.568 line:-1 position:50%
to keep objects
they're interacting with alive


152
00:07:48,568 --> 00:07:51,304 line:-1
and decrease it
when they are done with them.


153
00:07:51.304 --> 00:07:53.473 line:-1 position:50%
When the retainCount hits zero,


154
00:07:53.473 --> 00:07:56.176 line:-1 position:50%
the runtime
deallocates the object.


155
00:07:56,176 --> 00:07:59,279 line:-1
There are two types of reference
counting in Objective-C.


156
00:07:59,279 --> 00:08:02,615 line:-1
One is called
Manual Retain-Release -- MRR;


157
00:08:02.615 --> 00:08:06.252 line:-1 position:50%
the other is Automatic
Reference Counting -- ARC.


158
00:08:06,252 --> 00:08:08,688 line:-1
When compiling code
with the ARC feature,


159
00:08:08,688 --> 00:08:11,257 line:-1
the compiler takes
the references you create


160
00:08:11.257 --> 00:08:13.293 line:-1 position:50%
and automatically inserts calls


161
00:08:13.293 --> 00:08:16.429 line:-1 position:50%
to the underlying
memory-management mechanism.


162
00:08:16,429 --> 00:08:20,233 line:-1
metal-cpp objects are manually
retained and released.


163
00:08:20,233 --> 00:08:23,303 line:-1
So you need to understand
Cocoa's conventions


164
00:08:23,303 --> 00:08:26,973 line:-1
to know when to retain
and release objects.


165
00:08:26.973 --> 00:08:31.478 line:-1 position:50%
Unlike creating objects in C++,
metal-cpp objects


166
00:08:31,478 --> 00:08:34,948 line:-1
are neither created with new
nor destroyed with delete.


167
00:08:34.948 --> 00:08:38.785 line:-1 position:50%
With Cocoa's conventions,
you own any object you create


168
00:08:38.785 --> 00:08:43.423 line:-1 position:50%
with methods starting
with the alloc, new, copy,


169
00:08:43.423 --> 00:08:45.892 line:-1 position:50%
mutableCopy, or create.


170
00:08:45,892 --> 00:08:49,562 line:-1
You can take ownership
of an object using retain.


171
00:08:49,562 --> 00:08:53,333 line:-1
When you no longer need it,
you must relinquish ownership


172
00:08:53,333 --> 00:08:54,868 line:-1
of an object you own.


173
00:08:54,868 --> 00:08:58,972 line:-1
You can release it immediately
or release it afterwards.


174
00:08:58.972 --> 00:09:02.475 line:-1 position:50%
You must not relinquish
ownership of an object


175
00:09:02.475 --> 00:09:05.912 line:-1 position:50%
you do not own
as you risk a double free.


176
00:09:05,912 --> 00:09:08,081 line:-1
Next, I'll walk through
an example


177
00:09:08.081 --> 00:09:10.150 line:-1 position:50%
of these Cocoa conventions.


178
00:09:10.150 --> 00:09:14.154 line:-1 position:50%
In class A, a method uses alloc
to create an object


179
00:09:14,154 --> 00:09:16,756 line:-1
and init to initialize
this object.


180
00:09:16.756 --> 00:09:20.960 line:-1 position:50%
Remember, never call init
on an object twice.


181
00:09:20,960 --> 00:09:22,896 line:-1
Class A takes the ownership


182
00:09:22,896 --> 00:09:25,832 line:-1
and is responsible
for deallocating it.


183
00:09:25,832 --> 00:09:29,302 line:-1
Now the retain count
for this object is one.


184
00:09:29,302 --> 00:09:33,373 line:-1
Next, class B uses retain
to get the object


185
00:09:33.373 --> 00:09:35.975 line:-1 position:50%
and takes ownership
of this object.


186
00:09:35.975 --> 00:09:39.279 line:-1 position:50%
So far, I have two objects
that share the ownership


187
00:09:39.279 --> 00:09:42.582 line:-1 position:50%
of this object represented
by the orange cube.


188
00:09:42,582 --> 00:09:44,651 line:-1
The retain count
increases by one.


189
00:09:46,519 --> 00:09:49,355 line:-1
Class A doesn't need
this object anymore,


190
00:09:49.355 --> 00:09:53.126 line:-1 position:50%
so class A should manually
call release for it.


191
00:09:53,126 --> 00:09:56,830 line:-1
As a result, the retain count
decreases by one.


192
00:09:56,830 --> 00:10:00,066 line:-1
Now, only class B
owns the object.


193
00:10:00,066 --> 00:10:03,670 line:-1
OK, finally, class B wants
to release this object too.


194
00:10:03,670 --> 00:10:08,374 line:-1
Now the retain count is zero,
so the runtime frees the object.


195
00:10:08.374 --> 00:10:11.144 line:-1 position:50%
Here's a situation where
a method in class B


196
00:10:11,144 --> 00:10:13,513 line:-1
returns an object.


197
00:10:13,513 --> 00:10:16,616 line:-1
You still need this object
in the rest of the programs.


198
00:10:16.616 --> 00:10:19.552 line:-1 position:50%
In other words, you want
to relinquish ownership


199
00:10:19,552 --> 00:10:22,222 line:-1
of an object in a method
in class B,


200
00:10:22.222 --> 00:10:26.226 line:-1 position:50%
but you don't want it to be
deallocated immediately.


201
00:10:26.226 --> 00:10:30.263 line:-1 position:50%
In this case, you should call
autorelease in class B.


202
00:10:30,263 --> 00:10:33,333 line:-1
The retain count is still one
after you call autorelease,


203
00:10:33,333 --> 00:10:36,836 line:-1
and thus, you can still use
the object later.


204
00:10:36.836 --> 00:10:38.238 line:-1 position:50%
Here's the question:


205
00:10:38.238 --> 00:10:41.574 line:-1 position:50%
since class B does not own
this object anymore,


206
00:10:41,574 --> 00:10:44,577 line:-1
who is responsible
for deallocating it?


207
00:10:44.577 --> 00:10:47.580 line:-1 position:50%
The Foundation Framework
provides an important object,


208
00:10:47.580 --> 00:10:49.649 line:-1 position:50%
called the AutoreleasePool.


209
00:10:49.649 --> 00:10:54.387 line:-1 position:50%
The Autorelease API puts the
object into an AutoreleasePool.


210
00:10:54.387 --> 00:10:58.992 line:-1 position:50%
Now, the AutoreleasePool takes
the ownership of the object.


211
00:10:58.992 --> 00:11:02.028 line:-1 position:50%
The AutoreleasePool decrements
the receiver's retain count


212
00:11:02.028 --> 00:11:04.797 line:-1 position:50%
when the AutoreleasePool
is destroyed.


213
00:11:04,797 --> 00:11:08,835 line:-1
You are not the only one who
can create autoreleased objects.


214
00:11:08.835 --> 00:11:11.304 line:-1 position:50%
Metal creates several
autoreleased objects


215
00:11:11.304 --> 00:11:13.473 line:-1 position:50%
as part of its operation.


216
00:11:13,473 --> 00:11:16,175 line:-1
All methods that create
temporary objects


217
00:11:16.175 --> 00:11:18.211 line:-1 position:50%
add them to AutoreleasePools


218
00:11:18,211 --> 00:11:21,014 line:-1
by calling autorelease
under the hood.


219
00:11:21.014 --> 00:11:24.717 line:-1 position:50%
It is the AutoreleasePool's
responsibility to release them.


220
00:11:24.717 --> 00:11:27.320 line:-1 position:50%
In other words,
with an AutoreleasePool,


221
00:11:27.320 --> 00:11:30.156 line:-1 position:50%
you can code
in a more elegant way.


222
00:11:30.156 --> 00:11:33.526 line:-1 position:50%
You can have an AutoreleasePool
for the main application.


223
00:11:33.526 --> 00:11:36.429 line:-1 position:50%
We also encourage you
to create and manage


224
00:11:36,429 --> 00:11:38,932 line:-1
additional AutoreleasePools
at smaller scopes


225
00:11:38.932 --> 00:11:41.401 line:-1 position:50%
to reduce your program's
working set.


226
00:11:41,401 --> 00:11:45,204 line:-1
You also need AutoreleasePools
for every thread you create.


227
00:11:45.204 --> 00:11:48.508 line:-1 position:50%
Here's an example showing
how to use an AutoreleasePool


228
00:11:48,508 --> 00:11:51,077 line:-1
and autoreleased objects.


229
00:11:51.077 --> 00:11:53.680 line:-1 position:50%
In this sample,
an AutoreleasePool


230
00:11:53.680 --> 00:11:57.917 line:-1 position:50%
is created by alloc, which
means you take the ownership


231
00:11:57.917 --> 00:12:00.587 line:-1 position:50%
and it should be
manually released.


232
00:12:00,587 --> 00:12:03,289 line:-1
Now we have an AutoreleasePool.


233
00:12:03.289 --> 00:12:05.124 line:-1 position:50%
As we discussed
in the beginning,


234
00:12:05,124 --> 00:12:07,927 line:-1
you should create
a command buffer.


235
00:12:07.927 --> 00:12:11.130 line:-1 position:50%
It's not created
with alloc or create,


236
00:12:11.130 --> 00:12:13.566 line:-1 position:50%
so you don't own it.


237
00:12:13.566 --> 00:12:19.706 line:-1 position:50%
Instead, it's an autoreleased
object created by Metal.


238
00:12:19.706 --> 00:12:22.942 line:-1 position:50%
This command buffer will be put
into the AutoreleasePool.


239
00:12:22,942 --> 00:12:26,613 line:-1
It's the AutoreleasePool's
responsibility to deallocate it.


240
00:12:26.613 --> 00:12:28.181 line:-1 position:50%
You can use it as you wish


241
00:12:28.181 --> 00:12:31.551 line:-1 position:50%
until you release
the AutoreleasePool.


242
00:12:31,551 --> 00:12:35,655 line:-1
Then you need to create
a RenderPassDescriptor.


243
00:12:35.655 --> 00:12:39.192 line:-1 position:50%
This RenderPassDescriptor will
be put into the AutoreleasePool


244
00:12:39,192 --> 00:12:40,393 line:-1
as well.


245
00:12:40,393 --> 00:12:43,196 line:-1
Same to RenderCommandEncoder.


246
00:12:43.196 --> 00:12:46.899 line:-1 position:50%
It's also an autoreleased object
created by Metal.


247
00:12:46.899 --> 00:12:49.936 line:-1 position:50%
Don't forget
this currentDrawable object.


248
00:12:49.936 --> 00:12:53.606 line:-1 position:50%
It will be put into
the AutoreleasePool too.


249
00:12:53,606 --> 00:12:56,943 line:-1
At the end of the piece of code,
I use pPool->release


250
00:12:56.943 --> 00:12:59.112 line:-1 position:50%
to release the AutoreleasePool.


251
00:12:59.112 --> 00:13:02.115 line:-1 position:50%
Before being deallocated,
the AutoreleasePool


252
00:13:02.115 --> 00:13:04.651 line:-1 position:50%
releases everything
that it owns,


253
00:13:04.651 --> 00:13:07.920 line:-1 position:50%
in this case, it releases
the CommandBuffer,


254
00:13:07.920 --> 00:13:12.058 line:-1 position:50%
RenderPassDescriptor,
RenderCommandEncoder,


255
00:13:12,058 --> 00:13:14,060 line:-1
and currentDrawable.


256
00:13:14,060 --> 00:13:16,863 line:-1
Then the AutoreleasePool
is released.


257
00:13:16.863 --> 00:13:19.532 line:-1 position:50%
So far, you got to know
Cocoa's conventions,


258
00:13:19.532 --> 00:13:22.669 line:-1 position:50%
autoreleased objects,
and AutoreleasePools.


259
00:13:22.669 --> 00:13:26.439 line:-1 position:50%
It's important to correctly
manage object lifecycles


260
00:13:26,439 --> 00:13:29,842 line:-1
to avoid memory leaks
and zombie objects,


261
00:13:29,842 --> 00:13:32,612 line:-1
and we have great tools
to help you avoid


262
00:13:32.612 --> 00:13:35.014 line:-1 position:50%
and debug these issues.


263
00:13:35,014 --> 00:13:37,183 line:-1
I'll focus on two utilities:


264
00:13:37,183 --> 00:13:40,586 line:-1
NS::SharedPtr and NSZombie.


265
00:13:40,586 --> 00:13:44,457 line:-1
NS::SharedPtr is a new utility
that can help you manage


266
00:13:44.457 --> 00:13:46.626 line:-1 position:50%
the object lifecycle.


267
00:13:46.626 --> 00:13:48.995 line:-1 position:50%
You can find it under
Foundation framework


268
00:13:48,995 --> 00:13:51,064 line:-1
in the metal-cpp folder.


269
00:13:51.064 --> 00:13:53.332 line:-1 position:50%
Notice that it is not
exactly the same


270
00:13:53,332 --> 00:13:55,268 line:-1
as std:shared_ptr.


271
00:13:55,268 --> 00:13:59,639 line:-1
So there's no dependency
on the C++ standard library


272
00:13:59,639 --> 00:14:03,042 line:-1
and no extra cost
on storing the reference count.


273
00:14:03,042 --> 00:14:05,778 line:-1
Here's what NS::SharedPtr
is like.


274
00:14:05.778 --> 00:14:08.614 line:-1 position:50%
Transfer and retain functions
clearly express


275
00:14:08,614 --> 00:14:11,484 line:-1
the intent of consuming
an object.


276
00:14:11,484 --> 00:14:13,920 line:-1
Transfer creates a SharedPtr


277
00:14:13.920 --> 00:14:16.756 line:-1 position:50%
without increasing
the pointee's referenceCount,


278
00:14:16,756 --> 00:14:21,027 line:-1
effectively transferring
ownership to the SharedPtr.


279
00:14:21.027 --> 00:14:25.531 line:-1 position:50%
The retain function sends a
retain to the passed-in object.


280
00:14:25,531 --> 00:14:28,101 line:-1
Use this function
to keep alive objects


281
00:14:28,101 --> 00:14:29,936 line:-1
that are in AutoreleasePools


282
00:14:29.936 --> 00:14:32.538 line:-1 position:50%
and to express
that the pointer's owner


283
00:14:32.538 --> 00:14:36.542 line:-1 position:50%
has a vested interest
in the pointee's lifecycle.


284
00:14:36.542 --> 00:14:38.411 line:-1 position:50%
You can access
the underlying object


285
00:14:38.411 --> 00:14:42.749 line:-1 position:50%
as expected via get
and via the operator->.


286
00:14:42,749 --> 00:14:45,752 line:-1
SharedPtr copy,
move, construction,


287
00:14:45.752 --> 00:14:48.788 line:-1 position:50%
and assignment work as expected,


288
00:14:48,788 --> 00:14:51,524 line:-1
with copy increasing
the retainCount.


289
00:14:51.524 --> 00:14:54.560 line:-1 position:50%
Moves are fast and
do not affect the retain count


290
00:14:54.560 --> 00:14:56.429 line:-1 position:50%
in the general case.


291
00:14:56,429 --> 00:14:59,599 line:-1
SharedPtrs always send
exactly one release


292
00:14:59,599 --> 00:15:02,034 line:-1
to the pointee
on destruction.


293
00:15:02.034 --> 00:15:03.703 line:-1 position:50%
You can avoid this if you want


294
00:15:03,703 --> 00:15:06,239 line:-1
by calling
the detach function.


295
00:15:06.239 --> 00:15:07.707 line:-1 position:50%
Going back to the top,


296
00:15:07,707 --> 00:15:10,176 line:-1
it's important to know
the differences between


297
00:15:10,176 --> 00:15:14,747 line:-1
creating a pointer
by transferring or retaining it.


298
00:15:14,747 --> 00:15:17,083 line:-1
So for TransferPtr,


299
00:15:17.083 --> 00:15:22.789 line:-1 position:50%
suppose I have an MRR object,
with a reference count of 1.


300
00:15:22,789 --> 00:15:25,358 line:-1
After I pass it
to the TransferPtr function,


301
00:15:25.358 --> 00:15:28.327 line:-1 position:50%
the SharedPtr takes
ownership of the object,


302
00:15:28,327 --> 00:15:30,963 line:-1
but its retainCount
doesn't change.


303
00:15:30.963 --> 00:15:32.799 line:-1 position:50%
When the pointer
goes out of scope,


304
00:15:32,799 --> 00:15:34,867 line:-1
the SharedPtr's destructor runs


305
00:15:34.867 --> 00:15:37.637 line:-1 position:50%
and calls release
on the MRR object,


306
00:15:37.637 --> 00:15:40.139 line:-1 position:50%
which decrements
the retainCount to 0.


307
00:15:40,139 --> 00:15:43,276 line:-1
Another function
is NS::RetainPtr.


308
00:15:43.276 --> 00:15:46.012 line:-1 position:50%
When you want to avoid
deallocating an object


309
00:15:46.012 --> 00:15:47.780 line:-1 position:50%
because you want
to use it later,


310
00:15:47,780 --> 00:15:50,216 line:-1
you should use NS::RetainPtr.


311
00:15:50,216 --> 00:15:55,388 line:-1
Suppose we have this MRR object;
the retainCount is one.


312
00:15:55,388 --> 00:15:58,024 line:-1
After we pass it
to the RetainPtr function,


313
00:15:58.024 --> 00:16:00.726 line:-1 position:50%
the retainCount increases
by one.


314
00:16:00.726 --> 00:16:02.261 line:-1 position:50%
After running out of the scope,


315
00:16:02.261 --> 00:16:06.499 line:-1 position:50%
this RetainPtr calls release
for this MRR object.


316
00:16:06.499 --> 00:16:09.101 line:-1 position:50%
So the retainCount is one.


317
00:16:09.101 --> 00:16:12.405 line:-1 position:50%
In general, NS::TransferPtr
takes the ownership


318
00:16:12,405 --> 00:16:13,940 line:-1
of an object for you.


319
00:16:13.940 --> 00:16:17.443 line:-1 position:50%
But NS::RetainPtr
helps you retain an object


320
00:16:17,443 --> 00:16:20,746 line:-1
when you don't want it
to be deallocated.


321
00:16:20.746 --> 00:16:24.016 line:-1 position:50%
When you pass an object
to these two functions,


322
00:16:24,016 --> 00:16:27,320 line:-1
NS::TransferPtr doesn't change
the reference count


323
00:16:27.320 --> 00:16:31.557 line:-1 position:50%
but NS::RetainPtr increases
reference count by one


324
00:16:31,557 --> 00:16:34,493 line:-1
as it calls retain for you
under the hood.


325
00:16:34.493 --> 00:16:36.829 line:-1 position:50%
The destructor
of these two functions


326
00:16:36.829 --> 00:16:39.498 line:-1 position:50%
both call release
for the passed-in object


327
00:16:39.498 --> 00:16:43.269 line:-1 position:50%
and, therefore, reference
count decreases by one.


328
00:16:43.269 --> 00:16:45.571 line:-1 position:50%
If the reference count
hits zero,


329
00:16:45,571 --> 00:16:48,207 line:-1
the object will be freed
in runtime.


330
00:16:48.207 --> 00:16:51.744 line:-1 position:50%
Here's an example
of NS::TransferPtr.


331
00:16:51.744 --> 00:16:53.479 line:-1 position:50%
When I talked about
the render pass,


332
00:16:53.479 --> 00:16:55.681 line:-1 position:50%
which drew a single triangle,


333
00:16:55.681 --> 00:16:58.484 line:-1 position:50%
I needed this
render pipeline state.


334
00:16:58,484 --> 00:17:02,355 line:-1
Here are the calls to create
a render pipeline state object.


335
00:17:02.355 --> 00:17:05.791 line:-1 position:50%
These are the attributes that a
render pipeline descriptor needs.


336
00:17:05,791 --> 00:17:07,927 position:50%
According to
Cocoa's conventions,


337
00:17:07,927 --> 00:17:12,198 position:50%
since these calls starts
with new and alloc,


338
00:17:12,198 --> 00:17:14,066 position:50%
I own these objects.


339
00:17:14,066 --> 00:17:17,603 line:0
So I need to call release
for these objects.


340
00:17:17,603 --> 00:17:20,940 line:-1
With NS::SharedPtr,
I don't need to call release


341
00:17:20.940 --> 00:17:23.042 line:-1 position:50%
for those MRR objects


342
00:17:23,042 --> 00:17:27,747 line:-1
because NS::SharedPtrs takes
the ownership of these objects.


343
00:17:27.747 --> 00:17:33.219 line:-1 position:50%
So here, I pass raw pointers
to the TransferPtr function.


344
00:17:33.219 --> 00:17:36.289 line:-1 position:50%
After doing that,
there's no need to call release


345
00:17:36.289 --> 00:17:38.724 line:-1 position:50%
as I did in the previous slide.


346
00:17:38.724 --> 00:17:40.660 line:-1 position:50%
If you are familiar with ARC,


347
00:17:40,660 --> 00:17:44,363 line:-1
you may find that MRR
used with NS::SharedPtr


348
00:17:44,363 --> 00:17:46,399 line:-1
is similar to using ARC.


349
00:17:46.399 --> 00:17:48.467 line:-1 position:50%
You may encounter
use-after-free bugs


350
00:17:48.467 --> 00:17:50.536 line:-1 position:50%
when handling memory manually.


351
00:17:50,536 --> 00:17:52,838 line:-1
They occur when you are trying
to use an object


352
00:17:52,838 --> 00:17:55,207 line:-1
which has been already released.


353
00:17:55,207 --> 00:17:58,311 line:-1
NSZombie is a good way
to check for those bugs.


354
00:17:58.311 --> 00:18:00.313 line:-1 position:50%
When use-after-free
bugs occur,


355
00:18:00.313 --> 00:18:04.450 line:-1 position:50%
it triggers a breakpoint and
provides you with a stack trace.


356
00:18:04,450 --> 00:18:06,485 line:-1
You can enable Zombies
very easily


357
00:18:06.485 --> 00:18:08.321 line:-1 position:50%
with an environment variable.


358
00:18:08,321 --> 00:18:11,223 line:-1
Just set NSZombieEnabled
to YES.


359
00:18:11.223 --> 00:18:13.826 line:-1 position:50%
Or If you're using Xcode,


360
00:18:13,826 --> 00:18:16,028 line:-1
you can enable Zombies
in a scheme.


361
00:18:16.028 --> 00:18:18.431 line:-1 position:50%
Here's how it works.


362
00:18:18,431 --> 00:18:21,834 line:0
I want to create a new
render pipeline state object


363
00:18:21,834 --> 00:18:25,071 position:50%
with the same
render pipeline settings.


364
00:18:25,071 --> 00:18:28,841 position:50%
So in this
newRenderPipelineState function,


365
00:18:28,841 --> 00:18:32,812 line:0
I reuse the pDesc object.


366
00:18:34,814 --> 00:18:38,684 line:0
After clicking on run,
Xcode triggers a breakpoint


367
00:18:38,684 --> 00:18:40,886 line:0
and shows me the stack trace.


368
00:18:40,886 --> 00:18:43,723 line:0
That means
I got something wrong.


369
00:18:43.723 --> 00:18:47.193 line:-1 position:50%
Hm, what's the problem?


370
00:18:47.193 --> 00:18:53.999 line:-1 position:50%
Maybe NSZombie can help here,
so I enable NSZombie in scheme.


371
00:18:57.003 --> 00:19:01.307 line:-1 position:50%
When I run the program again,
NSZombie triggers a breakpoint.


372
00:19:01,307 --> 00:19:04,243 line:-1
I get something new
in the console output:


373
00:19:04,243 --> 00:19:09,181 line:-1
"message sent
to deallocated instance."


374
00:19:09,181 --> 00:19:12,885 line:-1
Oh, I reused an object
that I have already released.


375
00:19:12.885 --> 00:19:16.255 line:-1 position:50%
And it's
the render pipeline descriptor.


376
00:19:16.255 --> 00:19:19.025 line:-1 position:50%
So I need to use this
render pipeline descriptor


377
00:19:19.025 --> 00:19:21.227 line:-1 position:50%
before calling release.


378
00:19:21.227 --> 00:19:24.096 line:-1 position:50%
By doing that,
I fix the problem.


379
00:19:24,096 --> 00:19:28,034 position:50%
More tools and details
are covered in this year's talk,


380
00:19:28,034 --> 00:19:31,270 line:0
"Profile and optimize
your game's memory."


381
00:19:31,270 --> 00:19:34,607 line:0
For example, you can learn
how to track retainCount


382
00:19:34,607 --> 00:19:37,143 line:0
in allocations in instruments.


383
00:19:37,143 --> 00:19:40,546 line:0
Feel free to check out
other tools on Apple platforms.


384
00:19:40,546 --> 00:19:43,449 line:0
You will find out that they
can help you debug your game


385
00:19:43,449 --> 00:19:45,618 position:50%
and improve performance.


386
00:19:45,618 --> 00:19:50,456 line:-1
Now you know how to manage
object lifecycles in metal-cpp.


387
00:19:50,456 --> 00:19:53,492 line:-1
But you may still need to
interface with other frameworks,


388
00:19:53.492 --> 00:19:56.695 line:-1 position:50%
like game controller
and audio.


389
00:19:56,695 --> 00:19:59,231 line:-1
These are still in Objective-C.


390
00:19:59,231 --> 00:20:01,534 line:-1
How can you interface
with those APIs


391
00:20:01.534 --> 00:20:05.704 line:-1 position:50%
and design an elegant
application architecture?


392
00:20:05,704 --> 00:20:09,175 line:-1
Say you wrote a ViewController
in Objective-C,


393
00:20:09.175 --> 00:20:13.279 line:-1 position:50%
but you wrote a renderer in C++
with metal-cpp.


394
00:20:13.279 --> 00:20:16.315 line:-1 position:50%
You need to call renderer
methods, like draw,


395
00:20:16,315 --> 00:20:18,317 line:-1
from the ViewController.


396
00:20:18.317 --> 00:20:22.221 line:-1 position:50%
The challenge here is to nicely
separate the two languages


397
00:20:22.221 --> 00:20:25.624 line:-1 position:50%
but have them work together.


398
00:20:25.624 --> 00:20:29.028 line:-1 position:50%
The solution is to create
an adapter class


399
00:20:29,028 --> 00:20:32,965 line:-1
which calls C++
from Objective-C files.


400
00:20:32.965 --> 00:20:37.136 line:-1 position:50%
By doing this, you can focus
on Objective-C or C++


401
00:20:37.136 --> 00:20:40.439 line:-1 position:50%
in files where
you implement features.


402
00:20:40.439 --> 00:20:41.640 line:-1 position:50%
For example,


403
00:20:41.640 --> 00:20:45.578 line:-1 position:50%
I can create a RendererAdapter
class in Objective-C.


404
00:20:45.578 --> 00:20:48.047 line:-1 position:50%
And down in the implementation,


405
00:20:48.047 --> 00:20:51.450 line:-1 position:50%
I add an Objective-C method
so that I can call it


406
00:20:51,450 --> 00:20:53,886 line:-1
directly from
the ViewController.


407
00:20:53.886 --> 00:20:55.621 line:-1 position:50%
Inside of the interface,


408
00:20:55,621 --> 00:21:00,459 line:-1
I declare a C++ pointer
to a renderer object.


409
00:21:00.459 --> 00:21:02.795 line:-1 position:50%
Inside the body of the method,


410
00:21:02.795 --> 00:21:06.999 line:-1 position:50%
I directly call
the renderer's C++ method.


411
00:21:06.999 --> 00:21:10.002 line:-1 position:50%
This method needs to pass
the MTK::View


412
00:21:10,002 --> 00:21:13,672 line:-1
as a C++ object
into the draw method,


413
00:21:13,672 --> 00:21:18,010 line:-1
so it casts the view
as a C++ type


414
00:21:18.010 --> 00:21:20.112 line:-1 position:50%
by using the __bridge keyword.


415
00:21:20,112 --> 00:21:23,415 line:-1
I'll talk more
about this cast later.


416
00:21:23,415 --> 00:21:27,887 line:-1
In contrast, you need to call
MTKView which is written


417
00:21:27,887 --> 00:21:32,625 line:-1
with Objective-C in Renderer
which is written with C++.


418
00:21:32,625 --> 00:21:35,060 line:-1
It's challenging as well.


419
00:21:35.060 --> 00:21:39.131 line:-1 position:50%
Similarly, the solution
is to create an adapter class.


420
00:21:39.131 --> 00:21:41.967 line:-1 position:50%
With this class, in C++ files,


421
00:21:41.967 --> 00:21:47.039 line:-1 position:50%
you can call Objective-C methods
using C++ interface.


422
00:21:47.039 --> 00:21:50.943 line:-1 position:50%
For example, I can create
a ViewAdapter class.


423
00:21:50.943 --> 00:21:53.879 line:-1 position:50%
I write the interfaces in C++,


424
00:21:53.879 --> 00:21:55.548 line:-1 position:50%
so in the Renderer class,


425
00:21:55.548 --> 00:21:58.918 line:-1 position:50%
I can call those C++
view methods easily.


426
00:21:58,918 --> 00:22:00,553 line:-1
While in the implementation,


427
00:22:00,553 --> 00:22:03,756 line:-1
I call Objective-C methods
from MTKView,


428
00:22:03,756 --> 00:22:08,394 line:-1
including currentDrawable
and depthStencilTexture.


429
00:22:08.394 --> 00:22:11.697 line:-1 position:50%
You may notice there're some
__bridge keywords here.


430
00:22:11.697 --> 00:22:14.400 line:-1 position:50%
I use them to cast between
metal-cpp objects


431
00:22:14,400 --> 00:22:16,402 line:-1
and Objective-C objects.


432
00:22:16.402 --> 00:22:18.003 line:-1 position:50%
As you learned in the beginning,


433
00:22:18.003 --> 00:22:21.440 line:-1 position:50%
metal-cpp objects are manually
retained and released,


434
00:22:21,440 --> 00:22:24,176 line:-1
but objects created
by Objective-C


435
00:22:24,176 --> 00:22:27,046 line:-1
use automatic
reference counting.


436
00:22:27.046 --> 00:22:30.816 line:-1 position:50%
You need to move objects
from MRR to ARC


437
00:22:30.816 --> 00:22:33.786 line:-1 position:50%
and from ARC to MRR.


438
00:22:33.786 --> 00:22:35.521 line:-1 position:50%
Here are three types
of bridge casting


439
00:22:35.521 --> 00:22:39.558 line:-1 position:50%
which can help you cast
between Objective-C and C++.


440
00:22:39,558 --> 00:22:42,561 line:-1
They can also help you
transfer ownership


441
00:22:42.561 --> 00:22:45.464 line:-1 position:50%
_bridge casting casts
between Objective-C


442
00:22:45.464 --> 00:22:47.733 line:-1 position:50%
and metal-cpp objects.


443
00:22:47.733 --> 00:22:52.104 line:-1 position:50%
There is no transfer of
ownership between them.


444
00:22:52.104 --> 00:22:55.741 line:-1 position:50%
__bridge_retained casting
casts an Objective-C pointer


445
00:22:55.741 --> 00:23:00.746 line:-1 position:50%
to a metal-cpp pointer and
takes the ownership from ARC.


446
00:23:00.746 --> 00:23:03.749 line:-1 position:50%
__bridge_transfer casting moves
a metal-cpp pointer


447
00:23:03,749 --> 00:23:07,753 line:-1
to Objective-C and transfers
the ownership to ARC.


448
00:23:07.753 --> 00:23:10.189 line:-1 position:50%
Going back to the problem,
you need to cast


449
00:23:10,189 --> 00:23:13,792 line:-1
between metal-cpp objects
and Objective-C objects.


450
00:23:13.792 --> 00:23:16.262 line:-1 position:50%
If there's no transfer
of ownership,


451
00:23:16.262 --> 00:23:18.731 line:-1 position:50%
you can use __bridge cast.


452
00:23:18.731 --> 00:23:23.002 line:-1 position:50%
If you want to cast from
metal-cpp to Objective-C objects


453
00:23:23.002 --> 00:23:25.704 line:-1 position:50%
and transfer
the ownership to Objective-C,


454
00:23:25.704 --> 00:23:29.074 line:-1 position:50%
you should use
__bridge_transfer cast.


455
00:23:29.074 --> 00:23:32.444 line:-1 position:50%
If you want to cast from
Objective-C to metal-cpp objects


456
00:23:32.444 --> 00:23:34.913 line:-1 position:50%
and take the ownership
out of ARC,


457
00:23:34,913 --> 00:23:37,283 line:-1
you should use
__bridge_retained cast.


458
00:23:37.283 --> 00:23:40.085 line:-1 position:50%
Here's a case when
I have to use MetalKit


459
00:23:40,085 --> 00:23:42,388 line:-1
to leverage
the asset loading code.


460
00:23:42.388 --> 00:23:45.491 line:-1 position:50%
That means in my C++
application,


461
00:23:45,491 --> 00:23:49,161 line:-1
I need a texture
as a metal-cpp object,


462
00:23:49.161 --> 00:23:53.465 line:-1 position:50%
but it is created
by Objective-C methods.


463
00:23:53,465 --> 00:23:57,136 line:-1
I need the ability to transfer
ownership out of ARC


464
00:23:57.136 --> 00:23:59.605 line:-1 position:50%
so I can manually release it.


465
00:23:59,605 --> 00:24:00,839 line:-1
And in this case,


466
00:24:00.839 --> 00:24:06.045 line:-1 position:50%
I need to pick
__bridge_retained cast.


467
00:24:06,045 --> 00:24:10,015 line:0
I have this C++ function that
loads a texture from the catalog


468
00:24:10,015 --> 00:24:13,819 line:0
and I want to return
a metal-cpp texture.


469
00:24:13,819 --> 00:24:16,822 line:0
But inside, I'm calling
some Objective-C functions


470
00:24:16,822 --> 00:24:19,758 position:50%
in MetalKit.


471
00:24:19,758 --> 00:24:23,929 position:50%
I need to define the options
that a texture loader needs.


472
00:24:23,929 --> 00:24:29,068 line:0
Then I create a texture loader
by calling an Objective-C method


473
00:24:29,068 --> 00:24:31,170 line:0
from MetalKit.


474
00:24:31,170 --> 00:24:35,474 line:0
With that loader,
I can create a texture object


475
00:24:35,474 --> 00:24:38,377 position:50%
and load a texture
from the catalog.


476
00:24:38,377 --> 00:24:41,347 position:50%
This method is also
an Objective-C method


477
00:24:41,347 --> 00:24:43,215 position:50%
from MetalKit.


478
00:24:43,215 --> 00:24:46,452 position:50%
Now I have
an Objective-C type texture,


479
00:24:46,452 --> 00:24:49,922 line:0
I need to cast it
to the metal-cpp object


480
00:24:49,922 --> 00:24:52,191 line:0
and take it out of ARC.


481
00:24:52.191 --> 00:24:54.993 line:-1 position:50%
With these steps in mind,
it's time to code,


482
00:24:54.993 --> 00:24:58.664 line:-1 position:50%
and I'll show you
how casting works in practice.


483
00:24:58,664 --> 00:25:01,667 line:-1
First step is to define
the texture loader options


484
00:25:01.667 --> 00:25:03.902 line:-1 position:50%
that a texture loader needs.


485
00:25:03.902 --> 00:25:07.806 line:-1 position:50%
I can safely cast the metal-cpp
storage mode and usage


486
00:25:07,806 --> 00:25:09,742 line:-1
to the Objective-C type,


487
00:25:09,742 --> 00:25:13,946 line:-1
as the metal-cpp type
defines them to the same values.


488
00:25:13,946 --> 00:25:16,849 line:-1
Here I create a texture loader.


489
00:25:16.849 --> 00:25:20.252 line:-1 position:50%
I have a device that
is a metal-cpp object,


490
00:25:20.252 --> 00:25:24.757 line:-1 position:50%
and I need to pass it
to the initWithDevice method.


491
00:25:24,757 --> 00:25:28,961 line:-1
Because the metal-cpp object
is an Objective-C object,


492
00:25:28,961 --> 00:25:31,730 line:-1
I can cast it
like a toll-free object.


493
00:25:31,730 --> 00:25:35,200 position:50%
There is no transfer
of ownership.


494
00:25:35,200 --> 00:25:37,302 line:0
Now I use
the texture loader options


495
00:25:37,302 --> 00:25:39,938 line:0
and a texture loader
to create a texture.


496
00:25:39,938 --> 00:25:44,476 line:0
And I want to return the loaded
texture as a metal-cpp object.


497
00:25:44,476 --> 00:25:46,812 line:0
So I need
to take it out of ARC


498
00:25:46,812 --> 00:25:50,616 position:50%
and cast it to the corresponding
pointer type.


499
00:25:50,616 --> 00:25:53,252 line:0
This is done with
a __bridge_retained cast.


500
00:25:53,252 --> 00:25:55,287 position:50%
After this,
I can use this texture


501
00:25:55,287 --> 00:25:57,423 line:0
as any metal-cpp object.


502
00:25:57,423 --> 00:26:00,025 line:0
I am responsible
for releasing it.


503
00:26:00.025 --> 00:26:03.929 line:-1 position:50%
In this section,
I provided an adapter pattern


504
00:26:03.929 --> 00:26:06.432 line:-1 position:50%
which can help you handle
two different languages


505
00:26:06,432 --> 00:26:08,300 line:-1
in your program.


506
00:26:08.300 --> 00:26:13.038 line:-1 position:50%
I also showed how to interface
with Objective-C and C++


507
00:26:13,038 --> 00:26:15,174 line:-1
with three types of casts.


508
00:26:15,174 --> 00:26:18,710 line:-1
To summarize,
metal-cpp is a lightweight


509
00:26:18.710 --> 00:26:22.581 line:-1 position:50%
and very efficient
Metal C++ wrapper.


510
00:26:22,581 --> 00:26:26,285 line:-1
I talked about how to manage
object lifecycles


511
00:26:26,285 --> 00:26:29,021 line:-1
when using metal-cpp,


512
00:26:29.021 --> 00:26:31.557 line:-1 position:50%
how to interface
with Objective-C


513
00:26:31.557 --> 00:26:32.958 line:-1 position:50%
in an elegant manner,


514
00:26:32.958 --> 00:26:37.162 line:-1 position:50%
and how our developer tools
can help you debug.


515
00:26:37.162 --> 00:26:41.567 line:-1 position:50%
Download metal-cpp and play with
all the amazing samples now!


516
00:26:41.567 --> 00:26:44.203 line:-1 position:50%
See what you can create
with Metal.


517
00:26:44,203 --> 00:26:47,206 line:-1
We look forward to seeing
your C++ applications


518
00:26:47,206 --> 00:26:49,575 line:-1
running across
all Apple platforms.


519
00:26:49,575 --> 00:26:51,410 line:-1
Thanks for watching!


520
00:26:51,410 --> 00:26:55,614 align:right position:90% line:0
♪

