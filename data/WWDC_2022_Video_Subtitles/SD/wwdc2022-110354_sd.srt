2
00:00:00.000 --> 00:00:03.003 line:-1 position:50%
♪ Mellow instrumental
hip-hop music ♪


3
00:00:03,003 --> 00:00:09,810 position:90% size:2% line:0
♪


4
00:00:09,810 --> 00:00:11,545 line:-1
Hi, I'm Angela.


5
00:00:11.545 --> 00:00:13.413 line:-1 position:50%
And I'm Becca.


6
00:00:13,413 --> 00:00:15,415 line:-1
Welcome
to what's new in Swift!


7
00:00:15.415 --> 00:00:17.317 line:-1 position:50%
We're really excited
to talk to you today


8
00:00:17.317 --> 00:00:21.154 line:-1 position:50%
about all of the great
new features in Swift 5.7.


9
00:00:21,154 --> 00:00:22,956 line:-1
Many of the things
we'll talk about today


10
00:00:22.956 --> 00:00:28.195 line:-1 position:50%
demonstrate Swift's goal to make
your life as a developer easier.


11
00:00:28.195 --> 00:00:29.429 line:-1 position:50%
We'll look at new tooling


12
00:00:29,429 --> 00:00:31,732 line:-1
to help you customize
your workflow


13
00:00:31.732 --> 00:00:35.569 line:-1 position:50%
and some amazing
under-the-hood improvements.


14
00:00:35,569 --> 00:00:38,772 line:-1
Then we'll talk about the latest
in Swift's concurrency model


15
00:00:38.772 --> 00:00:43.243 line:-1 position:50%
and the road to Swift 6,
including full-thread safety.


16
00:00:43.243 --> 00:00:44.912 line:-1 position:50%
Then I'll finish up
by taking you through


17
00:00:44.912 --> 00:00:47.447 line:-1 position:50%
some language improvements
that make Swift easier to read


18
00:00:47,447 --> 00:00:50,784 line:-1
and write, including cleaner,
simpler generics,


19
00:00:50.784 --> 00:00:54.688 line:-1 position:50%
and powerful new
string processing facilities.


20
00:00:54.688 --> 00:00:57.424 line:-1 position:50%
But first,
let's start by talking about


21
00:00:57.424 --> 00:01:01.228 line:-1 position:50%
one of the things
that makes Swift so special --


22
00:01:01.228 --> 00:01:02.763 line:-1 position:50%
all of you.


23
00:01:02.763 --> 00:01:05.499 line:-1 position:50%
Your input and contributions
are what have enabled Swift


24
00:01:05,499 --> 00:01:08,268 line:-1
to expand so rapidly.


25
00:01:08.268 --> 00:01:11.038 line:-1 position:50%
Community involvement
is at Swift's core.


26
00:01:11.038 --> 00:01:14.174 line:-1 position:50%
This year, more of the Swift
project became available


27
00:01:14,174 --> 00:01:16,209 line:-1
to the community when docC --


28
00:01:16.209 --> 00:01:19.446 line:-1 position:50%
the documentation generation
tool announced last year --


29
00:01:19.446 --> 00:01:23.150 line:-1 position:50%
and the Swift.org website
were open sourced.


30
00:01:23.150 --> 00:01:24.651 line:-1 position:50%
Open source works best


31
00:01:24.651 --> 00:01:28.889 line:-1 position:50%
when you have an active
community shepherding it.


32
00:01:28,889 --> 00:01:31,591 line:-1
We've been using the workgroup
model for Swift on Server


33
00:01:31,591 --> 00:01:34,528 line:-1
and Diversity in Swift
to provide stewardship


34
00:01:34.528 --> 00:01:36.196 line:-1 position:50%
and support
for community members


35
00:01:36.196 --> 00:01:38.732 line:-1 position:50%
interested in specific areas.


36
00:01:38,732 --> 00:01:40,400 line:-1
This has been working
really well


37
00:01:40,400 --> 00:01:42,336 line:-1
so we've started
two new workgroups.


38
00:01:42.336 --> 00:01:44.171 line:-1 position:50%
One for iterating
on the Swift website


39
00:01:44,171 --> 00:01:46,340 line:-1
and making it more
of a community resource,


40
00:01:46.340 --> 00:01:49.409 line:-1 position:50%
and another
for C++ interoperability,


41
00:01:49.409 --> 00:01:54.581 line:-1 position:50%
to shape the design of the model
between C++ and Swift.


42
00:01:54,581 --> 00:01:57,551 line:-1
As we venture into new areas,
we all need support


43
00:01:57,551 --> 00:02:00,020 line:-1
from members
within the community.


44
00:02:00,020 --> 00:02:02,856 line:-1
As a part of that, the
Diversity in Swift workgroup


45
00:02:02,856 --> 00:02:05,792 line:-1
introduced the Swift
Mentorship Program last year.


46
00:02:05,792 --> 00:02:07,427 line:-1
The program provides pathways


47
00:02:07,427 --> 00:02:09,563 line:-1
to contribute to all
of the workgroup areas


48
00:02:09.563 --> 00:02:11.398 line:-1 position:50%
for folks who don't know
how to start


49
00:02:11,398 --> 00:02:15,869 line:-1
or are looking to deepen their
expertise in a particular area.


50
00:02:15,869 --> 00:02:18,805 line:-1
Last year's program
was a huge success.


51
00:02:18.805 --> 00:02:21.708 line:-1 position:50%
There were a lot
of interested mentees;


52
00:02:21.708 --> 00:02:25.912 line:-1 position:50%
and with that, we were able
to create 41 mentorship pairs.


53
00:02:25.912 --> 00:02:29.082 line:-1 position:50%
This success is why the program
is being brought back


54
00:02:29.082 --> 00:02:30.617 line:-1 position:50%
for year two.


55
00:02:30.617 --> 00:02:32.419 line:-1 position:50%
The program would love
to include everyone


56
00:02:32.419 --> 00:02:35.655 line:-1 position:50%
who's interested;
but to do that, we need you --


57
00:02:35,655 --> 00:02:38,792 line:-1
the excited and experienced
developers listening now


58
00:02:38.792 --> 00:02:40.827 line:-1 position:50%
who are ready to share
their breadth of knowledge


59
00:02:40.827 --> 00:02:42.763 line:-1 position:50%
and make new connections.


60
00:02:42,763 --> 00:02:45,599 line:-1
Because the mentorship program
is not just about the code


61
00:02:45,599 --> 00:02:49,002 line:-1
but about building relationships
within the community.


62
00:02:49,002 --> 00:02:52,005 line:-1
And a little guidance
can have a lasting effect.


63
00:02:52,005 --> 00:02:54,641 line:-1
Don't just take my word for it.


64
00:02:54,641 --> 00:02:58,045 position:50%
Last year, Amrit participated
in the mentorship program


65
00:02:58,045 --> 00:03:00,847 position:50%
and focused on compiler
and language design.


66
00:03:00,847 --> 00:03:02,749 position:50%
What started off
as intrigue for Amrit


67
00:03:02,749 --> 00:03:06,019 line:0
transformed into
tangible contributions.


68
00:03:06,019 --> 00:03:09,056 line:0
Diving into a new domain
is not easy.


69
00:03:09,056 --> 00:03:12,092 position:50%
Even so, she walked away
finding success


70
00:03:12,092 --> 00:03:14,828 line:0
and feeling inspired
to contribute more.


71
00:03:14,828 --> 00:03:16,229 line:0
Like many others,


72
00:03:16,229 --> 00:03:19,499 line:0
this experience
opened a door for Amrit.


73
00:03:19.499 --> 00:03:22.202 line:-1 position:50%
In addition to compiler
and language design,


74
00:03:22,202 --> 00:03:26,339 line:-1
last year there were a wide
range of available focus areas,


75
00:03:26.339 --> 00:03:28.008 line:-1 position:50%
from technical writing
and testing


76
00:03:28,008 --> 00:03:30,744 line:-1
to contributing
to Swift packages.


77
00:03:30.744 --> 00:03:33.080 line:-1 position:50%
This year,
we're adding even more


78
00:03:33,080 --> 00:03:36,116 line:-1
and there's always opportunities
for new topics.


79
00:03:36.116 --> 00:03:39.252 line:-1 position:50%
If you don't see something
in this list that interests you,


80
00:03:39.252 --> 00:03:42.255 line:-1 position:50%
you can still mention it
in your application.


81
00:03:42.255 --> 00:03:45.425 line:-1 position:50%
Another addition is that
this year's program will offer


82
00:03:45.425 --> 00:03:48.261 line:-1 position:50%
mentorship year-round
for starter bug contributions


83
00:03:48,261 --> 00:03:50,730 line:-1
to help accommodate anyone
who may have a lower capacity


84
00:03:50.730 --> 00:03:54.734 line:-1 position:50%
to participate but is still
excited to get involved.


85
00:03:54.734 --> 00:03:56.503 line:-1 position:50%
If you're interested
in applying,


86
00:03:56,503 --> 00:03:58,238 line:-1
or just eager to hear more,


87
00:03:58,238 --> 00:04:00,474 line:-1
check out the most
recent Swift blog post.


88
00:04:00.474 --> 00:04:02.809 line:-1 position:50%
There, you can find links
to detailed reflections


89
00:04:02.809 --> 00:04:05.512 line:-1 position:50%
from the highlighted mentees.


90
00:04:05,512 --> 00:04:08,048 line:-1
The mentorship program
is just one initiative


91
00:04:08.048 --> 00:04:10.717 line:-1 position:50%
under Diversity in Swift
umbrella.


92
00:04:10,717 --> 00:04:12,552 line:-1
To learn more about
the mentorship program


93
00:04:12.552 --> 00:04:14.754 line:-1 position:50%
and other Diversity in Swift
efforts,


94
00:04:14.754 --> 00:04:17.691 line:-1 position:50%
you can visit
Swift.org/diversity.


95
00:04:17.691 --> 00:04:20.494 line:-1 position:50%
To open the door even further,
we want to make it


96
00:04:20.494 --> 00:04:24.965 line:-1 position:50%
as easy as possible to use Swift
with the resources you have!


97
00:04:24,965 --> 00:04:27,868 line:-1
We have streamlined the Swift
toolchain distribution process


98
00:04:27,868 --> 00:04:29,269 line:-1
for the Linux platform


99
00:04:29,269 --> 00:04:32,072 line:-1
by adding support
for Linux package formats.


100
00:04:32,072 --> 00:04:33,940 line:-1
With the new native
toolchain installers,


101
00:04:33.940 --> 00:04:37.110 line:-1 position:50%
you can now download RPMs
for Amazon Linux 2


102
00:04:37.110 --> 00:04:40.380 line:-1 position:50%
and CentOS 7
directly from Swift.org.


103
00:04:40,380 --> 00:04:42,115 line:-1
These toolchains
are experimental,


104
00:04:42,115 --> 00:04:45,418 line:-1
so be sure to share feedback
on the Swift.org forums.


105
00:04:45,418 --> 00:04:48,155 line:-1
Swift is primarily used
for building apps.


106
00:04:48.155 --> 00:04:52.626 line:-1 position:50%
However, the vision has always
been for Swift to be scalable --


107
00:04:52.626 --> 00:04:54.661 line:-1 position:50%
used from everything
from high-level scripts


108
00:04:54.661 --> 00:04:57.531 line:-1 position:50%
down to bare-metal environments.


109
00:04:57.531 --> 00:04:58.932 line:-1 position:50%
To encourage Swift to be used


110
00:04:58.932 --> 00:05:01.234 line:-1 position:50%
where it's never
been used before,


111
00:05:01,234 --> 00:05:04,171 line:-1
Swift underwent some
major changes this year.


112
00:05:04.171 --> 00:05:05.705 line:-1 position:50%
To make the standard
library smaller


113
00:05:05,705 --> 00:05:08,441 line:-1
for standalone,
statically linked binaries,


114
00:05:08.441 --> 00:05:09.943 line:-1 position:50%
we dropped the dependency


115
00:05:09.943 --> 00:05:12.445 line:-1 position:50%
on an external
Unicode support library,


116
00:05:12,445 --> 00:05:17,384 line:-1
replacing it with a faster
native implementation.


117
00:05:17,384 --> 00:05:20,187 line:-1
Smaller, faster binaries
are a huge benefit


118
00:05:20.187 --> 00:05:22.756 line:-1 position:50%
when running on
event-driven server solutions.


119
00:05:22.756 --> 00:05:24.925 line:-1 position:50%
You get static linking
on Linux by default


120
00:05:24,925 --> 00:05:28,595 line:-1
to better support containerized
deployments for the server.


121
00:05:28.595 --> 00:05:30.530 line:-1 position:50%
This size reduction
makes Swift suitable


122
00:05:30,530 --> 00:05:32,432 line:-1
for even restricted
environments,


123
00:05:32.432 --> 00:05:33.633 line:-1 position:50%
which allowed us to use it


124
00:05:33.633 --> 00:05:36.269 line:-1 position:50%
in Apple's
Secure Enclave Processor.


125
00:05:36.269 --> 00:05:38.738 line:-1 position:50%
Swift is useful
from apps to servers


126
00:05:38.738 --> 00:05:41.675 line:-1 position:50%
all the way down
to restricted processors;


127
00:05:41,675 --> 00:05:46,713 line:-1
tying it all together
is the package ecosystem.


128
00:05:46.713 --> 00:05:48.782 line:-1 position:50%
This year's new features
in Swift packages


129
00:05:48.782 --> 00:05:50.584 line:-1 position:50%
will make your life better.


130
00:05:50.584 --> 00:05:55.655 line:-1 position:50%
To start, Swift Package Manager
has introduced TOFU.


131
00:05:55,655 --> 00:05:58,592 line:-1
No, not the delicious snack.


132
00:05:58,592 --> 00:06:01,928 line:-1
TOFU is an acronym that stands
for Trust On First Use.


133
00:06:01,928 --> 00:06:04,231 line:-1
It's a new security protocol
where the fingerprint


134
00:06:04.231 --> 00:06:06.066 line:-1 position:50%
of a package
is now being recorded


135
00:06:06,066 --> 00:06:08,468 line:-1
when the package
is first downloaded.


136
00:06:08,468 --> 00:06:11,037 line:-1
Subsequent downloads
will validate this fingerprint


137
00:06:11,037 --> 00:06:14,674 line:-1
and report an error if
the fingerprints are different.


138
00:06:14,674 --> 00:06:17,377 line:-1
This is just one example
of how trust and security


139
00:06:17.377 --> 00:06:20.146 line:-1 position:50%
are built into the core
of the package ecosystem


140
00:06:20.146 --> 00:06:23.383 line:-1 position:50%
to help you feel
confident using it.


141
00:06:23,383 --> 00:06:26,353 line:-1
Command plug-ins are a great way
to improve the workflow


142
00:06:26,353 --> 00:06:28,288 line:-1
for Swift developers.


143
00:06:28,288 --> 00:06:30,657 line:-1
They are the first step
in providing more extensible


144
00:06:30,657 --> 00:06:32,926 line:-1
and secure build tools.


145
00:06:32.926 --> 00:06:35.962 line:-1 position:50%
Command plug-ins can be used
for documentation generation,


146
00:06:35,962 --> 00:06:38,632 line:-1
source code reformatting
and more.


147
00:06:38,632 --> 00:06:41,067 line:-1
Instead of writing your
automation in a shell script


148
00:06:41.067 --> 00:06:44.437 line:-1 position:50%
and having to maintain separate
workflows, you can use Swift!


149
00:06:44,437 --> 00:06:46,906 line:-1
Think open source
formatters and linters.


150
00:06:46,906 --> 00:06:50,644 line:-1
Now, all of those open source
tools are available within Xcode


151
00:06:50,644 --> 00:06:53,947 line:-1
and Swift Package Manager.


152
00:06:53,947 --> 00:06:57,050 line:-1
Command plug-ins are the glue
between open source tools


153
00:06:57.050 --> 00:06:58.818 line:-1 position:50%
and Swift Package Manager.


154
00:06:58.818 --> 00:07:01.054 line:-1 position:50%
The Swift project
is embracing developer tools


155
00:07:01.054 --> 00:07:03.957 line:-1 position:50%
in the open source community
to provide seamless integration


156
00:07:03.957 --> 00:07:06.693 line:-1 position:50%
with your automated workflows.


157
00:07:06,693 --> 00:07:09,296 line:-1
docC is great tool
to integrate documentation


158
00:07:09,296 --> 00:07:10,697 line:-1
into your source code.


159
00:07:10.697 --> 00:07:14.734 line:-1 position:50%
This year, it got even better
with Objective-C and C support.


160
00:07:14,734 --> 00:07:16,536 line:-1
Let's take a look
at what it would take


161
00:07:16.536 --> 00:07:19.072 line:-1 position:50%
to create a plug-in
with docC.


162
00:07:19.072 --> 00:07:20.907 line:-1 position:50%
Plug-ins are just
simple Swift code.


163
00:07:20.907 --> 00:07:23.109 line:-1 position:50%
You can define a plug-in
by creating a struct


164
00:07:23.109 --> 00:07:25.478 line:-1 position:50%
that conforms to
the CommandPlugin protocol.


165
00:07:25.478 --> 00:07:28.014 line:-1 position:50%
And then you just add a function
that tells your plug-in


166
00:07:28,014 --> 00:07:30,250 line:-1
which tool you'd like to invoke.


167
00:07:30.250 --> 00:07:34.454 line:-1 position:50%
Within this function
is where we want to call docC.


168
00:07:34.454 --> 00:07:37.290 line:-1 position:50%
Once you've defined your
plug-in, it becomes available


169
00:07:37,290 --> 00:07:39,025 line:-1
through the Swift PM
command line interface


170
00:07:39,025 --> 00:07:40,927 line:-1
and Xcode as a menu entry.


171
00:07:40.927 --> 00:07:44.364 line:-1 position:50%
Now, we can tell Swift PM
to generate documentation


172
00:07:44,364 --> 00:07:48,568 line:-1
and it knows to pass this action
to the docC executable.


173
00:07:48,568 --> 00:07:50,337 line:-1
It doesn't stop there.


174
00:07:50,337 --> 00:07:54,240 line:-1
There's a second plug-in
known as build tool plug-ins.


175
00:07:54,240 --> 00:07:56,376 line:-1
These plug-ins
are packages that allow you


176
00:07:56,376 --> 00:07:59,245 line:-1
to inject additional steps
during the build.


177
00:07:59,245 --> 00:08:01,381 line:0
When you implement
a build tool plug-in,


178
00:08:01,381 --> 00:08:02,982 line:0
that will create a command
for the build system


179
00:08:02,982 --> 00:08:05,085 line:0
to execute in a sandbox.


180
00:08:05,085 --> 00:08:06,786 position:50%
They differ from
command plug-ins


181
00:08:06,786 --> 00:08:09,089 position:50%
which you execute
directly at any time


182
00:08:09,089 --> 00:08:11,224 position:50%
and can be granted
explicit permission


183
00:08:11,224 --> 00:08:13,993 line:0
to change files in your package.


184
00:08:13,993 --> 00:08:16,996 position:50%
Build tool plug-ins can be used
for source code generation


185
00:08:16,996 --> 00:08:20,233 line:0
or custom processing
for special types of files.


186
00:08:20.233 --> 00:08:23.570 line:-1 position:50%
With build tool plug-ins, this
would be the package layout.


187
00:08:23,570 --> 00:08:25,839 line:-1
In this example,
the plugin.Swift


188
00:08:25,839 --> 00:08:27,607 line:-1
is the Swift script
that implements


189
00:08:27,607 --> 00:08:29,142 line:-1
the package plug-in target.


190
00:08:29.142 --> 00:08:33.480 line:-1 position:50%
The plug-in is treated
as a Swift executable.


191
00:08:33,480 --> 00:08:35,482 line:-1
And you write the plug-in
in the same way


192
00:08:35,482 --> 00:08:38,852 line:-1
you write any
Swift executable.


193
00:08:38.852 --> 00:08:40.653 line:-1 position:50%
You can implement
your plug-in by defining


194
00:08:40.653 --> 00:08:43.456 line:-1 position:50%
a set of build commands
that tells the build system


195
00:08:43.456 --> 00:08:46.559 line:-1 position:50%
what executable command to run
and what outputs are expected


196
00:08:46.559 --> 00:08:48.294 line:-1 position:50%
as a result.


197
00:08:48,294 --> 00:08:50,630 line:-1
Package plug-ins
are secure solutions


198
00:08:50.630 --> 00:08:53.366 line:-1 position:50%
that provide extensibility
in your packages.


199
00:08:53,366 --> 00:08:55,702 position:50%
You can learn more
about how plug-ins work


200
00:08:55,702 --> 00:08:58,705 position:50%
and how to implement your own
plug-in, in two sessions,


201
00:08:58,705 --> 00:09:00,206 line:0
"Meet Swift Package plugins"


202
00:09:00,206 --> 00:09:03,410 line:0
and "Create Swift Package
plugins."


203
00:09:03,410 --> 00:09:05,545 line:0
As you expand
your use of packages,


204
00:09:05,545 --> 00:09:08,681 line:0
you might have encountered
module collisions.


205
00:09:08,681 --> 00:09:10,283 position:50%
That's when two
separate packages


206
00:09:10,283 --> 00:09:12,786 position:50%
define a module
with the same name.


207
00:09:12,786 --> 00:09:14,320 line:0
To solve this situation,


208
00:09:14,320 --> 00:09:19,225 line:0
Swift 5.7 introduces
module disambiguation.


209
00:09:19.225 --> 00:09:22.896 line:-1 position:50%
Module disambiguation
is a feature that allows you


210
00:09:22,896 --> 00:09:26,900 line:-1
to rename modules from outside
the packages that define them.


211
00:09:26.900 --> 00:09:28.902 line:-1 position:50%
Here in our
Stunning application,


212
00:09:28.902 --> 00:09:31.905 line:-1 position:50%
we're bringing in two packages
that define a Logging module,


213
00:09:31.905 --> 00:09:33.139 line:-1 position:50%
so they clash.


214
00:09:33,139 --> 00:09:35,909 line:0
To fix this for
our Stunning application,


215
00:09:35,909 --> 00:09:38,545 position:50%
you'll just need to add
the moduleAliases keyword


216
00:09:38,545 --> 00:09:42,949 position:50%
to the dependencies section
of your package manifest.


217
00:09:42.949 --> 00:09:44.717 line:-1 position:50%
That way you can use
two different names


218
00:09:44,717 --> 00:09:46,519 line:-1
to distinguish between modules


219
00:09:46,519 --> 00:09:49,456 line:-1
that previously had
the same name.


220
00:09:49,456 --> 00:09:53,560 line:-1
Swift 5.7 brings some fantastic
performance improvements.


221
00:09:53,560 --> 00:09:56,129 line:-1
Let's start
by looking at build times.


222
00:09:56,129 --> 00:09:58,698 line:-1
Last year, we told you
about how we had rewritten


223
00:09:58.698 --> 00:10:00.633 line:-1 position:50%
the Swift Driver --
the program that coordinates


224
00:10:00,633 --> 00:10:04,103 line:-1
the compilation
of Swift source code in Swift.


225
00:10:04,103 --> 00:10:05,371 line:-1
Last year's rearchitecture


226
00:10:05,371 --> 00:10:07,140 line:-1
unlocked some really
important changes


227
00:10:07,140 --> 00:10:09,442 line:-1
that speed up builds
significantly.


228
00:10:09.442 --> 00:10:11.611 line:-1 position:50%
The driver can now be used
as a framework


229
00:10:11.611 --> 00:10:13.746 line:-1 position:50%
directly inside
the Xcode build system


230
00:10:13.746 --> 00:10:16.316 line:-1 position:50%
instead of
as a separate executable.


231
00:10:16,316 --> 00:10:18,451 line:-1
This allows it to coordinate
builds more closely


232
00:10:18.451 --> 00:10:22.622 line:-1 position:50%
with the build system to allow
things like parallelization.


233
00:10:22,622 --> 00:10:25,124 position:50%
If you're someone who loves
the sound of quick builds,


234
00:10:25,124 --> 00:10:26,893 line:0
you can get
more details in the


235
00:10:26,893 --> 00:10:31,030 line:0
"Demystify parallelization
in Xcode builds" session.


236
00:10:31,030 --> 00:10:33,132 line:0
To show you
how much faster builds are,


237
00:10:33,132 --> 00:10:36,002 position:50%
let's look at some examples
of how long it takes to build


238
00:10:36,002 --> 00:10:39,305 position:50%
some of the tools we use often
that are written in Swift.


239
00:10:39,305 --> 00:10:41,841 line:0
On a 10-core iMac,
the improvements have ranged


240
00:10:41,841 --> 00:10:46,579 position:50%
from 5 percent
all the way up to 25 percent.


241
00:10:46.579 --> 00:10:49.883 line:-1 position:50%
Next, there are improvements
to the speed of type checking.


242
00:10:49.883 --> 00:10:52.585 line:-1 position:50%
This year, we improved
the type-checker performance


243
00:10:52.585 --> 00:10:56.155 line:-1 position:50%
by reimplementing a key part
of the generics system --


244
00:10:56.155 --> 00:10:58.191 line:-1 position:50%
the part that computes
a function signature


245
00:10:58.191 --> 00:11:00.727 line:-1 position:50%
from things like protocols
and "where" clauses.


246
00:11:00,727 --> 00:11:03,530 line:-1
In the old implementation,
time and memory usage


247
00:11:03.530 --> 00:11:07.166 line:-1 position:50%
could scale exponentially
as more protocols were involved.


248
00:11:07,166 --> 00:11:10,870 line:-1
For example, here, we have
a complicated set of protocols


249
00:11:10,870 --> 00:11:13,339 line:-1
that define a coordinate system,
with a lot


250
00:11:13.339 --> 00:11:16.576 line:-1 position:50%
of generic requirements
on the many associated types.


251
00:11:16.576 --> 00:11:20.713 line:-1 position:50%
Previously, this would take 17
seconds to type-check this code.


252
00:11:20,713 --> 00:11:24,217 line:-1
But now, in Swift 5.7,
this example is able


253
00:11:24,217 --> 00:11:28,888 line:-1
to type-check significantly
quicker, in under a second.


254
00:11:28.888 --> 00:11:32.825 line:-1 position:50%
We also have some equally
impressive runtime improvements.


255
00:11:32,825 --> 00:11:36,629 line:-1
Before Swift 5.7, we've seen
protocol checking on app startup


256
00:11:36.629 --> 00:11:39.632 line:-1 position:50%
take as long
as four seconds on iOS.


257
00:11:39.632 --> 00:11:42.969 line:-1 position:50%
Protocols needed to be computed
every time we launched apps,


258
00:11:42.969 --> 00:11:44.771 line:-1 position:50%
resulting in launch times
that got longer


259
00:11:44,771 --> 00:11:46,739 line:-1
the more protocols you added.


260
00:11:46.739 --> 00:11:48.708 line:-1 position:50%
Now, they're cached.


261
00:11:48.708 --> 00:11:50.643 line:-1 position:50%
Depending on how an app
was written


262
00:11:50.643 --> 00:11:52.679 line:-1 position:50%
and how many protocols it used,


263
00:11:52,679 --> 00:11:55,715 line:-1
this can mean launch times
being cut in half in some apps


264
00:11:55,715 --> 00:11:58,051 line:-1
when running on iOS 16.


265
00:11:58,051 --> 00:12:01,220 position:50%
The session "Improve app size
and runtime performance"


266
00:12:01,220 --> 00:12:03,356 line:0
will dive deeper
into how you can leverage


267
00:12:03,356 --> 00:12:07,160 position:50%
these improvements
in your own application.


268
00:12:07,160 --> 00:12:09,629 line:-1
Now, it's time for something
I'm sure a lot of you


269
00:12:09,629 --> 00:12:12,332 line:-1
have been eager to hear about.


270
00:12:12,332 --> 00:12:15,902 line:-1
Last year, we introduced
the new concurrency model,


271
00:12:15,902 --> 00:12:19,439 line:-1
bringing together actors
and async/await.


272
00:12:19,439 --> 00:12:23,409 line:-1
This had a transformative effect
on the concurrency architecture


273
00:12:23,409 --> 00:12:25,078 line:-1
of your applications.


274
00:12:25.078 --> 00:12:29.515 line:-1 position:50%
Async/await and actors are safer
and easier than callbacks


275
00:12:29,515 --> 00:12:31,718 line:-1
and manual queue management.


276
00:12:31,718 --> 00:12:34,220 line:-1
This year, we further
fleshed out the model


277
00:12:34.220 --> 00:12:37.423 line:-1 position:50%
with data race safety
at the forefront.


278
00:12:37.423 --> 00:12:39.559 line:-1 position:50%
Because concurrency
was such a fundamental


279
00:12:39.559 --> 00:12:41.928 line:-1 position:50%
and important improvement
to your app's codebase,


280
00:12:41.928 --> 00:12:44.430 line:-1 position:50%
we made it possible
to back-deploy these changes


281
00:12:44,430 --> 00:12:48,201 line:-1
all the way back to iOS 13
and macOS Catalina.


282
00:12:48.201 --> 00:12:50.503 line:-1 position:50%
In order to deploy
to older operating systems,


283
00:12:50,503 --> 00:12:54,207 line:-1
your app bundles a copy of the
Swift 5.5 concurrency runtime


284
00:12:54,207 --> 00:12:55,975 line:-1
for older OSes.


285
00:12:55,975 --> 00:12:58,177 line:-1
This is similar
to back-deploying Swift


286
00:12:58,177 --> 00:13:01,914 line:-1
to operating systems
before ABI stability.


287
00:13:01.914 --> 00:13:05.151 line:-1 position:50%
Next, we've taken this model
in new directions.


288
00:13:05.151 --> 00:13:06.586 line:-1 position:50%
We've introduced
language features


289
00:13:06,586 --> 00:13:08,521 line:-1
and supporting packages.


290
00:13:08.521 --> 00:13:12.759 line:-1 position:50%
First, let's talk about
data race avoidance.


291
00:13:12.759 --> 00:13:14.027 line:-1 position:50%
Before I jump into that,


292
00:13:14.027 --> 00:13:15.728 line:-1 position:50%
I should probably
take a step back


293
00:13:15.728 --> 00:13:18.498 line:-1 position:50%
and say that one of the really
important features of Swift,


294
00:13:18.498 --> 00:13:20.867 line:-1 position:50%
is memory safety by default.


295
00:13:20,867 --> 00:13:23,870 line:-1
Swift users can't do things
with unpredictable behavior,


296
00:13:23.870 --> 00:13:25.071 line:-1 position:50%
like reading a value


297
00:13:25.071 --> 00:13:27.573 line:-1 position:50%
while you're in the middle
of modifying it.


298
00:13:27.573 --> 00:13:31.277 line:-1 position:50%
In this example, we're removing
all of the numbers in an array


299
00:13:31.277 --> 00:13:33.446 line:-1 position:50%
that match
the same array's count.


300
00:13:33,446 --> 00:13:36,182 line:-1
Initially,
the array's count is 3,


301
00:13:36,182 --> 00:13:38,985 line:-1
so we'll remove
the 3 from the array.


302
00:13:38.985 --> 00:13:41.954 line:-1 position:50%
But once we've done that,
the count will be 2.


303
00:13:41,954 --> 00:13:44,524 line:-1
Do we remove the 3
and the 2 from the array,


304
00:13:44,524 --> 00:13:46,526 line:-1
or just the 3?


305
00:13:46,526 --> 00:13:48,327 line:-1
The answer is neither.


306
00:13:48,327 --> 00:13:50,163 line:-1
Swift will prevent you
from doing this


307
00:13:50.163 --> 00:13:52.865 line:-1 position:50%
because it's not safe
to access the array's count


308
00:13:52.865 --> 00:13:55.435 line:-1 position:50%
while you're in the middle
of modifying it.


309
00:13:55,435 --> 00:13:58,838 line:-1
Our goal is to do something
similar for thread safety.


310
00:13:58,838 --> 00:14:00,073 line:-1
We envision a language


311
00:14:00.073 --> 00:14:03.376 line:-1 position:50%
that eliminates low-level
data races by default.


312
00:14:03,376 --> 00:14:06,379 line:-1
In other words, we want
to prevent concurrency bugs


313
00:14:06.379 --> 00:14:09.215 line:-1 position:50%
that can cause
unpredictable behavior.


314
00:14:09,215 --> 00:14:10,950 line:-1
Here's another example.


315
00:14:10.950 --> 00:14:14.620 line:-1 position:50%
Using the same number's array,
we create a background task


316
00:14:14,620 --> 00:14:17,223 line:-1
that appends 0 to the array,


317
00:14:17,223 --> 00:14:20,560 line:-1
and then we remove
the array's last element.


318
00:14:20,560 --> 00:14:23,062 line:-1
But wait, does removing
the last element


319
00:14:23.062 --> 00:14:26.566 line:-1 position:50%
happen before or after
we append 0?


320
00:14:26.566 --> 00:14:29.669 line:-1 position:50%
The answer, again, is neither.


321
00:14:29.669 --> 00:14:32.405 line:-1 position:50%
Swift will block you from doing
this because it's not safe


322
00:14:32.405 --> 00:14:34.307 line:-1 position:50%
to modify the array
from a background task


323
00:14:34,307 --> 00:14:38,678 line:-1
without synchronizing access
with something like an actor.


324
00:14:38.678 --> 00:14:42.749 line:-1 position:50%
Actors were the first major step
towards eliminating data races.


325
00:14:42.749 --> 00:14:45.184 line:-1 position:50%
This year we've refined
the concurrency model


326
00:14:45.184 --> 00:14:49.122 line:-1 position:50%
to push us even further
towards the end goal.


327
00:14:49,122 --> 00:14:52,325 line:-1
You can think of each actor
as its own island,


328
00:14:52,325 --> 00:14:56,095 line:-1
isolated from everything else
in the sea of concurrency.


329
00:14:56,095 --> 00:14:58,798 line:-1
But what happens when
different threads want to query


330
00:14:58.798 --> 00:15:03.002 line:-1 position:50%
the information stored by
each of the isolated actors?


331
00:15:03,002 --> 00:15:06,072 line:0
This metaphor will be explored
in depth in the session


332
00:15:06,072 --> 00:15:10,643 line:0
"Eliminate data races
using Swift Concurrency."


333
00:15:10,643 --> 00:15:14,013 line:-1
From memory safety
to thread safety by default;


334
00:15:14.013 --> 00:15:16.849 line:-1 position:50%
that is the goal for Swift 6.


335
00:15:16.849 --> 00:15:19.051 line:-1 position:50%
To get us there,
we first improved last year's


336
00:15:19.051 --> 00:15:21.521 line:-1 position:50%
concurrency model
with the new language features


337
00:15:21,521 --> 00:15:23,122 line:-1
I just mentioned.


338
00:15:23,122 --> 00:15:24,991 line:-1
The second thing
I haven't mentioned yet


339
00:15:24,991 --> 00:15:26,692 line:-1
is the new opt-in safety checks


340
00:15:26.692 --> 00:15:30.163 line:-1 position:50%
that identify
potential data races.


341
00:15:30,163 --> 00:15:32,865 line:-1
You can experiment with
stricter concurrency checking


342
00:15:32,865 --> 00:15:36,202 line:-1
by enabling it
in your build settings.


343
00:15:36,202 --> 00:15:38,371 line:-1
Let's take a look
at actors again.


344
00:15:38,371 --> 00:15:41,641 position:50%
We can take this notion
of actor isolation,


345
00:15:41,641 --> 00:15:44,544 position:50%
and take it further
with distributed actors.


346
00:15:44,544 --> 00:15:47,313 position:50%
Distributed actors put those
islands on different machines


347
00:15:47,313 --> 00:15:49,248 line:0
with a network between them.


348
00:15:49,248 --> 00:15:52,185 line:0
This new language feature makes
developing distributed systems


349
00:15:52,185 --> 00:15:54,353 position:50%
much simpler.


350
00:15:54.353 --> 00:15:56.589 line:-1 position:50%
Let's say you want
to create a game app;


351
00:15:56,589 --> 00:15:59,425 line:-1
you can now easily write
the back end in Swift.


352
00:15:59.425 --> 00:16:02.395 line:-1 position:50%
Here, the distributed actor
is like an actor


353
00:16:02.395 --> 00:16:04.831 line:-1 position:50%
but it might be
on a different machine.


354
00:16:04.831 --> 00:16:07.500 line:-1 position:50%
In this example,
we're looking at computer player


355
00:16:07,500 --> 00:16:11,270 line:-1
that will maintain state
during a game with a user.


356
00:16:11.270 --> 00:16:14.173 line:-1 position:50%
The distributed keyword can
also be added to a function


357
00:16:14.173 --> 00:16:15.842 line:-1 position:50%
that we expect
will need to be called


358
00:16:15.842 --> 00:16:19.579 line:-1 position:50%
on an actor that might be
on a remote machine.


359
00:16:19,579 --> 00:16:22,448 line:-1
Let's add another function
called endOfRound.


360
00:16:22,448 --> 00:16:26,385 line:-1
It will loop over the players
and call makeMove on each one.


361
00:16:26,385 --> 00:16:28,921 line:-1
Some of these players
might be local or remote,


362
00:16:28,921 --> 00:16:30,022 line:-1
but we have the benefit


363
00:16:30,022 --> 00:16:33,025 line:-1
of not needing to care
about which is which.


364
00:16:33,025 --> 00:16:35,428 line:-1
The only difference
from a regular actor call


365
00:16:35.428 --> 00:16:38.197 line:-1 position:50%
is that a distributed actor
call can potentially fail


366
00:16:38,197 --> 00:16:40,233 line:-1
because of network errors.


367
00:16:40,233 --> 00:16:41,968 line:-1
In the event
of a network failure,


368
00:16:41,968 --> 00:16:44,437 line:-1
the actor method
would throw an error.


369
00:16:44.437 --> 00:16:46.272 line:-1 position:50%
So, you need to add
the try keyword


370
00:16:46.272 --> 00:16:49.108 line:-1 position:50%
as well as the usual
await keyword that's needed


371
00:16:49.108 --> 00:16:52.411 line:-1 position:50%
when you call a function
outside of the actor.


372
00:16:52.411 --> 00:16:54.413 line:-1 position:50%
Building on these core
language primitives,


373
00:16:54.413 --> 00:16:57.416 line:-1 position:50%
we also built an open source
Distributed Actors package


374
00:16:57,416 --> 00:16:59,752 line:-1
that is focused on
building server-side,


375
00:16:59,752 --> 00:17:02,588 line:-1
clustered distributed
systems in Swift.


376
00:17:02.588 --> 00:17:05.224 line:-1 position:50%
The package includes an
integrated networking layer


377
00:17:05.224 --> 00:17:09.195 line:-1 position:50%
using SwiftNIO and implements
the SWIM consensus protocol


378
00:17:09.195 --> 00:17:11.597 line:-1 position:50%
to manage state
across the cluster.


379
00:17:11,597 --> 00:17:13,633 line:0
The "Meet distributed actors
in Swift" session


380
00:17:13,633 --> 00:17:15,568 line:0
will go into more details
on how to build


381
00:17:15,568 --> 00:17:19,472 line:0
distributed systems
with these new features.


382
00:17:19,472 --> 00:17:23,075 line:-1
We also launched a new set
of open source algorithms


383
00:17:23,075 --> 00:17:27,113 line:-1
to provide easy out-of-the-box
solutions to common operations


384
00:17:27.113 --> 00:17:29.515 line:-1 position:50%
when dealing with AsyncSequence,


385
00:17:29.515 --> 00:17:32.151 line:-1 position:50%
which was released
with Swift 5.5.


386
00:17:32.151 --> 00:17:34.153 line:-1 position:50%
Releasing these APIs
as a package


387
00:17:34.153 --> 00:17:37.556 line:-1 position:50%
gives developers flexibility
in deploying across platforms


388
00:17:37.556 --> 00:17:40.760 line:-1 position:50%
and operating system versions.


389
00:17:40,760 --> 00:17:44,630 line:-1
There are several ways to
combine multiple async sequences


390
00:17:44.630 --> 00:17:47.366 line:-1 position:50%
and to group values
into collections.


391
00:17:47.366 --> 00:17:49.035 line:-1 position:50%
These are just some
of the algorithms


392
00:17:49.035 --> 00:17:51.070 line:-1 position:50%
included in the package.


393
00:17:51,070 --> 00:17:53,940 line:0
Check out the "Meet Swift
Async Algorithms" talk


394
00:17:53,940 --> 00:17:58,110 position:50%
to see how you can use
this new powerful API.


395
00:17:58.110 --> 00:18:00.646 line:-1 position:50%
But there's another aspect
of concurrency,


396
00:18:00.646 --> 00:18:02.515 line:-1 position:50%
which is performance.


397
00:18:02.515 --> 00:18:04.817 line:-1 position:50%
This year,
with actor prioritization,


398
00:18:04.817 --> 00:18:08.654 line:-1 position:50%
actors now execute
the highest-priority work first.


399
00:18:08,654 --> 00:18:10,456 line:-1
And continuing
our deep integration


400
00:18:10,456 --> 00:18:12,291 line:-1
with the operating system
scheduler,


401
00:18:12,291 --> 00:18:15,428 line:-1
the model has priority-inversion
prevention built in,


402
00:18:15,428 --> 00:18:20,299 line:-1
so less important work can't
block higher-priority work.


403
00:18:20.299 --> 00:18:23.069 line:-1 position:50%
Historically, it has been
really hard to visualize


404
00:18:23,069 --> 00:18:26,072 line:-1
the performance impact
of concurrency in your app.


405
00:18:26,072 --> 00:18:31,410 line:-1
But now, we have a great
new tool for doing exactly that.


406
00:18:31,410 --> 00:18:34,080 line:-1
The new Swift Concurrency view
in Instruments


407
00:18:34,080 --> 00:18:36,716 line:-1
can help you investigate
performance issues.


408
00:18:36.716 --> 00:18:39.552 line:-1 position:50%
The Swift Tasks
and Swift Actors instruments


409
00:18:39.552 --> 00:18:42.688 line:-1 position:50%
provide a full suite of tools
to help you visualize


410
00:18:42,688 --> 00:18:46,158 line:-1
and optimize
your concurrency code.


411
00:18:46,158 --> 00:18:49,095 line:-1
At the top level,
the Swift Tasks Instrument


412
00:18:49.095 --> 00:18:52.131 line:-1 position:50%
provides useful statistics,
including the number of tasks


413
00:18:52.131 --> 00:18:54.834 line:-1 position:50%
running simultaneously
and the total tasks


414
00:18:54,834 --> 00:18:58,004 line:-1
that have been created
up until that point in time.


415
00:18:58,004 --> 00:18:59,872 line:0
In the bottom half
of this window,


416
00:18:59,872 --> 00:19:03,776 line:0
you can see what's referred to
as a Task Forest.


417
00:19:03,776 --> 00:19:06,212 position:50%
It provides a graphical
representation


418
00:19:06,212 --> 00:19:07,980 line:0
of the parent-child
relationships


419
00:19:07,980 --> 00:19:11,550 position:50%
between tasks
in structured concurrent code.


420
00:19:11,550 --> 00:19:13,519 position:50%
This is just one
of the detailed views


421
00:19:13,519 --> 00:19:16,989 line:0
for the Swift Actor
Instrument.


422
00:19:16,989 --> 00:19:19,492 position:50%
To learn how to use
this exciting new tool,


423
00:19:19,492 --> 00:19:20,960 position:50%
you'll want to hop over
to the talk


424
00:19:20,960 --> 00:19:24,196 line:0
"Visualize and optimize
Swift concurrency."


425
00:19:24,196 --> 00:19:26,866 line:-1
And don't forget to give
those new packages a try.


426
00:19:26,866 --> 00:19:29,702 line:-1
Don't be shy to let us know
how it's going on the forums.


427
00:19:29,702 --> 00:19:32,004 line:-1
Now, I'll hand it over
to Becca to talk about


428
00:19:32,004 --> 00:19:36,142 line:-1
the many improvements
to Swift language usability.


429
00:19:36,142 --> 00:19:38,411 line:-1
Languages are tools,
and there's a funny thing


430
00:19:38.411 --> 00:19:40.546 line:-1 position:50%
about tools --
they can really affect


431
00:19:40,546 --> 00:19:42,848 line:-1
the things you build
with them.


432
00:19:42.848 --> 00:19:44.950 line:-1 position:50%
When all you have
is a hammer,


433
00:19:44.950 --> 00:19:48.120 line:-1 position:50%
you're going to build things
with nails instead of screws.


434
00:19:48,120 --> 00:19:50,856 line:-1
And even if you have
a full set of tools,


435
00:19:50.856 --> 00:19:52.658 line:-1 position:50%
if your hammer has
a big, grippy handle


436
00:19:52.658 --> 00:19:55.661 line:-1 position:50%
while your screwdriver
is plasticky and hard to hold,


437
00:19:55,661 --> 00:19:58,097 line:-1
you might still lean
towards the nails.


438
00:19:58,097 --> 00:19:59,999 line:-1
A language is the same way.


439
00:19:59,999 --> 00:20:02,501 line:-1
If Swift has a good tool
for expressing something,


440
00:20:02.501 --> 00:20:05.204 line:-1 position:50%
people will use
it more often.


441
00:20:05.204 --> 00:20:07.540 line:-1 position:50%
And this year, Swift's tools
for expressing what you want


442
00:20:07,540 --> 00:20:11,510 line:-1
your code to do
have improved in many ways.


443
00:20:11,510 --> 00:20:13,579 line:-1
Some of these changes
are simple conveniences


444
00:20:13.579 --> 00:20:15.414 line:-1 position:50%
for things you do often.


445
00:20:15,414 --> 00:20:18,784 line:-1
For example, it's really common
in Swift to use if let


446
00:20:18.784 --> 00:20:22.154 line:-1 position:50%
with the same name on both
sides of the equal sign.


447
00:20:22,154 --> 00:20:24,090 line:-1
After all, there probably
isn't a better name


448
00:20:24.090 --> 00:20:25.591 line:-1 position:50%
for the unwrapped value


449
00:20:25.591 --> 00:20:28.561 line:-1 position:50%
than the name you gave
the optional one.


450
00:20:28,561 --> 00:20:30,096 line:-1
But when the name
is really long,


451
00:20:30.096 --> 00:20:33.099 line:-1 position:50%
that repetition starts
to get cumbersome.


452
00:20:33,099 --> 00:20:35,734 line:-1
You might be tempted
to abbreviate the name,


453
00:20:35.734 --> 00:20:39.105 line:-1 position:50%
but then your code
becomes kind of cryptic.


454
00:20:39.105 --> 00:20:41.373 line:-1 position:50%
And if you later rename
the optional variable,


455
00:20:41,373 --> 00:20:45,244 line:-1
the abbreviation
might get out of sync.


456
00:20:45,244 --> 00:20:47,780 line:-1
Swift 5.7 introduces
a new shorthand


457
00:20:47,780 --> 00:20:49,648 line:-1
for this common pattern.


458
00:20:49,648 --> 00:20:51,016 line:-1
If you're unwrapping
an optional


459
00:20:51.016 --> 00:20:53.519 line:-1 position:50%
and want the unwrapped value
to have the same name,


460
00:20:53.519 --> 00:20:55.788 line:-1 position:50%
just drop
the right-hand side.


461
00:20:55,788 --> 00:20:58,491 line:-1
Swift will assume
it's the same.


462
00:20:58,491 --> 00:21:00,759 line:-1
And of course, this also
works with guard, too,


463
00:21:00.759 --> 00:21:04.029 line:-1 position:50%
and even while,
for that matter.


464
00:21:04.029 --> 00:21:06.832 line:-1 position:50%
We also looked at places where
a feature suddenly stops working


465
00:21:06,832 --> 00:21:09,201 line:-1
when you make
a minor change.


466
00:21:09.201 --> 00:21:11.370 line:-1 position:50%
For instance, Swift has always
been able to figure out


467
00:21:11.370 --> 00:21:13.939 line:-1 position:50%
what type a call will return
based on the code


468
00:21:13.939 --> 00:21:16.542 line:-1 position:50%
written inside
a one-statement closure.


469
00:21:16.542 --> 00:21:19.512 line:-1 position:50%
In this compactMap call,
the closure returns the value


470
00:21:19,512 --> 00:21:22,448 line:-1
of parseLine,
and the parseLine function


471
00:21:22.448 --> 00:21:25.351 line:-1 position:50%
returns a MailmapEntry,
so Swift can figure out


472
00:21:25,351 --> 00:21:30,189 line:-1
that entries should be
an array of MailmapEntry.


473
00:21:30.189 --> 00:21:32.158 line:-1 position:50%
This now works for more
complicated closures


474
00:21:32,158 --> 00:21:35,361 line:-1
that have multiple statements
or control flow features.


475
00:21:35.361 --> 00:21:37.596 line:-1 position:50%
So you can use do-catch,
or if...else,


476
00:21:37.596 --> 00:21:39.798 line:-1 position:50%
or just add a print call,
without having


477
00:21:39.798 --> 00:21:43.302 line:-1 position:50%
to manually specify
the closure's result type.


478
00:21:43.302 --> 00:21:45.971 line:-1 position:50%
Another thing
we looked at is danger flags


479
00:21:45,971 --> 00:21:49,575 line:-1
that aren't really flagging
any actual danger.


480
00:21:49,575 --> 00:21:52,912 position:50%
Swift is very concerned
with type and memory safety.


481
00:21:52.912 --> 00:21:54.446 line:-1 position:50%
To keep you
from making mistakes,


482
00:21:54.446 --> 00:21:56.015 line:-1 position:50%
it never
automatically converts


483
00:21:56,015 --> 00:21:58,317 line:-1
between pointers
with different pointer types,


484
00:21:58,317 --> 00:22:01,320 line:-1
nor between raw pointers
and typed pointers.


485
00:22:01,320 --> 00:22:02,922 line:-1
This is very
different from C,


486
00:22:02.922 --> 00:22:05.257 line:-1 position:50%
which allows
certain conversions.


487
00:22:05,257 --> 00:22:07,993 line:-1
For example, you can change
the signed-ness of the pointee,


488
00:22:07.993 --> 00:22:11.730 line:-1 position:50%
or cast any pointer to char star
to access it as bytes,


489
00:22:11.730 --> 00:22:15.401 line:-1 position:50%
without violating any
of C's pointer rules.


490
00:22:15,401 --> 00:22:17,770 position:50%
But sometimes these differences
in pointer behavior


491
00:22:17,770 --> 00:22:22,041 line:0
will cause problems when
a C API is imported into Swift.


492
00:22:22,041 --> 00:22:24,176 position:50%
The original developer may
have designed their APIs


493
00:22:24,176 --> 00:22:26,078 position:50%
with slight mismatches
that are handled


494
00:22:26,078 --> 00:22:30,783 line:0
by automatic conversions in C
but are errors in Swift.


495
00:22:30,783 --> 00:22:33,118 line:-1
In Swift, accessing
a pointer of one type


496
00:22:33.118 --> 00:22:35.988 line:-1 position:50%
as though it were a different
type is very dangerous,


497
00:22:35,988 --> 00:22:39,391 line:-1
so you have to describe what
you're doing very explicitly.


498
00:22:39.391 --> 00:22:41.160 line:-1 position:50%
But that's all pointless
if we're passing the pointer


499
00:22:41,160 --> 00:22:43,829 line:-1
directly to C,
because in C,


500
00:22:43,829 --> 00:22:47,499 line:-1
that pointer mismatch
is perfectly legal!


501
00:22:47.499 --> 00:22:50.169 line:-1 position:50%
So in this case, we've treated
something really straightforward


502
00:22:50.169 --> 00:22:52.638 line:-1 position:50%
as though it were dangerous.


503
00:22:52,638 --> 00:22:55,975 line:-1
This matters because, as much as
Swift values type safety,


504
00:22:55.975 --> 00:23:00.045 line:-1 position:50%
it also values easy access
to C-family code.


505
00:23:00.045 --> 00:23:01.814 line:-1 position:50%
That's why C
and Objective-C interop


506
00:23:01,814 --> 00:23:05,084 line:-1
are so rich and seamless,
and it's why the Swift project


507
00:23:05.084 --> 00:23:08.254 line:-1 position:50%
formed the C++ working group
Angela mentioned earlier


508
00:23:08,254 --> 00:23:11,590 line:-1
to start building equally
capable C++ interop.


509
00:23:11.590 --> 00:23:13.459 line:-1 position:50%
We don't want
using C functions like these


510
00:23:13.459 --> 00:23:16.762 line:-1 position:50%
to be unnecessarily painful.


511
00:23:16,762 --> 00:23:18,564 line:-1
So Swift now has
a separate set of rules


512
00:23:18.564 --> 00:23:21.433 line:-1 position:50%
for calls to imported
functions and methods.


513
00:23:21.433 --> 00:23:24.169 line:-1 position:50%
It allows pointer conversions
that would be legal in C


514
00:23:24,169 --> 00:23:26,972 line:-1
even though they normally
aren't in Swift.


515
00:23:26,972 --> 00:23:31,510 line:-1
That way, your Swift code
can use these APIs seamlessly.


516
00:23:31.510 --> 00:23:33.746 line:-1 position:50%
So far we've talked
about small improvements


517
00:23:33,746 --> 00:23:35,414 line:-1
to the tools
you already had.


518
00:23:35,414 --> 00:23:38,150 line:-1
But this year, Swift also
has a brand-new tool


519
00:23:38.150 --> 00:23:41.587 line:-1 position:50%
for extracting information
from strings.


520
00:23:41.587 --> 00:23:43.389 line:-1 position:50%
Here's a function
that parses some information


521
00:23:43.389 --> 00:23:45.090 line:-1 position:50%
out of a string.


522
00:23:45,090 --> 00:23:46,592 line:-1
This sort of task
has always been


523
00:23:46,592 --> 00:23:48,794 line:-1
a bit of a challenge
in Swift.


524
00:23:48.794 --> 00:23:51.797 line:-1 position:50%
You end up searching, splitting,
and slicing over and over


525
00:23:51,797 --> 00:23:54,767 line:-1
until you get what you want.


526
00:23:54.767 --> 00:23:56.568 line:-1 position:50%
When people notice this,
they tend to focus


527
00:23:56.568 --> 00:23:58.704 line:-1 position:50%
on the little things,
like how wordy it can be


528
00:23:58.704 --> 00:24:00.739 line:-1 position:50%
to manipulate
string indices,


529
00:24:00.739 --> 00:24:03.876 line:-1 position:50%
but I think that's kind of
missing the bigger picture.


530
00:24:03.876 --> 00:24:06.745 line:-1 position:50%
Because even if we changed
this syntax,


531
00:24:06.745 --> 00:24:09.181 line:-1 position:50%
it doesn't help you answer
the basic question you're asking


532
00:24:09,181 --> 00:24:12,384 line:-1
when you look at this code --
what does the line variable


533
00:24:12,384 --> 00:24:15,387 line:-1
that's passed into it
actually look like?


534
00:24:15,387 --> 00:24:18,457 line:-1
What sort of string is it
trying to take apart?


535
00:24:18.457 --> 00:24:20.659 line:-1 position:50%
If you stare at it long
enough, you might realize


536
00:24:20,659 --> 00:24:23,529 line:-1
that it's parsing a simplified
version of a mailmap --


537
00:24:23.529 --> 00:24:25.731 line:-1 position:50%
a file you put
in a git repository


538
00:24:25.731 --> 00:24:29.068 line:-1 position:50%
to correct a developer's
name in old commits.


539
00:24:29.068 --> 00:24:31.837 line:-1 position:50%
But extracting that information
by searching and slicing


540
00:24:31,837 --> 00:24:35,841 line:-1
is so involved that it's
hard to figure that out.


541
00:24:35.841 --> 00:24:38.344 line:-1 position:50%
You get so lost in how
to slice up the string


542
00:24:38,344 --> 00:24:42,314 line:-1
that you kind of lose track
of what that string is.


543
00:24:42.314 --> 00:24:45.951 line:-1 position:50%
The problem is not
these two expressions;


544
00:24:45,951 --> 00:24:48,354 line:-1
the problem is
the whole thing.


545
00:24:48.354 --> 00:24:49.888 line:-1 position:50%
We need to rip
out all of this


546
00:24:49,888 --> 00:24:52,091 line:-1
and replace it
with something better.


547
00:24:52,091 --> 00:24:54,493 line:-1
We need a
different approach;


548
00:24:54.493 --> 00:24:56.962 line:-1 position:50%
one where your code
sort of draws a picture


549
00:24:56.962 --> 00:24:58.831 line:-1 position:50%
of the string you want
to match,


550
00:24:58.831 --> 00:25:01.600 line:-1 position:50%
and the language figures
out how to do it.


551
00:25:01,600 --> 00:25:05,771 line:-1
A declarative approach,
not an imperative one.


552
00:25:05.771 --> 00:25:10.809 line:-1 position:50%
In Swift 5.7, you can now
do that by writing a regex.


553
00:25:10,809 --> 00:25:14,213 line:-1
A regex is a way to describe
a pattern in a string.


554
00:25:14.213 --> 00:25:16.715 line:-1 position:50%
For over 50 years,
languages and tools


555
00:25:16,715 --> 00:25:18,617 line:-1
have allowed developers
to write regexes


556
00:25:18,617 --> 00:25:21,587 line:-1
in a dense,
information-packed syntax.


557
00:25:21,587 --> 00:25:24,490 line:-1
Some of you already use them
in the Xcode find bar,


558
00:25:24,490 --> 00:25:26,425 line:-1
in command-line tools
like grep,


559
00:25:26.425 --> 00:25:29.094 line:-1 position:50%
in Foundation's
NSRegularExpression class,


560
00:25:29,094 --> 00:25:31,463 line:-1
or in other
programming languages.


561
00:25:31,463 --> 00:25:34,500 line:-1
That syntax is now supported
by Swift's regex literals,


562
00:25:34.500 --> 00:25:37.970 line:-1 position:50%
and it works just like it does
in any other developer tool.


563
00:25:37.970 --> 00:25:40.172 line:-1 position:50%
But some of you haven't
used regexes before


564
00:25:40,172 --> 00:25:42,841 line:-1
and you're probably going,
"Is that real code


565
00:25:42,841 --> 00:25:46,278 line:-1
or did a cat walk
across her keyboard?"


566
00:25:46.278 --> 00:25:47.946 line:-1 position:50%
And I don't blame you.


567
00:25:47.946 --> 00:25:50.449 line:-1 position:50%
Regex literals are written
in symbols and mnemonics


568
00:25:50,449 --> 00:25:53,719 line:-1
that you have to memorize
in order to read them.


569
00:25:53.719 --> 00:25:55.187 line:-1 position:50%
To someone who knows
the language,


570
00:25:55,187 --> 00:25:56,822 line:-1
even the gnarliest parts
of this regex,


571
00:25:56,822 --> 00:25:59,258 line:-1
like the part that matches
the developer's name


572
00:25:59.258 --> 00:26:02.761 line:-1 position:50%
are just combinations of
several simple matching rules.


573
00:26:02.761 --> 00:26:06.765 line:-1 position:50%
But that's a lot of behavior
to cram into 11 characters.


574
00:26:06.765 --> 00:26:10.202 line:-1 position:50%
Regex literals are so compact
that even experienced developers


575
00:26:10,202 --> 00:26:13,405 line:-1
sometimes need a minute to
understand a complicated one.


576
00:26:13,405 --> 00:26:15,808 line:-1
But what if you could write
the same kind of matching rules,


577
00:26:15.808 --> 00:26:18.944 line:-1 position:50%
just with words
instead of symbols?


578
00:26:18.944 --> 00:26:21.914 line:-1 position:50%
That seems like it'd be
easier to understand.


579
00:26:21.914 --> 00:26:23.148 line:-1 position:50%
In fact, put it
all together,


580
00:26:23.148 --> 00:26:26.885 line:-1 position:50%
and you get something
that looks a lot like SwiftUI.


581
00:26:26,885 --> 00:26:30,289 line:-1
That'd be a great alternative
to a regex literal, wouldn't it?


582
00:26:30.289 --> 00:26:33.459 line:-1 position:50%
So it's a good thing
Swift supports that!


583
00:26:33.459 --> 00:26:35.327 line:-1 position:50%
The RegexBuilder library
provides a whole new


584
00:26:35.327 --> 00:26:39.064 line:-1 position:50%
SwiftUI-style language
for regexes that's easier to use


585
00:26:39.064 --> 00:26:42.234 line:-1 position:50%
and more readable
than the traditional syntax.


586
00:26:42,234 --> 00:26:44,670 line:-1
It can do the same things
a regex literal can,


587
00:26:44.670 --> 00:26:47.339 line:-1 position:50%
but it describes its behavior
in words you can understand


588
00:26:47,339 --> 00:26:50,175 line:-1
or look up, instead of
symbols and abbreviations


589
00:26:50.175 --> 00:26:52.277 line:-1 position:50%
you have to memorize.


590
00:26:52.277 --> 00:26:54.413 line:-1 position:50%
Regex builders
are great for beginners,


591
00:26:54.413 --> 00:26:57.149 line:-1 position:50%
but this is far from
a beginner-only feature.


592
00:26:57.149 --> 00:26:59.251 line:-1 position:50%
It has powerful capabilities
that go way beyond


593
00:26:59,251 --> 00:27:01,620 line:-1
what a regex literal can do.


594
00:27:01.620 --> 00:27:03.455 line:-1 position:50%
To start with,
you can turn a regex


595
00:27:03.455 --> 00:27:05.991 line:-1 position:50%
into a reusable regex
component,


596
00:27:05.991 --> 00:27:08.494 line:-1 position:50%
just as you can turn
a SwiftUI view hierarchy


597
00:27:08.494 --> 00:27:10.596 line:-1 position:50%
into a view.


598
00:27:10,596 --> 00:27:12,831 line:-1
You can use these components
from other regexes


599
00:27:12,831 --> 00:27:14,766 line:-1
created with
the builder syntax,


600
00:27:14.766 --> 00:27:17.402 line:-1 position:50%
and you can even
make them recursive.


601
00:27:17,402 --> 00:27:19,738 line:-1
Regex builders also support
dropping some Swift types


602
00:27:19.738 --> 00:27:22.140 line:-1 position:50%
directly into a regex.


603
00:27:22.140 --> 00:27:24.109 line:-1 position:50%
For example,
string literals just match


604
00:27:24.109 --> 00:27:28.547 line:-1 position:50%
the exact text inside them --
no special escaping needed.


605
00:27:28.547 --> 00:27:30.215 line:-1 position:50%
You can also use
regex literals


606
00:27:30.215 --> 00:27:32.351 line:-1 position:50%
in the middle
of a regex builder.


607
00:27:32,351 --> 00:27:34,386 line:-1
So you can strike a balance
between the clarity


608
00:27:34.386 --> 00:27:38.557 line:-1 position:50%
of a regex builder and the
conciseness of a regex literal.


609
00:27:38,557 --> 00:27:41,660 line:-1
And other types -- like this
Foundation date-format style --


610
00:27:41,660 --> 00:27:44,530 line:-1
can integrate custom parsing
logic with regex builders,


611
00:27:44,530 --> 00:27:48,700 line:-1
and even convert the data to a
richer type before capturing it.


612
00:27:48.700 --> 00:27:50.836 line:-1 position:50%
Finally, no matter
which syntax you use,


613
00:27:50,836 --> 00:27:54,139 line:-1
regexes support a bunch
of useful matching methods


614
00:27:54.139 --> 00:27:58.210 line:-1 position:50%
and strongly typed captures
that are easy to use.


615
00:27:58.210 --> 00:28:00.112 line:-1 position:50%
Now, for the regex nerds
who have been squirming


616
00:28:00.112 --> 00:28:02.381 line:-1 position:50%
in their seats,


617
00:28:02.381 --> 00:28:05.217 line:-1 position:50%
Swift Regex uses a brand-new
open source matching engine,


618
00:28:05.217 --> 00:28:06.351 line:-1 position:50%
with a feature
set comparable


619
00:28:06,351 --> 00:28:09,621 line:-1
to the most advanced
regex implementations.


620
00:28:09.621 --> 00:28:13.191 line:-1 position:50%
The literal syntax is compatible
with the Unicode regex standard,


621
00:28:13,191 --> 00:28:16,261 line:-1
and it has an uncommon level
of Unicode correctness.


622
00:28:16,261 --> 00:28:19,164 line:-1
For instance, dot matches
a whole character by default,


623
00:28:19.164 --> 00:28:22.968 line:-1 position:50%
not a Unicode.Scalar
or a UTF-8 byte.


624
00:28:22,968 --> 00:28:25,170 line:-1
To use Swift Regex, your app
will need to be running


625
00:28:25.170 --> 00:28:28.006 line:-1 position:50%
on an OS with the Swift
Regex engine built into it,


626
00:28:28,006 --> 00:28:32,210 line:-1
like macOS 13 or iOS 16.


627
00:28:32,210 --> 00:28:34,513 line:-1
Swift Regex is
an entire language --


628
00:28:34,513 --> 00:28:36,415 line:-1
well, two languages, really --


629
00:28:36.415 --> 00:28:38.817 line:-1 position:50%
so there's much more
to say about it.


630
00:28:38,817 --> 00:28:40,786 position:50%
These two sessions --
"Meet Swift Regex"


631
00:28:40,786 --> 00:28:43,155 line:0
and "Swift Regex:
Beyond The Basics" --


632
00:28:43,155 --> 00:28:46,792 position:50%
will give you lots
more details about using it.


633
00:28:46.792 --> 00:28:48.026 line:-1 position:50%
Finally, there's one place


634
00:28:48,026 --> 00:28:50,462 line:-1
where we took a comprehensive
look at the tools we have


635
00:28:50.462 --> 00:28:53.198 line:-1 position:50%
and made a bunch of changes
to improve them.


636
00:28:53,198 --> 00:28:56,268 line:-1
That's in generics
and protocols.


637
00:28:56.268 --> 00:28:58.103 line:-1 position:50%
To show you how these tools
have improved,


638
00:28:58.103 --> 00:29:00.472 line:-1 position:50%
I'll need an
example protocol.


639
00:29:00.472 --> 00:29:02.207 line:-1 position:50%
Let's say you're writing
a git client


640
00:29:02,207 --> 00:29:05,844 line:-1
and you have to represent
mailmaps in two different ways.


641
00:29:05,844 --> 00:29:08,947 line:-1
When you're displaying commits,
you use a type with a dictionary


642
00:29:08.947 --> 00:29:11.583 line:-1 position:50%
to quickly look up names.


643
00:29:11.583 --> 00:29:13.952 line:-1 position:50%
But when you're letting
users edit the mailmap,


644
00:29:13.952 --> 00:29:16.154 line:-1 position:50%
you use a type with an array
to keep the entries


645
00:29:16,154 --> 00:29:18,857 line:-1
in their original order.


646
00:29:18,857 --> 00:29:20,626 line:0
And you have a protocol
called Mailmap


647
00:29:20,626 --> 00:29:22,327 position:50%
that both of
them conform to,


648
00:29:22,327 --> 00:29:26,698 position:50%
so your mailmap parser can
add entries to either type.


649
00:29:26,698 --> 00:29:28,500 line:-1
But there are two ways
the parser could use


650
00:29:28.500 --> 00:29:30.702 line:-1 position:50%
the Mailmap protocol.


651
00:29:30.702 --> 00:29:31.937 line:-1 position:50%
I've written two
different versions


652
00:29:31.937 --> 00:29:34.573 line:-1 position:50%
of this addEntries function
to illustrate them,


653
00:29:34,573 --> 00:29:36,174 line:-1
but it's actually
kind of hard to explain


654
00:29:36.174 --> 00:29:37.476 line:-1 position:50%
how they're different,


655
00:29:37,476 --> 00:29:41,613 line:-1
because Swift is using the same
syntax for two different things.


656
00:29:41.613 --> 00:29:45.350 line:-1 position:50%
It turns out that the word
"Mailmap" means one thing here


657
00:29:45,350 --> 00:29:47,753 line:-1
but it means something
subtly different here.


658
00:29:50,288 --> 00:29:53,058 position:50%
When you name a protocol
in an inheritance list,


659
00:29:53,058 --> 00:29:56,461 position:50%
generic parameter list,
generic conformance constraint,


660
00:29:56,461 --> 00:29:58,196 line:0
or an opaque result type,


661
00:29:58,196 --> 00:30:01,900 line:0
it means "an instance that
conforms to this protocol."


662
00:30:01,900 --> 00:30:04,369 line:0
But in a variable type,
a generic argument,


663
00:30:04,369 --> 00:30:06,371 line:0
a generic same-type constraint,


664
00:30:06,371 --> 00:30:08,707 position:50%
or a function parameter
or result type,


665
00:30:08,707 --> 00:30:10,976 position:50%
it actually means
"a box which contains


666
00:30:10,976 --> 00:30:14,613 position:50%
an instance that conforms
to this protocol."


667
00:30:14.613 --> 00:30:16.415 line:-1 position:50%
This distinction is important
because the box


668
00:30:16,415 --> 00:30:20,252 line:-1
typically uses more space,
takes more time to operate on,


669
00:30:20,252 --> 00:30:22,020 line:-1
and doesn't have all
of the capabilities


670
00:30:22,020 --> 00:30:24,389 line:-1
of the instance inside it.


671
00:30:24.389 --> 00:30:25.991 line:-1 position:50%
But the places where
you're using a box


672
00:30:25.991 --> 00:30:28.360 line:-1 position:50%
look just like the places
where you aren't,


673
00:30:28.360 --> 00:30:31.163 line:-1 position:50%
so it's hard to figure out
if you're using one.


674
00:30:31.163 --> 00:30:34.800 line:-1 position:50%
Swift 5.7 fixes
this oversight.


675
00:30:34.800 --> 00:30:36.368 line:-1 position:50%
When you're using one
of these boxes


676
00:30:36.368 --> 00:30:38.236 line:-1 position:50%
containing
a conforming type,


677
00:30:38.236 --> 00:30:41.973 line:-1 position:50%
Swift will now expect you
to write the any keyword.


678
00:30:41.973 --> 00:30:45.877 line:-1 position:50%
This is not mandatory in code
that was valid before Swift 5.7,


679
00:30:45.877 --> 00:30:47.946 line:-1 position:50%
but it is encouraged
and you will see it


680
00:30:47.946 --> 00:30:50.716 line:-1 position:50%
in generated interfaces
and error messages,


681
00:30:50,716 --> 00:30:53,618 line:-1
even if you don't
write it out explicitly.


682
00:30:53,618 --> 00:30:55,620 line:0
So the preferred way
to write all of those things


683
00:30:55,620 --> 00:30:58,824 line:0
in the right-hand column
is with the any keyword.


684
00:30:58,824 --> 00:31:00,759 position:50%
If you do that,
you'll be able to tell


685
00:31:00,759 --> 00:31:03,562 position:50%
when you're using
one of these boxes.


686
00:31:03,562 --> 00:31:05,330 line:-1
Now that the any keyword
marks one of the parameters


687
00:31:05,330 --> 00:31:07,833 line:-1
in this example,
it's a lot easier to explain


688
00:31:07,833 --> 00:31:10,335 line:-1
the difference between
these two functions.


689
00:31:10.335 --> 00:31:14.072 line:-1 position:50%
addEntries1 takes the
Mailmap as a generic type;


690
00:31:14.072 --> 00:31:17.275 line:-1 position:50%
addEntries2
takes it as an any type.


691
00:31:17.275 --> 00:31:18.877 line:-1 position:50%
And it's also easier
for error messages


692
00:31:18.877 --> 00:31:20.378 line:-1 position:50%
to explain what's happening


693
00:31:20,378 --> 00:31:23,448 line:-1
when you hit one of
the limitations of any types.


694
00:31:23.448 --> 00:31:26.451 line:-1 position:50%
For instance, this mergeMailmaps
function tries to pass


695
00:31:26,451 --> 00:31:30,388 line:-1
an any Mailmap to a generic
Mailmap parameter.


696
00:31:30,388 --> 00:31:31,590 line:-1
This used to
produce an error


697
00:31:31.590 --> 00:31:34.493 line:-1 position:50%
saying that Mailmap
cannot conform to itself,


698
00:31:34.493 --> 00:31:37.763 line:-1 position:50%
which always seemed
kind of paradoxical.


699
00:31:37.763 --> 00:31:39.998 line:-1 position:50%
But now that we have
the concept of any types,


700
00:31:39.998 --> 00:31:42.801 line:-1 position:50%
we can explain what's happening
more clearly.


701
00:31:42,801 --> 00:31:44,870 line:-1
The problem is
that any Mailmap --


702
00:31:44,870 --> 00:31:47,105 line:-1
the box containing a mailmap --


703
00:31:47.105 --> 00:31:49.941 line:-1 position:50%
doesn't conform
to the Mailmap protocol.


704
00:31:49,941 --> 00:31:51,743 position:50%
But the box is what
you're trying to pass,


705
00:31:51,743 --> 00:31:55,013 position:50%
and it doesn't fit
into the generic parameter.


706
00:31:55,013 --> 00:31:57,549 line:0
If you want to pass the instance
inside the box here,


707
00:31:57,549 --> 00:32:00,652 position:50%
you'd have to somehow
open up the box,


708
00:32:00,652 --> 00:32:04,489 position:50%
take out the mailmap inside
it, and pass that instead.


709
00:32:04,489 --> 00:32:08,460 line:-1
But actually,
in simple cases like this one,


710
00:32:08.460 --> 00:32:10.629 line:-1 position:50%
Swift will now
just do that for you.


711
00:32:10,629 --> 00:32:13,465 line:-1
Open up the box,
take out the instance inside it,


712
00:32:13.465 --> 00:32:16.101 line:-1 position:50%
and pass it
to the generic parameter.


713
00:32:16.101 --> 00:32:17.702 line:-1 position:50%
So you won't be seeing
this error message


714
00:32:17,702 --> 00:32:19,638 line:-1
nearly as much anymore.


715
00:32:19.638 --> 00:32:21.273 line:-1 position:50%
But there's an even more
exciting improvement


716
00:32:21.273 --> 00:32:23.875 line:-1 position:50%
to any types than that one.


717
00:32:23,875 --> 00:32:26,878 line:-1
Previously, a protocol could
not be used as an any type


718
00:32:26,878 --> 00:32:30,782 line:-1
if it either used the self
type or had associated types,


719
00:32:30,782 --> 00:32:32,918 line:-1
or even just conformed
to a protocol that did,


720
00:32:32.918 --> 00:32:34.886 line:-1 position:50%
like Equatable.


721
00:32:34.886 --> 00:32:38.490 line:-1 position:50%
But in Swift 5.7,
this error is just --


722
00:32:38.490 --> 00:32:39.791 line:-1 position:50%
poof --


723
00:32:39.791 --> 00:32:42.494 line:-1 position:50%
gone.


724
00:32:42.494 --> 00:32:44.296 line:-1 position:50%
A lot of developers
have struggled with this one,


725
00:32:44.296 --> 00:32:47.499 line:-1 position:50%
so we're thrilled to have
fixed it at the source.


726
00:32:47,499 --> 00:32:50,368 line:-1
Now, that's exciting enough
just for protocols like Mailmap,


727
00:32:50.368 --> 00:32:52.571 line:-1 position:50%
but this goes even further.


728
00:32:52,571 --> 00:32:55,640 line:-1
Because even very sophisticated
protocols, like Collection,


729
00:32:55.640 --> 00:32:58.276 line:-1 position:50%
can be used as any types.


730
00:32:58,276 --> 00:33:00,245 line:-1
You can even specify
the element type,


731
00:33:00,245 --> 00:33:04,249 line:-1
thanks to a new feature called
"primary associated types."


732
00:33:04.249 --> 00:33:05.417 line:-1 position:50%
A lot of associated types


733
00:33:05.417 --> 00:33:08.720 line:-1 position:50%
are basically just
implementation details.


734
00:33:08,720 --> 00:33:11,056 line:-1
You usually don't care
which type a collection uses


735
00:33:11.056 --> 00:33:13.925 line:-1 position:50%
for its index, iterator,
or subsequence;


736
00:33:13.925 --> 00:33:16.895 line:-1 position:50%
you just need to use
the type it supports.


737
00:33:16.895 --> 00:33:20.065 line:-1 position:50%
But its Element
is a different story.


738
00:33:20,065 --> 00:33:21,933 line:-1
You might not always care
exactly which Element type


739
00:33:21,933 --> 00:33:23,802 line:-1
a collection uses,
but you're probably


740
00:33:23,802 --> 00:33:25,770 line:-1
going to do something
with the elements,


741
00:33:25.770 --> 00:33:29.875 line:-1 position:50%
so you'll need to constrain them
or return them or something.


742
00:33:29.875 --> 00:33:32.010 line:-1 position:50%
When you have an associated
type like Element


743
00:33:32,010 --> 00:33:35,247 line:-1
that nearly every user
of a protocol will care about,


744
00:33:35.247 --> 00:33:37.015 line:-1 position:50%
you can put its name
after the protocol's name


745
00:33:37,015 --> 00:33:41,253 line:-1
in angle brackets to make it
a primary associated type.


746
00:33:41,253 --> 00:33:43,722 line:-1
Once you do that, you can
constrain the protocol's


747
00:33:43,722 --> 00:33:46,658 line:-1
primary associated types
with the angle bracket syntax


748
00:33:46.658 --> 00:33:49.594 line:-1 position:50%
pretty much anywhere you can
write the protocol's name,


749
00:33:49.594 --> 00:33:52.163 line:-1 position:50%
including in any Collection.


750
00:33:52.163 --> 00:33:54.900 line:-1 position:50%
Now, some of you might be
looking at this type and going,


751
00:33:54.900 --> 00:33:57.269 line:-1 position:50%
"Wait a minute.


752
00:33:57.269 --> 00:33:59.638 line:-1 position:50%
Isn't there already something
called AnyCollection,


753
00:33:59,638 --> 00:34:03,842 line:-1
just run together
and with the 'any' capitalized?"


754
00:34:03,842 --> 00:34:06,378 line:-1
And you're right, there is!


755
00:34:06.378 --> 00:34:09.648 line:-1 position:50%
The old AnyCollection
is a type-erasing wrapper --


756
00:34:09,648 --> 00:34:12,083 line:-1
a handwritten struct which
serves the same purpose


757
00:34:12.083 --> 00:34:13.885 line:-1 position:50%
as an any type.


758
00:34:13,885 --> 00:34:15,887 line:0
The difference is that
the AnyCollection struct


759
00:34:15,887 --> 00:34:18,990 line:0
is just line after line of
the most boring boilerplate code


760
00:34:18,990 --> 00:34:22,627 position:50%
you've ever seen in your
life; whereas the any type


761
00:34:22,627 --> 00:34:24,129 position:50%
is a built-in
language feature


762
00:34:24,129 --> 00:34:26,064 line:0
that does basically
the same thing --


763
00:34:26,064 --> 00:34:27,599 position:50%
for free!


764
00:34:27.599 --> 00:34:29.434 line:-1 position:50%
Now, the AnyCollection
struct will stick around


765
00:34:29.434 --> 00:34:31.336 line:-1 position:50%
for backwards compatibility
and because it has


766
00:34:31,336 --> 00:34:34,873 line:-1
a couple of features that any
types can't quite match yet.


767
00:34:34.873 --> 00:34:36.775 line:-1 position:50%
But if you have your own
type-erasing wrappers


768
00:34:36,775 --> 00:34:40,045 line:-1
in your code, you might want to
see if you can reimplement them


769
00:34:40.045 --> 00:34:44.282 line:-1 position:50%
using built-in any types instead
of box classes or closures.


770
00:34:44,282 --> 00:34:47,919 line:-1
Or maybe even just replace
them with type aliases.


771
00:34:47,919 --> 00:34:51,456 line:-1
So Swift has dramatically
improved any types.


772
00:34:51,456 --> 00:34:52,991 line:-1
It's introduced
the any keyword


773
00:34:52,991 --> 00:34:55,593 line:-1
so you can see
where you're using them.


774
00:34:55,593 --> 00:34:58,863 line:-1
It allows you to pass them
to generic arguments.


775
00:34:58.863 --> 00:35:01.099 line:-1 position:50%
It's abolished the restriction
that kept many protocols


776
00:35:01.099 --> 00:35:03.501 line:-1 position:50%
from being used with them.


777
00:35:03.501 --> 00:35:04.602 line:-1 position:50%
And it even lets
you constrain


778
00:35:04,602 --> 00:35:08,440 line:-1
an any type's primary
associated types.


779
00:35:08.440 --> 00:35:10.508 line:-1 position:50%
But even with all
of those improvements,


780
00:35:10.508 --> 00:35:13.478 line:-1 position:50%
any types still
have limitations.


781
00:35:13.478 --> 00:35:16.514 line:-1 position:50%
For example, even though
you can now use any Mailmaps


782
00:35:16,514 --> 00:35:18,850 line:-1
when Mailmap conforms
to Equatable,


783
00:35:18.850 --> 00:35:21.619 line:-1 position:50%
you still can't use the
equals operator with them,


784
00:35:21.619 --> 00:35:24.255 line:-1 position:50%
because the equals operator
requires both mailmaps


785
00:35:24,255 --> 00:35:27,459 line:-1
to have the same concrete type,
but that's not guaranteed


786
00:35:27.459 --> 00:35:30.028 line:-1 position:50%
when you're using
two any Mailmaps.


787
00:35:30,028 --> 00:35:32,597 line:-1
So even though Swift has
improved any types a lot,


788
00:35:32.597 --> 00:35:34.733 line:-1 position:50%
they still have
important limitations,


789
00:35:34.733 --> 00:35:37.969 line:-1 position:50%
in both capabilities
and performance.


790
00:35:37.969 --> 00:35:41.006 line:-1 position:50%
And that's why a lot of the
time, you shouldn't use them --


791
00:35:41.006 --> 00:35:43.375 line:-1 position:50%
you should use
generics instead.


792
00:35:43,375 --> 00:35:46,011 line:-1
So let's go back to the
two versions of addEntries


793
00:35:46.011 --> 00:35:48.013 line:-1 position:50%
and apply that wisdom.


794
00:35:48,013 --> 00:35:50,648 line:-1
Both versions do exactly
the same thing,


795
00:35:50,648 --> 00:35:53,284 line:-1
but the one on the top
uses generic types,


796
00:35:53.284 --> 00:35:56.755 line:-1 position:50%
and the one on the bottom
uses any types.


797
00:35:56.755 --> 00:35:59.157 line:-1 position:50%
The generic version
will likely be more efficient


798
00:35:59,157 --> 00:36:02,827 line:-1
and more capable,
so you ought to use that one.


799
00:36:02.827 --> 00:36:05.597 line:-1 position:50%
And yet, you're probably
tempted to use any types,


800
00:36:05,597 --> 00:36:08,733 line:-1
because they're just so much
easier to read and write.


801
00:36:08,733 --> 00:36:10,001 line:-1
To write the generic version,


802
00:36:10,001 --> 00:36:12,437 line:-1
you need to declare
two generic type names,


803
00:36:12.437 --> 00:36:14.639 line:-1 position:50%
constrain them both,
and finally,


804
00:36:14.639 --> 00:36:18.743 line:-1 position:50%
use those generic type names
as the types of the parameters.


805
00:36:18,743 --> 00:36:21,479 line:-1
That's just exhausting compared
to writing "any Collection"


806
00:36:21.479 --> 00:36:23.415 line:-1 position:50%
and "any Mailmap."


807
00:36:23,415 --> 00:36:27,385 line:-1
So you'd be tempted to use any
types despite their drawbacks.


808
00:36:27.385 --> 00:36:30.188 line:-1 position:50%
But that's the same thing
I was talking about earlier --


809
00:36:30.188 --> 00:36:32.190 line:-1 position:50%
using your hammer
instead of your screwdriver


810
00:36:32,190 --> 00:36:34,726 line:-1
because the hammer
has a big, grippy handle.


811
00:36:34,726 --> 00:36:37,262 line:-1
You shouldn't have
to make that choice.


812
00:36:37,262 --> 00:36:40,098 line:-1
So Swift is making generics
just as easy to use


813
00:36:40,098 --> 00:36:42,167 line:-1
as any types.


814
00:36:42.167 --> 00:36:44.936 line:-1 position:50%
If a generic parameter
is only used in one place,


815
00:36:44.936 --> 00:36:48.440 line:-1 position:50%
you can now write it with
the some keyword as a shorthand.


816
00:36:48.440 --> 00:36:50.842 line:-1 position:50%
And it even supports
primary associated types,


817
00:36:50,842 --> 00:36:53,178 line:-1
so you can accept all
collections of mailmap entries


818
00:36:53.178 --> 00:36:55.847 line:-1 position:50%
with code that's a lot
easier to understand.


819
00:36:55.847 --> 00:36:57.215 line:-1 position:50%
With that in your toolbox,


820
00:36:57.215 --> 00:37:00.351 line:-1 position:50%
there's no reason
to avoid generics anymore.


821
00:37:00,351 --> 00:37:02,887 line:-1
If you have a choice between
generics and any types,


822
00:37:02,887 --> 00:37:05,190 line:-1
generics will be
just as easy to use --


823
00:37:05,190 --> 00:37:07,992 line:-1
just write "some"
instead of "any".


824
00:37:07.992 --> 00:37:11.196 line:-1 position:50%
So you might as well use
the best tool for the job.


825
00:37:11,196 --> 00:37:13,164 position:50%
I've only scratched
the surface of these changes


826
00:37:13,164 --> 00:37:15,066 position:50%
to protocols and generics.


827
00:37:15,066 --> 00:37:17,168 line:0
For an in-depth look,
as well as a great review


828
00:37:17,168 --> 00:37:19,104 position:50%
of all of Swift's
generics features,


829
00:37:19,104 --> 00:37:21,339 line:0
we have two more talks
for you this year:


830
00:37:21,339 --> 00:37:23,007 line:0
"Embrace Swift generics,"


831
00:37:23,007 --> 00:37:25,343 line:0
and "Design protocol
interfaces in Swift."


832
00:37:28.179 --> 00:37:29.547 line:-1 position:50%
Now, Angela and I
have talked about


833
00:37:29.547 --> 00:37:31.783 line:-1 position:50%
nearly two dozen changes
to Swift,


834
00:37:31.783 --> 00:37:35.253 line:-1 position:50%
but there are lots more that we
couldn't fit into this session.


835
00:37:35,253 --> 00:37:38,690 line:-1
Every one of these changes
was pitched, proposed, reviewed,


836
00:37:38.690 --> 00:37:41.559 line:-1 position:50%
and accepted publicly
in the Evolution board


837
00:37:41,559 --> 00:37:43,428 line:-1
on the Swift Forums.


838
00:37:43,428 --> 00:37:45,897 line:-1
And all of them were shaped
and realized with the help


839
00:37:45.897 --> 00:37:48.833 line:-1 position:50%
of community members
from outside Apple.


840
00:37:48.833 --> 00:37:52.704 line:-1 position:50%
If you're one of those people,
thank you for making Swift 5.7


841
00:37:52,704 --> 00:37:55,073 line:-1
the great release it is.


842
00:37:55.073 --> 00:37:57.208 line:-1 position:50%
And if you want to help
decide what comes next,


843
00:37:57.208 --> 00:38:02.213 line:-1 position:50%
visit Swift.org/contributing
to find out how to participate.


844
00:38:02,213 --> 00:38:03,348 line:-1
Thanks for your time.


845
00:38:03,348 --> 00:38:04,949 line:-1
And happy coding.


846
00:38:06.985 --> 00:38:08.753 line:-1 position:50%
[LAUGHS]


847
00:38:08,753 --> 00:38:12,824 line:0 align:right position:90%
♪

