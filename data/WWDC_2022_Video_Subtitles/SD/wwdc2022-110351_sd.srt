2
00:00:00.033 --> 00:00:03.003 line:-1 position:50%
♪ Mellow instrumental
hip-hop music ♪


3
00:00:03,003 --> 00:00:09,443 line:0 align:right position:90%
♪


4
00:00:09.443 --> 00:00:10.444 line:-1 position:50%
Hello.


5
00:00:10.444 --> 00:00:13.213 line:-1 position:50%
I'm Doug from the Swift team,
and I'm here to talk about


6
00:00:13,213 --> 00:00:17,150 line:-1
Swift Concurrency's approach
to eliminating data races.


7
00:00:17.150 --> 00:00:20.554 line:-1 position:50%
We introduced Swift Concurrency
as a set of language features


8
00:00:20.554 --> 00:00:23.590 line:-1 position:50%
that make it easier to write
concurrent programs.


9
00:00:23.590 --> 00:00:27.060 line:-1 position:50%
For the mechanics of these
individual language features,


10
00:00:27,060 --> 00:00:32,399 line:-1
we refer you to the 2021 WWDC
talks covering each of them.


11
00:00:32,399 --> 00:00:33,800 line:-1
This talk takes a different,


12
00:00:33.800 --> 00:00:36.336 line:-1 position:50%
more holistic view
of Swift Concurrency


13
00:00:36,336 --> 00:00:38,505 line:-1
as a way of structuring
your program to make


14
00:00:38,505 --> 00:00:42,576 line:-1
efficient use of concurrency
without introducing data races.


15
00:00:42,576 --> 00:00:45,345 line:-1
But to do so,
we need a great analogy,


16
00:00:45.345 --> 00:00:50.918 line:-1 position:50%
so we invite you to sail with us
on the high seas of concurrency.


17
00:00:50,918 --> 00:00:53,020 line:-1
The sea of concurrency
is unpredictable,


18
00:00:53.020 --> 00:00:55.055 line:-1 position:50%
with many things
going on at once,


19
00:00:55.055 --> 00:00:58.091 line:-1 position:50%
but with you at the helm
and Swift helping you navigate


20
00:00:58.091 --> 00:01:01.161 line:-1 position:50%
the waters,
it can produce amazing things.


21
00:01:01,161 --> 00:01:02,829 line:-1
Let's dive in!


22
00:01:02.829 --> 00:01:05.999 line:-1 position:50%
We'll start
by talking about isolation,


23
00:01:05,999 --> 00:01:09,469 line:-1
which is one of the key ideas
of Swift's concurrency model,


24
00:01:09,469 --> 00:01:11,972 line:-1
ensuring that data
is not shared in a manner


25
00:01:11,972 --> 00:01:14,241 line:-1
that can introduce data races.


26
00:01:14.241 --> 00:01:17.644 line:-1 position:50%
Let's start with task isolation.


27
00:01:17.644 --> 00:01:22.716 line:-1 position:50%
In our sea of concurrency,
tasks are represented by boats.


28
00:01:22.716 --> 00:01:25.819 line:-1 position:50%
Boats are our main workers --
they have a job to do,


29
00:01:25.819 --> 00:01:29.589 line:-1 position:50%
which they perform sequentially
from start to finish.


30
00:01:29,589 --> 00:01:32,926 line:-1
They are asynchronous,
and their work can be suspended


31
00:01:32,926 --> 00:01:37,931 line:-1
any number of times at
"await" operations in the code.


32
00:01:37.931 --> 00:01:40.400 line:-1 position:50%
Finally,
they are self-contained:


33
00:01:40.400 --> 00:01:44.738 line:-1 position:50%
each task has its own resources,
so it can operate by itself,


34
00:01:44.738 --> 00:01:48.542 line:-1 position:50%
independently of all
of the other boats in the sea.


35
00:01:48.542 --> 00:01:51.278 line:-1 position:50%
If our boats are
completely independent,


36
00:01:51,278 --> 00:01:54,281 line:-1
we have concurrency
without data races,


37
00:01:54.281 --> 00:01:59.753 line:-1 position:50%
but it's not very useful
without some way to communicate.


38
00:01:59.753 --> 00:02:01.922 line:-1 position:50%
Let's add some communication!


39
00:02:01.922 --> 00:02:03.857 line:-1 position:50%
For example, one boat might have


40
00:02:03,857 --> 00:02:07,794 line:-1
a pineapple that it wants
to share with another boat.


41
00:02:07.794 --> 00:02:09.997 line:-1 position:50%
So the boats meet
on the open sea,


42
00:02:09.997 --> 00:02:13.600 line:-1 position:50%
and we transfer the pineapple
from one boat to the other.


43
00:02:13.600 --> 00:02:15.435 line:-1 position:50%
Now, this is where
the physical analogy


44
00:02:15.435 --> 00:02:18.071 line:-1 position:50%
breaks down a little bit,
because this pineapple


45
00:02:18.071 --> 00:02:22.142 line:-1 position:50%
is not a physical item that
moves from one boat to the next.


46
00:02:22,142 --> 00:02:25,445 line:-1
It's data, and in Swift we have
a couple of different ways


47
00:02:25.445 --> 00:02:29.116 line:-1 position:50%
we could represent that data.


48
00:02:29,116 --> 00:02:31,685 line:-1
How do we define
our pineapple type?


49
00:02:31,685 --> 00:02:34,888 line:-1
We like value types in Swift,
so let's make the pineapple


50
00:02:34.888 --> 00:02:39.626 line:-1 position:50%
a struct that's defined
by its weight and ripeness.


51
00:02:39,626 --> 00:02:41,528 line:-1
Let's see how this works.


52
00:02:41,528 --> 00:02:43,630 line:-1
When the boats meet
on the open sea,


53
00:02:43.630 --> 00:02:46.867 line:-1 position:50%
we're really passing a copy
of the pineapple instance


54
00:02:46,867 --> 00:02:48,869 line:-1
from one boat to the next,


55
00:02:48,869 --> 00:02:52,906 line:-1
and each boat goes away
with its own copy.


56
00:02:52,906 --> 00:02:55,142 line:-1
If you were to
mutate the copies,


57
00:02:55.142 --> 00:02:58.178 line:-1 position:50%
such as by calling
the slice() and ripen() methods,


58
00:02:58.178 --> 00:03:01.348 line:-1 position:50%
it won't have any effect
on the other one.


59
00:03:01.348 --> 00:03:03.550 line:-1 position:50%
Swift has always
preferred value types


60
00:03:03.550 --> 00:03:05.819 line:-1 position:50%
for exactly this reason --


61
00:03:05.819 --> 00:03:09.289 line:-1 position:50%
mutations have
only local effects.


62
00:03:09.289 --> 00:03:14.294 line:-1 position:50%
That principle helps
value types maintain isolation.


63
00:03:14.294 --> 00:03:18.398 line:-1 position:50%
Now, let's extend our data model
a bit and add chickens!


64
00:03:18.398 --> 00:03:20.367 line:-1 position:50%
Unlike pineapples,
which are pretty much


65
00:03:20.367 --> 00:03:23.503 line:-1 position:50%
only good for eating,
chickens are beautiful creatures


66
00:03:23,503 --> 00:03:26,339 line:-1
with their own
unique personalities.


67
00:03:26.339 --> 00:03:30.844 line:-1 position:50%
So, we're going to model
them with a class, like this.


68
00:03:30,844 --> 00:03:34,648 line:-1
Let's have our intrepid
seafarers exchange a chicken.


69
00:03:34.648 --> 00:03:37.417 line:-1 position:50%
When our boats meet,
we share the chicken,


70
00:03:37.417 --> 00:03:40.253 line:-1 position:50%
except that copying
a reference type like chicken


71
00:03:40,253 --> 00:03:43,323 line:-1
doesn't give you another
full copy of the chicken,


72
00:03:43.323 --> 00:03:47.594 line:-1 position:50%
it gives you a reference
to that specific object.


73
00:03:47.594 --> 00:03:49.963 line:-1 position:50%
So once our boats have
gone their separate ways,


74
00:03:49,963 --> 00:03:52,699 line:-1
we can see
that we have a problem:


75
00:03:52,699 --> 00:03:55,836 line:-1
both boats are doing
their work concurrently,


76
00:03:55,836 --> 00:03:57,237 line:-1
but they are not independent


77
00:03:57.237 --> 00:04:00.373 line:-1 position:50%
because they both reference
the same chicken object.


78
00:04:00.373 --> 00:04:04.311 line:-1 position:50%
That shared mutable data
is prone to data races,


79
00:04:04,311 --> 00:04:06,813 line:-1
such as when one boat
is trying to feed the chicken


80
00:04:06,813 --> 00:04:08,715 line:-1
and the other
wants to play with it,


81
00:04:08,715 --> 00:04:12,052 line:-1
leading to one
very confused chicken.


82
00:04:12,052 --> 00:04:15,589 line:-1
We need a way to know that it
was safe to share pineapples


83
00:04:15,589 --> 00:04:18,191 line:-1
amongst boats, but not chickens.


84
00:04:18,191 --> 00:04:21,828 line:-1
And then we need some checking
in place in the Swift compiler


85
00:04:21.828 --> 00:04:24.164 line:-1 position:50%
to ensure that chickens
aren't accidentally passed


86
00:04:24,164 --> 00:04:27,000 line:-1
from one boat to another.


87
00:04:27.000 --> 00:04:30.570 line:-1 position:50%
Swift protocols are a great way
of categorizing types


88
00:04:30,570 --> 00:04:33,473 line:-1
so you can reason
about their behavior.


89
00:04:33.473 --> 00:04:36.176 line:-1 position:50%
The Sendable protocol
is used to describe types


90
00:04:36.176 --> 00:04:40.280 line:-1 position:50%
that can safely be shared across
different isolation domains,


91
00:04:40,280 --> 00:04:43,416 line:-1
without creating data races.


92
00:04:43.416 --> 00:04:47.020 line:-1 position:50%
A type can be made Sendable
by writing a conformance.


93
00:04:47.020 --> 00:04:49.389 line:-1 position:50%
The Pineapple struct
conforms to Sendable


94
00:04:49,389 --> 00:04:53,093 line:-1
because it's a value type,
but the Chicken class cannot


95
00:04:53.093 --> 00:04:58.031 line:-1 position:50%
because it's an unsynchronized
reference type.


96
00:04:58,031 --> 00:05:01,234 line:-1
Modeling Sendable as a protocol
allows us to describe


97
00:05:01.234 --> 00:05:03.703 line:-1 position:50%
the places where data
is going to be shared


98
00:05:03,703 --> 00:05:06,273 line:-1
across isolation domains.


99
00:05:06.273 --> 00:05:09.276 line:-1 position:50%
For example,
when a task returns a value,


100
00:05:09,276 --> 00:05:12,045 line:-1
this value is provided
to any of the tasks


101
00:05:12,045 --> 00:05:15,015 line:-1
that are waiting for that value.


102
00:05:15,015 --> 00:05:18,552 line:-1
Here, we are trying to return
a Chicken from our Task,


103
00:05:18.552 --> 00:05:21.188 line:-1 position:50%
and we get an error
stating that this is unsafe


104
00:05:21.188 --> 00:05:25.158 line:-1 position:50%
because Chicken is not Sendable.


105
00:05:25.158 --> 00:05:28.495 line:-1 position:50%
The actual Sendable constraint
comes from the definition


106
00:05:28,495 --> 00:05:31,765 line:-1
of the Task struct itself,
which specifies that


107
00:05:31,765 --> 00:05:35,101 line:-1
the result type of a Task,
called Success,


108
00:05:35.101 --> 00:05:37.771 line:-1 position:50%
must conform
to the Sendable protocol.


109
00:05:37.771 --> 00:05:39.406 line:-1 position:50%
You should use
Sendable constraints


110
00:05:39.406 --> 00:05:41.541 line:-1 position:50%
where you have
generic parameters whose values


111
00:05:41.541 --> 00:05:45.845 line:-1 position:50%
will be passed across
different isolation domains.


112
00:05:45.845 --> 00:05:50.717 line:-1 position:50%
Now, let's revisit the idea
of sharing data among boats.


113
00:05:50,717 --> 00:05:54,354 line:-1
When two boats meet on the high
seas and want to share data,


114
00:05:54,354 --> 00:05:57,324 line:-1
we need someone to consistently
check all of the goods


115
00:05:57.324 --> 00:06:00.160 line:-1 position:50%
to make sure
they're safe to share.


116
00:06:00,160 --> 00:06:02,996 line:-1
That's the role of our friendly
customs inspector --


117
00:06:02,996 --> 00:06:05,198 line:-1
played here
by the Swift compiler --


118
00:06:05.198 --> 00:06:09.002 line:-1 position:50%
to make sure that only
Sendable types are exchanged.


119
00:06:09.002 --> 00:06:12.105 line:-1 position:50%
The pineapple is fine
and can be exchanged freely,


120
00:06:12,105 --> 00:06:14,040 line:-1
because it's Sendable.


121
00:06:14.040 --> 00:06:16.977 line:-1 position:50%
However, the chicken
cannot be exchanged,


122
00:06:16.977 --> 00:06:19.646 line:-1 position:50%
and our friendly customs
inspector will prevent us


123
00:06:19,646 --> 00:06:23,183 line:-1
from making that mistake.


124
00:06:23,183 --> 00:06:25,952 line:-1
The compiler is involved
in checking Sendable correctness


125
00:06:25.952 --> 00:06:28.488 line:-1 position:50%
at many different points.


126
00:06:28,488 --> 00:06:31,625 line:-1
Sendable types must be
correct by construction,


127
00:06:31.625 --> 00:06:35.895 line:-1 position:50%
and cannot allow any shared data
to be smuggled through them.


128
00:06:35,895 --> 00:06:39,099 line:-1
Enums and structs
generally define value types,


129
00:06:39.099 --> 00:06:41.801 line:-1 position:50%
which copy all of their
instance data along with them


130
00:06:41,801 --> 00:06:44,137 line:-1
to produce independent values.


131
00:06:44,137 --> 00:06:46,339 line:-1
Therefore, they can be Sendable


132
00:06:46,339 --> 00:06:51,745 line:-1
so long as all of their
instance data is also Sendable.


133
00:06:51.745 --> 00:06:54.281 line:-1 position:50%
Sendable can be propagated
through collections


134
00:06:54,281 --> 00:06:57,651 line:-1
and other generic types
using conditional conformance.


135
00:06:57.651 --> 00:07:00.086 line:-1 position:50%
An array of Sendable types
is Sendable,


136
00:07:00.086 --> 00:07:04.691 line:-1 position:50%
so a Crate full of pineapples
is also Sendable.


137
00:07:04.691 --> 00:07:07.060 line:-1 position:50%
All of these Sendable
conformances can even be


138
00:07:07.060 --> 00:07:10.563 line:-1 position:50%
inferred by the Swift compiler
for non-public types,


139
00:07:10,563 --> 00:07:12,532 line:-1
so Ripeness,
Pineapple, and Crate


140
00:07:12,532 --> 00:07:15,135 line:-1
are all implicitly Sendable.


141
00:07:15,135 --> 00:07:19,539 line:0
But let's say we create a coop
to house our flock of chickens.


142
00:07:19,539 --> 00:07:22,075 line:0
This type cannot
be marked as Sendable,


143
00:07:22,075 --> 00:07:24,811 line:0
because it contains
non-Sendable state:


144
00:07:24,811 --> 00:07:27,213 line:0
Chicken isn't Sendable,
so the array of chickens


145
00:07:27,213 --> 00:07:29,015 position:50%
isn't Sendable.


146
00:07:29,015 --> 00:07:31,084 line:0
We'll get an error message
from our compiler to indicate


147
00:07:31,084 --> 00:07:35,322 line:0
that this type
cannot safely be shared.


148
00:07:35,322 --> 00:07:38,658 line:-1
Classes are reference types,
so they can only be


149
00:07:38,658 --> 00:07:42,095 line:-1
made Sendable under
very narrow circumstances,


150
00:07:42,095 --> 00:07:46,099 line:-1
such as when a final class
only has immutable storage.


151
00:07:46,099 --> 00:07:48,535 line:-1
Our attempt to make
the Chicken class Sendable


152
00:07:48,535 --> 00:07:53,406 line:-1
will produce an error because
it contains mutable state.


153
00:07:53.406 --> 00:07:55.842 line:-1 position:50%
Now, it is possible
to implement reference types


154
00:07:55,842 --> 00:07:59,145 line:-1
that do their own internal
synchronization, for example,


155
00:07:59.145 --> 00:08:01.414 line:-1 position:50%
by using a lock consistently.


156
00:08:01.414 --> 00:08:04.184 line:-1 position:50%
These types are
conceptually Sendable,


157
00:08:04,184 --> 00:08:07,687 line:-1
but there is no way for Swift
to reason about that.


158
00:08:07,687 --> 00:08:12,058 line:-1
Use unchecked Sendable to
disable the compiler's checking.


159
00:08:12,058 --> 00:08:14,427 line:-1
Be careful with this,
because smuggling mutable state


160
00:08:14.427 --> 00:08:16.029 line:-1 position:50%
through @unchecked Sendable


161
00:08:16,029 --> 00:08:21,167 line:-1
undermines the data race safety
guarantees Swift is providing.


162
00:08:21,167 --> 00:08:25,038 position:50%
Task creation involves
executing a closure in a new,


163
00:08:25,038 --> 00:08:30,377 line:0
independent task, like sending
off a rowboat from your boat.


164
00:08:30,377 --> 00:08:33,813 position:50%
When we do this, we can capture
values from the original task


165
00:08:33,813 --> 00:08:36,383 position:50%
and pass them
into the new task,


166
00:08:36,383 --> 00:08:38,218 line:0
so we need Sendable checking


167
00:08:38,218 --> 00:08:41,488 position:50%
to ensure we don't
introduce data races.


168
00:08:41,488 --> 00:08:44,257 line:-1
If we do try to share
a non-Sendable type


169
00:08:44.257 --> 00:08:47.394 line:-1 position:50%
across this boundary, the
Swift compiler has us covered,


170
00:08:47,394 --> 00:08:51,398 line:-1
producing an error message
like this one.


171
00:08:51.398 --> 00:08:53.833 line:-1 position:50%
This isn't magic
for task creation.


172
00:08:53,833 --> 00:08:57,737 line:-1
The closure is being inferred
to be a Sendable closure,


173
00:08:57.737 --> 00:09:01.374 line:-1 position:50%
which could have been written
explicitly with At-Sendable.


174
00:09:01.374 --> 00:09:07.113 line:-1 position:50%
Sendable closures are values
of Sendable function type.


175
00:09:07.113 --> 00:09:10.216 line:-1 position:50%
At-Sendable can be written
on a function type to indicate


176
00:09:10,216 --> 00:09:13,753 line:-1
that the function type conforms
to the Sendable protocol.


177
00:09:13.753 --> 00:09:16.089 line:-1 position:50%
That implies that values
of that function type


178
00:09:16,089 --> 00:09:19,459 line:-1
can be passed to other isolation
domains and called there


179
00:09:19.459 --> 00:09:23.163 line:-1 position:50%
without introducing data races
on their captured state.


180
00:09:23,163 --> 00:09:26,332 line:-1
Normally, function types
cannot conform to protocols,


181
00:09:26.332 --> 00:09:29.335 line:-1 position:50%
but Sendable is special
because the compiler validates


182
00:09:29.335 --> 00:09:31.971 line:-1 position:50%
the semantic requirements
for it.


183
00:09:31,971 --> 00:09:34,707 line:-1
There is similar support
for tuples of Sendable types


184
00:09:34,707 --> 00:09:36,910 line:-1
conforming to the
Sendable protocol,


185
00:09:36,910 --> 00:09:38,344 line:-1
which allows Sendable
to be used


186
00:09:38.344 --> 00:09:41.915 line:-1 position:50%
throughout the entire language.


187
00:09:41.915 --> 00:09:44.984 line:-1 position:50%
The system we've described
has many concurrently executing


188
00:09:44.984 --> 00:09:48.655 line:-1 position:50%
tasks that are isolated
from each other.


189
00:09:48,655 --> 00:09:50,623 line:-1
The Sendable protocol
describes types


190
00:09:50,623 --> 00:09:52,959 line:-1
that can be safely shared
among tasks,


191
00:09:52.959 --> 00:09:55.261 line:-1 position:50%
and the Swift compiler
checks Sendable conformances


192
00:09:55.261 --> 00:09:59.566 line:-1 position:50%
at every level to maintain
isolation of the tasks.


193
00:09:59.566 --> 00:10:03.603 line:-1 position:50%
However, without any notion
of shared mutable data anywhere,


194
00:10:03,603 --> 00:10:04,804 line:-1
it's hard for the tasks


195
00:10:04,804 --> 00:10:07,073 line:-1
to coordinate
in a meaningful manner.


196
00:10:07,073 --> 00:10:10,276 line:-1
So we need some way
to share data amongst our tasks


197
00:10:10,276 --> 00:10:13,480 line:-1
that doesn't re-introduce
data races.


198
00:10:13,480 --> 00:10:16,416 line:-1
This is where actors come in.


199
00:10:16,416 --> 00:10:19,285 line:-1
Actors provide a way
to isolate state


200
00:10:19.285 --> 00:10:21.855 line:-1 position:50%
that can be accessed
by different tasks,


201
00:10:21,855 --> 00:10:26,793 line:-1
but in a coordinated manner
that eliminates data races.


202
00:10:26,793 --> 00:10:30,830 line:-1
Actors are the islands
in our sea of concurrency.


203
00:10:30.830 --> 00:10:33.967 line:-1 position:50%
Like boats,
each island is self-contained,


204
00:10:33.967 --> 00:10:36.002 line:-1 position:50%
with its own state
that is isolated


205
00:10:36,002 --> 00:10:38,671 line:-1
from everything else in the sea.


206
00:10:38,671 --> 00:10:41,374 line:-1
To access that state,
your code needs to be running


207
00:10:41,374 --> 00:10:43,109 line:-1
on the island.


208
00:10:43.109 --> 00:10:45.044 line:-1 position:50%
For example,
the advanceTime method


209
00:10:45,044 --> 00:10:47,113 line:-1
is isolated to this island.


210
00:10:47.113 --> 00:10:49.148 line:-1 position:50%
It lives on the island
and has access


211
00:10:49,148 --> 00:10:51,918 line:-1
to all of the island's state.


212
00:10:51,918 --> 00:10:56,422 line:0
To actually run code
on an island, you need a boat.


213
00:10:56,422 --> 00:10:59,325 position:50%
A boat can visit the island
to run code on the island,


214
00:10:59,325 --> 00:11:02,962 line:0
at which point it has
access to that state.


215
00:11:02,962 --> 00:11:07,066 line:-1
Only one boat can visit the
island to run code at a time,


216
00:11:07,066 --> 00:11:09,335 line:-1
which ensures that
there is no concurrent access


217
00:11:09,335 --> 00:11:11,304 line:-1
to the island's state.


218
00:11:11,304 --> 00:11:14,207 line:0
If other boats show up,
they must await their turn


219
00:11:14,207 --> 00:11:16,009 position:50%
to visit the island.


220
00:11:16,009 --> 00:11:19,245 line:0
And because it might be
a long time before a given boat


221
00:11:19,245 --> 00:11:22,382 position:50%
gets a chance to visit the
island, entering into an actor


222
00:11:22,382 --> 00:11:27,053 line:0
is a potential suspension point
marked by the “await” keyword.


223
00:11:27,053 --> 00:11:30,356 position:50%
Once the island frees up --
again, at a suspension point --


224
00:11:30,356 --> 00:11:34,227 position:50%
another boat can visit.


225
00:11:34.227 --> 00:11:36.996 line:-1 position:50%
Just like with two boats
meeting on the open sea,


226
00:11:36.996 --> 00:11:40.433 line:-1 position:50%
interactions between a boat
and an island need to maintain


227
00:11:40.433 --> 00:11:43.336 line:-1 position:50%
isolation of both,
by making sure


228
00:11:43,336 --> 00:11:47,140 line:-1
that non-Sendable types
don't pass between the two.


229
00:11:47,140 --> 00:11:50,276 position:50%
For example, perhaps we try
to add a chicken from our boat


230
00:11:50,276 --> 00:11:52,378 position:50%
to the flock on the island.


231
00:11:52,378 --> 00:11:55,415 line:0
This would create two references
to the same chicken object


232
00:11:55,415 --> 00:11:57,650 position:50%
from different
isolation domains,


233
00:11:57,650 --> 00:12:00,553 position:50%
so the Swift compiler
rejects it.


234
00:12:00,553 --> 00:12:03,890 position:50%
Similarly, if we try to adopt
a pet chicken from the island


235
00:12:03,890 --> 00:12:06,960 position:50%
and take it away on our boat,
Sendable checking ensures


236
00:12:06,960 --> 00:12:11,898 position:50%
that we cannot create
this data race.


237
00:12:11.898 --> 00:12:15.702 line:-1 position:50%
Actors are reference types,
but unlike classes, they isolate


238
00:12:15,702 --> 00:12:19,606 line:-1
all of their properties and code
to prevent concurrent access.


239
00:12:19.606 --> 00:12:21.975 line:-1 position:50%
Therefore,
having a reference to an actor


240
00:12:21,975 --> 00:12:25,511 line:-1
from a different
isolation domain is safe.


241
00:12:25.511 --> 00:12:28.047 line:-1 position:50%
It's like having a map
to an island:


242
00:12:28.047 --> 00:12:30.583 line:-1 position:50%
you can use the map
to go visit the island,


243
00:12:30,583 --> 00:12:32,885 line:-1
but you still need to go
through the docking procedure


244
00:12:32.885 --> 00:12:34.921 line:-1 position:50%
to access its state.


245
00:12:34,921 --> 00:12:40,660 line:-1
Therefore, all actor types
are implicitly Sendable.


246
00:12:40.660 --> 00:12:42.795 line:-1 position:50%
You might be wondering
how to know


247
00:12:42.795 --> 00:12:46.599 line:-1 position:50%
what code is isolated to
the actor and what code isn't.


248
00:12:46,599 --> 00:12:50,470 line:-1
Actor isolation is determined
by the context you're in.


249
00:12:50.470 --> 00:12:52.138 line:-1 position:50%
The instance properties
of an actor


250
00:12:52.138 --> 00:12:54.841 line:-1 position:50%
are isolated to that actor.


251
00:12:54.841 --> 00:12:58.144 line:-1 position:50%
Instance methods on the actor
or an extension of the actor


252
00:12:58.144 --> 00:13:03.249 line:-1 position:50%
are also isolated by default,
like this advanceTime method.


253
00:13:03.249 --> 00:13:06.886 line:-1 position:50%
Closures that are not Sendable,
such as the closure passed


254
00:13:06.886 --> 00:13:09.789 line:-1 position:50%
to the reduce algorithm,
stay on the actor and are


255
00:13:09.789 --> 00:13:14.260 line:-1 position:50%
actor-isolated when they are
in an actor-isolated context.


256
00:13:14.260 --> 00:13:17.330 line:-1 position:50%
The task initializer
also inherits actor isolation


257
00:13:17,330 --> 00:13:20,033 line:-1
from its context,
so the created task will be


258
00:13:20,033 --> 00:13:23,603 line:-1
scheduled on the same actor
as it was initiated from.


259
00:13:23,603 --> 00:13:27,540 line:-1
Here, that grants
access to the flock.


260
00:13:27,540 --> 00:13:29,809 position:50%
On the other hand,
a detached task


261
00:13:29,809 --> 00:13:33,046 position:50%
does not inherit actor isolation
from its context,


262
00:13:33,046 --> 00:13:35,181 line:0
because it is completely
independent of the context


263
00:13:35,181 --> 00:13:37,116 line:0
where it was created.


264
00:13:37,116 --> 00:13:38,985 position:50%
We can see that the code
in the closure here


265
00:13:38,985 --> 00:13:42,388 position:50%
is considered to be outside
the actor because it needs


266
00:13:42,388 --> 00:13:46,759 line:0
to use “await” to refer
to the isolated “food” property.


267
00:13:46,759 --> 00:13:52,265 line:0
We have a term for this closure:
it's non-isolated code.


268
00:13:52.265 --> 00:13:53.700 line:-1 position:50%
No-isolated code is code


269
00:13:53,700 --> 00:13:56,502 line:-1
that does not run
on any actor at all.


270
00:13:56.502 --> 00:13:58.738 line:-1 position:50%
You can explicitly make
a function that's within


271
00:13:58,738 --> 00:14:02,875 line:-1
an actor non-isolated by using
the non-isolated keyword,


272
00:14:02.875 --> 00:14:05.011 line:-1 position:50%
putting it outside of the actor.


273
00:14:05,011 --> 00:14:07,714 line:-1
Just like what happened
implicitly with the closure used


274
00:14:07,714 --> 00:14:10,016 line:-1
for the detached task.


275
00:14:10,016 --> 00:14:12,652 line:-1
That means if we want to read
some of the state


276
00:14:12,652 --> 00:14:16,489 line:-1
that's isolated to the actor,
we'll need to use “await”


277
00:14:16.489 --> 00:14:20.860 line:-1 position:50%
to visit the island and grab
a copy of the state we need.


278
00:14:20.860 --> 00:14:22.762 line:-1 position:50%
Non-isolated async code


279
00:14:22,762 --> 00:14:26,165 line:-1
always runs
on the global cooperative pool.


280
00:14:26.165 --> 00:14:29.836 line:-1 position:50%
Think of it as only running when
a boat is out on the open sea,


281
00:14:29,836 --> 00:14:33,773 line:-1
so you have to leave the island
you're visiting to do the work.


282
00:14:33,773 --> 00:14:35,508 line:-1
That means checking to ensure


283
00:14:35.508 --> 00:14:39.178 line:-1 position:50%
that you aren't taking any
non-Sendable data with you!


284
00:14:39,178 --> 00:14:42,482 line:-1
Here, the compiler detects
the potential data race,


285
00:14:42.482 --> 00:14:44.717 line:-1 position:50%
where an instance
of the non-Sendable Chicken


286
00:14:44.717 --> 00:14:47.887 line:-1 position:50%
is trying to leave the island.


287
00:14:47.887 --> 00:14:52.191 line:-1 position:50%
Let's consider one more case
of non-isolated code.


288
00:14:52.191 --> 00:14:56.028 line:-1 position:50%
The “greet” operation is
non-isolated, synchronous code.


289
00:14:56,028 --> 00:14:58,531 line:-1
It knows nothing
about boats or islands


290
00:14:58,531 --> 00:15:00,767 line:-1
or concurrency in general.


291
00:15:00,767 --> 00:15:01,968 line:-1
And here, we're calling it


292
00:15:01,968 --> 00:15:04,470 line:-1
from the actor-isolated
greetOne function,


293
00:15:04,470 --> 00:15:05,805 line:-1
and that's okay!


294
00:15:05.805 --> 00:15:07.140 line:-1 position:50%
This synchronous code,


295
00:15:07,140 --> 00:15:10,176 line:-1
when called from the island,
will stay on the island,


296
00:15:10,176 --> 00:15:14,180 line:-1
so it's free to operate
on the chicken from the flock.


297
00:15:14.180 --> 00:15:17.517 line:-1 position:50%
If instead we had a non-isolated
async operation


298
00:15:17,517 --> 00:15:18,818 line:-1
that calls “greet,”


299
00:15:18.818 --> 00:15:23.089 line:-1 position:50%
then “greet” will run there,
on a boat, in the open sea.


300
00:15:23,089 --> 00:15:25,057 line:-1
Most Swift code is like this:


301
00:15:25,057 --> 00:15:27,760 line:-1
synchronous,
non-isolated to any actor,


302
00:15:27.760 --> 00:15:30.530 line:-1 position:50%
and only operates on
the parameters it's been given,


303
00:15:30,530 --> 00:15:35,868 line:-1
so it stays in the isolation
domain where it is called.


304
00:15:35,868 --> 00:15:37,870 line:-1
Actors hold state
that is isolated


305
00:15:37,870 --> 00:15:40,206 line:-1
from the rest of the program.


306
00:15:40.206 --> 00:15:43.509 line:-1 position:50%
Only one task can run
on an actor at a time,


307
00:15:43.509 --> 00:15:47.180 line:-1 position:50%
so there is no concurrent
access to that state.


308
00:15:47,180 --> 00:15:49,215 line:-1
Sendable checking
applies any time


309
00:15:49,215 --> 00:15:52,819 line:-1
a task enters or exits
an actor to ensure


310
00:15:52.819 --> 00:15:56.856 line:-1 position:50%
that no unsynchronized
mutable state escapes.


311
00:15:56,856 --> 00:15:59,892 line:-1
Altogether, this makes actors
one of the building blocks


312
00:15:59,892 --> 00:16:04,230 line:-1
for a concurrent program
in Swift.


313
00:16:04,230 --> 00:16:06,866 line:-1
There's another special actor
we often talk about


314
00:16:06,866 --> 00:16:09,202 line:-1
called the main actor.


315
00:16:09,202 --> 00:16:11,704 line:-1
Think of the main actor
as a big island


316
00:16:11,704 --> 00:16:13,606 line:-1
in the middle of the sea.


317
00:16:13,606 --> 00:16:16,609 line:-1
It represents the main thread,
where all of the drawing


318
00:16:16.609 --> 00:16:19.712 line:-1 position:50%
and interaction for
your user interface occurs.


319
00:16:19,712 --> 00:16:20,913 line:-1
So if you want to draw
something,


320
00:16:20,913 --> 00:16:24,450 line:-1
you need to run the code
on the main actor's island.


321
00:16:24,450 --> 00:16:26,519 line:-1
It's so important for your UI,


322
00:16:26,519 --> 00:16:32,124 line:-1
that maybe we should even
call it the “U-I-land."


323
00:16:32.124 --> 00:16:34.594 line:-1 position:50%
When we say
that the main actor is “big,”


324
00:16:34,594 --> 00:16:37,330 line:-1
what we mean is that
it contains a lot of state


325
00:16:37,330 --> 00:16:39,866 line:-1
related to the program's
user interface.


326
00:16:39.866 --> 00:16:40.999 line:-1 position:50%
There's a lot of code,


327
00:16:40.999 --> 00:16:43.636 line:-1 position:50%
both in the UI frameworks
and in your apps,


328
00:16:43,636 --> 00:16:45,805 line:-1
that needs to run on it.


329
00:16:45,805 --> 00:16:47,907 line:0
However, it's still an actor,


330
00:16:47,907 --> 00:16:51,310 line:0
so it only runs one job
at a time.


331
00:16:51,310 --> 00:16:53,613 position:50%
So you have to be careful
not to put too much


332
00:16:53,613 --> 00:16:55,781 line:0
or long-running work
on the main actor,


333
00:16:55,781 --> 00:17:00,052 position:50%
because it can make
your UI unresponsive.


334
00:17:00,052 --> 00:17:01,554 line:-1
Isolation to the main actor


335
00:17:01.554 --> 00:17:04.657 line:-1 position:50%
is expressed with
the MainActor attribute.


336
00:17:04,657 --> 00:17:07,994 line:-1
This attribute can be applied
to a function or closure


337
00:17:07,994 --> 00:17:12,131 line:-1
to indicate that the code
must run on the main actor.


338
00:17:12.131 --> 00:17:16.636 line:-1 position:50%
Then, we say that this code
is isolated to the main actor.


339
00:17:16,636 --> 00:17:18,471 line:-1
The Swift compiler
will guarantee


340
00:17:18,471 --> 00:17:21,340 line:-1
that main-actor-isolated code
will only be executed


341
00:17:21,340 --> 00:17:24,143 line:-1
on the main thread,
using the same mechanism


342
00:17:24.143 --> 00:17:28.281 line:-1 position:50%
that ensures mutually exclusive
access to other actors.


343
00:17:28.281 --> 00:17:29.882 line:-1 position:50%
If one calls updateView


344
00:17:29,882 --> 00:17:32,818 line:-1
from a context that isn't
isolated to the main actor,


345
00:17:32,818 --> 00:17:34,954 line:-1
it will need to introduce
an “await”


346
00:17:34.954 --> 00:17:39.191 line:-1 position:50%
to account for the switch
over to the main actor.


347
00:17:39,191 --> 00:17:42,528 line:-1
The main actor attribute
can also be applied to types,


348
00:17:42.528 --> 00:17:45.064 line:-1 position:50%
in which case the instances
of those types


349
00:17:45,064 --> 00:17:47,566 line:-1
will be isolated
to the main actor.


350
00:17:47,566 --> 00:17:50,369 line:-1
Again, this is just like
any other actor --


351
00:17:50.369 --> 00:17:52.204 line:-1 position:50%
the properties
are only accessible


352
00:17:52,204 --> 00:17:55,074 line:-1
while on the main actor,
and the methods are isolated


353
00:17:55,074 --> 00:17:58,711 line:-1
to the main actor
unless they explicitly opt out.


354
00:17:58.711 --> 00:17:59.946 line:-1 position:50%
Like normal actors,


355
00:17:59.946 --> 00:18:03.549 line:-1 position:50%
references to main-actor classes
are themselves Sendable,


356
00:18:03,549 --> 00:18:07,019 line:-1
because their data is isolated.


357
00:18:07.019 --> 00:18:09.422 line:-1 position:50%
This makes the main actor
annotation suitable


358
00:18:09.422 --> 00:18:12.224 line:-1 position:50%
for your UI views
and view controllers,


359
00:18:12.224 --> 00:18:14.694 line:-1 position:50%
which are necessarily
tied to the main thread


360
00:18:14.694 --> 00:18:16.963 line:-1 position:50%
by the frameworks themselves.


361
00:18:16,963 --> 00:18:18,798 line:-1
You can share a reference
to your view controller


362
00:18:18.798 --> 00:18:21.801 line:-1 position:50%
with other tasks
and actors in your program,


363
00:18:21,801 --> 00:18:24,737 line:-1
and they can asynchronously call
back into the view controller


364
00:18:24.737 --> 00:18:26.272 line:-1 position:50%
to post results.


365
00:18:26,272 --> 00:18:30,910 line:-1
This has a direct effect
on your app's architecture.


366
00:18:30,910 --> 00:18:31,811 line:-1
In your app,


367
00:18:31.811 --> 00:18:35.881 line:-1 position:50%
your views and view controllers
will be on the main actor.


368
00:18:35.881 --> 00:18:39.251 line:-1 position:50%
Other program logic should be
separated from that main actor,


369
00:18:39.251 --> 00:18:42.288 line:-1 position:50%
using other actors
to safely model shared state


370
00:18:42,288 --> 00:18:45,658 line:-1
and tasks to describe
independent work.


371
00:18:45.658 --> 00:18:48.260 line:-1 position:50%
And those tasks can shuttle
between the main actor


372
00:18:48.260 --> 00:18:51.430 line:-1 position:50%
and other actors as necessary.


373
00:18:51,430 --> 00:18:53,899 line:-1
There's a lot going on
in a concurrent app,


374
00:18:53,899 --> 00:18:57,136 line:-1
so we've built some great tools
to help you make sense of it.


375
00:18:57,136 --> 00:18:58,604 position:50%
I invite you to check out


376
00:18:58,604 --> 00:19:01,173 line:0
the "Visualize and Optimize
Swift Concurrency" talk


377
00:19:01,173 --> 00:19:03,642 position:50%
to learn more.


378
00:19:03.642 --> 00:19:08.547 line:-1 position:50%
Let's dive into some deeper
waters to talk about atomicity.


379
00:19:08,547 --> 00:19:10,383 line:-1
The goal of the
Swift Concurrency model


380
00:19:10,383 --> 00:19:12,651 line:-1
is to eliminate data races.


381
00:19:12.651 --> 00:19:15.054 line:-1 position:50%
What that really means
is that it eliminates


382
00:19:15,054 --> 00:19:18,624 line:-1
low-level data races,
which involve data corruption.


383
00:19:18,624 --> 00:19:23,329 line:-1
You still need to reason about
atomicity at a high level.


384
00:19:23.329 --> 00:19:24.663 line:-1 position:50%
As we've talked about before,


385
00:19:24.663 --> 00:19:28.134 line:-1 position:50%
actors only run
one task at a time.


386
00:19:28,134 --> 00:19:30,569 line:-1
However, when you stop
running on an actor,


387
00:19:30.569 --> 00:19:32.905 line:-1 position:50%
the actor can run other tasks.


388
00:19:32,905 --> 00:19:35,441 line:-1
This ensures that the program
makes progress,


389
00:19:35.441 --> 00:19:38.244 line:-1 position:50%
eliminating the potential
for deadlocks.


390
00:19:38.244 --> 00:19:41.113 line:-1 position:50%
However, it requires you to
consider your actor's invariants


391
00:19:41,113 --> 00:19:43,682 line:-1
carefully around
await statements.


392
00:19:43,682 --> 00:19:47,119 line:-1
Otherwise, you can end up
with a high-level data race


393
00:19:47.119 --> 00:19:49.622 line:-1 position:50%
where the program
is in an unexpected state,


394
00:19:49.622 --> 00:19:52.992 line:-1 position:50%
even though no data
is actually corrupted.


395
00:19:52.992 --> 00:19:56.395 line:-1 position:50%
Let's break down
an example of this.


396
00:19:56,395 --> 00:19:58,731 line:-1
Here we have a function
that intends to deposit


397
00:19:58.731 --> 00:20:01.600 line:-1 position:50%
some additional pineapples
on an island.


398
00:20:01,600 --> 00:20:06,539 line:-1
It's outside of an actor,
so it's non-isolated async code.


399
00:20:06.539 --> 00:20:10.042 line:-1 position:50%
That means it runs out here
in the open sea.


400
00:20:10,042 --> 00:20:13,512 line:-1
It's been given some pineapples
and a map to the island


401
00:20:13.512 --> 00:20:16.649 line:-1 position:50%
where it should deposit
those pineapples.


402
00:20:16,649 --> 00:20:18,751 line:-1
The first interesting
operation here


403
00:20:18.751 --> 00:20:22.021 line:-1 position:50%
gets a copy of the food array
from the island.


404
00:20:22.021 --> 00:20:24.790 line:-1 position:50%
To do that, the boat needs
to visit the island,


405
00:20:24,790 --> 00:20:27,326 line:-1
signaled by the “await” keyword.


406
00:20:27.326 --> 00:20:29.428 line:-1 position:50%
As soon as it has a copy
of the food,


407
00:20:29,428 --> 00:20:31,464 line:-1
the boat heads back out
to the open sea


408
00:20:31.464 --> 00:20:33.432 line:-1 position:50%
to continue its work.


409
00:20:33,432 --> 00:20:36,435 line:-1
That means adding the pineapple
from the pineapples parameter


410
00:20:36.435 --> 00:20:39.138 line:-1 position:50%
to the two it got
from the island.


411
00:20:39.138 --> 00:20:43.375 line:-1 position:50%
Now, we can move along to the last line
of the function.


412
00:20:43,375 --> 00:20:46,645 line:-1
Our boat now needs
to visit the island again


413
00:20:46,645 --> 00:20:50,649 line:-1
to set the island's food array
to those three pineapples.


414
00:20:50.649 --> 00:20:52.518 line:-1 position:50%
Here, everything
worked out fine,


415
00:20:52,518 --> 00:20:55,287 line:-1
and we have the three pineapples
on the island!


416
00:20:55.287 --> 00:20:58.724 line:-1 position:50%
But things could
have gone a bit differently.


417
00:20:58.724 --> 00:21:03.395 line:-1 position:50%
Let's say a pirate ship snuck in
and stole all of the pineapples


418
00:21:03.395 --> 00:21:07.299 line:-1 position:50%
while our first boat was waiting
its turn to visit the island.


419
00:21:07.299 --> 00:21:10.236 line:-1 position:50%
Now, our original ship
deposits its three pineapples


420
00:21:10,236 --> 00:21:13,205 line:-1
on the island,
and we notice a problem.


421
00:21:13,205 --> 00:21:15,341 line:-1
The three pineapples
have suddenly turned


422
00:21:15,341 --> 00:21:17,977 line:-1
into five pineapples!


423
00:21:17,977 --> 00:21:19,645 line:-1
What happened here?


424
00:21:19,645 --> 00:21:22,448 line:-1
Well, notice that we have
two awaits


425
00:21:22,448 --> 00:21:25,551 line:-1
for access to state
on the same actor,


426
00:21:25.551 --> 00:21:27.520 line:-1 position:50%
and we're making
an assumption here


427
00:21:27,520 --> 00:21:29,388 line:-1
that the food array
on the island


428
00:21:29,388 --> 00:21:32,758 line:-1
doesn't change
between those two awaits.


429
00:21:32.758 --> 00:21:34.226 line:-1 position:50%
But these are awaits,


430
00:21:34.226 --> 00:21:36.929 line:-1 position:50%
meaning that our task
could get suspended here


431
00:21:36,929 --> 00:21:39,565 line:-1
and the actor could do other
higher-priority work,


432
00:21:39,565 --> 00:21:42,501 line:-1
like battling pirates.


433
00:21:42.501 --> 00:21:45.471 line:-1 position:50%
In this specific case,
the Swift compiler will reject


434
00:21:45,471 --> 00:21:49,775 line:-1
an attempt to outright modify
the state on another actor.


435
00:21:49.775 --> 00:21:52.545 line:-1 position:50%
However, we should really
rewrite our deposit operation


436
00:21:52,545 --> 00:21:56,949 line:-1
as synchronous code
on the actor, like this.


437
00:21:56,949 --> 00:21:58,951 line:-1
Because this
is synchronous code,


438
00:21:58,951 --> 00:22:01,720 line:-1
it will run on the actor
without interruption.


439
00:22:01.720 --> 00:22:03.856 line:-1 position:50%
So we can be sure
that the state of the island


440
00:22:03.856 --> 00:22:09.795 line:-1 position:50%
will be unchanged by anyone else
throughout the entire function.


441
00:22:09.795 --> 00:22:11.130 line:-1 position:50%
When you are writing your actor,


442
00:22:11,130 --> 00:22:14,567 line:-1
think in terms of synchronous,
transactional operations


443
00:22:14.567 --> 00:22:17.102 line:-1 position:50%
that can be interleaved
in any way.


444
00:22:17.102 --> 00:22:19.538 line:-1 position:50%
Every one of them
should ensure that the actor


445
00:22:19.538 --> 00:22:23.075 line:-1 position:50%
is in a good state
when it exits.


446
00:22:23.075 --> 00:22:26.579 line:-1 position:50%
For async actor operations,
keep them simple,


447
00:22:26.579 --> 00:22:28.914 line:-1 position:50%
forming them primarily
from your synchronous,


448
00:22:28,914 --> 00:22:31,050 line:-1
transactional operations,


449
00:22:31.050 --> 00:22:33.586 line:-1 position:50%
and take care that your actor
is in a good state


450
00:22:33.586 --> 00:22:35.921 line:-1 position:50%
at each await operation.


451
00:22:35.921 --> 00:22:38.657 line:-1 position:50%
This way, you can make full use
of actors to eliminate


452
00:22:38,657 --> 00:22:42,628 line:-1
both low-level
and high-level data races.


453
00:22:42,628 --> 00:22:44,230 line:-1
In a concurrent program,


454
00:22:44.230 --> 00:22:46.265 line:-1 position:50%
many things
are happening at once,


455
00:22:46,265 --> 00:22:48,167 line:-1
so the order in which
those things happen


456
00:22:48,167 --> 00:22:51,837 line:-1
can vary from one execution
to the next.


457
00:22:51,837 --> 00:22:55,074 line:-1
And yet programs often rely
on handling events


458
00:22:55,074 --> 00:22:56,875 line:-1
in a consistent order.


459
00:22:56,875 --> 00:22:58,477 line:-1
For example,
the stream of events


460
00:22:58.477 --> 00:23:02.548 line:-1 position:50%
that come in from user input
or messages from a server.


461
00:23:02.548 --> 00:23:04.149 line:-1 position:50%
When these
event streams come in,


462
00:23:04,149 --> 00:23:07,686 line:-1
we expect their effects
to happen in order.


463
00:23:07,686 --> 00:23:11,156 line:-1
Swift Concurrency provides tools
for ordering operations,


464
00:23:11.156 --> 00:23:14.927 line:-1 position:50%
however, actors are not
the tool for doing so.


465
00:23:14,927 --> 00:23:17,696 line:-1
Actors execute the
highest-priority work first,


466
00:23:17,696 --> 00:23:20,466 line:-1
to help the overall system
stay responsive.


467
00:23:20.466 --> 00:23:22.635 line:-1 position:50%
This eliminates
priority inversions


468
00:23:22,635 --> 00:23:24,703 line:-1
where lower-priority work
ends up happening


469
00:23:24.703 --> 00:23:28.807 line:-1 position:50%
before higher-priority work
on the same actor.


470
00:23:28,807 --> 00:23:31,243 line:-1
Note that this
is a significant difference


471
00:23:31.243 --> 00:23:33.279 line:-1 position:50%
from serial Dispatch queues,


472
00:23:33.279 --> 00:23:38.617 line:-1 position:50%
which execute in a strictly
First-In, First-Out order.


473
00:23:38.617 --> 00:23:41.620 line:-1 position:50%
Swift Concurrency has several
tools for ordering work.


474
00:23:41.620 --> 00:23:45.824 line:-1 position:50%
The first we've been talking
about a lot already -- tasks.


475
00:23:45,824 --> 00:23:48,560 line:-1
Tasks execute
from beginning to end,


476
00:23:48,560 --> 00:23:50,963 line:-1
with the normal control flow
you're used to,


477
00:23:50.963 --> 00:23:54.099 line:-1 position:50%
so they naturally order work.


478
00:23:54.099 --> 00:23:58.270 line:-1 position:50%
AsyncStream can be used to model
an actual stream of events.


479
00:23:58,270 --> 00:24:01,006 line:-1
One task can iterate
over the stream of events


480
00:24:01.006 --> 00:24:05.811 line:-1 position:50%
with a for-await-in loop,
processing each event in turn.


481
00:24:05,811 --> 00:24:07,446 line:-1
An AsyncStream can be shared


482
00:24:07.446 --> 00:24:09.615 line:-1 position:50%
with any number
of event producers,


483
00:24:09,615 --> 00:24:11,283 line:-1
which can add elements
to the stream


484
00:24:11,283 --> 00:24:14,820 line:-1
while maintaining order.


485
00:24:14.820 --> 00:24:17.856 line:-1 position:50%
We've talked a lot about
how Swift's concurrency model


486
00:24:17,856 --> 00:24:20,025 line:-1
is designed to eliminate
data races


487
00:24:20,025 --> 00:24:23,095 line:-1
using the notion of isolation,
which is maintained


488
00:24:23,095 --> 00:24:26,799 line:-1
by Sendable checking
at task and actor boundaries.


489
00:24:26,799 --> 00:24:29,635 line:-1
However, we cannot all
just stop what we are doing


490
00:24:29.635 --> 00:24:32.905 line:-1 position:50%
to go mark all of the
Sendable types everywhere.


491
00:24:32,905 --> 00:24:36,141 line:-1
Instead, we need
an incremental approach.


492
00:24:36,141 --> 00:24:39,445 line:-1
Swift 5.7 introduces
a build setting to specify


493
00:24:39,445 --> 00:24:44,550 line:-1
how strictly the Swift compiler
should check for Sendability.


494
00:24:44,550 --> 00:24:46,618 line:-1
The default setting is Minimal


495
00:24:46,618 --> 00:24:49,321 line:-1
meaning that the compiler
will only diagnose places


496
00:24:49.321 --> 00:24:53.225 line:-1 position:50%
where one has explicitly tried
to mark something as Sendable.


497
00:24:53.225 --> 00:24:56.729 line:-1 position:50%
This is similar to how Swift 5.5
and 5.6 behaved,


498
00:24:56,729 --> 00:25:00,733 line:-1
and for the above, there won't
be any warnings or errors.


499
00:25:00.733 --> 00:25:03.635 line:-1 position:50%
Now, if you add
a Sendable conformance,


500
00:25:03.635 --> 00:25:06.138 line:-1 position:50%
the compiler will complain
that the Coop type


501
00:25:06.138 --> 00:25:09.708 line:-1 position:50%
cannot be Sendable because
Chicken isn't Sendable.


502
00:25:09,708 --> 00:25:13,579 line:-1
However, this -- and other
Sendable-related problems --


503
00:25:13,579 --> 00:25:17,282 line:-1
will be presented as warnings
in Swift 5, not errors,


504
00:25:17,282 --> 00:25:22,054 line:-1
to make it easier to work
through the problems one by one.


505
00:25:22,054 --> 00:25:24,623 line:-1
To move further
toward data race safety,


506
00:25:24,623 --> 00:25:28,026 line:-1
enable the “targeted”
strict concurrency setting.


507
00:25:28,026 --> 00:25:30,462 line:-1
This setting enables Sendable
checking for code


508
00:25:30.462 --> 00:25:33.132 line:-1 position:50%
that has already adopted
Swift Concurrency features


509
00:25:33,132 --> 00:25:37,069 line:-1
like async/await, tasks,
or actors.


510
00:25:37,069 --> 00:25:38,804 line:-1
This will identify, for example,


511
00:25:38,804 --> 00:25:41,740 line:-1
attempts to capture values
of non-Sendable type


512
00:25:41,740 --> 00:25:45,477 line:-1
in a newly created task.


513
00:25:45.477 --> 00:25:50.082 line:-1 position:50%
Sometimes the non-Sendable types
come from another module.


514
00:25:50,082 --> 00:25:52,551 line:-1
Perhaps it's some package
that hasn't been updated


515
00:25:52,551 --> 00:25:55,287 line:-1
for Sendable yet,
or even your own module


516
00:25:55.287 --> 00:25:57.956 line:-1 position:50%
that you just haven't
gotten around to.


517
00:25:57,956 --> 00:26:01,293 line:-1
For those, you can temporarily
disable the Sendable warnings


518
00:26:01.293 --> 00:26:03.061 line:-1 position:50%
for types that come
from that module


519
00:26:03.061 --> 00:26:07.433 line:-1 position:50%
using the @preconcurrency
attribute.


520
00:26:07.433 --> 00:26:10.369 line:-1 position:50%
This will silence Sendable
warnings for the Chicken type


521
00:26:10.369 --> 00:26:12.638 line:-1 position:50%
within this source file.


522
00:26:12.638 --> 00:26:14.573 line:-1 position:50%
At some point,
the FarmAnimals module


523
00:26:14,573 --> 00:26:17,142 line:-1
will get updated
with Sendable conformances.


524
00:26:17.142 --> 00:26:19.812 line:-1 position:50%
Then, one of two things
will happen:


525
00:26:19,812 --> 00:26:22,347 line:-1
either Chicken
becomes Sendable somehow,


526
00:26:22,347 --> 00:26:25,484 line:-1
in which case the preconcurrency
attribute can be removed


527
00:26:25,484 --> 00:26:27,352 line:-1
from the import.


528
00:26:27,352 --> 00:26:30,589 line:-1
Or Chicken will be known
to be non-Sendable,


529
00:26:30,589 --> 00:26:33,225 line:-1
in which case the warning
will come back,


530
00:26:33,225 --> 00:26:35,961 line:-1
indicating that your assumptions
about Chicken being Sendable


531
00:26:35.961 --> 00:26:38.964 line:-1 position:50%
are, in fact, not correct.


532
00:26:38.964 --> 00:26:42.100 line:-1 position:50%
The targeted strictness setting
tries to strike a balance


533
00:26:42.100 --> 00:26:44.870 line:-1 position:50%
between compatibility
with existing code


534
00:26:44.870 --> 00:26:47.806 line:-1 position:50%
and identifying potential
data races.


535
00:26:47.806 --> 00:26:49.441 line:-1 position:50%
However, if you'd like to see


536
00:26:49.441 --> 00:26:51.443 line:-1 position:50%
everywhere that races
could occur,


537
00:26:51.443 --> 00:26:55.747 line:-1 position:50%
there is one more option:
complete checking.


538
00:26:55.747 --> 00:26:59.251 line:-1 position:50%
Complete checking approximates
the intended Swift 6 semantics


539
00:26:59.251 --> 00:27:01.753 line:-1 position:50%
to completely eliminate
data races.


540
00:27:01.753 --> 00:27:04.656 line:-1 position:50%
It checks everything
that the earlier two modes check


541
00:27:04,656 --> 00:27:07,759 line:-1
but does so for all code
in the module.


542
00:27:07.759 --> 00:27:09.261 line:-1 position:50%
Here, we're not
actually making use


543
00:27:09,261 --> 00:27:11,563 line:-1
of Swift's concurrency
features at all.


544
00:27:11.563 --> 00:27:14.199 line:-1 position:50%
Rather, it's performing work
on a dispatch queue,


545
00:27:14,199 --> 00:27:17,636 line:-1
which will execute
that code concurrently.


546
00:27:17.636 --> 00:27:20.005 line:-1 position:50%
The async operation
on a dispatch queue


547
00:27:20.005 --> 00:27:22.608 line:-1 position:50%
is actually known to take
a Sendable closure,


548
00:27:22.608 --> 00:27:25.043 line:-1 position:50%
so the compiler produces
a warning indicating


549
00:27:25,043 --> 00:27:27,913 line:-1
that there is a data race
when the non-Sendable body


550
00:27:27.913 --> 00:27:31.884 line:-1 position:50%
is captured by the code
running on the dispatch queue.


551
00:27:31.884 --> 00:27:36.889 line:-1 position:50%
We can fix this by making
the body parameter Sendable.


552
00:27:36,889 --> 00:27:38,991 line:-1
That change eliminates
this warning,


553
00:27:38,991 --> 00:27:41,793 line:-1
and now all of the callers
of doWork know


554
00:27:41,793 --> 00:27:45,564 line:-1
that they need to provide
a Sendable closure.


555
00:27:45,564 --> 00:27:48,433 position:50%
That means we get better
checking for data races,


556
00:27:48,433 --> 00:27:50,736 position:50%
and we can see
that the visit function now


557
00:27:50,736 --> 00:27:53,472 line:0
is the source of a data race.


558
00:27:53,472 --> 00:27:55,474 line:0
Complete checking
will help flush out


559
00:27:55,474 --> 00:28:00,045 line:0
the potential data races
in your program.


560
00:28:00,045 --> 00:28:03,415 line:-1
To achieve Swift's goal
of eliminating data races,


561
00:28:03,415 --> 00:28:06,818 line:-1
we'll eventually need to get
to complete checking.


562
00:28:06.818 --> 00:28:10.822 line:-1 position:50%
We encourage you to work
incrementally toward that goal:


563
00:28:10.822 --> 00:28:12.691 line:-1 position:50%
adopt Swift's concurrency model


564
00:28:12,691 --> 00:28:15,294 line:-1
to architect your app
for data race safety,


565
00:28:15,294 --> 00:28:18,297 line:-1
then enable progressively
stricter concurrency checking


566
00:28:18,297 --> 00:28:21,433 line:-1
to eliminate classes
of errors from your code.


567
00:28:21,433 --> 00:28:24,836 line:-1
And don't fret over marking your
imports with @preconcurrency


568
00:28:24,836 --> 00:28:27,339 line:-1
to suppress warnings
for imported types.


569
00:28:27.339 --> 00:28:30.509 line:-1 position:50%
As those modules adopt
stricter concurrency checking,


570
00:28:30,509 --> 00:28:33,912 line:-1
the compiler will recheck
your assumptions.


571
00:28:33.912 --> 00:28:36.281 line:-1 position:50%
At the end of this road,
your code will benefit


572
00:28:36,281 --> 00:28:39,351 line:-1
from both memory safety
and data race safety,


573
00:28:39,351 --> 00:28:42,854 line:-1
helping you focus
on building great apps.


574
00:28:42,854 --> 00:28:47,225 line:-1
And thank you for sailing with me
on the sea of concurrency.


575
00:28:47,225 --> 00:28:51,730 align:right line:0 position:90%
♪

