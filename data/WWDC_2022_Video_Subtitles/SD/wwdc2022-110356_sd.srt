2
00:00:00,000 --> 00:00:03,003 line:-1
♪ instrumental hip hop music ♪


3
00:00:03,003 --> 00:00:09,843 size:2% align:right position:90%
♪


4
00:00:09.843 --> 00:00:11.478 line:-1 position:50%
Hello! My name is Konrad


5
00:00:11,478 --> 00:00:13,080 line:-1
and I'm an engineer
on the Swift team.


6
00:00:13,080 --> 00:00:15,482 line:-1
Welcome to "Meet distributed
actors in Swift."


7
00:00:15,482 --> 00:00:17,317 line:-1
In this session,
we'll learn how you can take


8
00:00:17.317 --> 00:00:21.588 line:-1 position:50%
your Swift concurrency-based
apps beyond a single process.


9
00:00:21,588 --> 00:00:23,624 line:0
Swift actors were designed
to protect you


10
00:00:23,624 --> 00:00:26,360 line:0
from low-level data races
in the same process.


11
00:00:26,360 --> 00:00:30,864 line:0
They do this by compile time
enforced actor isolation checks.


12
00:00:30.864 --> 00:00:33.934 line:-1 position:50%
Distributed actors refine
the same conceptual actor model


13
00:00:33,934 --> 00:00:36,036 line:-1
and extend it
to multiple processes,


14
00:00:36,036 --> 00:00:39,506 line:-1
such as multiple devices
or servers in a cluster.


15
00:00:39,506 --> 00:00:42,509 line:0
So just in case you are not yet
familiar with Swift actors,


16
00:00:42,509 --> 00:00:43,877 position:50%
we recommend you first watch


17
00:00:43,877 --> 00:00:46,446 position:50%
the "Protect mutable state
with Swift actors" session


18
00:00:46,446 --> 00:00:49,716 position:50%
from WWDC 2021.


19
00:00:49,716 --> 00:00:51,351 line:-1
The app we'll work on
during this session


20
00:00:51,351 --> 00:00:54,688 line:-1
is a tic-tac-toe-style game
I've been developing recently:


21
00:00:54,688 --> 00:00:56,790 line:-1
Tic Tac Fish!


22
00:00:56,790 --> 00:00:59,026 line:-1
The fun idea here
is that you can select


23
00:00:59.026 --> 00:01:01.995 line:-1 position:50%
a team you're playing for,
which then corresponds to emojis


24
00:01:01.995 --> 00:01:05.132 line:-1 position:50%
that will be used to mark
your moves as you play the game.


25
00:01:05,132 --> 00:01:07,935 line:-1
Then, as you mark
your moves on the field,


26
00:01:07,935 --> 00:01:10,637 line:-1
emojis from your team
will be placed on the field


27
00:01:10,637 --> 00:01:12,639 line:-1
until one of the players wins.


28
00:01:12,639 --> 00:01:15,676 line:-1
Right now, I have only
implemented an offline mode,


29
00:01:15,676 --> 00:01:18,445 line:-1
where I can play against
a bot opponent,


30
00:01:18,445 --> 00:01:21,014 line:-1
but I'd like to introduce
a few multiplayer modes


31
00:01:21,014 --> 00:01:23,450 line:-1
to take my app
to the next level.


32
00:01:23.450 --> 00:01:26.253 line:-1 position:50%
I'm already using actors in
this app to manage concurrency


33
00:01:26,253 --> 00:01:28,655 line:-1
and model players
involved in the game.


34
00:01:28,655 --> 00:01:31,458 line:-1
Let's see what it takes
to migrate those player actors


35
00:01:31.458 --> 00:01:34.461 line:-1 position:50%
to different processes,
and how distributed actors


36
00:01:34,461 --> 00:01:37,030 line:-1
can help me do this.


37
00:01:37,030 --> 00:01:40,300 position:50%
Before we jump to the code,
let us take a step back


38
00:01:40,300 --> 00:01:42,836 line:0
and visualize why actors
are so well-suited


39
00:01:42,836 --> 00:01:46,740 line:0
for building concurrent
and distributed applications.


40
00:01:46.740 --> 00:01:49.910 line:-1 position:50%
Throughout WWDC sessions,
you may hear us use the term


41
00:01:49.910 --> 00:01:52.913 line:-1 position:50%
"sea of concurrency"
when talking about actors.


42
00:01:52,913 --> 00:01:54,915 line:-1
This is because
it's a great mental model


43
00:01:54,915 --> 00:01:56,717 line:-1
to think about them.


44
00:01:56,717 --> 00:02:00,187 line:-1
Each actor is its own island
in the sea of concurrency,


45
00:02:00.187 --> 00:02:02.823 line:-1 position:50%
and instead of accessing
each other's islands directly,


46
00:02:02.823 --> 00:02:05.525 line:-1 position:50%
they exchange messages
between them.


47
00:02:05,525 --> 00:02:08,295 position:50%
In Swift, sending those
messages across islands


48
00:02:08,295 --> 00:02:12,165 line:0
is implemented as asynchronous
method calls and async/await.


49
00:02:12.165 --> 00:02:16.169 line:-1 position:50%
This, in combination
with actor state isolation,


50
00:02:16,169 --> 00:02:18,071 line:-1
allows the compiler to guarantee


51
00:02:18.071 --> 00:02:20.540 line:-1 position:50%
that once an actor-based
program compiles,


52
00:02:20,540 --> 00:02:23,643 line:-1
it is free from low-level
data races.


53
00:02:23,643 --> 00:02:26,613 line:0
Now let us now take
this same conceptual model


54
00:02:26,613 --> 00:02:28,248 line:0
and apply it to our game,


55
00:02:28,248 --> 00:02:30,884 position:50%
reimagined as
a distributed system.


56
00:02:30,884 --> 00:02:33,153 position:50%
We can think of each device,
node in a cluster,


57
00:02:33,153 --> 00:02:34,821 position:50%
or process
of an operating system


58
00:02:34,821 --> 00:02:37,391 position:50%
as if it were an independent
sea of concurrency,


59
00:02:37,391 --> 00:02:39,860 position:50%
here marked as
the smaller dark rectangles.


60
00:02:39.860 --> 00:02:42.262 line:-1 position:50%
Within those, we were able
to synchronize information


61
00:02:42.262 --> 00:02:44.231 line:-1 position:50%
rather easily
since they were still


62
00:02:44.231 --> 00:02:46.400 line:-1 position:50%
sharing the same memory space.


63
00:02:46.400 --> 00:02:48.602 line:-1 position:50%
And while the same concept
of message passing


64
00:02:48.602 --> 00:02:50.504 line:-1 position:50%
works perfectly well
for concurrency


65
00:02:50.504 --> 00:02:52.005 line:-1 position:50%
as well as distribution,


66
00:02:52.005 --> 00:02:53.673 line:-1 position:50%
there are a few more
restrictions


67
00:02:53,673 --> 00:02:57,577 line:-1
distribution needs to put
into place for it all to work.


68
00:02:57,577 --> 00:03:00,580 line:0
This is where distributed actors
come into the picture.


69
00:03:00,580 --> 00:03:03,717 position:50%
By using distributed actors,
we're able to establish


70
00:03:03,717 --> 00:03:07,921 line:0
a channel between two processes
and send messages between them.


71
00:03:07,921 --> 00:03:11,291 line:-1
In other words,
if Swift actors were islands


72
00:03:11,291 --> 00:03:15,062 line:-1
in the sea of concurrency,
distributed actors are the same


73
00:03:15,062 --> 00:03:17,998 line:-1
in the vast sea
of distributed systems.


74
00:03:17,998 --> 00:03:21,535 position:50%
From a programming model,
not much has really changed --


75
00:03:21,535 --> 00:03:23,670 line:0
actors still isolate their state


76
00:03:23,670 --> 00:03:27,507 position:50%
and still can only communicate
using asynchronous messages.


77
00:03:27,507 --> 00:03:29,476 line:0
We could even have
more distributed actors


78
00:03:29,476 --> 00:03:31,144 position:50%
in the same process,


79
00:03:31,144 --> 00:03:33,313 position:50%
and for all intents
and purposes,


80
00:03:33,313 --> 00:03:35,449 line:-1
they are as useful
as local actors,


81
00:03:35,449 --> 00:03:37,217 line:-1
with the difference
that they're also ready


82
00:03:37.217 --> 00:03:41.455 line:-1 position:50%
to participate in remote
interactions whenever necessary.


83
00:03:41,455 --> 00:03:44,724 line:0
This ability to be potentially
remote without having to change


84
00:03:44,724 --> 00:03:47,260 position:50%
how we interact
with such distributed actor


85
00:03:47,260 --> 00:03:51,198 line:0
is called
"location transparency."


86
00:03:51.198 --> 00:03:52.899 line:-1 position:50%
This means that regardless


87
00:03:52.899 --> 00:03:55.168 line:-1 position:50%
where a distributed actor
is located,


88
00:03:55,168 --> 00:03:57,471 line:-1
we can interact
with it the same way.


89
00:03:57.471 --> 00:03:59.339 line:-1 position:50%
This is not only
fantastic for testing,


90
00:03:59,339 --> 00:04:02,909 line:-1
as we execute
the same logic in local actors,


91
00:04:02,909 --> 00:04:05,879 line:-1
but also enables us
to transparently move our actors


92
00:04:05.879 --> 00:04:07.981 line:-1 position:50%
to wherever they
should be located,


93
00:04:07,981 --> 00:04:10,517 line:-1
without having to change
their implementation.


94
00:04:10.517 --> 00:04:12.619 line:-1 position:50%
OK, I think we're ready
to look at some code


95
00:04:12,619 --> 00:04:15,922 line:-1
and convert our first actor
to a distributed actor.


96
00:04:15,922 --> 00:04:19,192 line:-1
First, let's have a quick look
at the general game UI,


97
00:04:19.192 --> 00:04:21.361 line:-1 position:50%
and how it interacts
with my player actors.


98
00:04:21.361 --> 00:04:24.231 line:-1 position:50%
The view is a pretty standard
SwiftUI code,


99
00:04:24.231 --> 00:04:26.833 line:-1 position:50%
and I have a few
text and button elements


100
00:04:26.833 --> 00:04:28.668 line:-1 position:50%
representing the game field.


101
00:04:28.668 --> 00:04:30.504 line:-1 position:50%
As a user clicks a GameCell,


102
00:04:30.504 --> 00:04:32.973 line:-1 position:50%
we ask the player actor
to generate a move


103
00:04:32.973 --> 00:04:36.209 line:-1 position:50%
and update the view models
that power the UI.


104
00:04:36.209 --> 00:04:37.644 line:-1 position:50%
Thanks to Swift concurrency,


105
00:04:37,644 --> 00:04:40,747 line:-1
all those updates are
thread-safe and well-behaved.


106
00:04:40.747 --> 00:04:43.350 line:-1 position:50%
Currently, the actor
representing user input


107
00:04:43.350 --> 00:04:45.819 line:-1 position:50%
is implemented
as an offline player.


108
00:04:45,819 --> 00:04:47,587 line:-1
Let's have a look at it next.


109
00:04:47,587 --> 00:04:50,090 line:-1
This actor encapsulates
some state that allows it


110
00:04:50.090 --> 00:04:52.025 line:-1 position:50%
to generate game moves.


111
00:04:52,025 --> 00:04:55,729 line:-1
Specifically, it needs to track
how many moves it already made


112
00:04:55.729 --> 00:04:58.064 line:-1 position:50%
and what team it is playing for.


113
00:04:58,064 --> 00:04:59,766 line:-1
Because each team
has a number of emojis


114
00:04:59,766 --> 00:05:02,802 line:-1
to chose from for each move,
use the number of moves made


115
00:05:02,802 --> 00:05:05,405 line:-1
to select
the emoji character ID.


116
00:05:05.405 --> 00:05:09.109 line:-1 position:50%
I also need to update the model
once a move has been created.


117
00:05:09,109 --> 00:05:11,578 line:-1
The model is
a MainActor isolated class,


118
00:05:11.578 --> 00:05:13.613 line:-1 position:50%
so mutations of it
are thread-safe.


119
00:05:13.613 --> 00:05:15.182 line:-1 position:50%
I do need to use "await"


120
00:05:15.182 --> 00:05:17.817 line:-1 position:50%
as I make
the userMadeMove call, though.


121
00:05:17,817 --> 00:05:20,654 position:50%
Lastly, the offline player
also declares a method that is


122
00:05:20,654 --> 00:05:24,257 line:0
going to be called whenever
the opponent has made a move.


123
00:05:24,257 --> 00:05:27,327 line:0
The only thing we need to do
here is update the view model,


124
00:05:27,327 --> 00:05:29,596 line:0
which will make
the game field active again


125
00:05:29,596 --> 00:05:31,932 position:50%
so the human player
can select their move,


126
00:05:31,932 --> 00:05:34,768 position:50%
and the cycle continues
until the game ends.


127
00:05:34.768 --> 00:05:37.437 line:-1 position:50%
Our bot player is also
represented using an actor.


128
00:05:37,437 --> 00:05:39,606 line:-1
Its implementation
is actually quite a bit simpler


129
00:05:39,606 --> 00:05:41,007 line:-1
than the offline player


130
00:05:41,007 --> 00:05:44,077 line:-1
since it does not have to worry
about updating the view model;


131
00:05:44.077 --> 00:05:46.012 line:-1 position:50%
it just keeps track
of the GameState


132
00:05:46,012 --> 00:05:47,681 line:-1
and generates game moves.


133
00:05:47.681 --> 00:05:49.749 line:-1 position:50%
Since the bot player
is a bit simpler,


134
00:05:49.749 --> 00:05:51.751 line:-1 position:50%
I think it's a good one
to start our conversion


135
00:05:51,751 --> 00:05:53,887 line:-1
to distributed actors.


136
00:05:53,887 --> 00:05:55,789 line:-1
OK, I think we're ready
to look at some code


137
00:05:55,789 --> 00:05:59,092 line:-1
and convert our first actor
to a distributed actor.


138
00:05:59.092 --> 00:06:01.761 line:-1 position:50%
The first step towards our
distributed Tic Tac Fish game


139
00:06:01,761 --> 00:06:03,897 line:-1
will be to convert
the BotPlayer type


140
00:06:03,897 --> 00:06:04,998 line:-1
to a distributed actor,


141
00:06:04.998 --> 00:06:07.200 line:-1 position:50%
while still only
using it locally.


142
00:06:07,200 --> 00:06:10,036 line:-1
Let's open Xcode
and see how we can do that.


143
00:06:10.036 --> 00:06:12.539 line:-1 position:50%
In order to declare
a distributed actor,


144
00:06:12.539 --> 00:06:14.908 line:-1 position:50%
I'll need to import
the new distributed module,


145
00:06:14.908 --> 00:06:17.277 line:-1 position:50%
which we introduced
in Swift 5.7.


146
00:06:17,277 --> 00:06:19,479 line:-1
This module contains
all the necessary types


147
00:06:19,479 --> 00:06:23,283 line:-1
I'm going to need to declare
and use distributed actors.


148
00:06:23.283 --> 00:06:25.318 line:-1 position:50%
I can now add
the distributed keyword


149
00:06:25.318 --> 00:06:28.989 line:-1 position:50%
in front of the BotPlayer actor
declaration, like this.


150
00:06:28,989 --> 00:06:31,424 line:-1
This will cause the actor
to automatically conform


151
00:06:31,424 --> 00:06:33,093 line:-1
to the DistributedActor
protocol,


152
00:06:33.093 --> 00:06:36.029 line:-1 position:50%
and enable a number of
additional compile time checks.


153
00:06:36,029 --> 00:06:37,230 line:-1
Let's see what kind of errors


154
00:06:37.230 --> 00:06:39.466 line:-1 position:50%
the compiler will ask us
to fix now.


155
00:06:39.466 --> 00:06:42.369 line:-1 position:50%
The compiler helpfully tells us
that the BotPlayer does not


156
00:06:42,369 --> 00:06:44,738 line:-1
declare an ActorSystem
it can be used with.


157
00:06:44.738 --> 00:06:45.872 line:-1 position:50%
As distributed actors


158
00:06:45,872 --> 00:06:48,441 line:-1
always belong to some
distributed actor system,


159
00:06:48.441 --> 00:06:50.510 line:-1 position:50%
which handles all
the serialization and networking


160
00:06:50,510 --> 00:06:52,579 line:-1
necessary to perform
remote calls;


161
00:06:52,579 --> 00:06:55,215 line:-1
we need to declare
what type of actor system


162
00:06:55.215 --> 00:06:57.784 line:-1 position:50%
this actor is intended
to be used with.


163
00:06:57,784 --> 00:07:00,720 line:-1
Since, for now, my only goal
is to have the bot player


164
00:07:00.720 --> 00:07:03.056 line:-1 position:50%
pass all the distributed
isolation checks,


165
00:07:03.056 --> 00:07:06.393 line:-1 position:50%
without actually running it on
a remote host, I can use the


166
00:07:06,393 --> 00:07:08,561 line:-1
LocalTestingDistributedActor
System


167
00:07:08.561 --> 00:07:10.797 line:-1 position:50%
that comes
with the Distributed module.


168
00:07:10,797 --> 00:07:11,931 line:-1
I can tell the compiler


169
00:07:11,931 --> 00:07:14,067 line:-1
about the actor system
we're going to use


170
00:07:14,067 --> 00:07:15,802 line:-1
by either declaring
a module-wide


171
00:07:15.802 --> 00:07:18.405 line:-1 position:50%
DefaultDistributedActorSystem
typealias,


172
00:07:18.405 --> 00:07:22.809 line:-1 position:50%
or an ActorSystem typealias in
the body of the specific actor.


173
00:07:22,809 --> 00:07:27,314 line:-1
The latter bit is a bit more
specific, so let's go with that.


174
00:07:32,319 --> 00:07:34,554 line:-1
The next error is about
the "id" property,


175
00:07:34.554 --> 00:07:36.456 line:-1 position:50%
that I had previously
implemented manually


176
00:07:36.456 --> 00:07:39.092 line:-1 position:50%
in order to conform
to the Identifiable protocol


177
00:07:39,092 --> 00:07:41,895 line:-1
that both my player actors
need to conform to.


178
00:07:41,895 --> 00:07:44,631 line:-1
The error now says
that the ID property


179
00:07:44,631 --> 00:07:47,701 line:-1
cannot be defined explicitly
as it conflicts


180
00:07:47,701 --> 00:07:50,870 line:-1
with a distributed actor
synthesized property.


181
00:07:50,870 --> 00:07:53,707 line:-1
IDs are a crucial piece
of distributed actors.


182
00:07:53.707 --> 00:07:56.076 line:-1 position:50%
They are used
to uniquely identify an actor


183
00:07:56.076 --> 00:08:00.113 line:-1 position:50%
in the entire distributed actor
system that it is part of.


184
00:08:00.113 --> 00:08:02.649 line:-1 position:50%
They are assigned by
the distributed actor system


185
00:08:02,649 --> 00:08:04,050 line:-1
as the actor is initialized,


186
00:08:04.050 --> 00:08:06.286 line:-1 position:50%
and later managed
by that system.


187
00:08:06,286 --> 00:08:08,488 line:-1
As such,
we cannot declare or assign


188
00:08:08,488 --> 00:08:10,323 line:-1
the ID property manually --


189
00:08:10.323 --> 00:08:12.592 line:-1 position:50%
the actor system
will be doing this for us.


190
00:08:12.592 --> 00:08:15.428 line:-1 position:50%
In other words, I can simply
leave it to the actor system


191
00:08:15.428 --> 00:08:18.998 line:-1 position:50%
and remove my manually
declared ID property.


192
00:08:18.998 --> 00:08:20.934 line:-1 position:50%
The last error
we need to deal with here


193
00:08:20,934 --> 00:08:23,670 line:-1
is the distributed
actor's initializer.


194
00:08:23.670 --> 00:08:26.206 line:-1 position:50%
The compiler says
that the actorSystem property


195
00:08:26,206 --> 00:08:28,742 line:-1
has not been
initialized before use.


196
00:08:28,742 --> 00:08:31,077 line:-1
This is another compiler
synthesized property


197
00:08:31.077 --> 00:08:33.413 line:-1 position:50%
that is part
of every distributed actor.


198
00:08:33.413 --> 00:08:36.282 line:-1 position:50%
Not only do we need to declare
the type of actor system


199
00:08:36,282 --> 00:08:38,718 line:-1
we want to use,
but we also need to initialize


200
00:08:38.718 --> 00:08:40.887 line:-1 position:50%
the synthesized
actorSystem property


201
00:08:40.887 --> 00:08:43.156 line:-1 position:50%
with some concrete actor system.


202
00:08:43,156 --> 00:08:45,024 line:-1
Generally,
the right thing to do here


203
00:08:45,024 --> 00:08:47,360 line:-1
is to accept an actor system
in the initializer,


204
00:08:47.360 --> 00:08:49.462 line:-1 position:50%
and pass it through
to the property.


205
00:08:49.462 --> 00:08:52.198 line:-1 position:50%
This way, I could pass in
a different actor system


206
00:08:52,198 --> 00:08:56,469 line:-1
implementation in my tests
to facilitate easy unit testing.


207
00:08:56.469 --> 00:08:59.205 line:-1 position:50%
We'll also have to pass
an instance whenever we create


208
00:08:59,205 --> 00:09:03,109 line:-1
a new bot player,
so let's do this now.


209
00:09:11.117 --> 00:09:14.387 line:-1 position:50%
Awesome! We're done with
all the declaration side errors.


210
00:09:14.387 --> 00:09:15.889 line:-1 position:50%
But there's still
some call-site errors


211
00:09:15.889 --> 00:09:18.858 line:-1 position:50%
we need to address though.


212
00:09:18,858 --> 00:09:20,693 line:-1
It seems that
only distributed methods


213
00:09:20,693 --> 00:09:23,963 line:-1
can be called on potentially
remote distributed actors.


214
00:09:23,963 --> 00:09:27,434 line:-1
This is similar to annotating
only some actors in your system


215
00:09:27.434 --> 00:09:29.402 line:-1 position:50%
as distributed actors.


216
00:09:29.402 --> 00:09:31.337 line:-1 position:50%
Not every method
on a distributed actor


217
00:09:31,337 --> 00:09:34,307 line:-1
is necessarily designed
to be called remotely.


218
00:09:34,307 --> 00:09:36,342 line:-1
They can have
small helper functions,


219
00:09:36,342 --> 00:09:38,244 line:-1
or functions
which assume the caller


220
00:09:38.244 --> 00:09:40.380 line:-1 position:50%
has already been authenticated.


221
00:09:40.380 --> 00:09:43.116 line:-1 position:50%
This is why Swift asks you
to be explicit about


222
00:09:43,116 --> 00:09:45,251 line:-1
the distributed API surface,


223
00:09:45.251 --> 00:09:47.720 line:-1 position:50%
you want to expose
to remote callers.


224
00:09:47.720 --> 00:09:50.457 line:-1 position:50%
Thankfully, this is also
easily fixed by just adding


225
00:09:50.457 --> 00:09:53.393 line:-1 position:50%
the distributed keyword
to those functions.


226
00:09:53,393 --> 00:09:55,895 line:-1
As both makeMove
and opponentMoved methods


227
00:09:55,895 --> 00:09:57,831 line:-1
are intended
to be called remotely,


228
00:09:57,831 --> 00:10:01,935 line:-1
let me add the distributed
keyword to them to both of them.


229
00:10:06,439 --> 00:10:09,375 line:-1
OK! With that,
there's only one last thing


230
00:10:09.375 --> 00:10:11.311 line:-1 position:50%
we need to take care of.


231
00:10:11,311 --> 00:10:14,214 line:-1
As distributed method calls
can cross network boundaries,


232
00:10:14,214 --> 00:10:16,583 line:-1
we need to ensure
that all of their parameters


233
00:10:16,583 --> 00:10:19,352 line:-1
and return values conform
to the serialization requirement


234
00:10:19,352 --> 00:10:21,321 line:-1
of the actor system.


235
00:10:21.321 --> 00:10:24.123 line:-1 position:50%
In our case, the actor system
is using Codable,


236
00:10:24.123 --> 00:10:26.459 line:-1 position:50%
Swift's native
serialization mechanism.


237
00:10:26.459 --> 00:10:28.995 line:-1 position:50%
Specifically, the compiler
tells us that,


238
00:10:28.995 --> 00:10:31.664 line:-1 position:50%
"Result type GameMove
does not conform


239
00:10:31.664 --> 00:10:34.634 line:-1 position:50%
to the serialization
requirement Codable."


240
00:10:34.634 --> 00:10:37.737 line:-1 position:50%
Let me have a quick look
at the GameMove type.


241
00:10:37.737 --> 00:10:40.640 line:-1 position:50%
Luckily, it seems that
it's a clean little data type


242
00:10:40.640 --> 00:10:42.375 line:-1 position:50%
that I can easily make Codable


243
00:10:42.375 --> 00:10:44.944 line:-1 position:50%
by just adding
the necessary conformance.


244
00:10:44,944 --> 00:10:46,546 line:-1
The Swift compiler
will synthesize


245
00:10:46.546 --> 00:10:49.115 line:-1 position:50%
the necessary Codable
implementation for me.


246
00:10:49.115 --> 00:10:50.450 line:-1 position:50%
And with that, we're done!


247
00:10:50.450 --> 00:10:53.486 line:-1 position:50%
I can check
the game runs as expected.


248
00:10:55,488 --> 00:10:57,690 line:-1
OK, a point for team fish!


249
00:10:57.690 --> 00:10:59.792 line:-1 position:50%
And although
the bot player still executing


250
00:10:59,792 --> 00:11:02,529 line:-1
on the same local device,
we have already paved the way


251
00:11:02.529 --> 00:11:04.864 line:-1 position:50%
for the exciting next step.


252
00:11:04,864 --> 00:11:06,566 line:-1
In this step, we'll actually
reap the benefits


253
00:11:06.566 --> 00:11:10.770 line:-1 position:50%
of the bot player's newly gained
location transparency powers.


254
00:11:10.770 --> 00:11:12.639 line:-1 position:50%
I have already prepared
a WebSocket-based


255
00:11:12,639 --> 00:11:15,608 line:-1
sample actor system
that we can use for this.


256
00:11:15.608 --> 00:11:17.343 line:-1 position:50%
By making use
of this actor system,


257
00:11:17,343 --> 00:11:18,945 line:-1
we'll be able
to move our bot player


258
00:11:18.945 --> 00:11:20.880 line:-1 position:50%
to a server-side
Swift application,


259
00:11:20.880 --> 00:11:24.350 line:-1 position:50%
and resolve a remote reference
to it from our mobile game.


260
00:11:24,350 --> 00:11:26,185 line:-1
As far as the actor
is concerned,


261
00:11:26.185 --> 00:11:28.988 line:-1 position:50%
we only need to change
the declared ActorSystem


262
00:11:28.988 --> 00:11:31.658 line:-1 position:50%
from the LocalTesting
DistributedActor System


263
00:11:31.658 --> 00:11:34.928 line:-1 position:50%
to the
SampleWebSocketActorSystem


264
00:11:34,928 --> 00:11:37,230 line:-1
that I prepared
for the sample app.


265
00:11:37,230 --> 00:11:40,366 line:-1
The rest of the actor code
remains the same.


266
00:11:40,366 --> 00:11:43,570 line:-1
Next, let us resolve
a remote bot player reference,


267
00:11:43,570 --> 00:11:45,672 line:-1
rather than
creating one locally.


268
00:11:45,672 --> 00:11:49,442 line:-1
It is worth keeping in mind that
the terms "local" and "remote"


269
00:11:49.442 --> 00:11:52.645 line:-1 position:50%
are a matter of perspective when
it comes to distributed actors.


270
00:11:52.645 --> 00:11:55.748 line:-1 position:50%
For every remote reference,
there is some corresponding


271
00:11:55,748 --> 00:11:57,784 line:-1
local instance
on some other node


272
00:11:57.784 --> 00:11:59.485 line:-1 position:50%
in the distributed actor system.


273
00:11:59.485 --> 00:12:01.888 line:-1 position:50%
Creating a local instance
of a distributed actor


274
00:12:01.888 --> 00:12:05.091 line:-1 position:50%
is performed much the same way
as any other Swift object:


275
00:12:05,091 --> 00:12:06,726 line:-1
by calling its initializer.


276
00:12:06.726 --> 00:12:10.029 line:-1 position:50%
Obtaining a remote reference
to a distributed actor, however,


277
00:12:10.029 --> 00:12:12.565 line:-1 position:50%
follows a slightly
different pattern.


278
00:12:12.565 --> 00:12:14.400 line:-1 position:50%
Instead of creating an actor,


279
00:12:14.400 --> 00:12:17.036 line:-1 position:50%
we will attempt to resolve
an actor ID


280
00:12:17,036 --> 00:12:19,072 line:-1
using a concrete actor system.


281
00:12:19,072 --> 00:12:22,609 line:-1
The static resolve method allows
us to ask an actor system


282
00:12:22.609 --> 00:12:25.111 line:-1 position:50%
to attempt to give us
an existing actor instance


283
00:12:25.111 --> 00:12:27.113 line:-1 position:50%
for an actor with that ID


284
00:12:27,113 --> 00:12:31,017 line:-1
or, return a remote reference
to an actor identified by it.


285
00:12:31.017 --> 00:12:33.519 line:-1 position:50%
Actor systems should not
perform actual remote lookups


286
00:12:33.519 --> 00:12:36.389 line:-1 position:50%
when resolving identifiers
because as you can see,


287
00:12:36,389 --> 00:12:38,958 line:-1
the resolve method
is not asynchronous,


288
00:12:38.958 --> 00:12:40.793 line:-1 position:50%
and therefore
should return quickly


289
00:12:40.793 --> 00:12:42.328 line:-1 position:50%
and not perform any networking


290
00:12:42,328 --> 00:12:44,263 line:-1
or otherwise
blocking operations.


291
00:12:44.263 --> 00:12:47.033 line:-1 position:50%
If an identity looks valid,
and seems to be pointing


292
00:12:47,033 --> 00:12:50,036 line:-1
at a valid remote location,
systems shall assume


293
00:12:50,036 --> 00:12:53,973 line:-1
that such actor exists and
return a remote reference to it.


294
00:12:53,973 --> 00:12:57,343 line:-1
Keep in mind that
at the time of resolving an ID,


295
00:12:57,343 --> 00:13:00,079 line:-1
the actual instance
on the remote system


296
00:13:00,079 --> 00:13:01,948 line:-1
may not even exist yet!


297
00:13:01,948 --> 00:13:04,517 line:-1
For example, here we're
making up a random identifier


298
00:13:04.517 --> 00:13:05.985 line:-1 position:50%
for an opponent bot player


299
00:13:05.985 --> 00:13:08.821 line:-1 position:50%
that should be dedicated
to playing a game with us.


300
00:13:08.821 --> 00:13:11.124 line:-1 position:50%
This bot does not exist yet,
but it will be created


301
00:13:11.124 --> 00:13:13.426 line:-1 position:50%
on the server-side system
as the first message


302
00:13:13,426 --> 00:13:16,062 line:-1
designated to this ID
is received.


303
00:13:16,062 --> 00:13:19,198 line:-1
Now moving on to
a server-side Swift application.


304
00:13:19.198 --> 00:13:22.001 line:-1 position:50%
Thanks to the sample WebSocket
actor system I prepared,


305
00:13:22.001 --> 00:13:24.704 line:-1 position:50%
implementing that
will be a breeze.


306
00:13:24.704 --> 00:13:28.608 line:-1 position:50%
First, we create the WebSocket
actor system in server mode,


307
00:13:28,608 --> 00:13:30,309 line:-1
which makes it bind
and listen to the port


308
00:13:30,309 --> 00:13:32,912 line:-1
rather than connect to it.


309
00:13:32.912 --> 00:13:36.716 line:-1 position:50%
And we have the app wait
until the system is terminated.


310
00:13:36,716 --> 00:13:38,985 line:0
Next, we'll somehow need
to handle the pattern


311
00:13:38,985 --> 00:13:40,520 position:50%
of creating actors on demand


312
00:13:40,520 --> 00:13:43,322 position:50%
as we receive messages
addressed to IDs


313
00:13:43,322 --> 00:13:46,759 position:50%
that are not yet assigned
any actor instances.


314
00:13:46,759 --> 00:13:49,696 line:0
Generally, the actor system
will receive incoming messages,


315
00:13:49.696 --> 00:13:52.432 line:-1 position:50%
attempt to resolve
their recipient IDs


316
00:13:52.432 --> 00:13:55.268 line:-1 position:50%
in order locate a local
distributed actor instance,


317
00:13:55,268 --> 00:13:59,672 line:-1
and then execute a remote call
on the located actor.


318
00:13:59.672 --> 00:14:01.107 line:-1 position:50%
As we just discussed though,


319
00:14:01.107 --> 00:14:03.943 line:-1 position:50%
our bot player IDs
are literally made up,


320
00:14:03,943 --> 00:14:07,647 line:0
so the system can't possibly
know about them


321
00:14:07,647 --> 00:14:11,684 position:50%
and even less so create the
right type of actor by itself.


322
00:14:11.684 --> 00:14:14.253 line:-1 position:50%
Thankfully, our sample actor
system implementation


323
00:14:14,253 --> 00:14:16,756 line:-1
has just the right pattern
prepared for us:


324
00:14:16,756 --> 00:14:18,725 line:-1
on-demand actor creation.


325
00:14:18,725 --> 00:14:21,160 line:-1
Please note here
that this is only a pattern,


326
00:14:21.160 --> 00:14:22.995 line:-1 position:50%
and not something built in
or provided by


327
00:14:22.995 --> 00:14:25.098 line:-1 position:50%
the distributed actor module.


328
00:14:25,098 --> 00:14:27,366 line:-1
It is, however,
a great example of how flexible


329
00:14:27.366 --> 00:14:30.737 line:-1 position:50%
and powerful actor system
implementations can be.


330
00:14:30,737 --> 00:14:32,939 line:-1
A system can offer
various patterns


331
00:14:32.939 --> 00:14:36.209 line:-1 position:50%
and make complex tasks
simple to deal with.


332
00:14:36.209 --> 00:14:38.978 line:-1 position:50%
Using this pattern,
the actor system attempts


333
00:14:38,978 --> 00:14:42,815 line:-1
to resolve a local actor
for all incoming IDs as usual.


334
00:14:42.815 --> 00:14:45.585 line:-1 position:50%
However, when it fails
to find an existing actor,


335
00:14:45,585 --> 00:14:47,920 line:-1
it attempts to
resolveCreateOnDemand.


336
00:14:47.920 --> 00:14:50.089 line:-1 position:50%
Since we are in control
of both our client code


337
00:14:50.089 --> 00:14:53.059 line:-1 position:50%
making up the IDs
and the piece of server code,


338
00:14:53.059 --> 00:14:55.061 line:-1 position:50%
we can help
the actor system out


339
00:14:55.061 --> 00:14:58.064 line:-1 position:50%
by creating
the necessary actors on demand.


340
00:14:58.064 --> 00:15:00.933 line:-1 position:50%
Since the bot identifiers
we have been making up


341
00:15:00,933 --> 00:15:04,103 line:-1
on the client are using some
recognizable naming scheme --


342
00:15:04.103 --> 00:15:06.906 line:-1 position:50%
like adding tags
to the ActorIdentity


343
00:15:06,906 --> 00:15:09,542 line:-1
or just using
some recognizable names --


344
00:15:09.542 --> 00:15:12.211 line:-1 position:50%
we can detect those IDs
and create a new bot opponent


345
00:15:12,211 --> 00:15:15,681 line:-1
for every message that does not
have one active yet.


346
00:15:15.681 --> 00:15:17.583 line:-1 position:50%
We'll only create
a new bot player


347
00:15:17.583 --> 00:15:19.685 line:-1 position:50%
for the first message
designated to it,


348
00:15:19,685 --> 00:15:21,154 line:-1
as subsequent remote calls


349
00:15:21,154 --> 00:15:24,157 line:-1
will simply resolve
the existing instance.


350
00:15:24.157 --> 00:15:25.992 line:-1 position:50%
And that's all there is to it!


351
00:15:25,992 --> 00:15:27,693 line:-1
Our server implementation
is complete


352
00:15:27.693 --> 00:15:30.963 line:-1 position:50%
and we can now play a game
with our remote bot player.


353
00:15:30.963 --> 00:15:34.467 line:-1 position:50%
We can run the server from the
command line using Swift run,


354
00:15:34.467 --> 00:15:37.403 line:-1 position:50%
or using Xcode
and selecting the server scheme


355
00:15:37.403 --> 00:15:39.472 line:-1 position:50%
and clicking Run as usual.


356
00:15:39,472 --> 00:15:41,207 position:50%
As we're done
making our first move,


357
00:15:41,207 --> 00:15:44,343 line:0
we ask the bot player to do
the same by calling makeMove


358
00:15:44,343 --> 00:15:46,846 line:0
on the remote player reference
we have created.


359
00:15:46,846 --> 00:15:49,615 line:0
This triggers a resolve
in the server-side system.


360
00:15:49,615 --> 00:15:52,285 line:0
It can't find an existing bot
for this ID,


361
00:15:52,285 --> 00:15:55,788 position:50%
so it attempts and succeeds,
creating a bot on demand.


362
00:15:55,788 --> 00:15:58,291 line:0
The bot receives
a makeMove call,


363
00:15:58,291 --> 00:16:01,327 position:50%
and replies with the GameMove
it generated.


364
00:16:01,327 --> 00:16:03,162 line:-1
That was pretty great already!


365
00:16:03.162 --> 00:16:05.064 line:-1 position:50%
While we did have to do
some up-front work


366
00:16:05.064 --> 00:16:07.567 line:-1 position:50%
to convert our bot player
to a distributed actor,


367
00:16:07.567 --> 00:16:09.368 line:-1 position:50%
actually moving it
to the remote system


368
00:16:09,368 --> 00:16:11,370 line:-1
was pretty straightforward.


369
00:16:11,370 --> 00:16:13,172 line:-1
And we didn't have
to deal with any networking


370
00:16:13.172 --> 00:16:16.576 line:-1 position:50%
or serialization implementation
details at all!


371
00:16:16,576 --> 00:16:18,077 line:-1
All the heavy lifting
was done for us


372
00:16:18.077 --> 00:16:19.846 line:-1 position:50%
by the distributed actor system.


373
00:16:19,846 --> 00:16:21,414 line:-1
And while there aren't
many hardened


374
00:16:21,414 --> 00:16:24,050 line:-1
feature-complete implementations
available just yet,


375
00:16:24.050 --> 00:16:25.818 line:-1 position:50%
this ease of going distributed


376
00:16:25.818 --> 00:16:28.287 line:-1 position:50%
is something we're striving
for with this feature.


377
00:16:28.287 --> 00:16:29.755 line:-1 position:50%
Next,
let's see how we can build


378
00:16:29.755 --> 00:16:32.725 line:-1 position:50%
a true multiplayer experience
for our game.


379
00:16:32.725 --> 00:16:34.961 line:-1 position:50%
Our previous example
used distributed actors


380
00:16:34.961 --> 00:16:37.096 line:-1 position:50%
in a client/server scenario,
which you may be


381
00:16:37.096 --> 00:16:39.932 line:-1 position:50%
familiar with already
from other apps you worked on.


382
00:16:39,932 --> 00:16:42,101 line:-1
However, distributed actors
can also be used


383
00:16:42.101 --> 00:16:43.836 line:-1 position:50%
in peer-to-peer systems,


384
00:16:43,836 --> 00:16:46,772 line:-1
where there isn't a dedicated
server component at all.


385
00:16:46.772 --> 00:16:48.774 line:-1 position:50%
This matches another idea
I had for our game.


386
00:16:48.774 --> 00:16:51.010 line:-1 position:50%
Sometimes when traveling,
you end up in these locations


387
00:16:51,010 --> 00:16:53,179 line:-1
that don't really have
great internet,


388
00:16:53.179 --> 00:16:55.581 line:-1 position:50%
but the local Wi-Fi works great.


389
00:16:55.581 --> 00:16:57.216 line:-1 position:50%
I'd like to still
be able to challenge


390
00:16:57.216 --> 00:16:58.251 line:-1 position:50%
and play with my friends --


391
00:16:58.251 --> 00:16:59.952 line:-1 position:50%
which are connected
to the same network --


392
00:16:59.952 --> 00:17:02.321 line:-1 position:50%
as I end up in such a situation.


393
00:17:02.321 --> 00:17:03.756 line:-1 position:50%
I went ahead and implemented


394
00:17:03.756 --> 00:17:06.058 line:-1 position:50%
another actor system
implementation,


395
00:17:06,058 --> 00:17:07,693 line:-1
this time using
local networking features


396
00:17:07,693 --> 00:17:10,029 line:-1
offered by Network framework.


397
00:17:10,029 --> 00:17:11,864 line:-1
While we don't dive into
the implementation


398
00:17:11.864 --> 00:17:14.367 line:-1 position:50%
of that actor system
in this talk, you can watch


399
00:17:14,367 --> 00:17:18,571 line:0
"Advances in Networking, Part 2"
from WWDC 2019


400
00:17:18,571 --> 00:17:21,440 position:50%
to learn how you would implement
such custom protocol.


401
00:17:21,440 --> 00:17:24,310 line:-1
It is also worth pointing out
that access to local network


402
00:17:24.310 --> 00:17:26.946 line:-1 position:50%
can expose very
privacy-sensitive information,


403
00:17:26,946 --> 00:17:29,548 line:-1
so please take care
to use it respectfully.


404
00:17:29.548 --> 00:17:31.083 line:-1 position:50%
Since this time
we'll be dealing with


405
00:17:31,083 --> 00:17:33,920 line:-1
already existing distributed
actors on other devices,


406
00:17:33,920 --> 00:17:36,122 line:-1
we can no longer
just make up the IDs


407
00:17:36,122 --> 00:17:38,424 line:-1
like we did in the previous
example.


408
00:17:38,424 --> 00:17:40,226 line:-1
We have to discover
the specific actor


409
00:17:40.226 --> 00:17:42.962 line:-1 position:50%
on the other device
we'd like to play a game with.


410
00:17:42.962 --> 00:17:45.331 line:-1 position:50%
This problem isn't unique
to distributed actors,


411
00:17:45.331 --> 00:17:48.467 line:-1 position:50%
and is generally solved using
service discovery mechanisms.


412
00:17:48.467 --> 00:17:50.970 line:-1 position:50%
However, in the domain
of distributed actors,


413
00:17:50.970 --> 00:17:53.272 line:-1 position:50%
there is a common pattern
and style of API


414
00:17:53,272 --> 00:17:55,775 line:-1
actor systems are expected
to offer that allows you


415
00:17:55,775 --> 00:17:59,278 line:-1
to stick to strongly-typed APIs
throughout all your code.


416
00:17:59,278 --> 00:18:01,414 position:50%
We call it
the receptionist pattern,


417
00:18:01,414 --> 00:18:04,684 line:0
because similar to a hotel,
actors need to check in with it


418
00:18:04,684 --> 00:18:08,321 line:0
in order to become known and
available for others to meet.


419
00:18:08,321 --> 00:18:10,690 position:50%
Every actor system
has its own receptionist


420
00:18:10,690 --> 00:18:13,659 position:50%
and they can use whatever means
most suitable for the underlying


421
00:18:13,659 --> 00:18:16,996 position:50%
transport mechanisms
to implement actor discovery.


422
00:18:16.996 --> 00:18:20.533 line:-1 position:50%
Sometimes this may rely on
existing service discovery APIs,


423
00:18:20,533 --> 00:18:23,703 line:-1
and only layer a type-safe API
on top of them,


424
00:18:23,703 --> 00:18:26,405 line:-1
or it may implement
a gossip-based mechanism,


425
00:18:26,405 --> 00:18:28,240 line:-1
or something else entirely.


426
00:18:28,240 --> 00:18:30,209 line:-1
This, however,
is an implementation detail


427
00:18:30.209 --> 00:18:33.145 line:-1 position:50%
from the perspective
of the user of the actor system;


428
00:18:33.145 --> 00:18:35.815 line:-1 position:50%
all we need to care about
is checking in our actor


429
00:18:35,815 --> 00:18:37,350 line:-1
to make it discoverable


430
00:18:37,350 --> 00:18:39,352 line:-1
and look up actors
by some tag or type


431
00:18:39.352 --> 00:18:41.487 line:-1 position:50%
when we need to discover them.


432
00:18:41,487 --> 00:18:44,290 position:50%
Let's have a look at a simple
receptionist I have implemented


433
00:18:44,290 --> 00:18:46,926 position:50%
for our
SampleLocalNetworkActorSystem.


434
00:18:46,926 --> 00:18:50,863 line:-1
It allows an actor to check in,
which enables all receptionists


435
00:18:50.863 --> 00:18:53.499 line:-1 position:50%
in the distributed actor system
to discover it.


436
00:18:53,499 --> 00:18:57,403 line:-1
We can then get a listing
of all actors of a specific type


437
00:18:57.403 --> 00:19:00.806 line:-1 position:50%
and tag as they become
available in that system.


438
00:19:00,806 --> 00:19:03,009 line:-1
Let's use this receptionist
to discover


439
00:19:03,009 --> 00:19:06,679 line:-1
a concrete opponent actor
we'd like to play a game with.


440
00:19:06,679 --> 00:19:09,448 line:-1
Previously, our GameView
directly created --


441
00:19:09.448 --> 00:19:12.852 line:-1 position:50%
or resolved -- an opponent
in its view initializer.


442
00:19:12.852 --> 00:19:15.354 line:-1 position:50%
We can no longer do this,
as we need to asynchronously


443
00:19:15,354 --> 00:19:18,157 line:-1
wait for an opponent
to appear on the network.


444
00:19:18.157 --> 00:19:21.460 line:-1 position:50%
To do this, let me introduce
a matchmaking view


445
00:19:21,460 --> 00:19:23,596 line:-1
that will show a "Looking for
opponent..." message


446
00:19:23,596 --> 00:19:25,731 line:-1
while we're trying
to discover one.


447
00:19:25.731 --> 00:19:28.701 line:-1 position:50%
As this view appears,
we'll kick off the matchmaking.


448
00:19:28.701 --> 00:19:29.835 line:-1 position:50%
The matchmaking will be done


449
00:19:29,835 --> 00:19:32,571 line:-1
in a new unstructured task
in which we'll ask


450
00:19:32.571 --> 00:19:34.807 line:-1 position:50%
the local actor system's
receptionist


451
00:19:34,807 --> 00:19:36,909 line:-1
for a listing
of all actors tagged


452
00:19:36,909 --> 00:19:39,545 line:-1
using the opposing team's tag.


453
00:19:39,545 --> 00:19:41,580 line:-1
So if we're playing
for team fish,


454
00:19:41.580 --> 00:19:44.750 line:-1 position:50%
we'll be looking for players
from the team rodents,


455
00:19:44.750 --> 00:19:45.785 line:-1 position:50%
and vice versa.


456
00:19:45,785 --> 00:19:47,953 position:50%
Next,
we'll use an async for loop


457
00:19:47,953 --> 00:19:50,156 line:0
to await incoming
opponent actors.


458
00:19:50,156 --> 00:19:52,992 line:0
As the system discovers
a nearby device with an opponent


459
00:19:52,992 --> 00:19:56,128 position:50%
we could play with,
this task loop will be resumed.


460
00:19:56,128 --> 00:19:58,998 position:50%
Let's assume the opponent
is always ready to play a game


461
00:19:58,998 --> 00:20:00,766 line:0
and immediately store it
in our model


462
00:20:00,766 --> 00:20:02,435 position:50%
and start a game with them.


463
00:20:02.435 --> 00:20:03.936 line:-1 position:50%
We use a helper function
to decide


464
00:20:03,936 --> 00:20:06,338 line:-1
who should make the first move,
and finally,


465
00:20:06,338 --> 00:20:09,442 line:-1
tell the opponent that we want
to start a game with them.


466
00:20:09,442 --> 00:20:11,744 position:50%
Be sure to return here,
in order to break out


467
00:20:11,744 --> 00:20:14,447 position:50%
of the async for loop,
as we only need one opponent


468
00:20:14,447 --> 00:20:16,615 line:0
to be done
with our matchmaking task.


469
00:20:16.615 --> 00:20:19.285 line:-1 position:50%
For this gameplay mode,
we do have to change


470
00:20:19,285 --> 00:20:21,720 line:-1
our OfflinePlayer implementation
a little.


471
00:20:21,720 --> 00:20:24,056 line:-1
Let's call it
LocalNetworkPlayer,


472
00:20:24.056 --> 00:20:27.793 line:-1 position:50%
and it'll be using the
SampleLocalNetworkActorSystem.


473
00:20:27.793 --> 00:20:31.330 line:-1 position:50%
What's most interesting about it
is that the makeMove method


474
00:20:31.330 --> 00:20:33.699 line:-1 position:50%
of the the actor
representing a human player


475
00:20:33,699 --> 00:20:35,701 line:-1
may now be invoked remotely!


476
00:20:35.701 --> 00:20:37.470 line:-1 position:50%
But making the move is actually


477
00:20:37.470 --> 00:20:39.705 line:-1 position:50%
the responsibility
of a human player.


478
00:20:39,705 --> 00:20:41,340 line:-1
In order to solve
this challenge,


479
00:20:41,340 --> 00:20:43,442 line:-1
we introduce
a humanSelectedField


480
00:20:43.442 --> 00:20:46.045 line:-1 position:50%
asynchronous function
to our view model.


481
00:20:46,045 --> 00:20:48,380 line:-1
It is powered by a @Published
value that is triggered


482
00:20:48,380 --> 00:20:51,450 line:-1
when the human
user clicks on one of the
fields.


483
00:20:51.450 --> 00:20:53.219 line:-1 position:50%
As the human player
clicks a field,


484
00:20:53.219 --> 00:20:56.388 line:-1 position:50%
our makeMove function resumes,
and we complete the remote call


485
00:20:56.388 --> 00:20:59.825 line:-1 position:50%
by returning the performed
GameMove to the remote caller.


486
00:20:59,825 --> 00:21:01,827 line:-1
And again,
that's all there is to it!


487
00:21:01.827 --> 00:21:03.429 line:-1 position:50%
We had to change
the actor implementation


488
00:21:03.429 --> 00:21:06.332 line:-1 position:50%
a little to handle our
true multiplayer game mode,


489
00:21:06,332 --> 00:21:07,533 line:-1
but nothing really changed


490
00:21:07,533 --> 00:21:09,668 line:-1
in the overall design
of the system.


491
00:21:09.668 --> 00:21:11.170 line:-1 position:50%
And most importantly,


492
00:21:11,170 --> 00:21:13,572 line:-1
nothing in our game logic
changes was really specific


493
00:21:13.572 --> 00:21:16.075 line:-1 position:50%
to the fact we'll be using
local networking.


494
00:21:16.075 --> 00:21:18.477 line:-1 position:50%
We discover an opponent
and play a game with them


495
00:21:18.477 --> 00:21:21.280 line:-1 position:50%
by invoking distributed methods
on player actors.


496
00:21:21.280 --> 00:21:24.783 line:-1 position:50%
To demo this game mode, I'll
need an opponent to play with.


497
00:21:24.783 --> 00:21:27.386 line:-1 position:50%
Let's ask my fluffy assistant
Caplin the Capybara.


498
00:21:27,386 --> 00:21:29,588 line:-1
I heard he's pretty good at it!


499
00:21:32.925 --> 00:21:35.961 line:-1 position:50%
OK, he's pretty smart.


500
00:21:38.731 --> 00:21:41.567 line:-1 position:50%
He is pretty good at it.


501
00:21:41.567 --> 00:21:44.670 line:-1 position:50%
Let me try here.


502
00:21:44.670 --> 00:21:46.272 line:-1 position:50%
Oh, he got me!


503
00:21:46,272 --> 00:21:47,806 line:-1
This time you win,
little critter,


504
00:21:47.806 --> 00:21:49.942 line:-1 position:50%
but we'll play another session.


505
00:21:49.942 --> 00:21:52.311 line:-1 position:50%
Thanks for your help, Caplin!


506
00:21:52.311 --> 00:21:53.412 line:-1 position:50%
Last but not least,


507
00:21:53,412 --> 00:21:55,414 line:-1
let me give you an idea
of what we can achieve


508
00:21:55,414 --> 00:21:57,483 line:-1
by combining
different actor systems.


509
00:21:57.483 --> 00:22:00.653 line:-1 position:50%
For example, we can use
the WebSocket system to register


510
00:22:00.653 --> 00:22:03.055 line:-1 position:50%
device-hosted actor
player actors


511
00:22:03.055 --> 00:22:04.957 line:-1 position:50%
in a server-side lobby system


512
00:22:04,957 --> 00:22:07,126 line:-1
that will pair them up
and act as a proxy


513
00:22:07.126 --> 00:22:10.262 line:-1 position:50%
for distributed calls
between them.


514
00:22:10,262 --> 00:22:12,398 line:-1
We might implement
a GameLobby actor,


515
00:22:12.398 --> 00:22:14.466 line:-1 position:50%
with which device-hosted
player actors


516
00:22:14.466 --> 00:22:16.468 line:-1 position:50%
are able to register themselves.


517
00:22:16,468 --> 00:22:18,637 position:50%
As devices enter
the play online mode,


518
00:22:18,637 --> 00:22:21,707 position:50%
they would discover the
GameLobby using a receptionist,


519
00:22:21,707 --> 00:22:23,442 position:50%
and call join on it.


520
00:22:23.442 --> 00:22:25.844 line:-1 position:50%
The GameLobby keeps track
of available players


521
00:22:25,844 --> 00:22:27,613 line:-1
and starts a game session


522
00:22:27.613 --> 00:22:30.149 line:-1 position:50%
when a pair of players
has been identified.


523
00:22:30.149 --> 00:22:32.952 line:-1 position:50%
A game session would act
as the driver of the game,


524
00:22:32,952 --> 00:22:34,286 line:-1
polling moves and marking them


525
00:22:34,286 --> 00:22:36,922 line:-1
in the server-stored
representation of the game.


526
00:22:36,922 --> 00:22:39,091 line:-1
As the game completes,
we can collect results


527
00:22:39.091 --> 00:22:40.960 line:-1 position:50%
and report back to the lobby.


528
00:22:40,960 --> 00:22:42,795 line:-1
More interestingly though,


529
00:22:42,795 --> 00:22:45,331 line:-1
we can scale
this design horizontally.


530
00:22:45,331 --> 00:22:47,233 line:-1
We can of course create
more game session actors


531
00:22:47,233 --> 00:22:50,369 line:-1
to serve more games
concurrently on a single server,


532
00:22:50,369 --> 00:22:51,870 line:-1
but thanks
to distributed actors,


533
00:22:51,870 --> 00:22:54,373 line:-1
we could even create
a game session on other nodes


534
00:22:54.373 --> 00:22:56.675 line:-1 position:50%
in order to load balance
the number of concurrent games


535
00:22:56.675 --> 00:22:58.344 line:-1 position:50%
across a cluster.


536
00:22:58.344 --> 00:23:01.614 line:-1 position:50%
That is, if only we had
a cluster actor system.


537
00:23:01.614 --> 00:23:03.115 line:-1 position:50%
And, in fact, we do!


538
00:23:03.115 --> 00:23:06.118 line:-1 position:50%
We open-sourced a feature-rich
Cluster Actor system library


539
00:23:06.118 --> 00:23:08.387 line:-1 position:50%
for you to use
in such scenarios.


540
00:23:08,387 --> 00:23:10,856 line:-1
It's implemented using SwiftNIO,
and specialized


541
00:23:10.856 --> 00:23:13.592 line:-1 position:50%
for server-side
data-center clustering.


542
00:23:13,592 --> 00:23:16,161 line:-1
It applies advanced techniques
for failure detection,


543
00:23:16,161 --> 00:23:17,997 line:-1
and comes with it's own
implementation


544
00:23:17,997 --> 00:23:20,266 line:-1
of a cluster-wide receptionist.


545
00:23:20,266 --> 00:23:22,167 line:-1
We encourage you
to have a look at it,


546
00:23:22,167 --> 00:23:24,770 line:-1
as it is both an advanced
reference implementation


547
00:23:24,770 --> 00:23:25,971 line:-1
of an actor system,


548
00:23:25.971 --> 00:23:28.974 line:-1 position:50%
and because of its powerful
server-side applications.


549
00:23:28,974 --> 00:23:31,610 line:-1
Let's recap what we learned
during this session.


550
00:23:31.610 --> 00:23:34.513 line:-1 position:50%
First, we learned about
distributed actors


551
00:23:34.513 --> 00:23:36.849 line:-1 position:50%
and how we provide additional
compiler-assisted


552
00:23:36,849 --> 00:23:39,318 line:-1
actor isolation
and serialization checking.


553
00:23:39.318 --> 00:23:42.054 line:-1 position:50%
We learned how they enable
location transparency,


554
00:23:42.054 --> 00:23:44.490 line:-1 position:50%
and how we can make use of it
to free our actors


555
00:23:44,490 --> 00:23:47,226 line:-1
from the necessity of being
located in the same process


556
00:23:47.226 --> 00:23:48.794 line:-1 position:50%
as their caller.


557
00:23:48,794 --> 00:23:51,697 line:-1
We also saw a few actor system
implementations in action


558
00:23:51,697 --> 00:23:53,799 line:-1
to get you inspired about
what you could build


559
00:23:53.799 --> 00:23:55.701 line:-1 position:50%
using distributed actors.


560
00:23:55.701 --> 00:23:58.671 line:-1 position:50%
Distributed actors are only
as powerful as the actor systems


561
00:23:58.671 --> 00:24:00.139 line:-1 position:50%
they are used with.


562
00:24:00.139 --> 00:24:01.507 line:-1 position:50%
So for your reference,


563
00:24:01,507 --> 00:24:04,576 line:-1
here is a list of actor systems
we saw during this session.


564
00:24:04,576 --> 00:24:07,946 line:-1
The local testing system, which
ships by default with Swift,


565
00:24:07.946 --> 00:24:09.982 line:-1 position:50%
and two sample actor systems:


566
00:24:09,982 --> 00:24:12,685 line:-1
a client/server style
WebSocket-based one


567
00:24:12,685 --> 00:24:15,120 line:-1
and a local
networking-based system.


568
00:24:15.120 --> 00:24:16.722 line:-1 position:50%
These systems are rather
incomplete,


569
00:24:16,722 --> 00:24:18,524 line:-1
and served more
as an inspiration


570
00:24:18.524 --> 00:24:21.293 line:-1 position:50%
for what you might build
using distributed actors.


571
00:24:21,293 --> 00:24:23,195 line:-1
You can view them
in the sample code app


572
00:24:23,195 --> 00:24:25,531 line:-1
associated with this session.


573
00:24:25,531 --> 00:24:27,900 line:0
And last but not least,
an open source


574
00:24:27,900 --> 00:24:30,836 position:50%
fully featured server-side
clustering implementation.


575
00:24:30,836 --> 00:24:32,771 position:50%
Available as
a beta package now,


576
00:24:32,771 --> 00:24:35,774 position:50%
and it will be matured
alongside Swift 5.7.


577
00:24:35.774 --> 00:24:37.876 line:-1 position:50%
To learn more about
distributed actors,


578
00:24:37.876 --> 00:24:40.012 line:-1 position:50%
you can refer
to the following resources:


579
00:24:40,012 --> 00:24:42,581 line:-1
the sample code associated
with this session,


580
00:24:42,581 --> 00:24:45,050 line:-1
which includes all the steps
of our Tic Tac Fish game


581
00:24:45,050 --> 00:24:47,319 line:-1
so you can deep dive
into the code yourself.


582
00:24:47,319 --> 00:24:49,054 line:0
The Swift evolution proposals


583
00:24:49,054 --> 00:24:52,191 position:50%
associated with the distributed
actors language feature,


584
00:24:52,191 --> 00:24:55,761 line:0
which explain the mechanisms
powering them in great detail.


585
00:24:55,761 --> 00:24:57,563 position:50%
You can also reach out
on the Swift forums,


586
00:24:57,563 --> 00:25:00,265 position:50%
where you can find
a distributed actors category


587
00:25:00,265 --> 00:25:04,403 line:0
dedicated to actor system
developers and users alike.


588
00:25:04,403 --> 00:25:06,205 line:-1
Thanks for listening, and I'm
looking forward to seeing


589
00:25:06.205 --> 00:25:08.907 line:-1 position:50%
what you'll use distributed
actors for in your apps!


590
00:25:08,907 --> 00:25:14,913 position:90% size:2% align:right
♪

