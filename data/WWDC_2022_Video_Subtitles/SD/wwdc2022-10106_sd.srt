2
00:00:00.501 --> 00:00:08.509 line:-1 align:center
♪ ♪


3
00:00:09.810 --> 00:00:13.046 line:-2 align:center
Welcome to Profile and
Optimize Your Game's Memory.


4
00:00:13.080 --> 00:00:16.149 line:-2 align:center
I'm Jack Xu (许) from GPU Software team
at Apple.


5
00:00:16.183 --> 00:00:18.952 line:-1 align:center
We're joined by my colleague Seth Lù (陆).


6
00:00:18,986 --> 00:00:21,688 line:-2
In the last few years,
our teams have been working


7
00:00:21,722 --> 00:00:23,490 line:-1
with game developers like you


8
00:00:23,524 --> 00:00:26,560 line:-2
to understand
and improve game memory together.


9
00:00:26,593 --> 00:00:28,996 line:-1
Today, we want to share our learnings,


10
00:00:29,029 --> 00:00:32,933 line:-2
so you can also have a head start
when you debug your game's memory


11
00:00:32.966 --> 00:00:36.803 line:-2 align:center
and create awesome games
with the best player experience.


12
00:00:37.905 --> 00:00:42.943 line:-2 align:center
We're going to break down memory usage in
your game, from both CPU and GPU objects.


13
00:00:43.877 --> 00:00:46.680 line:-1 align:center
Plus, analyze allocations in your game,


14
00:00:46.713 --> 00:00:48.549 line:-1 align:center
actual use on physical memory,


15
00:00:48.582 --> 00:00:51.285 line:-1 align:center
and references between objects.


16
00:00:51.318 --> 00:00:53.554 line:-1 align:center
Because there are many facets of memory,


17
00:00:53,587 --> 00:00:58,292 line:-2
our developer tools also reveal
memory mysteries from different angles.


18
00:00:58,325 --> 00:01:02,296 line:-2
We'll take a guided tour,
and experience how we use all of them,


19
00:01:02.329 --> 00:01:06.800 line:-2 align:center
including Xcode, Instruments,
and command line tools in Terminal.


20
00:01:06,834 --> 00:01:12,039 line:-2
In today's guided tour, we will begin
with a prelude to understand game memory.


21
00:01:12,072 --> 00:01:15,275 line:-2
And start to profile memory
and memory growth,


22
00:01:15,309 --> 00:01:18,679 line:-1
where Seth will tell us about Instruments.


23
00:01:18,712 --> 00:01:23,383 line:-2
After taking the temporal approach with
Instruments, we will further our journey,


24
00:01:23.417 --> 00:01:28.488 line:-2 align:center
and analyze the memory graph of your game
using tools in Xcode and Terminal.


25
00:01:28.522 --> 00:01:31.658 line:-2 align:center
These workflows focus on
the current state of memory use,


26
00:01:31,692 --> 00:01:35,329 line:-2
and the breakdown
of the total game memory.


27
00:01:35.362 --> 00:01:38.765 line:-2 align:center
Finally, Seth will share
how you can use Metal Debugger


28
00:01:38,799 --> 00:01:40,734 line:-1
to optimize Metal resources,


29
00:01:40,767 --> 00:01:45,739 line:-2
which is a somewhat standalone,
yet core area in game memory.


30
00:01:45.772 --> 00:01:50.177 line:-2 align:center
Now, let's start rolling
with understanding game memory.


31
00:01:51,044 --> 00:01:53,213 line:-1
When you launch your game from Xcode,


32
00:01:53.247 --> 00:01:56.316 line:-2 align:center
such as the Modern Rendering
with Metal sample code,


33
00:01:56,350 --> 00:02:00,420 line:-2
you can open this Memory Report
in Xcode's debug navigator.


34
00:02:00,454 --> 00:02:04,825 line:-2
It is your first view on the game's
current and recent memory usage,


35
00:02:04,858 --> 00:02:07,127 line:-1
and its impact level on the system.


36
00:02:08.862 --> 00:02:12.866 line:-2 align:center
The number on the gauge shows you
the current memory use of the game.


37
00:02:12,900 --> 00:02:15,002 line:-2
An important first step
in memory debugging


38
00:02:15.035 --> 00:02:17.504 line:-1 align:center
is to understand what this number means.


39
00:02:19.173 --> 00:02:20.707 line:-1 align:center
To put it in one line,


40
00:02:20.741 --> 00:02:25.979 line:-2 align:center
actual memory use in your game
is not the same as allocations.


41
00:02:26,013 --> 00:02:28,682 line:-1
Actual memory use is on physical memory.


42
00:02:28,715 --> 00:02:31,952 line:-2
While allocations
is the memory requested by the game,


43
00:02:31.985 --> 00:02:34.221 line:-1 align:center
on the virtual memory address space.


44
00:02:34.254 --> 00:02:38.125 line:-2 align:center
And different kinds of allocations
are naturally calculated separately.


45
00:02:41,061 --> 00:02:42,896 line:0
When your game allocates memory,


46
00:02:42,930 --> 00:02:47,134 line:0
those new allocations do not immediately
nor directly take up space


47
00:02:47,167 --> 00:02:48,602 line:0
on physical memory.


48
00:02:48,635 --> 00:02:53,006 line:-2
On the contrary, they will reserve some
space on virtual memory address space,


49
00:02:53,040 --> 00:02:56,577 line:-2
which the system provides
for each process.


50
00:02:56,610 --> 00:02:59,646 line:-2
And when the program actually
uses this allocation later,


51
00:02:59.680 --> 00:03:02.850 line:-2 align:center
will the system prepare space
on physical memory.


52
00:03:04.518 --> 00:03:08.055 line:-2 align:center
Allocations of the same kind
are grouped into categories,


53
00:03:08,088 --> 00:03:11,291 line:-2
and sparsely occupy
the virtual address space.


54
00:03:11.325 --> 00:03:13.760 line:-1 align:center
These categories may include:


55
00:03:13.794 --> 00:03:16.363 line:-1 align:center
the program's executable binary;


56
00:03:16.396 --> 00:03:18.799 line:-1 align:center
all the libraries and frameworks;


57
00:03:18.832 --> 00:03:22.002 line:-2 align:center
the stack, providing storage
for local and temporary variables


58
00:03:22.035 --> 00:03:24.872 line:-1 align:center
as well as some function arguments;


59
00:03:24,905 --> 00:03:27,641 line:-1
dynamic memory regions also known as heap;


60
00:03:27.674 --> 00:03:29.543 line:-1 align:center
including class instance storage


61
00:03:29,576 --> 00:03:32,679 line:-1
and memory the program manually allocates;


62
00:03:32.713 --> 00:03:37.017 line:-2 align:center
regions mapped from read-only resources
such as game asset files;


63
00:03:37.050 --> 00:03:39.620 line:-1 align:center
and of course, Metal objects in your game,


64
00:03:39.653 --> 00:03:44.691 line:-2 align:center
such as buffers, textures,
and pipeline state objects.


65
00:03:44,725 --> 00:03:48,729 line:-1
And these categories are made of regions.


66
00:03:48,762 --> 00:03:53,767 line:-2
Under the hood, memory operations
work at the granularity of memory pages,


67
00:03:53.800 --> 00:03:57.905 line:-2 align:center
which are 16 kibibytes each
on modern Apple devices.


68
00:03:57.938 --> 00:04:01.708 line:-2 align:center
This means each region takes up
one or more pages,


69
00:04:01.742 --> 00:04:04.344 line:-1 align:center
and is at least 16 kibibytes large.


70
00:04:05.646 --> 00:04:10.017 line:-2 align:center
As the game continues,
the state of its memory keeps evolving;


71
00:04:10.050 --> 00:04:11.952 line:-1 align:center
new objects get allocated,


72
00:04:11,985 --> 00:04:14,021 line:-1
old items get destroyed,


73
00:04:14,054 --> 00:04:16,757 line:-1
the regions keep changing.


74
00:04:16.790 --> 00:04:20.227 line:-2 align:center
But only used pages on the regions
are on physical memory,


75
00:04:20,260 --> 00:04:23,263 line:-2
which the system diligently charges
to your game,


76
00:04:23.297 --> 00:04:25.332 line:-1 align:center
as to any other apps.


77
00:04:27.234 --> 00:04:30.070 line:-2 align:center
Memory pages in your game
can be one of three kinds:


78
00:04:30,103 --> 00:04:32,973 line:-1
dirty, compressed, and clean.


79
00:04:33,006 --> 00:04:35,776 line:-1
Let's check out what they are.


80
00:04:35.809 --> 00:04:39.980 line:-2 align:center
Dirty memory pages includes memory
that your game has written to.


81
00:04:40.013 --> 00:04:42.850 line:-1 align:center
This includes memory allocations in heap,


82
00:04:42,883 --> 00:04:47,888 line:-2
and frameworks, once your game modifies
those variables or symbols.


83
00:04:47,921 --> 00:04:49,890 line:-1
On devices with Apple silicon,


84
00:04:49,923 --> 00:04:53,660 line:-2
accessed Metal resources
also fall into this category,


85
00:04:53.694 --> 00:04:59.132 line:-2 align:center
this is because CPU and GPU share
the same pool of fast unified memory.


86
00:05:00.501 --> 00:05:04.071 line:-2 align:center
However, if some dirty pages
are not used for a long time,


87
00:05:04,104 --> 00:05:07,207 line:-2
the system might reduce
their presence on physical memory


88
00:05:07,241 --> 00:05:10,944 line:-2
by compressing these pages
or storing them on flash or disk,


89
00:05:10,978 --> 00:05:12,913 line:-1
which we call swapping.


90
00:05:12.946 --> 00:05:17.050 line:-2 align:center
This will allow the device
to run more apps and services.


91
00:05:17.084 --> 00:05:20.387 line:-2 align:center
Later, when your game asks
for these pages again,


92
00:05:20.420 --> 00:05:24.024 line:-2 align:center
the system will decompress
or page in them from disk.


93
00:05:24.057 --> 00:05:29.663 line:-2 align:center
Note, your game will still get charged
for their uncompressed size.


94
00:05:29,696 --> 00:05:31,598 line:-1
For clean memory pages,


95
00:05:31,632 --> 00:05:34,635 line:-2
they include read-only files
mapped from disk,


96
00:05:34,668 --> 00:05:37,804 line:-1
such as texture or audio assets,


97
00:05:37,838 --> 00:05:40,874 line:-1
and frameworks loaded into the process.


98
00:05:40.908 --> 00:05:45.279 line:-2 align:center
The system can empty or reload them
from disk at any time,


99
00:05:45.312 --> 00:05:48.582 line:-2 align:center
so they don't count towards
your game's memory footprint.


100
00:05:48.615 --> 00:05:51.852 line:-1 align:center
However, they may be resident on memory,


101
00:05:51.885 --> 00:05:57.057 line:-2 align:center
and excessive use will slow down
the system and your game.


102
00:05:57,090 --> 00:06:01,361 line:-2
It's usually the most interesting
to look at the first two parts,


103
00:06:01,395 --> 00:06:04,064 line:-1
which combined, we call memory footprint.


104
00:06:04.097 --> 00:06:07.868 line:-2 align:center
And the system uses this
to enforce memory limit.


105
00:06:09,970 --> 00:06:13,507 line:-2
In some terminologies,
people say "dirty memory"


106
00:06:13.540 --> 00:06:18.345 line:-2 align:center
when they mean memory footprint,
as dirty is the opposite of clean.


107
00:06:18.378 --> 00:06:21.281 line:-1 align:center
But don't worry, when things become fuzzy,


108
00:06:21,315 --> 00:06:24,184 line:-1
we will call out which one we mean.


109
00:06:24,218 --> 00:06:29,089 line:-2
So now you know how memory works,
and how system charges it to the game.


110
00:06:29.990 --> 00:06:32.292 line:-1 align:center
Besides this Xcode memory gauge,


111
00:06:32,326 --> 00:06:36,129 line:-2
you can find memory footprint
in many places on the system,


112
00:06:36.163 --> 00:06:39.433 line:-1 align:center
including the Activity Monitor app on Mac.


113
00:06:39.466 --> 00:06:43.770 line:-2 align:center
And some Apple platforms use it
for app memory limits.


114
00:06:43,804 --> 00:06:47,908 line:-2
Your game can also use this metric
to guide its memory use.


115
00:06:47.941 --> 00:06:53.413 line:-2 align:center
There are useful APIs to query
current footprint and available memory.


116
00:06:53,447 --> 00:06:54,915 line:-1
Here's a quick look.


117
00:06:54,948 --> 00:07:00,153 line:-2
To get available system memory
for your iOS, iPadOS or tvOS game,


118
00:07:00.187 --> 00:07:05.459 line:-2 align:center
call os_proc_available_memory,
which is in os/proc.h header file.


119
00:07:07,261 --> 00:07:10,264 line:-2
And for memory footprint
on any Apple platform,


120
00:07:10,297 --> 00:07:13,100 line:-1
you can get it via proc_pid_rusage,


121
00:07:13,133 --> 00:07:15,802 line:-1
with process ID from "get pid",


122
00:07:15,836 --> 00:07:19,573 line:-2
"rusage_info_current",
which is version 6 at the moment,


123
00:07:19.606 --> 00:07:22.543 line:-1 align:center
and the data store.


124
00:07:22,576 --> 00:07:26,847 line:-2
And retrieve its physical footprint or
lifetime max physical footprint property.


125
00:07:28,148 --> 00:07:33,687 line:-2
To recap, in this first section,
we reviewed some concepts about memory.


126
00:07:33.720 --> 00:07:37.624 line:-2 align:center
Allocations in your game happen
on virtual memory address space,


127
00:07:37,658 --> 00:07:42,496 line:-2
and they will take up physical
memory space as 16 kibibyte pages,


128
00:07:42,529 --> 00:07:45,299 line:-1
once they're accessed by your game.


129
00:07:45,332 --> 00:07:50,771 line:-2
Memory footprint is the primary
and universal metric on Apple platforms


130
00:07:50,804 --> 00:07:53,574 line:-2
to determine your game's
actual memory use.


131
00:07:53,607 --> 00:07:58,779 line:-2
Memory footprint contains dirty,
compressed, and swapped pages.


132
00:07:58,812 --> 00:08:03,183 line:-2
It includes both CPU and GPU objects
on Apple silicon.


133
00:08:03,217 --> 00:08:06,920 line:-2
And it's used for
memory limit enforcement.


134
00:08:06.954 --> 00:08:12.893 line:-2 align:center
Your game can call system APIs to
get its footprint, and available memory.


135
00:08:12.926 --> 00:08:16.063 line:-2 align:center
Now that you know how memory works
behind the scenes,


136
00:08:16,096 --> 00:08:18,332 line:-1
let's find out how it looks in your game.


137
00:08:18.365 --> 00:08:21.869 line:-2 align:center
Let me hand over to Seth,
to tell you more.


138
00:08:21,902 --> 00:08:23,170 line:-1
Seth Lù: Thanks, Jack.


139
00:08:23.203 --> 00:08:26.573 line:-2 align:center
Now, let's get started with capturing
the memory growth for a game.


140
00:08:26,607 --> 00:08:30,611 line:-2
And I'll continue to use
the Modern Renderer sample project.


141
00:08:30.644 --> 00:08:32.446 line:-1 align:center
When you run a game from Xcode,


142
00:08:32.479 --> 00:08:36.183 line:-2 align:center
the Memory Gauge shows you
the memory footprint over time.


143
00:08:36,216 --> 00:08:39,286 line:-2
However, you can get a much more detailed
look at the memory use


144
00:08:39,319 --> 00:08:42,289 line:-1
by profiling the game in Instruments.


145
00:08:42,322 --> 00:08:46,260 line:-2
Because oftentimes a game could
allocate a lot of memory at launch time,


146
00:08:46.293 --> 00:08:48.495 line:-2 align:center
you may want to begin profiling
from a new game launch


147
00:08:48.529 --> 00:08:51.732 line:-1 align:center
instead of attaching to an existing run.


148
00:08:51,765 --> 00:08:54,968 line:-2
From Xcode,
to quickly begin profiling your game,


149
00:08:55,002 --> 00:08:59,206 line:-2
press and hold the run button,
then choose "Profile".


150
00:08:59,239 --> 00:09:02,109 line:-2
This will automatically bring you
to Instruments.


151
00:09:02.142 --> 00:09:05.012 line:-2 align:center
The Instruments app includes
a collection of profiling tools


152
00:09:05,045 --> 00:09:07,447 line:-2
that record different aspects
of the system


153
00:09:07,481 --> 00:09:10,517 line:-2
and visualizes the recorded data
on a timeline.


154
00:09:10.551 --> 00:09:12.853 line:-1 align:center
New this year is the Game Memory template


155
00:09:12.886 --> 00:09:15.856 line:-2 align:center
that can help you better understand
the memory growth in your Metal game.


156
00:09:17,291 --> 00:09:21,428 line:-2
This template comes with the Allocations
and Metal Resource Events instruments


157
00:09:21.461 --> 00:09:24.531 line:-1 align:center
to record memory allocations with history,


158
00:09:24,565 --> 00:09:27,801 line:-1
VM Tracker to record memory footprint,


159
00:09:27.835 --> 00:09:31.605 line:-2 align:center
Virtual Memory Trace
to record virtual memory activity,


160
00:09:31,638 --> 00:09:35,442 line:-2
and Metal Application and GPU
to record Metal-related events.


161
00:09:37,477 --> 00:09:40,814 line:-2
And in this demo, I'll highlight
the first three instruments:


162
00:09:40.848 --> 00:09:44.685 line:-2 align:center
Allocations, Metal Resource Events,
and VM Tracker.


163
00:09:44.718 --> 00:09:47.955 line:-2 align:center
But first,
let's record a trace for the game.


164
00:09:47.988 --> 00:09:51.391 line:-2 align:center
You can press the record button here
to start recording.


165
00:09:51,425 --> 00:09:53,193 line:-1
And later, to stop recording,


166
00:09:53.227 --> 00:09:57.130 line:-2 align:center
you can press the same button
or simply quit the game.


167
00:09:57.164 --> 00:09:59.399 line:-2 align:center
While Instruments is recording
the Modern Renderer,


168
00:09:59,433 --> 00:10:03,036 line:-2
let me show you an alternative way
to record a trace.


169
00:10:03.070 --> 00:10:06.974 line:-2 align:center
The xctrace command allows you
to programmatically perform recordings,


170
00:10:07,007 --> 00:10:09,376 line:-2
which may be useful
in automation workflows.


171
00:10:10.944 --> 00:10:13.514 line:-2 align:center
Additionally,
you can specify the device name


172
00:10:13,547 --> 00:10:17,751 line:-2
to choose an iPhone,
iPad, or Apple TV as the target.


173
00:10:18,819 --> 00:10:21,021 line:-2
Now that I have captured
an Instruments trace,


174
00:10:21.054 --> 00:10:23.624 line:-1 align:center
let's first take a look at Allocations.


175
00:10:23.657 --> 00:10:27.261 line:-2 align:center
The Allocations instrument gives you
a detailed view of memory allocations,


176
00:10:27,294 --> 00:10:30,330 line:-1
their sizes, and object reference counts.


177
00:10:30,364 --> 00:10:34,067 line:-2
However, it doesn't include
private Metal resources.


178
00:10:34,101 --> 00:10:38,338 line:-2
The Statistics view displays
all heap allocations and anonymous VM.


179
00:10:40,274 --> 00:10:45,779 line:-2
The All Heap Allocations include malloc'ed
buffers which may contain objects,


180
00:10:45.812 --> 00:10:50.617 line:-2 align:center
and All Anonymous VM includes
interesting VM regions that may be dirty.


181
00:10:50.651 --> 00:10:54.388 line:-2 align:center
And we'll see in a moment that some
Metal resources belong to this category.


182
00:10:56,123 --> 00:10:59,660 line:-2
Now, let's take a look
inside All Heap Allocations.


183
00:10:59.693 --> 00:11:03.964 line:-2 align:center
Usually, the larger allocations
are more interesting for optimization.


184
00:11:03.997 --> 00:11:07.634 line:-2 align:center
To find the single largest allocation, you
can click on the Size table column


185
00:11:07.668 --> 00:11:09.837 line:-1 align:center
to sort the allocations by size.


186
00:11:11.238 --> 00:11:13.774 line:-2 align:center
For an allocation,
you can click on this arrow


187
00:11:13.807 --> 00:11:17.878 line:-2 align:center
to see the reference count changes
for Swift and Objective-C objects.


188
00:11:20.147 --> 00:11:22.583 line:-2 align:center
And with this large allocation selected
in the list,


189
00:11:22.616 --> 00:11:26.887 line:-2 align:center
there is the stack trace of
the allocation history in the inspector.


190
00:11:26.920 --> 00:11:31.592 line:-2 align:center
Clicking on the button allows
hiding the system libraries or frameworks.


191
00:11:31,625 --> 00:11:34,228 line:-1
And here, according to the stack trace,


192
00:11:34.261 --> 00:11:37.531 line:-2 align:center
the allocation happened
when Modern Renderer loaded the assets.


193
00:11:38,866 --> 00:11:43,136 line:-2
Double clicking on the frame
can also bring you to the source code.


194
00:11:43.170 --> 00:11:47.374 line:-2 align:center
Now, let's go back and take a look inside
the "All Anonymous VM" category.


195
00:11:48.809 --> 00:11:52.646 line:-2 align:center
In Metal games, you may find
a lot of allocations in the IOAccelerator


196
00:11:52,679 --> 00:11:55,582 line:-1
and IOSurface categories.


197
00:11:55.616 --> 00:11:59.453 line:-2 align:center
Allocations in IOAccelerator
correspond to Metal resources.


198
00:12:00.854 --> 00:12:04.892 line:-2 align:center
From the stack trace, you can see this
allocation happened while loading assets.


199
00:12:06.493 --> 00:12:10.497 line:-2 align:center
Allocations in IOSurface
correspond to drawables.


200
00:12:10,531 --> 00:12:14,401 line:-2
And here, the stack trace shows
the MetalKit view requested the drawable.


201
00:12:16,036 --> 00:12:20,307 line:-2
The Allocations instrument, by default,
visualizes the allocation size.


202
00:12:20,340 --> 00:12:23,544 line:-2
However, it also comes with
alternative looks.


203
00:12:23,577 --> 00:12:26,013 line:-2
You can on the arrow button
in the Allocations track


204
00:12:26,046 --> 00:12:29,616 line:-2
to customize the display mode
to visualize Allocation Density.


205
00:12:29,650 --> 00:12:33,520 line:-2
This will update the graph to show you the
amount of allocations performed over time


206
00:12:33,554 --> 00:12:36,657 line:-1
and reveal spikes for memory allocations.


207
00:12:36,690 --> 00:12:39,726 line:-2
These spikes may be sources
of memory growth.


208
00:12:39.760 --> 00:12:43.263 line:-2 align:center
So the data shown in Allocations
is quite low-level.


209
00:12:43.297 --> 00:12:46.300 line:-2 align:center
To get a better understanding
of the allocated Metal resources,


210
00:12:46,333 --> 00:12:50,003 line:-1
let's move on to Metal Resource Events.


211
00:12:50.037 --> 00:12:54.775 line:-2 align:center
The Metal Resource Events instrument
is designed around Metal resources.


212
00:12:54.808 --> 00:12:56.310 line:-1 align:center
In the Resource Events view,


213
00:12:56,343 --> 00:13:00,681 line:-2
you can find a history of Metal resource
allocations and deallocations.


214
00:13:00,714 --> 00:13:04,218 line:-2
Here, you could also identify
the Metal resources by their labels


215
00:13:04.251 --> 00:13:08.222 line:-2 align:center
which you can specify programmatically
through the Metal API.


216
00:13:08,255 --> 00:13:10,290 line:-1
And similar to the Allocations instrument,


217
00:13:10.324 --> 00:13:13.894 line:-2 align:center
you can find a stack trace for
the allocation history in the inspector.


218
00:13:15.929 --> 00:13:19.399 line:-2 align:center
This instrument also adds the Allocation
and the Deallocations track


219
00:13:19,433 --> 00:13:21,034 line:-1
under the Metal device.


220
00:13:21,068 --> 00:13:23,804 line:-1
They help visualize the density of events.


221
00:13:23.837 --> 00:13:26.740 line:-2 align:center
So far,
Allocations and Metal Resource Events


222
00:13:26.773 --> 00:13:29.676 line:-1 align:center
can help understand memory allocations.


223
00:13:29,710 --> 00:13:33,814 line:-2
However, allocations don't always
translate to memory footprint.


224
00:13:33,847 --> 00:13:37,351 line:-2
So let's move on to VM Tracker
to investigate the actual memory use.


225
00:13:38,352 --> 00:13:41,154 line:-2
The VM Tracker instrument
shows the non-compressed dirty


226
00:13:41,188 --> 00:13:44,057 line:-1
and compressed or swapped memory.


227
00:13:44.091 --> 00:13:48.061 line:-2 align:center
The Dirty Size represents
the non-compressed dirty memory.


228
00:13:48,095 --> 00:13:52,165 line:-2
And the Swapped Size represents
the compressed or swapped memory.


229
00:13:52.199 --> 00:13:54.868 line:-2 align:center
In this recording, there's no compressed
or swapped memory use


230
00:13:54.902 --> 00:13:57.538 line:-1 align:center
from the Modern Renderer.


231
00:13:57,571 --> 00:14:00,874 line:-2
The detailed Summary view
shows the VM regions.


232
00:14:00.908 --> 00:14:04.244 line:-2 align:center
And in the "mapped file" region,
you may find some memory-mapped resources


233
00:14:04,278 --> 00:14:06,280 line:-1
like your game assets.


234
00:14:06.313 --> 00:14:10.384 line:-2 align:center
Here, Modern Renderer maps
the bistro asset file into memory.


235
00:14:10.417 --> 00:14:13.320 line:-2 align:center
So that's a brief overview
of the Allocations,


236
00:14:13.353 --> 00:14:17.090 line:-2 align:center
Metal Resource Events
and VM Tracker in Instruments.


237
00:14:17,124 --> 00:14:20,394 align:center
To quickly recap
how you can profile memory growth:


238
00:14:20,427 --> 00:14:22,930 align:center
First, choose the Game Memory template,


239
00:14:22,963 --> 00:14:25,766 line:0
and then, record and analyze the trace.


240
00:14:25,799 --> 00:14:28,168 align:center
Sometimes, you may repeat this process
a few times


241
00:14:28,202 --> 00:14:31,839 align:center
when reproducing or verifying
memory growth patterns.


242
00:14:31,872 --> 00:14:34,474 align:center
We hope the new Game Memory template
can help you better understand


243
00:14:34,508 --> 00:14:37,945 align:center
the memory allocation
or footprint growth in your game.


244
00:14:37,978 --> 00:14:42,115 line:0
And please check out these other videos
to learn more about using Instruments.


245
00:14:42.149 --> 00:14:43.917 line:-1 align:center
Now, back to Jack.


246
00:14:45.619 --> 00:14:48.055 line:-2 align:center
The game Memory template
looks really cool,


247
00:14:48.088 --> 00:14:51.491 line:-2 align:center
and it's going to be so useful
to help with understanding changes


248
00:14:51.525 --> 00:14:53.861 line:-1 align:center
of memory use over time.


249
00:14:53.894 --> 00:14:57.631 line:-2 align:center
In addition, you might also want
to capture the memory state of the game


250
00:14:57.664 --> 00:15:01.268 line:-2 align:center
at a given time, so you can dig deeper
into that memory state


251
00:15:01.301 --> 00:15:04.571 line:-1 align:center
and examine it through different lenses.


252
00:15:04,605 --> 00:15:08,275 line:-2
And for that, we have memory graphs
and a suite of tools.


253
00:15:09.710 --> 00:15:13.347 line:-2 align:center
Memory graph is a file
to efficiently store a complete snapshot


254
00:15:13.380 --> 00:15:15.082 line:-1 align:center
of your game's memory state,


255
00:15:15,115 --> 00:15:17,150 line:-1
including object creation history,


256
00:15:17.184 --> 00:15:20.153 line:-2 align:center
references,
and any compression or swapping.


257
00:15:21,788 --> 00:15:23,957 line:-1
You can take a snapshot anytime you want,


258
00:15:23.991 --> 00:15:27.160 line:-2 align:center
such as when an issue occurs,
or a pair of those,


259
00:15:27,194 --> 00:15:31,865 line:-2
before and after an issue happened
for comparison.


260
00:15:31,899 --> 00:15:35,035 line:-2
To spice things up,
let's use a cookbook analogy


261
00:15:35.068 --> 00:15:38.739 line:-2 align:center
on how to analyze memory
with memory graphs.


262
00:15:38,772 --> 00:15:41,909 line:-2
It includes an ingredient
and a preparation part.


263
00:15:43,710 --> 00:15:47,080 line:-2
For the Ingredients, well,
you would need your game;


264
00:15:47,114 --> 00:15:49,550 line:-1
something called Malloc Stack Logging;


265
00:15:49.583 --> 00:15:52.586 line:-1 align:center
and, a captured memory graph.


266
00:15:52,619 --> 00:15:55,055 line:-2
It's quick to configure
Malloc Stack Logging


267
00:15:55,088 --> 00:15:56,723 line:-1
and to capture a memory graph.


268
00:15:58,592 --> 00:16:03,030 line:-2
Malloc Stack Logging records allocation
information in the game process.


269
00:16:03.063 --> 00:16:05.299 line:-1 align:center
You can find it in Scheme settings.


270
00:16:05.332 --> 00:16:08.669 line:-2 align:center
Choose the Run action,
go to Diagnostics,


271
00:16:08,702 --> 00:16:11,271 line:-2
and tick the Malloc Stack Logging
checkbox.


272
00:16:13,040 --> 00:16:15,642 line:-2
In case you wonder what the two
options are;


273
00:16:15,676 --> 00:16:19,313 line:-2
All Allocation and Free History
keeps track of all objects


274
00:16:19.346 --> 00:16:22.049 line:-1 align:center
even after they are deallocated.


275
00:16:22.082 --> 00:16:24.351 line:-1 align:center
The logging data may take up more memory,


276
00:16:24,384 --> 00:16:28,622 line:-2
but it's useful for debugging issues
such as fragmentation.


277
00:16:28,655 --> 00:16:33,160 line:-2
On the other hand, Live Allocation Only
discards deallocated objects


278
00:16:33,193 --> 00:16:36,263 line:-1
from its history, so it's lighter.


279
00:16:36.296 --> 00:16:39.199 line:-2 align:center
In this case,
I'm only investigating references,


280
00:16:39,233 --> 00:16:43,437 line:-2
which are on live objects,
so I can pick this option.


281
00:16:43,470 --> 00:16:45,572 line:-1
In fact, most of the time,


282
00:16:45,606 --> 00:16:49,209 line:-2
Live Allocation Only will be
your recommended option.


283
00:16:50,677 --> 00:16:56,049 line:-2
Alternatively, you can set environment
variable if not launching from Xcode.


284
00:16:56.083 --> 00:17:00.187 line:-2 align:center
Check out the malloc manual page
for some additional recording modes.


285
00:17:00,220 --> 00:17:03,190 line:-1
After that, also prepare a memory graph.


286
00:17:03,223 --> 00:17:05,626 line:-2
Just click on
the debug memory graph button


287
00:17:05,659 --> 00:17:07,895 line:-1
in the debug area.


288
00:17:07,928 --> 00:17:09,863 line:-1
Xcode will take a memory snapshot,


289
00:17:09,897 --> 00:17:13,667 line:-1
process it, and enter the memory debugger.


290
00:17:13.700 --> 00:17:18.505 line:-2 align:center
Xcode Memory Debugger provides intuitive
perspectives into the game's memory use.


291
00:17:18,539 --> 00:17:22,142 line:-1
Let's take a minute to explore the view.


292
00:17:22.176 --> 00:17:25.445 line:-2 align:center
On the left side,
Debug Navigator gives you


293
00:17:25,479 --> 00:17:28,482 line:-1
a hierarchical list of object instances.


294
00:17:30,484 --> 00:17:34,421 line:-2
On the right, File Inspector provides
useful information


295
00:17:34,454 --> 00:17:38,625 line:-2
such as memory footprint,
uptime, and capture date.


296
00:17:40,928 --> 00:17:44,164 line:-2
In the middle area
shines the memory graph view


297
00:17:44,198 --> 00:17:47,134 line:-2
where you have the selected object
from the left,


298
00:17:47,167 --> 00:17:50,771 line:-1
and how references connect to this object.


299
00:17:50,804 --> 00:17:53,740 line:-1
I'll come back to this graph in a bit.


300
00:17:56,109 --> 00:17:59,847 line:-2
And the File menu gives you the option
to save this memory graph


301
00:17:59,880 --> 00:18:03,517 line:-2
for future analysis,
or to easily share with your team.


302
00:18:05,118 --> 00:18:07,888 line:-2
For a Mac game,
you can also capture a memory graph


303
00:18:07.921 --> 00:18:12.659 line:-2 align:center
with the leaks command line program,
using process ID or name.


304
00:18:12,693 --> 00:18:16,163 line:-2
This means you could do it remotely
in a secure shell,


305
00:18:16.196 --> 00:18:18.031 line:-1 align:center
so the cursor stays in the game,


306
00:18:18.065 --> 00:18:23.103 line:-2 align:center
in case your game is running fullscreen
and needs to stay in focus.


307
00:18:23.136 --> 00:18:26.907 line:-2 align:center
So that's what you'll need
to start memory graph analysis.


308
00:18:28,275 --> 00:18:32,880 line:-2
Now it's time to examine this memory graph
using Xcode Memory Debugger,


309
00:18:32,913 --> 00:18:36,083 line:-2
plus some versatile command line tools
in Terminal,


310
00:18:36.116 --> 00:18:41.121 line:-2 align:center
to find out allocations,
footprint, and even more.


311
00:18:41,154 --> 00:18:45,759 line:-2
A good first step
is to break down memory use by categories.


312
00:18:45.792 --> 00:18:48.629 line:-1 align:center
The footprint program does just that.


313
00:18:50.430 --> 00:18:56.203 line:-2 align:center
Footprint uses information in the memory
graph to recreate this high level summary.


314
00:18:56.236 --> 00:19:01.241 line:-2 align:center
Typically, you will want to first focus
on the larger categories.


315
00:19:01.275 --> 00:19:05.812 line:-2 align:center
For game memory graphs such as this one
from the Modern Rendering sample code,


316
00:19:05,846 --> 00:19:09,783 line:-1
IOAccelerator is usually the largest one.


317
00:19:09,816 --> 00:19:14,988 line:-1
As Seth said, it includes Metal resources.


318
00:19:15.022 --> 00:19:20.494 line:-2 align:center
Here, heap allocations go to several
MALLOC_(prefixed) categories,


319
00:19:20,527 --> 00:19:25,899 line:-2
since the system groups heap allocations
to size pools to improve performance.


320
00:19:25,933 --> 00:19:30,170 line:-2
These objects may come from many places,
such as third-party plugins,


321
00:19:30.204 --> 00:19:34.875 line:-2 align:center
or libraries, where your game does
sound effects or physics simulation.


322
00:19:36,343 --> 00:19:39,479 line:-2
Here's a memory graph
from an awesome Apple Arcade game,


323
00:19:39.513 --> 00:19:43.283 line:-2 align:center
Manifold Garden,
created by William "Cheer" Studio.


324
00:19:43,317 --> 00:19:46,753 line:-2
I'm glad they allow me to show you
the game's memory usage.


325
00:19:46.787 --> 00:19:51.558 line:-2 align:center
If your game uses a game engine,
like Manifold Garden using Unity,


326
00:19:51,592 --> 00:19:54,528 line:-2
or a custom allocator
on top of memory map,


327
00:19:54.561 --> 00:19:58.899 line:-2 align:center
that memory would be shown as
untagged VM_ALLOCATE like this.


328
00:19:58.932 --> 00:20:01.702 line:-1 align:center
Here's a pro tip: on Apple platforms,


329
00:20:01,735 --> 00:20:04,872 line:-2
your game can use
up to 16 app-specific tags,


330
00:20:04,905 --> 00:20:08,442 line:-2
so you can have more clarity
when drilling down memory usage.


331
00:20:08,475 --> 00:20:11,144 line:-1
It's as easy as a one line change.


332
00:20:12.312 --> 00:20:16.283 line:-2 align:center
First, make the tag
from one of 16 options.


333
00:20:16,316 --> 00:20:21,522 line:-2
Then replace the minus one with
this new tag as the "file descriptor",


334
00:20:21,555 --> 00:20:24,091 line:-1
when calling "em map".


335
00:20:24,124 --> 00:20:28,562 line:-2
Check out "em map's" manual page to learn
how tags and categories are defined.


336
00:20:30,597 --> 00:20:32,833 line:-1
If you use "mach VM allocate",


337
00:20:32,866 --> 00:20:37,171 line:-2
include the same flag in
the flag argument when allocating.


338
00:20:39.573 --> 00:20:41.642 line:-1 align:center
In the world of footprint program,


339
00:20:41,675 --> 00:20:45,245 line:-2
the dirty size also includes swap
and compressed,


340
00:20:45,279 --> 00:20:48,982 line:-2
so think of it as total charged
for each category.


341
00:20:50,250 --> 00:20:53,754 line:-2
That's a brief idea of the composition
of current memory use,


342
00:20:53,787 --> 00:20:56,857 line:-1
and how it makes up the footprint.


343
00:20:56.890 --> 00:21:01.361 line:-2 align:center
Some of this memory is less used
and become compressed or swapped.


344
00:21:01,395 --> 00:21:04,364 line:-1
They might be sources of memory savings.


345
00:21:04,398 --> 00:21:07,167 line:-2
The next step is to find out
how much compressed


346
00:21:07.201 --> 00:21:10.871 line:-2 align:center
or swapped memory the game uses,
and optimize.


347
00:21:12,773 --> 00:21:16,610 line:-2
For this, you can run the memory graph
with vmmap.


348
00:21:16,643 --> 00:21:19,580 line:-1
It gives you dirty and swapped sizes,


349
00:21:19,613 --> 00:21:22,082 line:-1
instead of two combined.


350
00:21:22.115 --> 00:21:24.985 line:-2 align:center
This dirty column includes
currently not swapped


351
00:21:25.018 --> 00:21:27.487 line:-1 align:center
or compressed regular dirty memory,


352
00:21:27,521 --> 00:21:30,524 line:-2
while the swapped column includes
the original size


353
00:21:30.557 --> 00:21:33.694 line:-1 align:center
of compressed or swapped memory.


354
00:21:33,727 --> 00:21:37,965 line:-2
The system adds these two columns together
to determine footprint.


355
00:21:37,998 --> 00:21:42,636 line:-2
But since content in the swapped size
column isn't used as often,


356
00:21:42.669 --> 00:21:45.772 line:-2 align:center
it is a good indicator
for what to look for


357
00:21:45,806 --> 00:21:48,442 line:-1
to optimize your game's memory.


358
00:21:48,475 --> 00:21:51,345 line:-2
Oh, by the way,
here is the allocation size,


359
00:21:51.378 --> 00:21:54.114 line:-1 align:center
with the virtual size column.


360
00:21:54,147 --> 00:21:58,285 line:-2
And the resident size includes clean pages
such as executables


361
00:21:58,318 --> 00:22:00,521 line:-1
and memory mapped files.


362
00:22:02.422 --> 00:22:07.294 line:-2 align:center
Conveniently, vmmap shows
heap allocations with a separate table.


363
00:22:07.327 --> 00:22:09.363 line:-1 align:center
At the bottom of its output,


364
00:22:09,396 --> 00:22:13,300 line:-1
vmmap groups heap memory by zones.


365
00:22:13.333 --> 00:22:18.172 line:-2 align:center
These zones reflect their usage
or lifecycle in your game.


366
00:22:18,205 --> 00:22:20,674 line:-1
Because I turned on MallocStackLogging,


367
00:22:20,707 --> 00:22:24,811 line:-2
allocations on the heap
are in the tool's zone.


368
00:22:24.845 --> 00:22:27.714 line:-2 align:center
Otherwise,
they would be in two default zones:


369
00:22:27,748 --> 00:22:33,887 line:-2
MallocHelperZone and DefaultMallocZone,
based on the allocation size.


370
00:22:33.921 --> 00:22:40.594 line:-2 align:center
And usually you could skip smaller system
utility zones such as QuartzCore zone.


371
00:22:42,196 --> 00:22:47,334 line:-2
Also, if you suspect fragmentation,
indicated by high fragmentation size


372
00:22:47,367 --> 00:22:52,439 line:-2
or percentage,
like dozens or hundreds of megabytes,


373
00:22:52,472 --> 00:22:57,411 line:0
the WWDC 2021 session covers more
about fragmentation issues.


374
00:22:58,645 --> 00:23:02,282 line:-2
And running vmmap
without dash dash summary,


375
00:23:02,316 --> 00:23:04,718 line:-1
or to use vmmap in standard mode,


376
00:23:04,751 --> 00:23:09,223 line:-2
shows each vm region within
those categories line by line.


377
00:23:09.256 --> 00:23:14.595 line:-2 align:center
Just like how the virtual address space
looks like, as we discussed earlier.


378
00:23:14.628 --> 00:23:21.068 line:-2 align:center
So with vmmap, you can distill less used
dirty memory from actively used ones.


379
00:23:21,101 --> 00:23:23,871 line:-2
And typically,
there are also a good amount


380
00:23:23.904 --> 00:23:27.207 line:-1 align:center
of dynamic allocations of various sizes,


381
00:23:27.241 --> 00:23:30.010 line:-1 align:center
or malloc'd heap memory usage in the game.


382
00:23:30,043 --> 00:23:32,045 line:-1
They need a special look.


383
00:23:32,880 --> 00:23:36,550 line:-2
Heap tool groups malloc'd resources
by their classes,


384
00:23:36,583 --> 00:23:39,253 line:-1
and sorts them by instance count.


385
00:23:39.286 --> 00:23:43.524 line:-2 align:center
These classes are determined in
C++ with a VTable,


386
00:23:43.557 --> 00:23:45.993 line:-1 align:center
Objective-C, or Swift.


387
00:23:47,628 --> 00:23:49,997 line:-1
We are using the —quiet argument


388
00:23:50.030 --> 00:23:53.734 line:-1 align:center
to skip the header about some metadata.


389
00:23:53.767 --> 00:23:59.206 line:-2 align:center
New this year, heap is more intelligent
at identifying object types.


390
00:23:59.239 --> 00:24:02.676 line:-2 align:center
It uses information recorded
by Malloc Stack Logging


391
00:24:02.709 --> 00:24:05.979 line:-2 align:center
to present the caller
or responsible library,


392
00:24:06,013 --> 00:24:09,683 line:-2
so a huge non-object
is a thing of the past.


393
00:24:10,584 --> 00:24:14,888 line:-2
And here is the memory graph
from Manifold Garden again.


394
00:24:14,922 --> 00:24:18,392 line:-2
In this example,
it is revealed for the first time


395
00:24:18,425 --> 00:24:23,463 line:-2
how much heap usage is taken up
by plugins like FMOD Studio,


396
00:24:23,497 --> 00:24:27,801 line:-2
and game components
such as GameAssembly.dylib.


397
00:24:27.835 --> 00:24:32.306 line:-2 align:center
So now you can be more informed
on how the memory is spread out.


398
00:24:32.339 --> 00:24:38.078 line:-2 align:center
And it also hints which direction to go
for getting more info on these objects.


399
00:24:38.111 --> 00:24:42.216 line:-2 align:center
In this example,
the developer can open FMOD Studio


400
00:24:42.249 --> 00:24:45.919 line:-2 align:center
to fine tune the soundtrack
and sound effects in the game,


401
00:24:45.953 --> 00:24:50.691 line:-2 align:center
or go to Unity to look for
game code optimizations, and so on.


402
00:24:52.593 --> 00:24:55.295 line:-2 align:center
Sometimes,
sorting by class total size


403
00:24:55,329 --> 00:24:58,765 line:-2
rather than class instance count
is more helpful.


404
00:24:58,799 --> 00:25:01,535 line:-2
In the memory graph
of the Modern Rendering sample project,


405
00:25:01.568 --> 00:25:07.641 line:-2 align:center
the top contributor is a class
using over 258 million bytes.


406
00:25:07.674 --> 00:25:11.512 line:-2 align:center
To continue looking for larger objects
in the Modern Rendering sample,


407
00:25:11.545 --> 00:25:17.584 line:-2 align:center
use heap to sort objects by class
total size with —sortBySize,


408
00:25:17,618 --> 00:25:21,688 line:-2
and list all objects
with —showSizes,


409
00:25:21,722 --> 00:25:24,725 line:-1
rather than a summary of each class.


410
00:25:24,758 --> 00:25:28,629 line:-2
And, there is one object of
NSConcreteMutableData


411
00:25:28.662 --> 00:25:34.201 line:-2 align:center
in Bytes Storage with a size
of 255 million bytes:


412
00:25:34.234 --> 00:25:37.971 line:-1 align:center
that looks like one worth looking at.


413
00:25:38,005 --> 00:25:40,908 line:-1
Next, I want to find out what it is.


414
00:25:40,941 --> 00:25:44,278 line:-2
And I want to know
its address for a start.


415
00:25:44,311 --> 00:25:49,816 line:-2
I add —address and enter
the pattern NSConcreteMutableData


416
00:25:49,850 --> 00:25:53,153 line:-2
followed by wildcard–
dot star,


417
00:25:53,187 --> 00:25:55,355 line:-1
and a size filter in the bracket


418
00:25:55.389 --> 00:26:00.093 line:-2 align:center
to only list objects
10 megabytes large and upwards.


419
00:26:00.127 --> 00:26:02.796 line:-1 align:center
And here is the address of the object.


420
00:26:02,829 --> 00:26:07,334 line:-2
I'll use it in the following steps
for more in-depth analysis.


421
00:26:07,367 --> 00:26:13,407 line:-2
So that's heap tool, with improved
object identification for instances.


422
00:26:13,440 --> 00:26:16,276 line:-2
So far, you've seen three tools
to understand


423
00:26:16,310 --> 00:26:18,979 line:-1
what objects are using memory in the game,


424
00:26:19,012 --> 00:26:21,548 line:-1
and they all provide different views.


425
00:26:21,582 --> 00:26:24,351 line:-1
What I showed was just one workflow.


426
00:26:24,384 --> 00:26:26,620 line:-2
Depending on
the particular memory patterns,


427
00:26:26.653 --> 00:26:28.889 line:-1 align:center
or technologies used in your game,


428
00:26:28,922 --> 00:26:31,692 line:-2
you can use them
in any way that suits your needs.


429
00:26:33,894 --> 00:26:36,163 line:-1
With discoveries for objects


430
00:26:36,196 --> 00:26:39,066 line:-2
that we are not quite sure
of their existence,


431
00:26:39,099 --> 00:26:41,835 line:-1
the next step is to get its origin,


432
00:26:41.869 --> 00:26:44.104 line:-1 align:center
which is its allocation call stack.


433
00:26:45.172 --> 00:26:48.575 line:-2 align:center
In the case of the 200 million bytes
object in Modern Rendering,


434
00:26:48,609 --> 00:26:50,944 line:-1
I use the —callTree mode


435
00:26:50,978 --> 00:26:54,915 line:-1
and pass in its address to malloc_history.


436
00:26:54,948 --> 00:26:57,451 line:-1
Together with additional invert argument,


437
00:26:57,484 --> 00:27:01,655 line:-2
I can focus on functions
closest to the allocation.


438
00:27:01,688 --> 00:27:03,156 line:-1
And voila.


439
00:27:03,190 --> 00:27:06,793 line:-1
Here is the back trace of the allocation.


440
00:27:06,827 --> 00:27:12,065 line:-2
Similarly, Xcode Memory Debugger shows
the allocation history of an object too


441
00:27:12.099 --> 00:27:13.600 line:-1 align:center
in the inspector.


442
00:27:13,634 --> 00:27:17,371 line:-2
Just select an object,
click on the Memory Inspector,


443
00:27:17.404 --> 00:27:20.774 line:-1 align:center
and there it is.


444
00:27:20.807 --> 00:27:24.344 line:-2 align:center
As another example,
pass in VM_ALLOCATE


445
00:27:24.378 --> 00:27:27.281 line:-2 align:center
as the class pattern
instead of an address,


446
00:27:27,314 --> 00:27:31,084 line:-2
to check for anonymous VM usage
in your game or plugin,


447
00:27:31.118 --> 00:27:34.888 line:-1 align:center
such as debugging a custom allocator.


448
00:27:34.922 --> 00:27:37.958 line:-1 align:center
Whether using Xcode or malloc_history,


449
00:27:37.991 --> 00:27:40.294 line:-1 align:center
you can know the allocation back trace,


450
00:27:40,327 --> 00:27:43,030 line:-1
and decide if you want to dig deeper,


451
00:27:43,063 --> 00:27:46,800 line:-2
including setting a breakpoint
at the line, for a start.


452
00:27:48,802 --> 00:27:55,475 line:-2
And last but not least, it's also helpful
to investigate object references.


453
00:27:55.509 --> 00:27:58.846 line:-2 align:center
Memory graph always records
object references,


454
00:27:58,879 --> 00:28:04,017 line:-2
even when MallocStackLogging
is not enabled for various reasons.


455
00:28:04,051 --> 00:28:08,689 line:-2
We've used leaks before to capture
a memory graph outside of Xcode.


456
00:28:08,722 --> 00:28:10,190 line:-1
Leaks does more.


457
00:28:10,224 --> 00:28:12,993 line:-2
It checks for all references
in the memory graph,


458
00:28:13.026 --> 00:28:17.431 line:-2 align:center
and that is why it knows about leaks
and retain cycles.


459
00:28:17.464 --> 00:28:20.634 line:-2 align:center
Leaks gets this tree of references
to the object


460
00:28:20.667 --> 00:28:24.905 line:-2 align:center
by using the trace tree argument
and the object address from heap.


461
00:28:24,938 --> 00:28:28,909 line:-2
However, because this is a rather
large tree in this example,


462
00:28:28,942 --> 00:28:32,679 line:-2
there is a somewhat better way
to view it than in Terminal.


463
00:28:34.281 --> 00:28:37.751 line:-2 align:center
With Xcode 14,
we redesigned the memory graph view


464
00:28:37.784 --> 00:28:42.289 line:-2 align:center
to show both ingoing and outgoing edges
of the selected object.


465
00:28:43,357 --> 00:28:46,059 line:-2
It even has a new
neighbor selection popover,


466
00:28:46,093 --> 00:28:49,396 line:-2
to choose the edges
you want Xcode to draw.


467
00:28:49.429 --> 00:28:52.132 line:-2 align:center
This is going to greatly improve
productivity


468
00:28:52.165 --> 00:28:56.603 line:-2 align:center
when trying to understand object
references in complex game states.


469
00:28:58.105 --> 00:29:00.541 line:-1 align:center
After exploring around for a little bit,


470
00:29:00,574 --> 00:29:05,345 line:-2
I'm pretty sure the texture manager
is what is accessing this object.


471
00:29:05,379 --> 00:29:07,814 line:-2
For your game,
consider using leaks tool


472
00:29:07,848 --> 00:29:12,386 line:-2
and the memory graph view to find
important object reference relationships,


473
00:29:12.419 --> 00:29:16.190 line:-2 align:center
to learn how these objects
are accessed in the game.


474
00:29:16,223 --> 00:29:18,992 line:-2
So that how to view and find out
important references


475
00:29:19.026 --> 00:29:22.729 line:-1 align:center
of an object using leaks or Xcode.


476
00:29:22,763 --> 00:29:24,565 line:-1
Please check out leaks' manual page,


477
00:29:24,598 --> 00:29:28,268 line:-2
and Xcode help
for more usage of these tools.


478
00:29:29,603 --> 00:29:32,039 line:-1
In this memory graph analysis cookbook,


479
00:29:32,072 --> 00:29:35,375 line:-1
each step uses some specific tools.


480
00:29:35.409 --> 00:29:40.047 line:-2 align:center
All of them work together to complete
the analysis on a memory graph.


481
00:29:41,548 --> 00:29:45,552 line:0
To summarize, the first thing
is to enable MallocStackLogging


482
00:29:45,586 --> 00:29:50,991 align:center
when you expect to capture and analyze
memory with a memory graph.


483
00:29:51,024 --> 00:29:54,595 line:0
Then capture a memory graph
with Xcode for your game,


484
00:29:54,628 --> 00:29:58,765 align:center
or alternatively use leaks tool
for your Mac game.


485
00:29:58,799 --> 00:30:02,870 line:0
Next, find large and troublesome objects.


486
00:30:02,903 --> 00:30:07,474 line:0
Footprint, vmmap, and heap tools
provide breakdown of memory,


487
00:30:07,508 --> 00:30:11,111 line:0
both on a high level and in details.


488
00:30:11,144 --> 00:30:15,282 align:center
With malloc_history, you can find out
where objects are allocated


489
00:30:15,315 --> 00:30:19,820 align:center
and leaks can analyze object usage
or references.


490
00:30:19,853 --> 00:30:22,756 line:0
These previous sessions
include in-depth walkthroughs


491
00:30:22,789 --> 00:30:26,260 line:0
as well as demos
of more usage of these tools.


492
00:30:26.293 --> 00:30:30.063 line:-2 align:center
Until now, we have deferred probing
into Metal resources.


493
00:30:30,097 --> 00:30:32,533 line:-1
Well, now is the time.


494
00:30:32,566 --> 00:30:35,769 line:-1
To tell you more, here's Seth.


495
00:30:35,802 --> 00:30:37,104 line:-1
Hi again!


496
00:30:37,137 --> 00:30:40,807 line:-2
In games, Metal resources
can use a big chunk of memory.


497
00:30:40,841 --> 00:30:43,310 line:-2
But there are ways to optimize
their memory use.


498
00:30:44.411 --> 00:30:46.513 line:-2 align:center
Here I've summarized a list
of memory savings


499
00:30:46,547 --> 00:30:50,551 line:-2
that you can use when optimizing
the Metal resources in your game.


500
00:30:50,584 --> 00:30:54,254 line:-2
We'll take a look at how Metal Debugger
can help you with auditing the resources


501
00:30:54,288 --> 00:30:58,025 line:-2
and learn some advanced techniques
for further reducing your game memory.


502
00:30:59.026 --> 00:31:03.230 line:-2 align:center
Metal Debugger is the one stop shop
for debugging your Metal games.


503
00:31:03,263 --> 00:31:05,365 line:-1
After taking a GPU frame capture,


504
00:31:05.399 --> 00:31:07.334 line:-1 align:center
you can find a summary page.


505
00:31:07.367 --> 00:31:10.604 line:-2 align:center
This provides you with some general stats
about the captured workload.


506
00:31:12,172 --> 00:31:13,740 line:-1
In the lower half of the page,


507
00:31:13.774 --> 00:31:17.477 line:-2 align:center
there is a list of insights
divided in four categories.


508
00:31:17.511 --> 00:31:22.115 line:-2 align:center
Insights in the "Memory" category
suggest memory savings for your game.


509
00:31:22,149 --> 00:31:25,752 line:-2
There aren't many memory insights
particular for this trace;


510
00:31:25,786 --> 00:31:29,356 line:-2
we can save just a few megabytes
of memory after addressing these insights.


511
00:31:31,225 --> 00:31:35,095 line:-2
However, there may be more memory savings
specific to your game.


512
00:31:35.128 --> 00:31:38.265 line:-2 align:center
To get a more complete picture of
the memory used by Metal resources,


513
00:31:38.298 --> 00:31:41.435 line:-2 align:center
you can use the Memory Viewer
from clicking on the Show Memory button.


514
00:31:42,903 --> 00:31:47,441 line:-2
The Memory Viewer offers you a full list
of resources captured from the game.


515
00:31:47,474 --> 00:31:50,844 line:-2
The upper half shows
different categories for filtering.


516
00:31:50,878 --> 00:31:54,681 line:-2
You can quickly use this to
look up resources, say, textures.


517
00:31:54,715 --> 00:31:58,785 line:-2
And in the lower half,
the table displays just the textures.


518
00:31:58,819 --> 00:32:01,755 line:-1
Let's take out the filter for now.


519
00:32:01,788 --> 00:32:06,059 line:-2
The resource table has a collection
of columns to help you optimize your game.


520
00:32:06.093 --> 00:32:09.329 line:-2 align:center
And I'd like to highlight a few columns
that may help you quickly identify


521
00:32:09.363 --> 00:32:10.964 line:-1 align:center
some interesting resources.


522
00:32:13.100 --> 00:32:17.337 line:-2 align:center
The Insights column is similar to
what we just saw on the summary page.


523
00:32:17.371 --> 00:32:19.706 line:-2 align:center
You may quickly view all the resources
with insights


524
00:32:19,740 --> 00:32:23,343 line:-1
when sorting the table by this column.


525
00:32:23.377 --> 00:32:26.313 line:-2 align:center
And clicking on an insight icon
will reveal a popover


526
00:32:26.346 --> 00:32:30.717 line:-2 align:center
explaining the finding
and providing some possible actions.


527
00:32:30,751 --> 00:32:34,288 line:-2
Right next to this column
is Allocated Size.


528
00:32:34,321 --> 00:32:37,991 line:-2
You can sort by this column
to see the largest resources.


529
00:32:38,025 --> 00:32:41,361 line:-2
It may be useful to audit if some
resources actually make good use


530
00:32:41.395 --> 00:32:43.397 line:-1 align:center
of their memory size.


531
00:32:43,430 --> 00:32:47,601 line:-2
For example, some textures may be resized
to smaller resolutions


532
00:32:47,634 --> 00:32:51,305 line:-2
and some models loaded in buffers
may use a lower poly count,


533
00:32:51,338 --> 00:32:55,242 line:-2
given that doing so won't affect
the visual quality of the game.


534
00:32:55,275 --> 00:32:57,377 line:-2
There are some alternative ways
to save texture memory


535
00:32:57.411 --> 00:32:59.680 line:-1 align:center
that I'll mention in a minute.


536
00:32:59,713 --> 00:33:03,050 line:-2
Another interesting column here
is Time Since Last Bound.


537
00:33:03,083 --> 00:33:08,222 line:-2
You can sort the resources by this column
to find which haven't been used recently.


538
00:33:08,255 --> 00:33:09,857 line:-1
If a resource is never used,


539
00:33:09,890 --> 00:33:14,428 line:-2
it may be a good idea to double check
if it's worth loading the asset.


540
00:33:14.461 --> 00:33:16.763 line:-2 align:center
For a resource
that hasn't been bound for a while,


541
00:33:16,797 --> 00:33:20,734 line:-2
you may consider releasing it
if it won't be used again in the future.


542
00:33:20,767 --> 00:33:24,972 line:-2
Alternatively, you can set
its purgeable state to volatile.


543
00:33:25.005 --> 00:33:28.475 line:-2 align:center
A Metal resource may be in
one of the three purgeable states:


544
00:33:28,509 --> 00:33:32,346 line:-1
non-volatile, volatile, and empty.


545
00:33:32.379 --> 00:33:35.949 line:-1 align:center
By default, resources are non-volatile.


546
00:33:35.983 --> 00:33:37.918 line:-2 align:center
By setting the purgeable state
to volatile,


547
00:33:37.951 --> 00:33:39.887 line:-1 align:center
Metal may evict the resource from memory


548
00:33:39,920 --> 00:33:42,656 line:-2
in case of high memory pressure
in the system.


549
00:33:42.689 --> 00:33:45.325 line:-2 align:center
Once the resource is empty,
the system will no longer charge it


550
00:33:45,359 --> 00:33:47,995 line:-1
towards the game's footprint.


551
00:33:48,028 --> 00:33:49,663 line:-1
When your game needs the resource again,


552
00:33:49,696 --> 00:33:53,367 line:-2
check if the content's still there,
and reload if needed.


553
00:33:53.400 --> 00:33:56.870 line:-2 align:center
Consider only using volatile
for infrequently used resources,


554
00:33:56,904 --> 00:33:59,339 line:-2
so the purgeable state
doesn't work against you.


555
00:34:01,375 --> 00:34:05,012 line:-2
So those are some of the general notes
for all resources.


556
00:34:05,045 --> 00:34:08,015 line:-2
And now,
let's take a closer look at textures.


557
00:34:08.949 --> 00:34:12.219 line:-2 align:center
Not all columns are shown by default
in Memory Viewer.


558
00:34:12,252 --> 00:34:15,289 line:-2
Right clicking on the table header
will allow showing and hiding columns


559
00:34:15.322 --> 00:34:18.158 line:-1 align:center
like texture's Pixel Format.


560
00:34:18,192 --> 00:34:23,163 line:-2
You may get different amount of savings by
optimizing the pixel format for a texture.


561
00:34:23,197 --> 00:34:27,000 line:-2
Many textures in a game could use
a 16-bit half precision pixel format


562
00:34:27,034 --> 00:34:29,837 line:-1
to reduce memory use and bandwidth.


563
00:34:29,870 --> 00:34:32,940 line:-2
In cases when you need a texture
with a single alpha component,


564
00:34:32,973 --> 00:34:35,642 line:-1
you may avoid multiple color channels.


565
00:34:35,676 --> 00:34:39,146 line:-2
And lastly, some read-only textures
may benefit from block compression


566
00:34:39,179 --> 00:34:41,615 line:-1
for lower memory use.


567
00:34:41,648 --> 00:34:43,717 line:0
For block compressed pixel formats,


568
00:34:43,750 --> 00:34:46,687 line:0
there are options such as ASTC and BC.


569
00:34:46,720 --> 00:34:49,122 align:center
Additionally, since A15 Bionic,


570
00:34:49,156 --> 00:34:51,892 line:0
you can use lossy compression for textures
and render targets


571
00:34:51,925 --> 00:34:55,562 align:center
to save memory while preserving
quality wherever possible.


572
00:34:55,596 --> 00:34:58,432 line:0
Please check out these previous
videos for more details.


573
00:35:00,634 --> 00:35:03,203 line:-2
And those are some of the memory savings
you can quickly discover


574
00:35:03.237 --> 00:35:05.172 line:-1 align:center
from using Memory Viewer.


575
00:35:05.205 --> 00:35:07.341 line:-2 align:center
But there are a few additional techniques
you may take


576
00:35:07,374 --> 00:35:09,977 line:-1
to further optimize your game.


577
00:35:10,010 --> 00:35:12,546 line:-1
If a texture is only used by single pass,


578
00:35:12.579 --> 00:35:14.648 line:-1 align:center
you can set its storage mode to memoryless


579
00:35:14.681 --> 00:35:16.783 line:-1 align:center
to save memory and bandwidth.


580
00:35:16,817 --> 00:35:19,620 line:-2
Memoryless textures work well
for temporary render targets,


581
00:35:19,653 --> 00:35:23,156 line:-2
like depth, stencil,
or multi-sampled textures.


582
00:35:23,190 --> 00:35:26,293 line:-2
Otherwise, if the texture
is only used by the GPU,


583
00:35:26,326 --> 00:35:28,061 line:-1
you can set its storage mode to private,


584
00:35:28,095 --> 00:35:31,131 line:-1
or else shared or managed.


585
00:35:31.164 --> 00:35:34.601 line:-2 align:center
As a reminder, managed mode is not needed
on Apple silicon Macs,


586
00:35:34.635 --> 00:35:37.371 line:-1 align:center
just like on iPhone and iPad.


587
00:35:37.404 --> 00:35:39.473 line:-1 align:center
Here's an example case.


588
00:35:39.506 --> 00:35:42.876 line:-2 align:center
The game has
a Depth32Float_Stencil8 texture.


589
00:35:42,910 --> 00:35:46,079 line:-1
The depth texture is used across passes,


590
00:35:46,113 --> 00:35:48,215 line:-2
but the stencil texture's content
is discarded


591
00:35:48.248 --> 00:35:51.318 line:-1 align:center
and won't be used later in the frame.


592
00:35:51.351 --> 00:35:54.154 line:-2 align:center
So instead,
the game could use two textures


593
00:35:54.188 --> 00:35:57.925 line:-2 align:center
and make the stencil texture memoryless,
to save memory and bandwidth.


594
00:35:59,359 --> 00:36:02,930 line:-2
Lastly, I'd like to mention another
technique that might be interesting to you


595
00:36:02.963 --> 00:36:05.432 line:-2 align:center
for making the most out of the memory
in your game.


596
00:36:05,465 --> 00:36:07,901 align:center
You may use aliased resources
from a heap


597
00:36:07,935 --> 00:36:09,937 align:center
if your game doesn't use them
at the same time.


598
00:36:09,970 --> 00:36:12,973 line:0
They can share the memory backed
by the same allocation.


599
00:36:13,006 --> 00:36:17,411 line:0
But be extra careful when synchronizing
the accesses to those resources.


600
00:36:17,444 --> 00:36:19,780 line:0
You can check out
the "Go bindless with Metal 3" talk


601
00:36:19,813 --> 00:36:23,317 line:0
to learn more about using resources
allocated from a heap.


602
00:36:23,350 --> 00:36:26,820 line:-2
So that wraps up our checklist
of memory savings.


603
00:36:26.854 --> 00:36:30.190 line:-2 align:center
And I hope this checklist will help you
audit the Metal resources in your game.


604
00:36:31,725 --> 00:36:33,861 line:0
To learn more about using
Metal Debugger for optimizing


605
00:36:33,894 --> 00:36:38,031 align:center
your game memory,
please check out these other WWDC talks.


606
00:36:38,065 --> 00:36:39,499 align:center
And back to you, Jack.


607
00:36:41,235 --> 00:36:42,503 line:-1
Thank you, Seth.


608
00:36:42.536 --> 00:36:46.340 line:-2 align:center
Today, we took a guided tour
and explored many interesting things


609
00:36:46,373 --> 00:36:50,177 line:-2
you can do to understand and improve
your game's memory usage.


610
00:36:50,210 --> 00:36:53,981 line:-2
First, memory footprint
is the primary metric


611
00:36:54,014 --> 00:36:56,650 line:-1
in understanding your game's memory usage,


612
00:36:56,683 --> 00:37:01,722 line:-2
and it includes dirty plus compressed
and swapped memory.


613
00:37:01,755 --> 00:37:05,859 line:-2
Then, we experienced powerful
memory debugging tools.


614
00:37:05,893 --> 00:37:09,496 line:-2
Seth showed us how Instruments
empower memory profiling


615
00:37:09,530 --> 00:37:11,865 line:-1
with useful telemetry tracks.


616
00:37:11.899 --> 00:37:16.537 line:-2 align:center
The new Game Memory template
is exactly tailored for this job.


617
00:37:16,570 --> 00:37:22,442 line:-2
After that, I presented memory graph
to store a snapshot of game memory state.


618
00:37:22.476 --> 00:37:25.712 line:-2 align:center
There are flexible and powerful
command line programs


619
00:37:25.746 --> 00:37:28.315 line:-1 align:center
to analyze memory graphs for objects,


620
00:37:28.348 --> 00:37:31.652 line:-1 align:center
references, and allocation history.


621
00:37:31,685 --> 00:37:35,822 line:-2
Improvements in the heap tool
and redesigned Xcode Memory Debugger


622
00:37:35.856 --> 00:37:38.825 line:-1 align:center
will supercharge game memory analysis.


623
00:37:38,859 --> 00:37:42,329 line:-2
Lastly, Seth shared
a memory savings checklist


624
00:37:42.362 --> 00:37:44.231 line:-1 align:center
for Metal resources,


625
00:37:44.264 --> 00:37:47.334 line:-2 align:center
and how Metal Debugger
can help answer questions


626
00:37:47.367 --> 00:37:51.138 line:-1 align:center
about Metal resource usage in your game.


627
00:37:51,171 --> 00:37:54,575 line:-2
You could also learn more
from other WWDC sessions,


628
00:37:54.608 --> 00:37:57.444 line:-1 align:center
documentation, and manual pages.


629
00:37:58,445 --> 00:38:02,349 line:-2
We are constantly advancing
our best and most flexible tools for you.


630
00:38:02,382 --> 00:38:04,318 line:-1
So why not try them out?


631
00:38:04,351 --> 00:38:06,720 line:-1
They may just be what you are looking for.


632
00:38:07.955 --> 00:38:11.525 line:-2 align:center
And don't hesitate to share with us
any feedback you may have,


633
00:38:11,558 --> 00:38:15,162 line:-2
via any channels
such as the Feedback Assistant.


634
00:38:15,195 --> 00:38:17,064 line:-1
Have fun in your memory journey,


635
00:38:17,097 --> 00:38:18,465 line:-1
and thanks for watching.  ♪ ♪

