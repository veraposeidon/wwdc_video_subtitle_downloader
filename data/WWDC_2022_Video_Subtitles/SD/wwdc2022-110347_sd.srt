2
00:00:00.334 --> 00:00:07.341 line:-1 align:center
♪ ♪


3
00:00:10.177 --> 00:00:13.180 line:-1 align:center
Hi, and welcome to WWDC.


4
00:00:13.213 --> 00:00:15.415 line:-2 align:center
My name is David,
and I'd like to tell you about


5
00:00:15.449 --> 00:00:18.685 line:-2 align:center
how you can explore
more content with MusicKit.


6
00:00:18.719 --> 00:00:21.288 line:-2 align:center
The MusicKit framework
was launched in 2021,


7
00:00:21,321 --> 00:00:25,659 line:-2
providing a set of APIs to access
and play music natively in Swift.


8
00:00:25.692 --> 00:00:28.996 line:-2 align:center
This framework makes it easy for
your app to integrate with Apple Music,


9
00:00:29.029 --> 00:00:32.299 line:-2 align:center
providing access
to the entire Apple Music catalog.


10
00:00:32,332 --> 00:00:34,968 line:-2
Today, I'd like to talk about
some of the major enhancements


11
00:00:35.002 --> 00:00:36.937 line:-1 align:center
we've made to MusicKit.


12
00:00:36,970 --> 00:00:40,641 line:-2
I'll start off with some additions to get
even more out of the Apple Music catalog,


13
00:00:40,674 --> 00:00:45,012 line:-2
with new music item types,
new requests, and new metadata.


14
00:00:46.046 --> 00:00:49.283 line:-2 align:center
After that, I'll discuss how
you can fetch personalized content


15
00:00:49,316 --> 00:00:53,187 line:-2
to provide a tailored experience
for each of your users.


16
00:00:53.220 --> 00:00:56.223 line:-2 align:center
Next up, I'll go
beyond the Apple Music catalog.


17
00:00:56,256 --> 00:00:59,092 line:-2
This year, you can take your app
to a whole new level


18
00:00:59.126 --> 00:01:02.596 line:-2 align:center
by including music
from your user's library.


19
00:01:02,629 --> 00:01:06,133 line:-2
Finally, I'll discuss
how to actively interact with the library,


20
00:01:06.166 --> 00:01:09.036 line:-2 align:center
such as adding items to the library
or a playlist,


21
00:01:09,069 --> 00:01:12,072 line:-1
as well as creating and editing playlists.


22
00:01:12.105 --> 00:01:14.842 line:-2 align:center
Let's dive into
the catalog content additions.


23
00:01:14.875 --> 00:01:18.579 line:-2 align:center
The initial release of MusicKit
introduced a new model layer for music,


24
00:01:18.612 --> 00:01:22.616 line:-2 align:center
including core types like Songs,
Albums, and Playlists.


25
00:01:22.649 --> 00:01:25.252 line:-2 align:center
This year, we're making it easier
to discover new music


26
00:01:25,285 --> 00:01:28,722 line:-2
with MusicKit
with the addition of two new types:


27
00:01:28.755 --> 00:01:30.824 line:-1 align:center
Curator and Radio Show.


28
00:01:32,092 --> 00:01:34,561 line:-1
Beyond that, MusicKit now also allows you


29
00:01:34.595 --> 00:01:37.831 line:-2 align:center
to build great UI
for searching through the catalog,


30
00:01:37,865 --> 00:01:41,134 line:-2
access top charts to get
the most popular songs, albums,


31
00:01:41,168 --> 00:01:44,204 line:-1
and more, and fetch new attributes


32
00:01:44,238 --> 00:01:48,809 line:-2
such as higher quality audio metadata
like Spatial Audio with Dolby Atmos.


33
00:01:49,610 --> 00:01:53,213 line:-2
Let's start with curators and radio shows,
which are fantastic resources


34
00:01:53.247 --> 00:01:54.882 line:-1 align:center
for music discovery.


35
00:01:54.915 --> 00:01:58.385 line:-2 align:center
Here, we're taking a look
at an example Curator, Nike.


36
00:01:58,418 --> 00:02:02,756 line:-2
Other examples of curators
are Shazam and Beats by Dr. Dre.


37
00:02:02.789 --> 00:02:07.127 line:-2 align:center
Here, we can easily find all of
the playlists generated by this curator.


38
00:02:07,160 --> 00:02:11,231 line:-2
This functionality allows people to get
quick access to playlists they may love,


39
00:02:11.265 --> 00:02:14.434 line:-2 align:center
finding new songs
or revisiting old favorites.


40
00:02:14.468 --> 00:02:17.304 line:-2 align:center
Now let's dive
into the more technical details.


41
00:02:18.238 --> 00:02:20.641 line:-1 align:center
Curators host a variety of attributes.


42
00:02:20,674 --> 00:02:24,244 line:-2
Some of the primary attributes
of this new Curator type are name,


43
00:02:24.278 --> 00:02:28.348 line:-1 align:center
url, artwork, and kind.


44
00:02:28,382 --> 00:02:32,719 line:-2
The kind property is an enum that can
either be "editorial" or "external"


45
00:02:32,753 --> 00:02:37,291 line:-2
indicating whether a given curator is
an Apple curator or a third party curator.


46
00:02:38.258 --> 00:02:40.761 line:-2 align:center
Curators also have
a playlists relationship


47
00:02:40,794 --> 00:02:42,896 line:-1
showing playlists made by that curator,


48
00:02:42.930 --> 00:02:46.133 line:-2 align:center
truly servicing
the music discovery notion we just saw.


49
00:02:47.835 --> 00:02:50.304 line:-1 align:center
Next, we have the Radio Show type.


50
00:02:50.337 --> 00:02:52.940 line:-2 align:center
Radio Shows like
"New Music Daily by Zane Lowe"


51
00:02:52,973 --> 00:02:56,343 line:-2
and "Pop Hits Radio by Brooke Reese"
are another way to discover


52
00:02:56,376 --> 00:02:59,046 line:-1
new music through seasoned professionals.


53
00:02:59,079 --> 00:03:00,647 line:-1
Much like the Curator type,


54
00:03:00.681 --> 00:03:03.317 line:-2 align:center
radio shows also have
a playlists relationship


55
00:03:03.350 --> 00:03:06.320 line:-1 align:center
to find the music a radio show features.


56
00:03:06,353 --> 00:03:09,623 line:-2
Just as these two new types
hold relationships to playlists,


57
00:03:09,656 --> 00:03:13,260 line:-2
we are also exposing two new
relationships on the Playlist type,


58
00:03:13,293 --> 00:03:17,698 line:-2
"Curator" and "RadioShow" for
the reversed logic: that given a playlist,


59
00:03:17,731 --> 00:03:21,702 line:-2
we can easily get the structure
of which entity generated said playlist.


60
00:03:23,203 --> 00:03:26,840 line:-2
MusicKit allows searching the catalog
for content from a plethora of types,


61
00:03:26,874 --> 00:03:31,645 line:-2
and now we're adding support for our new
item types, like curators and radio shows.


62
00:03:31,678 --> 00:03:34,481 line:-2
The list just continues to grow,
and as a result,


63
00:03:34.515 --> 00:03:37.651 line:-2 align:center
building good UI becomes
more and more challenging.


64
00:03:37,684 --> 00:03:40,621 line:-2
That's why this year,
we're making it much easier for you


65
00:03:40.654 --> 00:03:43.857 line:-1 align:center
through top results and suggestions.


66
00:03:43.891 --> 00:03:47.694 line:-2 align:center
Let's take a look at the utility
these enhancements bring to a UI.


67
00:03:47,728 --> 00:03:51,164 line:-2
When typing to search for content,
you may want to provide strong,


68
00:03:51.198 --> 00:03:53.834 line:-1 align:center
music-related auto-complete support.


69
00:03:53.867 --> 00:03:56.170 line:-1 align:center
That's where suggestions come into play,


70
00:03:56,203 --> 00:03:59,239 line:-2
providing terms
that people may be trying to reach.


71
00:03:59,273 --> 00:04:02,309 line:-2
You can even take it a step further
and display top results


72
00:04:02.342 --> 00:04:06.380 line:-2 align:center
for quick access
to what people may be searching for.


73
00:04:06.413 --> 00:04:09.650 line:-2 align:center
For the best results, you may not care
about the type of the item,


74
00:04:09.683 --> 00:04:12.653 line:-1 align:center
but instead want to focus on relevancy.


75
00:04:12.686 --> 00:04:15.355 line:-1 align:center
This is the power of top results.


76
00:04:15,389 --> 00:04:18,659 line:-2
Now, let's take a look at what
implementing this would look like,


77
00:04:18,692 --> 00:04:20,227 line:-1
starting with Top Results.


78
00:04:20,260 --> 00:04:23,864 line:-2
Here we have the existing way to create
a catalog search request,


79
00:04:23.897 --> 00:04:25.499 line:-1 align:center
requiring a search term


80
00:04:25.532 --> 00:04:28.001 line:-2 align:center
and the types of items
that you want represented.


81
00:04:28.035 --> 00:04:31.805 line:-2 align:center
The response includes collections
categorized by the requested types,


82
00:04:31.839 --> 00:04:35.175 line:-2 align:center
meaning multiple lists
of type specific results.


83
00:04:35,209 --> 00:04:38,078 line:-2
Although this is great,
we want to expose a single list


84
00:04:38,111 --> 00:04:41,081 line:-2
of the most relevant results
that is type agnostic.


85
00:04:41,114 --> 00:04:45,652 line:-2
And requesting this information
is as simple as adding one line.


86
00:04:45.686 --> 00:04:49.790 line:-2 align:center
Here we're setting the includeTopResults
property on the request to true,


87
00:04:49.823 --> 00:04:53.060 line:-2 align:center
and a new property
is filled in the response.


88
00:04:53.093 --> 00:04:55.796 line:-1 align:center
This new property is named topResults


89
00:04:55,829 --> 00:04:58,866 line:-2
which contains items
of any of the requested types.


90
00:04:58,899 --> 00:05:02,202 line:0
Here's what the output
of the print statement looks like.


91
00:05:02,236 --> 00:05:06,073 align:center
We can see that the top results
returned are a mix of songs, artists,


92
00:05:06,106 --> 00:05:11,011 line:0
and albums in a single collection
and is ordered by relevancy.


93
00:05:11,044 --> 00:05:14,047 line:-2
Now I'll show you how to help
people get to their search destination


94
00:05:14,081 --> 00:05:16,683 line:-1
faster with Suggestions.


95
00:05:16,717 --> 00:05:20,687 line:-2
Simply create a suggestions request
with a string term.


96
00:05:20,721 --> 00:05:25,192 align:center
Upon calling response,
you'll get back a suggestions response.


97
00:05:25,225 --> 00:05:27,961 align:center
The response contains
an array of Suggestions.


98
00:05:27,995 --> 00:05:32,232 align:center
And each suggestion includes a display
term which is suitable for your UI,


99
00:05:32,266 --> 00:05:34,067 align:center
as well as a search term.


100
00:05:34,101 --> 00:05:37,538 align:center
When people select a suggestion,
you can fetch the corresponding results


101
00:05:37,571 --> 00:05:40,240 align:center
by performing a search request
with the search term.


102
00:05:41,508 --> 00:05:46,280 line:-2
Catalog charts are a great way to stay
up-to-date with the most popular songs.


103
00:05:46,313 --> 00:05:50,584 line:-2
MusicKit offers various types of charts
to see what's trending.


104
00:05:50.617 --> 00:05:53.053 line:-2 align:center
The types of charts
being offered are top charts,


105
00:05:53.086 --> 00:05:57.824 line:-2 align:center
such as Top Songs or Top Albums,
which correspond to the most played music,


106
00:05:57,858 --> 00:06:01,528 line:-1
city charts, and daily top 100.


107
00:06:01,562 --> 00:06:06,633 line:-2
You may also specify the requested charts
to be filtered by a specific genre.


108
00:06:06.667 --> 00:06:09.870 line:-2 align:center
Retrieving these charts
through code is extremely simple.


109
00:06:09.903 --> 00:06:12.539 line:-2 align:center
The catalog charts request
follows established patterns


110
00:06:12,573 --> 00:06:15,709 line:-2
already used
in the catalog search request.


111
00:06:15.742 --> 00:06:18.879 line:-1 align:center
First, initialize a charts request.


112
00:06:18.912 --> 00:06:22.182 line:-2 align:center
You can then specify
the kinds of charts you'd like.


113
00:06:22.216 --> 00:06:25.252 line:-2 align:center
By default,
this will fetch the most played content,


114
00:06:25.285 --> 00:06:30.157 line:-2 align:center
but you can also include daily
global top charts and city top charts.


115
00:06:30,190 --> 00:06:33,560 line:-2
Lastly, just specify the types
you want your charts to contain.


116
00:06:33,594 --> 00:06:35,896 line:0
And that's it.


117
00:06:35,929 --> 00:06:38,699 line:0
When we access the first playlist chart
in the response,


118
00:06:38,732 --> 00:06:43,270 line:0
we get a MusicCatalogChart
representing the daily global top charts.


119
00:06:43,303 --> 00:06:48,775 line:0
Its items are playlists like "Top 100:
Global" and "Top 100: USA".


120
00:06:48,809 --> 00:06:52,279 line:0
If you've been fetching catalog charts
using MusicDataRequest in the past,


121
00:06:52,312 --> 00:06:55,482 align:center
you no longer need to,
as MusicKit will do the work for you,


122
00:06:55,516 --> 00:06:58,752 line:0
with pagination support
built into the collection of items.


123
00:06:58,785 --> 00:07:00,320 line:-1
In 2021,


124
00:07:00,354 --> 00:07:02,789 line:-2
we introduced
groundbreaking audio experiences


125
00:07:02,823 --> 00:07:05,959 line:-2
with true multidimensional sound
and clarity:


126
00:07:05.993 --> 00:07:09.396 line:-2 align:center
Spatial Audio with support
for Dolby Atmos.


127
00:07:09,429 --> 00:07:13,166 line:-2
This immersive experience is
already available for thousands of songs,


128
00:07:13.200 --> 00:07:15.702 line:-1 align:center
and now you can access this data.


129
00:07:15,736 --> 00:07:20,674 line:-2
MusicKit exposes which audio resources are
available for any song or album


130
00:07:20,707 --> 00:07:25,646 line:-2
through Audio Variants, so now,
you can relay this information to others.


131
00:07:25.679 --> 00:07:28.315 line:-2 align:center
Examples of audio variants
are the previously mentioned


132
00:07:28.348 --> 00:07:33.387 line:-2 align:center
Spatial Audio with Dolby Atmos,
Lossless Audio, and much more.


133
00:07:34,755 --> 00:07:38,492 line:-2
We are also exposing a new
boolean property alongside audio variants,


134
00:07:38,525 --> 00:07:43,297 line:-2
is Apple Digital Master, which is
the highest quality master supported.


135
00:07:43.330 --> 00:07:46.099 line:-2 align:center
Since this metadata is
exposed at the item level,


136
00:07:46,133 --> 00:07:48,368 line:-2
audio variants
are perfect for a detail view,


137
00:07:48,402 --> 00:07:51,471 line:-1
allowing you to achieve UI like this.


138
00:07:51,505 --> 00:07:54,341 line:-1
Here we have a detail view of an album.


139
00:07:54.374 --> 00:07:56.743 line:-2 align:center
And here,
we can see the appropriate badges


140
00:07:56,777 --> 00:07:59,580 line:-2
based on the audio variants
property mentioned earlier,


141
00:07:59,613 --> 00:08:02,950 line:-2
letting users know
what audio quality they can expect.


142
00:08:02.983 --> 00:08:05.819 line:-2 align:center
In this case,
spatial audio and lossless audio


143
00:08:05,853 --> 00:08:08,088 line:-1
are available for this specific album.


144
00:08:08,121 --> 00:08:11,325 line:-2
Now let's see how we can write
code to achieve this.


145
00:08:11,358 --> 00:08:14,928 line:-2
Loading audio variants are like loading
any other extended attribute.


146
00:08:14.962 --> 00:08:18.732 line:-2 align:center
Take an existing album or song,
in this case an album,


147
00:08:18.765 --> 00:08:22.803 line:-2 align:center
and use the with method to load
the audioVariants extended attribute.


148
00:08:22,836 --> 00:08:27,441 line:-2
Now your detailedAlbum has
the audioVariants property populated.


149
00:08:27,474 --> 00:08:29,510 line:0
Here we can see
the audio variants property,


150
00:08:29,543 --> 00:08:32,913 line:0
which is an array
whose element is an AudioVariant.


151
00:08:32,946 --> 00:08:36,884 line:0
With these values, you can indicate
in your UI the available audio resources


152
00:08:36,917 --> 00:08:40,153 align:center
for that particular element,
just like we saw earlier.


153
00:08:40,187 --> 00:08:42,256 align:center
Now, this is great,
but you may want to show these


154
00:08:42,289 --> 00:08:45,959 align:center
audio badges on more than
just top level or detail views.


155
00:08:45,993 --> 00:08:48,562 line:0
That's why
we're also taking it one step further


156
00:08:48,595 --> 00:08:52,099 line:0
and exposing the active audio variant
for the music player.


157
00:08:52,132 --> 00:08:55,469 line:-2
Accessing the active audio variant allows
for a visual indication


158
00:08:55,502 --> 00:08:58,772 line:-2
of the quality of audio
for the currently playing item,


159
00:08:58.805 --> 00:09:01.542 line:-1 align:center
such as Dolby Atmos in this view.


160
00:09:01,575 --> 00:09:04,511 line:-2
And the MusicKit player API
automatically chooses


161
00:09:04,545 --> 00:09:08,382 line:-2
the correct audio quality based on
user settings and network conditions.


162
00:09:09.216 --> 00:09:11.518 line:-2 align:center
To access the active
trait from the player,


163
00:09:11,552 --> 00:09:15,122 line:-2
first, we access the
ApplicationMusicPlayer's playback state


164
00:09:15.155 --> 00:09:17.157 line:-1 align:center
in an observed object.


165
00:09:17,191 --> 00:09:21,728 line:-2
We can then access the active audioVariant
directly from the playback state


166
00:09:21.762 --> 00:09:24.031 line:-2 align:center
Now,
we simply check the audioVariant property


167
00:09:24,064 --> 00:09:27,734 line:-2
to see if it's dolbyAtmos,
and add additional UI if it is.


168
00:09:27.768 --> 00:09:30.204 line:-2 align:center
Because the playback state
is an observed object,


169
00:09:30,237 --> 00:09:32,272 line:-1
this view will automatically update


170
00:09:32,306 --> 00:09:34,274 line:-2
whenever the currently
playing item changes,


171
00:09:34,308 --> 00:09:37,311 line:-2
making sure your view is
always up-to-date.


172
00:09:37,344 --> 00:09:39,680 line:-2
Now that we've gone over
some catalog additions,


173
00:09:39,713 --> 00:09:42,282 line:-2
let's dive into
fetching personalized content.


174
00:09:42,316 --> 00:09:45,285 line:-2
Personalized content is data
specific to a subscriber,


175
00:09:45,319 --> 00:09:49,423 line:-2
providing a unique and tailored
experience for every user in your app.


176
00:09:49.456 --> 00:09:52.526 line:-2 align:center
Normally, personalized content
requires special authentications


177
00:09:52,559 --> 00:09:55,395 line:-2
and user tokens,
but in the MusicKit framework,


178
00:09:55,429 --> 00:09:59,132 line:-2
we've made this all automatic so you don't
have to deal with any of the hassle.


179
00:09:59.166 --> 00:10:01.502 line:-2 align:center
The personalized content
we're bringing to developers


180
00:10:01,535 --> 00:10:03,770 line:-1
is access to recently played items


181
00:10:03,804 --> 00:10:06,907 line:-1
and personal recommendations.


182
00:10:06,940 --> 00:10:09,443 line:-2
Recently played content is
a valuable piece of data


183
00:10:09,476 --> 00:10:12,279 line:-2
for a person's
music consumption experience.


184
00:10:12.312 --> 00:10:16.917 line:-2 align:center
It allows for quick and easy access
to music items you know they enjoy.


185
00:10:16,950 --> 00:10:20,354 line:-2
And when listening to new music,
it allows people to later go back


186
00:10:20.387 --> 00:10:22.489 line:-1 align:center
and refer to their history.


187
00:10:22,523 --> 00:10:25,526 line:-2
To fetch recently played
containers like albums, playlists,


188
00:10:25.559 --> 00:10:29.730 line:-2 align:center
and stations, you can create
a recently played container request.


189
00:10:29.763 --> 00:10:32.432 line:-2 align:center
Note that if you play a song
from a playlist or album,


190
00:10:32.466 --> 00:10:34.635 line:-1 align:center
the container type will be retrieved.


191
00:10:34,668 --> 00:10:38,138 line:0
In the response,
you will find recently played music items,


192
00:10:38,172 --> 00:10:43,443 align:center
which offer convenience accessors
for the title, subtitle, and artwork.


193
00:10:43.477 --> 00:10:46.947 line:-2 align:center
You can also fetch recently played items
of more specific types,


194
00:10:46,980 --> 00:10:48,882 line:-1
like songs or stations.


195
00:10:48,916 --> 00:10:52,653 line:-2
Here, we create a recently played request,
specifying the Song type


196
00:10:52,686 --> 00:10:56,490 line:-2
through the generic parameter,
indicated by the angle brackets.


197
00:10:56,523 --> 00:10:59,693 line:0
Our response now only contains
the songs that we have played.


198
00:10:59,726 --> 00:11:02,596 line:-1
Now, onto personal recommendations.


199
00:11:02.629 --> 00:11:07.067 line:-2 align:center
Personal recommendations let your app
experience feel more intimate and engaging


200
00:11:07.100 --> 00:11:11.905 line:-2 align:center
as they are generated based off
the user's library and listening history.


201
00:11:11.939 --> 00:11:14.575 line:-2 align:center
Recommendations are
nicely organized by themes,


202
00:11:14,608 --> 00:11:20,147 line:-2
resulting in groupings by genres, artists,
collections like "Made for You," and more.


203
00:11:20.180 --> 00:11:22.683 line:-1 align:center
To fetch personal recommendations,


204
00:11:22.716 --> 00:11:25.552 line:-2 align:center
simply create
a personal recommendations request.


205
00:11:25,586 --> 00:11:28,388 line:-2
The response is
a collection of recommendations.


206
00:11:28,422 --> 00:11:32,092 line:0
When we log the first recommendation,
we can see that this particular element


207
00:11:32,125 --> 00:11:34,595 align:center
represents the "Made for You"
recommendation.


208
00:11:34,628 --> 00:11:38,632 line:0
Recommendations have an ID,
title, and nextRefreshDate.


209
00:11:38,665 --> 00:11:42,135 line:0
The nextRefreshDate represents
the date time for when this recommendation


210
00:11:42,169 --> 00:11:45,372 align:center
should be refreshed
for the most up-to-date suggestions.


211
00:11:45,405 --> 00:11:49,109 line:0
The playlists property contains all
of the playlists that are made for me.


212
00:11:49,142 --> 00:11:52,446 line:0
Let's take a look at another
example of a recommendation.


213
00:11:52,479 --> 00:11:56,250 line:-2
Here we'll print out the second element
of the recommendations response.


214
00:11:56,283 --> 00:11:59,820 align:center
I listen to a ton of alternative music,
and this recommendation contains


215
00:11:59,853 --> 00:12:04,391 align:center
a mix of different types,
in this case, Albums and Playlists.


216
00:12:04,424 --> 00:12:06,994 line:0
Those are grouped
in a single collection of items,


217
00:12:07,027 --> 00:12:11,131 line:0
which are ordered by relevancy,
much like top results for catalog search.


218
00:12:11,164 --> 00:12:14,868 line:-2
Now, let's take it a step further
and talk about how you can create


219
00:12:14,902 --> 00:12:17,371 line:-2
even more relevant experiences
around music


220
00:12:17,404 --> 00:12:21,175 line:-2
by incorporating content
from your user's library into your app.


221
00:12:21.208 --> 00:12:25.312 line:-2 align:center
This year, MusicKit allows your app
to fetch items from the library


222
00:12:25,345 --> 00:12:28,749 line:-2
with two types of requests:
the library request


223
00:12:28,782 --> 00:12:31,485 line:-1
and the library sectioned request,


224
00:12:31,518 --> 00:12:34,588 line:-1
search for content in the user's library,


225
00:12:34,621 --> 00:12:37,524 line:-2
and load extended attributes
and relationships


226
00:12:37.558 --> 00:12:39.927 line:-1 align:center
specifically from the library.


227
00:12:39,960 --> 00:12:42,296 line:-1
Before we see the technical details,


228
00:12:42,329 --> 00:12:45,566 line:-2
let's see how we can use library content
to enhance your app.


229
00:12:45.599 --> 00:12:48.435 line:-2 align:center
I've been working on a fitness app
called Music Marathon


230
00:12:48.468 --> 00:12:50.704 line:-1 align:center
that will track your outdoor runs.


231
00:12:50.737 --> 00:12:52.906 line:-1 align:center
By incorporating MusicKit in the project,


232
00:12:52,940 --> 00:12:55,509 line:-2
we allow people to play music
directly through the app


233
00:12:55,542 --> 00:12:59,546 line:-2
instead of context switching between
the Apple Music app and this one.


234
00:12:59,580 --> 00:13:03,016 line:-2
Let's start a new workout
and look for music content.


235
00:13:04,818 --> 00:13:07,154 line:-2
Here we see some
recommended playlists retrieved


236
00:13:07,187 --> 00:13:09,122 line:-1
from the personal recommendations request,


237
00:13:09,156 --> 00:13:12,860 line:-2
to give people quick access
to playlists we think they'll love.


238
00:13:12.893 --> 00:13:17.531 line:-2 align:center
Going to the library tab,
we can see it's an empty view.


239
00:13:17.564 --> 00:13:20.267 line:-2 align:center
It would be great to be able to see
all of my personal playlists,


240
00:13:20,300 --> 00:13:21,835 line:-1
so let's write that feature.


241
00:13:21,869 --> 00:13:25,439 line:-2
I already have some UI set up
to handle the basics of this view,


242
00:13:25.472 --> 00:13:29.109 line:-2 align:center
and now I want to load
the playlists from my library.


243
00:13:29,142 --> 00:13:30,777 line:-1
First, I'll make library request...


244
00:13:33,647 --> 00:13:35,749 line:-2
Specifying playlist
in the generic parameter


245
00:13:35,782 --> 00:13:38,785 line:-2
to indicate that we want the playlists
from the user's library.


246
00:13:42,256 --> 00:13:44,958 line:-2
And I'll store it in a local variable
I'll name "request."


247
00:13:47.928 --> 00:13:51.098 line:-2 align:center
Next I'll take this request
and call the response function.


248
00:13:53,867 --> 00:13:56,403 line:-1
This method is an async throwing method,


249
00:13:56,436 --> 00:13:58,572 line:-1
so let's add the try and await keywords.


250
00:13:58,605 --> 00:14:01,441 line:-2
and once again store it
in a response variable.


251
00:14:04,311 --> 00:14:07,614 line:-2
Then, I'll update the state object
to receive this response.


252
00:14:11,752 --> 00:14:14,555 line:-2
Now all that's left to do
is update the list


253
00:14:14,588 --> 00:14:17,457 line:-1
so we can see the playlists in my UI.


254
00:14:17.491 --> 00:14:21.228 line:-2 align:center
I'll iterate through the items
in the response using a ForEach...


255
00:14:25,432 --> 00:14:28,669 line:-2
And retrieve each playlist
in the MusicItemCollection.


256
00:14:30,404 --> 00:14:31,638 line:-1
Now that we have the playlists,


257
00:14:31.672 --> 00:14:33.941 line:-2 align:center
I'll pass them into a PlaylistCell
I've already made.


258
00:14:35,642 --> 00:14:37,644 line:-1
Now if we re-run...


259
00:14:44,017 --> 00:14:46,753 line:-1
And navigate back to the app,


260
00:14:46.787 --> 00:14:50.057 line:-2 align:center
we can see all of my personal
playlists in the library.


261
00:14:50,090 --> 00:14:52,826 line:-2
Now, I can choose to listen
to personal recommendations,


262
00:14:52.860 --> 00:14:57.097 line:-2 align:center
anything from the Apple Music catalog,
and my own personal library.


263
00:14:57.130 --> 00:15:00.467 line:-2 align:center
Now that we've seen how easy
it is to access library content,


264
00:15:00.501 --> 00:15:02.569 line:-2 align:center
let's look at what else
the library request can do.


265
00:15:02,603 --> 00:15:05,239 line:-2
The music library request
is a powerful API


266
00:15:05,272 --> 00:15:07,741 line:-1
to fetch items from the user's library.


267
00:15:07,774 --> 00:15:11,845 line:-2
On iOS, unlike other requests
to fetch content from the music catalog,


268
00:15:11,879 --> 00:15:15,682 line:-2
MusicLibraryRequest will not
actually load data from the network.


269
00:15:15.716 --> 00:15:19.152 line:-2 align:center
Instead, it will load items
from the copy of the user's library


270
00:15:19,186 --> 00:15:21,622 line:-1
that is stored on device.


271
00:15:21.655 --> 00:15:24.591 line:-2 align:center
The basics of this request
only require you to specify


272
00:15:24.625 --> 00:15:27.027 line:-1 align:center
which music item type is desired.


273
00:15:27,060 --> 00:15:29,429 line:-2
This item type is passed
through the generic parameter


274
00:15:29,463 --> 00:15:32,332 line:-1
of the MusicLibraryRequest.


275
00:15:32.366 --> 00:15:36.003 line:-2 align:center
You can apply a variety of filters
and sort options on the request


276
00:15:36,036 --> 00:15:39,873 line:-2
in order to finely tune your call
to match your requirements.


277
00:15:39.907 --> 00:15:43.710 line:-2 align:center
This request is also capable
of fetching already downloaded content,


278
00:15:43,744 --> 00:15:46,947 line:-1
supporting a fully offline experience.


279
00:15:46,980 --> 00:15:50,450 line:-2
Let's start with the simple, base request,
the same request we wrote


280
00:15:50.484 --> 00:15:55.322 line:-2 align:center
in the Music Marathon app, but this time,
ask for the Albums in the library.


281
00:15:55,355 --> 00:15:58,625 line:-2
The album type is specified
through the generic parameter.


282
00:15:58,659 --> 00:16:01,695 line:-2
To perform the request,
call the response function.


283
00:16:01,728 --> 00:16:04,898 line:0
Looking at the output,
we have a MusicLibraryResponse,


284
00:16:04,932 --> 00:16:07,334 line:0
where its items are a MusicItemCollection


285
00:16:07,367 --> 00:16:11,104 align:center
of all the albums found
within the user's music library.


286
00:16:11,138 --> 00:16:14,541 line:0
Here we notice that these Albums are
the same Album structure that you would


287
00:16:14,575 --> 00:16:19,346 align:center
get from one of our various catalog
requests and have the same capabilities.


288
00:16:19,379 --> 00:16:22,649 line:0
Whereas in this example we are
fetching every album in the library,


289
00:16:22,683 --> 00:16:27,221 line:0
we know there are scenarios where
you only want a specific subset of albums.


290
00:16:27,254 --> 00:16:31,458 align:center
That's why MusicLibraryRequest
also enables you to be more specific


291
00:16:31,491 --> 00:16:34,595 align:center
about what items
you want to fetch from the library.


292
00:16:34,628 --> 00:16:38,665 line:-2
Let's take the same request
we wrote before and add a filter.


293
00:16:38,699 --> 00:16:42,369 line:-2
Here, we want to load all albums
where the isCompilation property


294
00:16:42.402 --> 00:16:43.971 line:-1 align:center
is equal to true.


295
00:16:44,004 --> 00:16:47,941 line:-2
When you call filter method,
Xcode's autocompletion will only offer


296
00:16:47,975 --> 00:16:52,212 line:-2
specific key paths that are supported
for the type of item you are requesting.


297
00:16:52,246 --> 00:16:56,283 line:0
Now, the response only has
albums which are compilations.


298
00:16:56,316 --> 00:16:59,653 line:0
But that's not all the power
the MusicLibraryRequest has to offer.


299
00:16:59,686 --> 00:17:01,655 align:center
You can chain multiple filters,


300
00:17:01,688 --> 00:17:04,958 line:0
giving you a more refined request
with each addition.


301
00:17:04,992 --> 00:17:08,862 line:-2
What if we wanted all of
the compilations of a particular genre?


302
00:17:08,896 --> 00:17:11,331 line:-1
We can add another filter to the request.


303
00:17:11.365 --> 00:17:15.002 line:-2 align:center
For example, here we have
an instance of Genre named "Dance."


304
00:17:15.035 --> 00:17:18.305 line:-2 align:center
You can filter by the genre's relationship
to restrict the results


305
00:17:18.338 --> 00:17:22.309 line:-2 align:center
to only include compilations
that contain this specific genre.


306
00:17:22,342 --> 00:17:25,746 line:0
Now our response
only contains dance compilations.


307
00:17:25,779 --> 00:17:29,283 line:0
How about only including dance
compilations that are already downloaded?


308
00:17:29,316 --> 00:17:32,252 line:-2
To do that,
just set the includeOnlyDownloadedContent


309
00:17:32,286 --> 00:17:33,787 line:-1
to true on the request.


310
00:17:33,820 --> 00:17:34,955 line:-1
And that's it.


311
00:17:34,988 --> 00:17:37,891 line:0
The response is
the same MusicLibraryResponse,


312
00:17:37,925 --> 00:17:41,662 align:center
but the items now only contain
elements that are downloaded.


313
00:17:41,695 --> 00:17:45,165 align:center
As you can see,
the music library request is very powerful


314
00:17:45,199 --> 00:17:50,204 align:center
and unlocks new capabilities that weren't
possible with a custom MusicDataRequest.


315
00:17:50,237 --> 00:17:54,842 align:center
But MusicKit offers even more options
to fetch data from the user's library.


316
00:17:54.875 --> 00:17:57.611 line:-1 align:center
Meet the Library Sectioned Request.


317
00:17:57.644 --> 00:18:02.082 line:-2 align:center
The sectioned request is able
to fetch items grouped by sections.


318
00:18:02,115 --> 00:18:06,987 line:-2
As a result, the sectioned request
takes in two distinct generic parameters.


319
00:18:07.020 --> 00:18:11.758 line:-2 align:center
The first representing the section type,
and the second, the item type.


320
00:18:11,792 --> 00:18:14,661 line:-2
The library sectioned request
supports the same capabilities


321
00:18:14.695 --> 00:18:18.098 line:-2 align:center
as the regular library request,
such as a variety of filter


322
00:18:18,131 --> 00:18:23,470 line:-2
and sort methods which you can apply
to either the sections or the items.


323
00:18:23,504 --> 00:18:26,874 line:-2
Here's how you can fetch
all albums sectioned by their genres


324
00:18:26,907 --> 00:18:29,743 line:-1
using the library sectioned request.


325
00:18:29,776 --> 00:18:33,647 line:0
The sectioned Response holds a property
named "sections" where each element


326
00:18:33,680 --> 00:18:38,318 line:0
corresponds to the first generic parameter
of the request, Genre in this case.


327
00:18:38,352 --> 00:18:42,456 line:0
Each genre not only exposes
its own attributes, but it also contains


328
00:18:42,489 --> 00:18:46,660 align:center
a collection of albums,
accessible via the items property.


329
00:18:46,693 --> 00:18:50,030 align:center
Those items correspond
to the second generic argument.


330
00:18:50,063 --> 00:18:53,367 line:0
Here, the highlight shows albums
whose genre is Alternative.


331
00:18:53,400 --> 00:18:56,937 line:0
And as mentioned before,
the capabilities of filtering and sorting


332
00:18:56,970 --> 00:18:59,706 align:center
are also available
for this sectioned request.


333
00:18:59,740 --> 00:19:02,643 line:0
Let's say we want the same albums,
sectioned by genres,


334
00:19:02,676 --> 00:19:05,979 align:center
but the albums sorted
by their artist's name.


335
00:19:06.013 --> 00:19:07.681 line:-1 align:center
We add a sort filter.


336
00:19:07,714 --> 00:19:11,585 line:-2
By specifying the artistName keyPath
on Albums and saying that we want


337
00:19:11,618 --> 00:19:15,055 line:-2
these to be ascending,
we're sorting the response.


338
00:19:15.088 --> 00:19:18.592 line:-2 align:center
Notice that the method is sortItems
as we are specifying the sorting


339
00:19:18,625 --> 00:19:21,662 line:-2
to be applied to the items
and not the sections.


340
00:19:21,695 --> 00:19:23,564 line:-1
Had we wanted to specify the sections,


341
00:19:23.597 --> 00:19:27.668 line:-2 align:center
a set of filterSections
and sortSection methods are available.


342
00:19:27,701 --> 00:19:29,670 line:-1
Let's take a look at the new response.


343
00:19:32.139 --> 00:19:35.776 line:-2 align:center
We can now see that our albums
are ordered alphabetically by artist name


344
00:19:35,809 --> 00:19:37,811 line:-1
instead of by their titles.


345
00:19:37,845 --> 00:19:42,516 line:-2
Both the library request and library
sectioned request are extremely powerful,


346
00:19:42,549 --> 00:19:45,485 line:-2
but you might also want to complement
your music search UI


347
00:19:45,519 --> 00:19:48,655 line:-2
by adding search results
from the user's library.


348
00:19:48,689 --> 00:19:52,593 line:-2
So we've added a new structured request
which operates almost identically


349
00:19:52,626 --> 00:19:54,962 line:-2
to catalog search,
but instead of loading results


350
00:19:54,995 --> 00:19:59,666 line:-2
from the catalog, it finds
relevant items in the user's library.


351
00:19:59.700 --> 00:20:02.669 line:-2 align:center
Just like its catalog counterpart,
the library search request


352
00:20:02.703 --> 00:20:06.773 line:-2 align:center
only requires a search term
and an array of types.


353
00:20:06,807 --> 00:20:10,244 line:-2
Now that we've seen the different ways
to retrieve items from the user's library,


354
00:20:10,277 --> 00:20:13,814 line:-2
what about loading extended
attributes and relationships?


355
00:20:13,847 --> 00:20:17,784 line:-2
As you may know, the initial release
of MusicKit introduced the with method,


356
00:20:17.818 --> 00:20:22.189 line:-2 align:center
loading these properties from
Apple Music API in a straightforward way.


357
00:20:22.222 --> 00:20:24.658 line:-2 align:center
This year,
we're augmenting the current with method


358
00:20:24.691 --> 00:20:28.195 line:-2 align:center
to also take in
a preferred source parameter.


359
00:20:28.228 --> 00:20:32.299 line:-2 align:center
This preferred source indicates where
to load data from, for extended attributes


360
00:20:32.332 --> 00:20:36.170 line:-2 align:center
and relationships that are available
in both the Apple Music catalog


361
00:20:36,203 --> 00:20:38,438 line:-1
and the user's library.


362
00:20:38,472 --> 00:20:41,942 line:-2
And for the properties that only live
in either the catalog or the library,


363
00:20:41.975 --> 00:20:44.711 line:-2 align:center
they will still fetched
regardless of the preferred source


364
00:20:44,745 --> 00:20:47,581 line:-1
to make sure nothing is ignored.


365
00:20:47.614 --> 00:20:49.950 line:-2 align:center
In addition,
you can use this functionality


366
00:20:49.983 --> 00:20:52.419 line:-2 align:center
no matter where
the initial item came from,


367
00:20:52.452 --> 00:20:56.390 line:-2 align:center
whether it be a catalog request,
a library request, or elsewhere.


368
00:20:56.423 --> 00:20:57.958 line:-1 align:center
It all just works.


369
00:20:58,959 --> 00:21:02,963 line:-2
Here we have the known way of
receiving a relationship of a music item.


370
00:21:02.996 --> 00:21:06.700 line:-2 align:center
We're loading the tracks of an album,
and when we display the output,


371
00:21:06,733 --> 00:21:09,269 line:0
we can see
all of the tracks for that album.


372
00:21:09,303 --> 00:21:13,574 line:0
However, with the new addition
of the preferredSource property,


373
00:21:13,607 --> 00:21:15,242 align:center
we can specify that we would like to fetch


374
00:21:15,275 --> 00:21:17,578 line:0
this relationship from the library.


375
00:21:17,611 --> 00:21:22,349 align:center
Now our output only contains the tracks
of the album found in the library.


376
00:21:22,382 --> 00:21:25,886 line:-2
With the various ways you can
now fetch items from the user's library,


377
00:21:25.919 --> 00:21:28.655 line:-2 align:center
it only makes sense to allow users
to be able to interact


378
00:21:28.689 --> 00:21:31.358 line:-2 align:center
with their library
directly through MusicKit.


379
00:21:31,391 --> 00:21:34,228 line:-2
Let's jump back into my sample app,
Music Marathon,


380
00:21:34,261 --> 00:21:37,164 line:-2
to see some of the capabilities
the library offers.


381
00:21:37,197 --> 00:21:39,333 line:-2
As I'm working out,
I want to browse through some


382
00:21:39.366 --> 00:21:40.834 line:-1 align:center
of my personal recommendations.


383
00:21:43.270 --> 00:21:45.839 line:-2 align:center
As I look through the tracks,
I realize that one of these songs


384
00:21:45.873 --> 00:21:47.975 line:-1 align:center
would be perfect for my workout playlist.


385
00:21:48,008 --> 00:21:51,311 line:-2
If hold down one of these cells,
a contextual menu pops up,


386
00:21:51.345 --> 00:21:53.881 line:-2 align:center
allowing me
to add this song to a playlist.


387
00:21:53.914 --> 00:21:57.851 line:-2 align:center
When we press it, a pop-up
of all of my playlists appear again.


388
00:21:57.885 --> 00:22:01.555 line:-2 align:center
Let's write code to add the selected track
to whichever playlist I pick.


389
00:22:01,588 --> 00:22:05,025 line:-2
I've already piped the selected item
to our AddToPlaylistCell cell,


390
00:22:05,058 --> 00:22:09,229 line:-2
so all we have to do is access the
MusicLibrary through the shared instance.


391
00:22:13.534 --> 00:22:16.703 line:-1 align:center
We'll call the "add" method,


392
00:22:16,737 --> 00:22:18,972 line:-1
specifying our selected track


393
00:22:19.006 --> 00:22:21.275 line:-1 align:center
and which playlist we want to add to.


394
00:22:23.343 --> 00:22:25.812 line:-2 align:center
This method is also
an async throwing function,


395
00:22:25.846 --> 00:22:28.815 line:-2 align:center
so we add once again
the try and await keywords.


396
00:22:31,084 --> 00:22:33,053 line:-1
Lastly, we'll dismiss the picker


397
00:22:33,086 --> 00:22:36,490 line:-2
by setting the isShowingPlaylistPicker
binding variable to false.


398
00:22:38,225 --> 00:22:40,827 line:-1
Now if we re-run


399
00:22:40.861 --> 00:22:44.598 line:-2 align:center
and add a track to a playlist
and select one of our playlists,


400
00:22:44,631 --> 00:22:47,901 line:-1
we should expect to see this item added.


401
00:22:47,935 --> 00:22:50,704 line:-2
Navigating back to the library tab
within the app,


402
00:22:50.737 --> 00:22:53.607 line:-2 align:center
we can see the song is
now added to our workout playlist.


403
00:22:53.640 --> 00:22:56.443 line:-2 align:center
And that's how simple it is
to add an item to a playlist.


404
00:22:56,476 --> 00:22:59,913 line:-2
Let's look at some of the other
functionality the library offers.


405
00:22:59.947 --> 00:23:03.317 line:-2 align:center
The various other ways to interact
with the library are adding content


406
00:23:03.350 --> 00:23:06.420 line:-1 align:center
to the library, creating playlists,


407
00:23:06.453 --> 00:23:10.524 line:-2 align:center
and editing playlists' metadata
and track list.


408
00:23:10.557 --> 00:23:14.728 line:-2 align:center
Adding content to the user's music library
allows people to find specific songs


409
00:23:14,761 --> 00:23:18,532 line:-2
or albums in the library tab
of the Apple Music app,


410
00:23:18.565 --> 00:23:21.134 line:-1 align:center
as well as synchronizes across all devices


411
00:23:21.168 --> 00:23:24.338 line:-2 align:center
when "Sync Library" is turned on
in Settings.


412
00:23:24,371 --> 00:23:27,474 line:-2
Providing this functionality
directly in your app saves people


413
00:23:27.508 --> 00:23:30.878 line:-2 align:center
from context switching between
the Apple Music app and yours,


414
00:23:30,911 --> 00:23:34,515 line:-2
so they can stay engaged
in the content you're providing.


415
00:23:34.548 --> 00:23:36.917 line:-1 align:center
Also, by integrating adding to the library


416
00:23:36,950 --> 00:23:39,586 line:-2
along with the newly introduced
library requests,


417
00:23:39,620 --> 00:23:42,322 line:-2
your app can immediately benefit
from these results,


418
00:23:42.356 --> 00:23:46.026 line:-2 align:center
giving users easy access
to content they love.


419
00:23:46,059 --> 00:23:47,928 line:-1
Even with this powerful service,


420
00:23:47,961 --> 00:23:51,331 line:-2
you may still want to craft
specific musical experiences.


421
00:23:51,365 --> 00:23:56,236 line:-2
So this year, we're bringing
playlist creation and editing to MusicKit.


422
00:23:56,270 --> 00:23:59,806 line:-2
You can now create playlists
on behalf of your users.


423
00:23:59.840 --> 00:24:03.277 line:-2 align:center
We're also allowing items,
such as songs or even whole albums,


424
00:24:03.310 --> 00:24:07.447 line:-2 align:center
to be added to any eligible playlist
in the user's library.


425
00:24:07,481 --> 00:24:11,151 line:-2
Creating playlists are fantastic
for grouping content that people love


426
00:24:11,185 --> 00:24:14,188 line:-1
or fitting any mood your app wants to set.


427
00:24:14.221 --> 00:24:16.557 line:-2 align:center
And by adding content
to existing playlists,


428
00:24:16,590 --> 00:24:19,860 line:-2
you allow for the various
music discovery tools MusicKit offers


429
00:24:19,893 --> 00:24:22,629 line:-1
to directly affect people.


430
00:24:22,663 --> 00:24:24,898 line:-2
You can now also edit playlists
that you've created,


431
00:24:24,932 --> 00:24:28,402 line:-2
being able to edit the track list
and metadata to make sure


432
00:24:28.435 --> 00:24:30.504 line:-1 align:center
everything is just as you want it.


433
00:24:30,537 --> 00:24:33,507 line:-2
And those are the ways you can
interact with users' libraries


434
00:24:33.540 --> 00:24:35.776 line:-1 align:center
from within your app.


435
00:24:35,809 --> 00:24:39,713 line:-2
To wrap up, MusicKit received
some major upgrades this year.


436
00:24:39.746 --> 00:24:43.750 line:-2 align:center
Easily incorporate our catalog
enhancements for new types, properties,


437
00:24:43,784 --> 00:24:47,988 line:-2
and search augmentations to your existing
apps for an even better experience.


438
00:24:49.256 --> 00:24:51.458 line:-2 align:center
Integrate library content
and functionality


439
00:24:51,491 --> 00:24:53,260 line:-1
to unlock brand-new capabilities


440
00:24:53,293 --> 00:24:55,596 line:-2
and let users be in control
of their experience.


441
00:24:57,130 --> 00:25:00,367 line:-2
And using MusicKit can enhance
multiple different types of apps.


442
00:25:00.400 --> 00:25:03.637 line:-2 align:center
Fitness apps, games,
social media apps, mapping apps,


443
00:25:03.670 --> 00:25:07.975 line:-2 align:center
and more can all benefit
from playing or sharing music.


444
00:25:08.008 --> 00:25:12.012 line:-2 align:center
To go even further, make sure
to check out some related sessions.


445
00:25:12,045 --> 00:25:14,681 line:0
Dive deeper into Swift
and learn about the new additions


446
00:25:14,715 --> 00:25:19,620 line:0
to the language to get the most out of
MusicKit and other Apple Frameworks.


447
00:25:19,653 --> 00:25:23,257 align:center
Check out the MusicKit session from 2021
to learn how to set up your app


448
00:25:23,290 --> 00:25:28,662 line:0
to use the framework, initiate playback,
and present subscription offers.


449
00:25:28,695 --> 00:25:32,432 align:center
And if you're interested in integrating
with Apple Music on Android or the web,


450
00:25:32,466 --> 00:25:36,370 line:0
we have another session that goes over
how to use Apple Music API directly.


451
00:25:37,538 --> 00:25:40,207 align:center
I hope you enjoyed our session,
and make sure to stay updated


452
00:25:40,240 --> 00:25:42,442 line:0
and engaged through our developer forums.


453
00:25:42.476 --> 00:25:46.847 line:-2 align:center
Thank you for watching,
and enjoy WWDC 2022.

