1
00:00:03,770 --> 00:00:06,373 line:-1
Hello and welcome to WWDC.


2
00:00:09,142 --> 00:00:10,811 line:0
I'm Gokhan Avkarogullari,


3
00:00:10,878 --> 00:00:14,615 line:0
and I lead the graphics acceleration
driver teams for Apple Silicon.


4
00:00:15,716 --> 00:00:18,151 line:-2
Today,
my colleague Sam and I will tell you


5
00:00:18,218 --> 00:00:21,655 line:-2
how to bring your Metal-based apps
to Apple Silicon Macs,


6
00:00:21,722 --> 00:00:26,293 line:-2
and then how to make them faster,
more robust and ready for the future.


7
00:00:26,960 --> 00:00:30,397 line:-2
For many years,
Apple has designed the graphics processors


8
00:00:30,464 --> 00:00:35,903 line:-2
found in the amazing A series chips
used in iPhone, iPad and Apple TV.


9
00:00:35,969 --> 00:00:41,008 line:-2
For the first time, we're bringing our
deep expertise in GPU design to the Mac.


10
00:00:42,009 --> 00:00:43,477 line:-1
So, let's get started.


11
00:00:44,678 --> 00:00:47,748 line:-2
The Apple Silicon Mac
contains an Apple-designed GPU


12
00:00:47,814 --> 00:00:52,386 line:-2
that is designed to handle the workloads
found in desktop games and Pro Apps,


13
00:00:52,719 --> 00:00:56,790 line:-2
all while delivering new levels of speed
and power efficiency.


14
00:00:58,158 --> 00:01:00,894 line:-1
This is DiRT Rally from Feral Games.


15
00:01:01,795 --> 00:01:05,399 line:-2
This was recorded directly
from an Apple Silicon Mac


16
00:01:05,465 --> 00:01:09,436 line:-2
running the unmodified
x86-compiled binary,


17
00:01:09,503 --> 00:01:11,238 line:-1
translated using Rosetta.


18
00:01:12,072 --> 00:01:14,608 line:-2
You can see
all the modern rendering techniques


19
00:01:14,675 --> 00:01:17,711 line:-1
applied to high-quality game assets.


20
00:01:17,778 --> 00:01:22,749 line:-2
Complex shading, reflections,
particle effects, motion blur


21
00:01:22,816 --> 00:01:25,752 line:-2
and lush vegetation
make the game look great.


22
00:01:26,286 --> 00:01:30,390 line:-2
And, of course, the Apple-designed GPU
makes it run smoothly.


23
00:01:30,757 --> 00:01:33,026 line:-2
How do we deliver
this level of performance?


24
00:01:34,528 --> 00:01:39,299 line:-2
We do it using the same powerful
Tile Based Deferred Rendering architecture


25
00:01:39,366 --> 00:01:42,236 line:-1
used on iPhone, iPad and Apple TV.


26
00:01:44,204 --> 00:01:46,640 line:-1
If you are familiar with these devices,


27
00:01:46,707 --> 00:01:50,911 line:-2
then you know that there are several
important advantages to this architecture


28
00:01:50,978 --> 00:01:54,781 line:-2
that are exposed via the Metal graphics
and compute API.


29
00:01:55,315 --> 00:01:57,951 line:-2
Capabilities
such as Programmable Blending,


30
00:01:58,018 --> 00:02:00,387 line:-1
Tile Shaders and Local Image Blocks


31
00:02:00,454 --> 00:02:04,024 line:-2
are now available
to take your Mac app or game


32
00:02:04,091 --> 00:02:06,326 line:-1
to a whole new level of performance.


33
00:02:08,495 --> 00:02:11,832 line:-1
In fact, the GPU in the Apple Silicon Mac


34
00:02:11,899 --> 00:02:14,168 line:-1
supports a unified Metal feature set


35
00:02:14,234 --> 00:02:18,939 line:-2
that combines what was previously
available on both macOS and iOS.


36
00:02:20,908 --> 00:02:24,945 line:-2
And we've done our homework
to make this move as easy as possible.


37
00:02:25,412 --> 00:02:28,415 line:-2
This enables you to get the benefits
of the faster,


38
00:02:28,482 --> 00:02:32,286 line:-2
more power-efficient GPU
with more features


39
00:02:32,352 --> 00:02:35,155 line:-1
without having to retool your app or game.


40
00:02:36,623 --> 00:02:41,195 line:-2
However, it's really important for you
to follow the guidance in today's talk


41
00:02:41,261 --> 00:02:44,131 line:-2
to account for certain
behavioral differences


42
00:02:44,198 --> 00:02:47,267 line:-2
and really unlock
the full potential of the platform.


43
00:02:47,334 --> 00:02:49,269 line:-1
Before we get into the specifics,


44
00:02:49,336 --> 00:02:51,438 line:-2
let's take a look
at the path you will take.


45
00:02:52,940 --> 00:02:56,610 line:-2
On Intel-based Macs,
your app runs natively.


46
00:02:57,778 --> 00:03:02,115 line:-2
On Apple Silicon Macs,
your app will run out of the box


47
00:03:02,182 --> 00:03:06,019 line:-2
under Rosetta's
highly optimized translation layer.


48
00:03:06,653 --> 00:03:08,155 line:-1
Under translation,


49
00:03:08,222 --> 00:03:12,993 line:-2
your app will be automatically opted
into several Metal consistency features


50
00:03:13,060 --> 00:03:15,929 line:-1
that ensure your apps look great too.


51
00:03:16,964 --> 00:03:21,802 line:-2
Translation and consistency features
do have some performance costs,


52
00:03:21,869 --> 00:03:24,938 line:-2
so your next step will be
to recompile your app


53
00:03:25,005 --> 00:03:27,307 line:-1
for Apple Silicon's native architecture.


54
00:03:27,875 --> 00:03:31,912 line:-2
You will then find and fix
any Metal consistency issues.


55
00:03:33,247 --> 00:03:36,650 line:0
And if you want optimal performance
on Apple GPUs,


56
00:03:36,717 --> 00:03:40,654 line:0
check out the session
by my colleagues Michael and Dom,


57
00:03:40,721 --> 00:03:43,724 line:0
"Optimize Metal Performance
for Apple Silicon Macs."


58
00:03:45,192 --> 00:03:47,060 line:-1
Let's look at today's agenda.


59
00:03:48,061 --> 00:03:51,932 line:-2
The first section is about adapting
your app for the Apple GPU.


60
00:03:52,566 --> 00:03:56,570 line:-2
I will start by reviewing
the GPU architecture of Intel-based Macs


61
00:03:56,637 --> 00:03:59,206 line:-1
and the differences with the Apple GPUs,


62
00:03:59,840 --> 00:04:03,343 line:-2
and I'll discuss the APIs
supported on the Apple Silicon Mac


63
00:04:03,410 --> 00:04:06,180 line:-2
and Metal features
you can use in your apps.


64
00:04:07,981 --> 00:04:10,651 line:-2
Different GPU families
will behave differently


65
00:04:10,717 --> 00:04:13,854 line:-2
when it comes to undefined behaviors,
programming errors


66
00:04:13,921 --> 00:04:16,089 line:-1
and performance characteristics.


67
00:04:16,156 --> 00:04:19,826 line:-2
So in the second section,
we will talk about a few common issues


68
00:04:19,892 --> 00:04:23,330 line:-2
we observed on some apps
coming form Intel-based Macs.


69
00:04:24,498 --> 00:04:28,268 line:-2
And finally, Sam will talk
about what we recommend you do


70
00:04:28,335 --> 00:04:31,438 line:-2
for consistent rendering
using Metal on the Mac.


71
00:04:32,906 --> 00:04:36,476 line:-2
So let's start with adapting your app
for the Apple GPU.


72
00:04:38,045 --> 00:04:40,814 line:-1
Let me highlight some of the major changes


73
00:04:40,881 --> 00:04:43,917 line:-2
from the Intel-based Mac
to Apple Silicon Mac


74
00:04:43,984 --> 00:04:46,086 line:-1
when it comes to the GPU.


75
00:04:46,153 --> 00:04:49,523 line:-2
Apple Silicon Mac
contains an Apple-designed GPU,


76
00:04:49,590 --> 00:04:55,128 line:-2
whereas Intel-based Macs contain GPUs
from Intel, AMD and Nvidia.


77
00:04:55,829 --> 00:05:00,267 line:-2
Apple GPU is built on the Tile Based
Deferred Renderer architecture,


78
00:05:00,334 --> 00:05:05,739 line:-2
whereas Intel, AMD and Nvidia GPUs
are known as immediate mode renderers.


79
00:05:06,273 --> 00:05:08,642 line:-1
I will cover the differences in a minute.


80
00:05:09,710 --> 00:05:14,114 line:-2
Apple-designed GPU combine
the feature set of iOS and macOS.


81
00:05:14,181 --> 00:05:18,085 line:-2
Both Mac 2 and Apple GPU family
feature set are supported.


82
00:05:18,585 --> 00:05:21,722 line:-2
Intel-based Macs
support only Mac 2 family.


83
00:05:22,756 --> 00:05:24,424 line:-1
Now, let me describe to you


84
00:05:24,491 --> 00:05:28,762 line:-2
how Tile Based Deferred Renderer
differs from immediate mode renderers.


85
00:05:30,264 --> 00:05:32,766 line:-2
Let us start
with an immediate mode renderer,


86
00:05:32,833 --> 00:05:34,668 line:-1
abbreviated here as IMR.


87
00:05:36,637 --> 00:05:39,139 line:-2
This is a logical view
of the architecture.


88
00:05:40,274 --> 00:05:41,909 line:-1
From left to right,


89
00:05:41,975 --> 00:05:46,980 line:-2
the hardware fetches vertex attributes,
executes the vertex shaders


90
00:05:47,047 --> 00:05:50,083 line:-1
and transforms geometry into screen space


91
00:05:50,150 --> 00:05:52,452 line:-1
with the help of fixed-function hardware.


92
00:05:53,053 --> 00:05:56,056 line:-2
Then, the fragment stage
rasterizes the triangles


93
00:05:56,123 --> 00:05:59,226 line:-2
and performs some early
depth testing for efficiency.


94
00:06:00,160 --> 00:06:04,965 line:-2
An important note here is that
triangles can span the entire screen,


95
00:06:05,032 --> 00:06:07,334 line:-1
or two triangles from the same draw call


96
00:06:07,401 --> 00:06:09,870 line:-2
might end up in widely different places
on the screen,


97
00:06:10,504 --> 00:06:13,440 line:-2
meaning that the hardware
needs the entire depth buffer


98
00:06:13,507 --> 00:06:16,043 line:-1
and only can cache a small subset of it.


99
00:06:16,977 --> 00:06:19,680 line:-1
Early depth test is followed by shading.


100
00:06:19,746 --> 00:06:22,149 line:-1
When early depth test cannot be done,


101
00:06:22,216 --> 00:06:25,219 line:-2
the depth testing is done
post-fragment shading.


102
00:06:26,420 --> 00:06:28,622 line:-1
There's also alpha test and blending,


103
00:06:28,689 --> 00:06:31,592 line:-2
where access to color buffers
are required.


104
00:06:31,658 --> 00:06:34,361 line:-1
Just like as it is for the depth buffer,


105
00:06:34,428 --> 00:06:37,197 line:-2
the color buffer is needed
in its entirety,


106
00:06:37,264 --> 00:06:40,133 line:-1
and only a small part of it can be cached.


107
00:06:41,134 --> 00:06:43,570 line:-1
Now that we reviewed IMR architecture,


108
00:06:43,637 --> 00:06:46,473 line:-2
I will move on
to the Tile Based Deferred Renderer


109
00:06:46,540 --> 00:06:49,343 line:-2
and highlight the differences
step by step.


110
00:06:49,910 --> 00:06:53,514 line:-2
The first change is tiling the geometry
in screen space


111
00:06:53,580 --> 00:06:57,050 line:-2
and creating a database
for all geometry in memory


112
00:06:57,584 --> 00:07:00,320 line:-2
that I'm going to refer to
as Tiled Vertex Buffer.


113
00:07:01,255 --> 00:07:04,958 line:-2
Since we have all the geometry information
for an entire tile,


114
00:07:05,025 --> 00:07:07,027 line:-1
we can rasterize it up front.


115
00:07:07,094 --> 00:07:10,297 line:-1
As a result, for each pixel in the tile,


116
00:07:10,364 --> 00:07:13,734 line:-2
we know for which opaque fragment
the shading will have to happen.


117
00:07:14,401 --> 00:07:18,238 line:-2
We also know which opaque fragments
will fail the depth test.


118
00:07:18,739 --> 00:07:22,476 line:-2
As a result,
the hidden surfaces are entirely removed.


119
00:07:22,543 --> 00:07:26,313 line:-2
We don't shade any fragment that
will later be occluded by another one.


120
00:07:26,813 --> 00:07:30,117 line:-2
We can do this with just
tile size depth buffer on the chip


121
00:07:30,184 --> 00:07:32,352 line:-1
rather than the entire depth buffer.


122
00:07:33,420 --> 00:07:36,356 line:-2
It does not matter
if a triangle is full-screen


123
00:07:36,423 --> 00:07:40,093 line:-2
or in the same draw call triangles
are widely distributed on the screen.


124
00:07:40,494 --> 00:07:45,199 line:-2
We get perfect testing
with just a tile size on-chip depth buffer


125
00:07:45,265 --> 00:07:47,334 line:-1
thanks to the Tiled Vertex Buffer.


126
00:07:48,035 --> 00:07:51,772 line:-2
Additionally, if we are not going to use
that depth buffer later,


127
00:07:51,839 --> 00:07:54,608 line:-2
we can use memoryless
render target feature


128
00:07:54,675 --> 00:07:59,079 line:-2
and not store the depth data
and not use memory for the depth buffer.


129
00:07:59,146 --> 00:08:00,781 line:-1
It's a win-win situation.


130
00:08:01,448 --> 00:08:05,686 line:-2
Not only that,
we also can do blending and alpha testing


131
00:08:05,752 --> 00:08:09,323 line:-2
without ever having to load
from the full color buffer in memory.


132
00:08:09,923 --> 00:08:12,793 line:-1
Because we process an entire tile at once,


133
00:08:12,860 --> 00:08:15,929 line:-2
we only need a tile's worth
of color buffer on the chip.


134
00:08:16,563 --> 00:08:20,334 line:-2
Please note that the arrow
for color buffer in memory is one-way.


135
00:08:20,667 --> 00:08:23,470 line:-2
We never need to access it
for alpha testing,


136
00:08:23,537 --> 00:08:27,307 line:-2
write mask or blending
or for anything else.


137
00:08:29,276 --> 00:08:32,813 line:-2
This architecture allows
for alpha test and blending operation


138
00:08:32,880 --> 00:08:36,783 line:-2
to be performed by the shader core
instead of fixed-function hardware.


139
00:08:37,384 --> 00:08:41,855 line:-2
It also allows you access to the contents
of the color buffer in your shader,


140
00:08:41,922 --> 00:08:44,224 line:-2
which you can use
for programmable blending,


141
00:08:44,291 --> 00:08:46,593 line:-1
custom MSAA resolve, and so on.


142
00:08:47,761 --> 00:08:52,733 line:-2
Obviously, feedback such as depth writes
between the depth buffer and shading


143
00:08:52,799 --> 00:08:54,835 line:-1
is covered by this architecture.


144
00:08:55,836 --> 00:08:56,837 line:-1
To recap,


145
00:08:57,371 --> 00:09:00,374 line:-2
Tile Based Deferred Renderers
have two main phases:


146
00:09:01,074 --> 00:09:04,278 line:-2
tiling, where all of the geometry
will be processed,


147
00:09:04,344 --> 00:09:07,314 line:-2
rendering,
where all the pixels will be processed.


148
00:09:07,681 --> 00:09:08,982 line:-1
Let us summarize.


149
00:09:09,449 --> 00:09:12,352 line:-1
On a TBDR GPU, a well-written app


150
00:09:12,419 --> 00:09:16,490 line:-2
uses a lot less memory bandwidth
than an IMR GPU.


151
00:09:17,357 --> 00:09:22,262 line:-2
Since processing is done for a full tile,
all blending happens in registers,


152
00:09:22,329 --> 00:09:25,132 line:-1
so it's really fast and power-efficient.


153
00:09:25,199 --> 00:09:29,436 line:-2
This is great for games,
Pro Apps and UI performance as well.


154
00:09:30,404 --> 00:09:35,976 line:-2
No reason to re-fetch color, depth
or stencil buffers over and over again.


155
00:09:36,043 --> 00:09:38,612 line:-1
As a result, memory bandwidth is saved,


156
00:09:38,679 --> 00:09:42,182 line:-2
performance increases,
power consumption goes down.


157
00:09:42,983 --> 00:09:47,554 line:-2
Now that we reviewed the architecture,
we can move on to app's view of the GPU.


158
00:09:48,021 --> 00:09:52,092 line:-2
With Apple Silicon Mac,
you get what you had before and more.


159
00:09:52,693 --> 00:09:56,129 line:-2
This new Mac supports everything
the Intel-based Macs support.


160
00:09:56,864 --> 00:09:59,900 line:-2
All the APIs we and you love,
such as Metal,


161
00:09:59,967 --> 00:10:03,570 line:-2
MPS, Core Animation, and so on,
are available.


162
00:10:04,371 --> 00:10:08,509 line:-2
All the other APIs that are also used,
such as OpenGL and OpenCL,


163
00:10:08,575 --> 00:10:11,545 line:-1
are also available on Apple Silicon Mac.


164
00:10:11,912 --> 00:10:16,517 line:-2
I will briefly talk about GL and CL first
and then move on to Metal.


165
00:10:18,519 --> 00:10:23,323 line:-2
OpenGL and OpenCL are still deprecated,
but they are not yet removed.


166
00:10:23,891 --> 00:10:27,027 line:-2
They are present
for backwards-compatibility purposes


167
00:10:27,094 --> 00:10:31,431 line:-2
with the library of existing Mac apps
that use these legacy technologies.


168
00:10:32,399 --> 00:10:35,802 line:-1
OpenGL is supported up to version 4.1


169
00:10:35,869 --> 00:10:38,338 line:-1
and OpenCL to version 1.1.


170
00:10:38,906 --> 00:10:40,807 line:-1
For features not in the core,


171
00:10:40,874 --> 00:10:44,745 line:-2
you should always use extension
or query checks before using them.


172
00:10:46,213 --> 00:10:49,683 line:-2
Note that Apple-designed GPUs
are engineered for Metal.


173
00:10:50,184 --> 00:10:54,488 line:-2
If you are still using OpenGL and OpenCL
in your app or game,


174
00:10:54,555 --> 00:10:57,724 line:-2
you should prioritize moving to Metal
as soon as possible.


175
00:10:58,392 --> 00:11:02,696 line:-2
Otherwise, you will continue to leave
performance and capability on the table.


176
00:11:04,464 --> 00:11:06,633 line:-1
Now, on to more exciting things.


177
00:11:07,301 --> 00:11:11,672 line:-2
Let's talk about those new features
that Apple-designed GPUs bring to the Mac.


178
00:11:12,639 --> 00:11:16,777 line:-2
Apple Silicon Macs have the feature set
defined by the Metal GPU Family Mac 2.


179
00:11:17,277 --> 00:11:19,613 line:-1
Additionally, for the first time ever,


180
00:11:19,680 --> 00:11:23,717 line:-2
the features that are specific
to Apple GPUs are coming to the Mac.


181
00:11:23,784 --> 00:11:26,753 line:-2
These features provide
tremendous upside for your apps


182
00:11:26,820 --> 00:11:28,655 line:-1
in terms of better performance,


183
00:11:28,722 --> 00:11:31,325 line:-2
lower poser consumption
and lower memory usage.


184
00:11:32,593 --> 00:11:34,127 line:-1
Through the use of the features,


185
00:11:34,194 --> 00:11:38,398 line:0
such as Programmable Blending,
Tile Shaders and Local Image Blocks,


186
00:11:38,465 --> 00:11:42,936 line:0
you can accelerate deferred, forward,
and all types of tiled rendering.


187
00:11:44,404 --> 00:11:48,475 line:-2
With memoryless render targets
and on-chip MSAA resolve,


188
00:11:48,542 --> 00:11:51,178 line:-1
MSAA feature shines on this system.


189
00:11:51,245 --> 00:11:54,615 line:-2
You can even use MSAA
with deferred rendering


190
00:11:54,681 --> 00:11:58,218 line:-2
because all the processing is done
on the chip in this architecture


191
00:11:58,285 --> 00:12:01,822 line:-2
without the cost of additional
memory bandwidth and storage.


192
00:12:02,823 --> 00:12:06,159 line:-2
There are many other features,
such as ASTC textures,


193
00:12:06,226 --> 00:12:09,530 line:-2
image block sample coverage control,
and so on


194
00:12:09,596 --> 00:12:13,934 line:-2
that open up opportunities
for new techniques and optimizations.


195
00:12:14,368 --> 00:12:15,369 line:-1
Let's recap.


196
00:12:15,869 --> 00:12:19,907 line:-2
Your app should work fine,
as all APIs are already supported.


197
00:12:21,108 --> 00:12:24,778 line:-2
Be aware of the underlying
Tile Based Deferred Renderer architecture


198
00:12:24,845 --> 00:12:26,980 line:-1
and use its best practices.


199
00:12:27,481 --> 00:12:28,682 line:-1
And don't stop there.


200
00:12:29,116 --> 00:12:32,419 line:-2
Take advantage of the new features
and the new architecture.


201
00:12:32,886 --> 00:12:35,689 line:-2
They will improve
your app's performance even more.


202
00:12:36,924 --> 00:12:39,026 line:-1
Now we are going to look into some issues


203
00:12:39,092 --> 00:12:44,097 line:-2
that we observed on Metal API misuse
on the Mac on some apps.


204
00:12:44,164 --> 00:12:46,500 line:-1
We will review what the right usage is.


205
00:12:47,801 --> 00:12:50,270 line:-1
I will start with Metal feature detection.


206
00:12:51,038 --> 00:12:53,240 line:-1
After that, Sam will take over


207
00:12:53,307 --> 00:12:57,344 line:-2
and will talk about a few
app-correctness issues that we observed


208
00:12:57,411 --> 00:12:58,946 line:-1
and how we can fix those,


209
00:12:59,012 --> 00:13:02,249 line:-2
such as load and store actions,
position invariance


210
00:13:02,316 --> 00:13:04,585 line:-1
and Threadgroup Memory synchronization


211
00:13:04,651 --> 00:13:08,555 line:-2
and sampling previous depth
while forming up new depth values.


212
00:13:10,190 --> 00:13:12,492 line:-1
Let us start with Metal feature detection.


213
00:13:12,960 --> 00:13:16,296 line:-2
Previously, we talked about
the unified feature set support.


214
00:13:16,897 --> 00:13:20,334 line:-2
So how do you go about finding
the availability of these features?


215
00:13:21,235 --> 00:13:24,738 line:-2
Applications should query
Metal GPU features directly.


216
00:13:25,272 --> 00:13:28,609 line:-2
Metal organizes features
into different GPU families


217
00:13:28,675 --> 00:13:31,078 line:-1
that can be queried for a given device.


218
00:13:31,945 --> 00:13:34,615 line:-2
Some individual feature queries
are also available.


219
00:13:35,182 --> 00:13:39,119 line:-2
Make use of those for features
that vary within the same GPU family.


220
00:13:40,053 --> 00:13:41,188 line:-1
One important note.


221
00:13:41,688 --> 00:13:45,526 line:-2
Querying the GPU name to know
if a particular feature is supported


222
00:13:45,592 --> 00:13:47,561 line:-1
is not the best practice.


223
00:13:47,628 --> 00:13:49,796 line:-1
The code is not future-proof.


224
00:13:49,863 --> 00:13:51,031 line:-1
Let's see an example.


225
00:13:52,232 --> 00:13:55,669 line:-2
Here is some code
basing feature usage on the OS,


226
00:13:55,736 --> 00:13:59,139 line:-2
differentiating between
macOS and iOS platforms.


227
00:14:01,074 --> 00:14:04,978 line:-2
Then, it uses the GPU name
to decide some other information,


228
00:14:05,045 --> 00:14:09,383 line:-2
such as SIMD group size
and if the device is marked as low-power.


229
00:14:09,449 --> 00:14:12,519 line:-2
And finally,
it assumes that Apple GPU features


230
00:14:12,586 --> 00:14:14,488 line:-1
are not available on macOS.


231
00:14:15,422 --> 00:14:18,025 line:-2
This is not true anymore
with Apple Silicon Mac.


232
00:14:18,692 --> 00:14:22,996 line:-2
Instead, applications should gather
this information using the Metal API.


233
00:14:23,797 --> 00:14:26,633 line:-1
The supportsFamily API can be used to know


234
00:14:26,700 --> 00:14:28,769 line:-1
if Apple GPU features are supported.


235
00:14:29,169 --> 00:14:31,071 line:-1
The SIMD group size can be found


236
00:14:31,138 --> 00:14:35,542 line:-2
using the method threadExecutionWidth
on a compute pipeline object.


237
00:14:37,077 --> 00:14:41,582 line:-2
And to know if a GPU needs to be treated
as integrated or discrete,


238
00:14:41,648 --> 00:14:43,951 line:-1
use the isLowPower API.


239
00:14:45,018 --> 00:14:49,356 line:-2
Note that for Apple GPUs,
isLowPower returns "false,"


240
00:14:49,423 --> 00:14:52,226 line:-2
which means
that you should treat these GPUs


241
00:14:52,292 --> 00:14:54,494 line:-1
in a similar way as discrete GPUs.


242
00:14:54,561 --> 00:14:58,232 line:-2
This is because the performance
characteristics of Apple GPUs


243
00:14:58,298 --> 00:15:01,935 line:-2
are in line with discrete ones,
not the integrated ones.


244
00:15:02,936 --> 00:15:04,838 line:-1
Despite the property name, though,


245
00:15:04,905 --> 00:15:08,475 line:-2
Apple GPUs are also way,
way more power-efficient


246
00:15:08,542 --> 00:15:11,278 line:-1
than both integrated and discrete GPUs.


247
00:15:11,979 --> 00:15:14,515 line:-2
Now that we reviewed
Metal feature detection,


248
00:15:14,581 --> 00:15:18,585 line:-2
it's time to review how to correctly use
load and store actions.


249
00:15:19,319 --> 00:15:21,855 line:-1
Sam will tell you all about it and more.


250
00:15:21,922 --> 00:15:22,990 line:-1
Sam?


251
00:15:23,657 --> 00:15:24,791 line:-1
Thanks, Gokhan.


252
00:15:25,259 --> 00:15:29,730 line:-2
Let's now talk about a common issue
related to Metal load and store actions.


253
00:15:31,365 --> 00:15:32,866 line:-1
First, a quick recap.


254
00:15:33,700 --> 00:15:37,871 line:-2
Load and store actions control the action
performed on an attachment,


255
00:15:37,938 --> 00:15:42,843 line:-2
either color, depth or stencil,
at the start and end of a render pass.


256
00:15:43,877 --> 00:15:48,749 line:-2
On Apple GPUs, they directly control
the state of the on-chip tile memory.


257
00:15:48,815 --> 00:15:51,618 line:-2
This memory is initialized
based on load actions


258
00:15:52,119 --> 00:15:54,454 line:-1
and flushed based on store actions.


259
00:15:55,088 --> 00:15:57,791 line:-2
An incorrect usage can cause
performance issues


260
00:15:58,392 --> 00:16:02,095 line:-2
if attachments are unnecessarily
loaded or stored.


261
00:16:03,263 --> 00:16:04,698 line:-1
Please refer to the video


262
00:16:04,765 --> 00:16:07,768 line:-2
"Optimize Metal Performance
for Apple Silicon Macs"


263
00:16:08,302 --> 00:16:10,871 line:-2
to know how to best use
load and store actions.


264
00:16:11,872 --> 00:16:15,242 line:-2
But in this section,
let's focus on correctness issues.


265
00:16:16,143 --> 00:16:19,713 line:-2
Here is an example showing
some incorrect usage on the left.


266
00:16:21,048 --> 00:16:23,851 line:-2
We had rendered the skybox
in an earlier pass,


267
00:16:23,917 --> 00:16:26,587 line:-1
and then drew the scene in the final pass.


268
00:16:27,421 --> 00:16:31,225 line:-2
However, we used a DontCare
load action for the final pass,


269
00:16:31,291 --> 00:16:34,094 line:-2
causing the skybox to not be uploaded
to tile memory,


270
00:16:34,828 --> 00:16:36,697 line:-1
generating graphics artifacts.


271
00:16:38,031 --> 00:16:41,235 line:-2
Setting the load action to Load
avoids this issue.


272
00:16:43,203 --> 00:16:46,406 line:-2
Let's take a look at a diagram
to understand what is happening.


273
00:16:47,774 --> 00:16:51,378 line:-2
We first start with a previously rendered
texture in system memory.


274
00:16:52,346 --> 00:16:54,648 line:-1
And if a DontCare load action is chosen,


275
00:16:54,715 --> 00:16:59,520 line:-2
Apple GPUs will not upload the textures
from system memory to tile memory,


276
00:17:00,020 --> 00:17:02,055 line:-1
leaving it uninitialized.


277
00:17:02,122 --> 00:17:05,858 line:-2
The scene will then be drawn
on top of this uninitialized data,


278
00:17:05,925 --> 00:17:09,029 line:-2
and if the drawing does not cover
the full frame buffer,


279
00:17:09,096 --> 00:17:13,099 line:-2
uninitialized data will remain,
creating correctness issues.


280
00:17:13,165 --> 00:17:18,372 line:-2
However, if loadAction load is chosen,
the tile memory is correctly initialized.


281
00:17:18,872 --> 00:17:23,310 line:-2
In this case, the scene is rendered
on top of the previous content.


282
00:17:23,844 --> 00:17:25,579 line:-1
Let's now look at store actions.


283
00:17:26,946 --> 00:17:29,149 line:-1
If a DontCare store action is chosen,


284
00:17:29,216 --> 00:17:33,086 line:-2
the tile memory
is not being flushed to system memory,


285
00:17:33,153 --> 00:17:35,155 line:-1
leaving it potentially uninitialized.


286
00:17:35,956 --> 00:17:37,791 line:-1
This is not the desired behavior


287
00:17:37,858 --> 00:17:41,461 line:-2
if this texture is consumed
by a later render pass.


288
00:17:43,096 --> 00:17:46,466 line:-2
However,
if a storeAction store is being used,


289
00:17:46,533 --> 00:17:50,270 line:-2
the rendering done in tile memory
is populated to system memory.


290
00:17:51,338 --> 00:17:55,108 line:-2
Let's summarize how to correctly use
load and store actions.


291
00:17:55,943 --> 00:17:58,745 line:-1
For load actions, make sure to only load


292
00:17:58,812 --> 00:18:01,215 line:-2
if the previous content
needs to be preserved.


293
00:18:02,082 --> 00:18:05,652 line:-2
This is the case when a draw
does not cover the full frame buffer


294
00:18:05,719 --> 00:18:09,223 line:-2
and accumulation is needed
on top of the previous rendering.


295
00:18:11,024 --> 00:18:14,361 line:-2
If you don't need accumulation,
do not use a loadAction load,


296
00:18:14,428 --> 00:18:15,963 line:-1
as it costs performance.


297
00:18:17,231 --> 00:18:19,199 line:-1
Similarly, choose to store


298
00:18:19,266 --> 00:18:22,569 line:-2
only if the content
will be consumed in the later pass.


299
00:18:23,270 --> 00:18:27,541 line:-2
Otherwise, make sure to not store
to avoid extra memory traffic.


300
00:18:29,643 --> 00:18:33,580 line:-2
Let's carry on with an issue
related to position invariance.


301
00:18:34,548 --> 00:18:37,751 line:-2
The results
of the same vertex position calculation


302
00:18:37,818 --> 00:18:41,188 line:-2
across different vertex shaders
can be slightly different.


303
00:18:42,589 --> 00:18:44,725 line:-1
This is because, by default,


304
00:18:44,791 --> 00:18:48,262 line:-2
the Apple GPU compiler
highly optimizes vertex shaders.


305
00:18:48,962 --> 00:18:53,667 line:-2
As a consequence, different optimizations
between vertex shaders


306
00:18:53,734 --> 00:18:56,170 line:-1
might lead to position value differences.


307
00:18:57,237 --> 00:19:01,208 line:-2
If an application relies on
position invariance without enabling it,


308
00:19:01,808 --> 00:19:04,011 line:-1
correctness issues might be observed.


309
00:19:05,445 --> 00:19:09,383 line:-2
So, in Metal, position invariance
is not guaranteed by default.


310
00:19:09,449 --> 00:19:11,585 line:-1
It has to be explicitly enabled.


311
00:19:12,519 --> 00:19:14,922 line:-2
This is exactly what is happening
in this image.


312
00:19:15,556 --> 00:19:18,258 line:-1
Due to position invariance being disabled,


313
00:19:18,325 --> 00:19:21,228 line:-2
position outputs are slightly different
between two passes,


314
00:19:21,795 --> 00:19:24,164 line:-1
causing many pixels to be discarded.


315
00:19:25,732 --> 00:19:29,336 line:-2
Here is the same image with
position invariance correctly enabled.


316
00:19:31,905 --> 00:19:33,974 line:-2
Let's illustrate this issue
with a diagram.


317
00:19:34,775 --> 00:19:37,845 line:-2
Let's assume that the first pass
of a multipass algorithm


318
00:19:37,911 --> 00:19:39,746 line:-1
has rendered some geometry


319
00:19:39,813 --> 00:19:43,483 line:-2
and stored the depth texture
in system memory for later usage.


320
00:19:44,384 --> 00:19:47,754 line:-2
Then comes Pass2
that loads this depth texture.


321
00:19:47,821 --> 00:19:50,924 line:-2
Also note that the tile memory
that is holding color values


322
00:19:50,991 --> 00:19:53,360 line:-2
is cleared at the beginning
of the render pass.


323
00:19:53,427 --> 00:19:56,830 line:-2
Pass2 then starts rendering
the same geometry as Pass1,


324
00:19:56,897 --> 00:20:00,501 line:-2
but this time
with the depth test set to EQUAL.


325
00:20:00,567 --> 00:20:03,337 line:-2
And due to position invariance
being disabled,


326
00:20:03,403 --> 00:20:06,507 line:-2
Pass2 generates slightly different
depth values than Pass1.


327
00:20:07,040 --> 00:20:11,044 line:-2
This causes some pixels
to fail the depth test and be discarded.


328
00:20:12,312 --> 00:20:16,583 line:0
For those pixels, the cleared color
is populated to system memory,


329
00:20:16,650 --> 00:20:18,085 line:0
causing correctness issues.


330
00:20:18,919 --> 00:20:20,821 line:-1
Let's now take a look at the code.


331
00:20:22,523 --> 00:20:26,193 line:0
Here we have the two vertex shaders
used in the previous diagram,


332
00:20:26,260 --> 00:20:28,462 line:0
vertexPass1 and vertexPass2.


333
00:20:29,830 --> 00:20:34,034 line:0
As you can see, the position computation
is exactly the same


334
00:20:34,101 --> 00:20:36,036 line:0
between the two shaders.


335
00:20:36,103 --> 00:20:38,772 line:0
It calls computePosition in both cases.


336
00:20:39,840 --> 00:20:41,241 line:0
But there is no guarantee


337
00:20:41,308 --> 00:20:44,945 line:0
that it will actually produce
the exact same values for the position.


338
00:20:46,747 --> 00:20:49,449 line:0
This is due to the code
around the position computation


339
00:20:49,516 --> 00:20:52,886 line:0
that might trigger differences
in compiler optimizations,


340
00:20:52,953 --> 00:20:54,621 line:0
affecting the position itself.


341
00:20:56,190 --> 00:20:57,691 line:-1
How can this be avoided?


342
00:20:59,159 --> 00:21:02,596 line:-2
First, make sure to pass
the preserveInvariance option


343
00:21:02,663 --> 00:21:05,465 line:-2
to the Metal compiler
when creating a Metal library.


344
00:21:06,333 --> 00:21:09,937 line:-2
Note that there is a similar option
if you use the off-line compiler.


345
00:21:11,338 --> 00:21:14,141 line:0
And for all the vertex shaders
within this library


346
00:21:14,208 --> 00:21:16,043 line:0
that require position invariance,


347
00:21:16,643 --> 00:21:19,546 line:0
just add the invariant keyword
on the position output.


348
00:21:21,215 --> 00:21:24,651 line:0
Note that you need to set these
two options to ensure position invariance.


349
00:21:25,319 --> 00:21:28,422 line:0
And since position invariance comes
at a performance cost,


350
00:21:28,488 --> 00:21:32,759 line:0
carefully enable these options
only for shaders that really require it.


351
00:21:34,394 --> 00:21:36,964 line:-2
We encourage you
to go through your application


352
00:21:37,030 --> 00:21:40,901 line:-2
and identify vertex shaders
that require position invariance.


353
00:21:41,802 --> 00:21:46,406 line:-2
This will likely be needed where the
depth-compare function is set to "equal,"


354
00:21:46,473 --> 00:21:50,711 line:-2
as it will require matching depth values
between different passes.


355
00:21:51,745 --> 00:21:53,914 line:-1
And to enable position invariance,


356
00:21:53,981 --> 00:21:57,484 line:-2
make sure to use the preserveInvariance
flag during compilation


357
00:21:58,018 --> 00:22:01,989 line:-2
and the invariant keyword on the position
output in your vertex shaders.


358
00:22:02,356 --> 00:22:06,059 line:-2
Now let's take a look
at Threadgroup Memory Synchronization.


359
00:22:07,060 --> 00:22:10,464 line:-2
This is an area
where you can get great performance


360
00:22:10,531 --> 00:22:14,768 line:-2
if you have a good understanding
of the underlying hardware architecture.


361
00:22:16,336 --> 00:22:19,673 line:-2
Let's first refresh the notion
of threadgroups and SIMD groups.


362
00:22:21,175 --> 00:22:24,344 line:-2
Compute passes launch a set
of individual threads


363
00:22:24,411 --> 00:22:25,946 line:-1
organized into threadgroups.


364
00:22:26,513 --> 00:22:29,516 line:-2
The threads within a threadgroup
execute together


365
00:22:29,583 --> 00:22:31,952 line:-2
and can share a common block
of threadgroup memory.


366
00:22:33,086 --> 00:22:37,391 line:-2
Access to this memory needs to be properly
synchronized for correct ordering.


367
00:22:38,625 --> 00:22:41,929 line:-2
Threadgroups are further organized
into SIMD groups


368
00:22:41,995 --> 00:22:44,464 line:-1
that execute concurrently on the GPU.


369
00:22:45,566 --> 00:22:49,169 line:-2
However,
the SIMD group size is GPU-specific.


370
00:22:49,670 --> 00:22:51,772 line:-1
It is 32 on Apple GPUs.


371
00:22:52,606 --> 00:22:56,610 line:-2
Knowing the SIMD group size can be very
useful to optimize your compute shaders...


372
00:22:57,711 --> 00:23:01,481 line:-2
particularly if there is
only one SIMD group per threadgroup.


373
00:23:01,548 --> 00:23:04,184 line:-2
There is no need to synchronize
between SIMD groups.


374
00:23:06,220 --> 00:23:09,823 line:-2
In order to ensure correct synchronization
on any GPU,


375
00:23:09,890 --> 00:23:14,094 line:-2
you should query the SIMD group size
through the Metal API at runtime.


376
00:23:15,562 --> 00:23:19,132 line:-2
And if an application does not use
the correct SIMD group size,


377
00:23:19,199 --> 00:23:23,070 line:-2
synchronization might be missing,
causing correctness issues.


378
00:23:23,971 --> 00:23:25,339 line:-1
Let's see an example.


379
00:23:26,306 --> 00:23:29,042 line:-2
The artifacts in this image
are due to the fact


380
00:23:29,109 --> 00:23:33,847 line:-2
that the application expects only one
SIMD group in a 64-threadgroup size,


381
00:23:33,914 --> 00:23:36,884 line:-2
omitting any kind
of threadgroup memory synchronization.


382
00:23:38,118 --> 00:23:41,154 line:-2
Here is the correct image
with proper synchronization.


383
00:23:42,789 --> 00:23:45,692 line:-2
Let's dig into the compute shader used
in this application.


384
00:23:46,393 --> 00:23:49,162 line:-2
This kernel
makes use of threadgroup memory.


385
00:23:49,963 --> 00:23:53,800 line:-2
It has also been launched
using a threadgroup size of 64.


386
00:23:55,602 --> 00:23:58,438 line:-2
You can also see
that the threadgroup memory


387
00:23:58,505 --> 00:24:01,875 line:-2
is first initialized
and read back later in the shader.


388
00:24:04,378 --> 00:24:06,847 line:-2
Note that there is
cross-thread communication,


389
00:24:06,914 --> 00:24:11,051 line:-2
as the buffer written from one thread
will be consumed on another thread.


390
00:24:11,718 --> 00:24:15,956 line:-2
However, nothing in the code
guarantees correct ordering.


391
00:24:16,557 --> 00:24:17,991 line:-1
Something is missing here.


392
00:24:18,859 --> 00:24:21,261 line:-2
You probably already guessed
what is missing:


393
00:24:21,328 --> 00:24:22,796 line:-1
memory synchronization.


394
00:24:24,831 --> 00:24:28,569 line:0
Here is what the code looks like
when adding proper synchronization.


395
00:24:29,236 --> 00:24:32,573 line:0
First, the application queries
the SIMD group size


396
00:24:32,639 --> 00:24:35,075 line:0
using the built-in threads_per_simdgroup.


397
00:24:35,809 --> 00:24:39,046 line:0
These can then be used
to inject the correct synchronization.


398
00:24:41,582 --> 00:24:44,084 line:0
If there is only one SIMD group
per threadgroup--


399
00:24:44,151 --> 00:24:47,221 line:0
in this shader,
it means that simd_size is 64--


400
00:24:47,287 --> 00:24:51,525 line:0
then a simple SIMD group barrier
is required to guarantee memory ordering.


401
00:24:52,192 --> 00:24:54,361 line:0
However, if there are several SIMD groups,


402
00:24:54,428 --> 00:24:58,599 line:0
a full threadgroup barrier is required
to synchronize all the SIMD groups.


403
00:24:59,933 --> 00:25:03,871 line:0
And even though extra control flow
is generally not a good practice,


404
00:25:03,937 --> 00:25:07,407 line:0
in this particular case,
as simd_size is a constant,


405
00:25:07,474 --> 00:25:12,079 line:0
the compiler is able to optimize out
the code path that will not be taken.


406
00:25:12,145 --> 00:25:16,650 line:0
This code will ensure
correct synchronization on any GPUs.


407
00:25:18,852 --> 00:25:22,523 line:0
For best performance,
you might want to rewrite your shaders


408
00:25:22,589 --> 00:25:26,793 line:0
with a 32 SIMD group size in mind
to avoid threadgroup barriers,


409
00:25:26,860 --> 00:25:28,362 line:0
as they are expensive.


410
00:25:29,363 --> 00:25:31,832 line:0
Applications could have
different sets of shaders


411
00:25:31,899 --> 00:25:34,101 line:0
optimized for a given SIMD group size


412
00:25:34,668 --> 00:25:37,237 line:0
and would choose at runtime
which variant to use.


413
00:25:39,039 --> 00:25:41,875 line:-2
With that in mind,
go through your compute shaders


414
00:25:41,942 --> 00:25:45,112 line:-2
and ensure correct
threadgroup memory synchronization.


415
00:25:45,812 --> 00:25:48,081 line:-1
GPUs have different SIMD group size,


416
00:25:48,148 --> 00:25:50,551 line:-2
which will require
different synchronization.


417
00:25:51,852 --> 00:25:53,887 line:-1
Make sure to query the SIMD group size


418
00:25:53,954 --> 00:25:57,858 line:-2
either in your shader,
using the built-in threads_per_simdgroup,


419
00:25:57,925 --> 00:26:01,461 line:-2
or with the Metal API,
using threadExecutionWidth.


420
00:26:03,096 --> 00:26:04,698 line:-1
And for better performance,


421
00:26:04,765 --> 00:26:09,369 line:-2
write multiple versions of your shader
optimized for a given SIMD group size.


422
00:26:09,837 --> 00:26:12,840 line:-2
Let's now explore
a final issue that we observed


423
00:26:12,906 --> 00:26:15,576 line:-2
related to depth
and stencil texture sampling.


424
00:26:16,276 --> 00:26:20,781 line:-2
Applications should ensure correct texture
and attachment bindings.


425
00:26:20,848 --> 00:26:24,718 line:-2
More specifically,
a texture used as an attachment


426
00:26:24,785 --> 00:26:27,287 line:-2
cannot also be sampled
in the same render pass.


427
00:26:29,022 --> 00:26:34,661 line:-2
This might create a concurrent read-write
access to the same rendering texture


428
00:26:34,728 --> 00:26:36,496 line:-1
and trigger correctness issues.


429
00:26:37,598 --> 00:26:39,867 line:-2
This is exactly what is happening
in this image.


430
00:26:40,901 --> 00:26:45,739 line:-2
The current depth attachment is also
being sampled in the same render pass.


431
00:26:47,808 --> 00:26:49,543 line:-1
No artifacts are being observed


432
00:26:49,610 --> 00:26:52,846 line:-2
if the application avoids
this undefined behavior.


433
00:26:52,913 --> 00:26:55,983 line:-2
A diagram will help us understand
what is happening.


434
00:26:57,417 --> 00:27:00,254 line:-2
We first start with a depth texture
in system memory.


435
00:27:02,489 --> 00:27:06,527 line:-2
Then the first draw comes in
and starts accumulating depth.


436
00:27:07,427 --> 00:27:09,096 line:-1
Fragment shaders within this draw


437
00:27:09,162 --> 00:27:13,000 line:-2
execute and sample the depth texture
from system memory.


438
00:27:14,401 --> 00:27:15,836 line:-1
Then comes a later draw.


439
00:27:16,370 --> 00:27:20,941 line:-2
Same story here. It will accumulate depth
and sample the depth texture.


440
00:27:22,309 --> 00:27:24,545 line:-1
One important point in this diagram


441
00:27:24,611 --> 00:27:28,982 line:-2
is the fact that depth is accumulated
prior to fragment shader execution.


442
00:27:29,616 --> 00:27:32,819 line:-1
This will be the case for opaque geometry,


443
00:27:32,886 --> 00:27:35,889 line:-2
where fragment shaders
don't modify the depth.


444
00:27:37,925 --> 00:27:41,962 line:-2
At this point in the render pass,
all the depth information is finalized.


445
00:27:43,130 --> 00:27:48,268 line:-2
Apple GPUs will then start flushing
the on-chip depth and stencil memory


446
00:27:48,335 --> 00:27:50,070 line:-1
back to system memory.


447
00:27:51,438 --> 00:27:56,443 line:-2
This is where a concurrent read-write
access to the same depth texture


448
00:27:56,510 --> 00:27:58,612 line:-1
introduces correctness issues.


449
00:27:59,313 --> 00:28:03,750 line:-2
And note that this race condition can
happen on any draws in your render pass,


450
00:28:03,817 --> 00:28:05,719 line:-1
not only the last one.


451
00:28:06,820 --> 00:28:09,690 line:-1
In summary, ensure that your application


452
00:28:09,756 --> 00:28:13,327 line:-2
does not sample
the current depth and stencil attachments


453
00:28:13,393 --> 00:28:15,128 line:-1
in the same render pass.


454
00:28:15,195 --> 00:28:18,131 line:-1
This is undefined behavior on any GPUs.


455
00:28:18,565 --> 00:28:23,303 line:-2
Also, do not use texture or memory
barriers to work around this issue.


456
00:28:23,937 --> 00:28:25,772 line:-1
Those are very expensive,


457
00:28:25,839 --> 00:28:30,878 line:-2
especially on Apple GPUs using
a tile-based default render architecture.


458
00:28:30,944 --> 00:28:36,416 line:-2
Instead, if your application really
requires sampling the current attachments,


459
00:28:36,483 --> 00:28:38,685 line:-1
create a second copy for sampling.


460
00:28:39,419 --> 00:28:42,556 line:-1
Let's now wrap up with what you need to do


461
00:28:42,623 --> 00:28:45,893 line:-2
in order to get consistent rendering
using Metal.


462
00:28:47,628 --> 00:28:49,563 line:-1
In our application testing,


463
00:28:49,630 --> 00:28:53,333 line:-2
we observed three main issues
affecting graphics correctness.


464
00:28:54,568 --> 00:28:57,838 line:-2
That is why we developed
three Metal work-arounds


465
00:28:57,905 --> 00:29:00,474 line:-2
that are enabled
for backward compatibility.


466
00:29:01,642 --> 00:29:03,911 line:-1
These work-arounds are only applied


467
00:29:03,977 --> 00:29:08,315 line:-2
for applications compiled
with a macOS Catalina SDK or earlier.


468
00:29:10,250 --> 00:29:15,088 line:-2
The first issue is when applications
are using DontCare load actions


469
00:29:15,155 --> 00:29:16,924 line:-1
where it should have been a load.


470
00:29:17,658 --> 00:29:21,662 line:-2
In this case, Metal is remapping
all DontCare load actions


471
00:29:21,728 --> 00:29:24,598 line:-2
to actual loads
to avoid correctness issues.


472
00:29:26,200 --> 00:29:29,102 line:-2
The second issue
is related to position invariance.


473
00:29:29,670 --> 00:29:34,274 line:-2
Some applications rely on
position invariance without enabling it.


474
00:29:35,142 --> 00:29:39,379 line:-2
Metal is then forcing position invariance
for all vertex shaders.


475
00:29:40,948 --> 00:29:43,884 line:-1
And finally, if the same depth texture


476
00:29:43,951 --> 00:29:47,521 line:-2
is both sampled and rendered
in the same render pass,


477
00:29:47,588 --> 00:29:50,691 line:-2
Metal will snapshot the texture
prior rendering.


478
00:29:50,757 --> 00:29:54,027 line:-1
Again, these work-arounds are only enabled


479
00:29:54,094 --> 00:29:57,998 line:-2
for applications compiled
with a macOS Catalina SDK or earlier.


480
00:29:58,665 --> 00:30:02,069 line:-2
And as you probably suspect,
they also come at a performance cost,


481
00:30:02,736 --> 00:30:04,705 line:-1
so this is really not what you want.


482
00:30:05,172 --> 00:30:07,107 line:-1
To help you identify these issues,


483
00:30:07,174 --> 00:30:11,311 line:-2
we augmented the Metal API
validation layer to catch a few of those,


484
00:30:12,145 --> 00:30:15,182 line:-2
such as the misuse
of DontCare load and store actions,


485
00:30:15,649 --> 00:30:19,152 line:-2
as well as sampling the current depth
and stencil attachments.


486
00:30:21,154 --> 00:30:24,157 line:-2
Here is a recap
of the Metal best practices


487
00:30:24,224 --> 00:30:27,261 line:-2
to get consistent rendering
across different GPUs.


488
00:30:27,327 --> 00:30:28,762 line:-1
Go through your application


489
00:30:28,829 --> 00:30:31,698 line:-2
and make sure
that this is already what you are doing.


490
00:30:31,765 --> 00:30:34,668 line:-2
And if not,
just follow these simple recommendations.


491
00:30:36,303 --> 00:30:38,939 line:-1
Regarding Metal GPU feature detection,


492
00:30:39,006 --> 00:30:44,077 line:-2
make sure that it is API-driven by
querying the Metal GPU features directly.


493
00:30:44,645 --> 00:30:47,214 line:-2
Carefully choose
your load and store actions


494
00:30:47,281 --> 00:30:50,284 line:-2
to address both correctness
and performance issues.


495
00:30:51,051 --> 00:30:54,354 line:-2
Do not unnecessarily load
or store attachments,


496
00:30:54,421 --> 00:30:56,290 line:-1
as it will increase memory traffic.


497
00:30:56,857 --> 00:30:59,660 line:-1
Also consider using memoryless attachments


498
00:30:59,726 --> 00:31:02,496 line:-2
to lower the memory footprint
of your application.


499
00:31:03,096 --> 00:31:05,933 line:-2
These can typically be used
for depth attachments.


500
00:31:06,934 --> 00:31:09,636 line:-1
Enable position invariance where required.


501
00:31:11,405 --> 00:31:14,208 line:-2
Ensure correct threadgroup memory
synchronization


502
00:31:14,274 --> 00:31:16,343 line:-1
by querying the SIMD group size


503
00:31:16,410 --> 00:31:19,513 line:-2
and using the appropriate
synchronization primitives.


504
00:31:19,580 --> 00:31:23,951 line:0
And finally, avoid sampling
the current depth and stencil attachments


505
00:31:24,017 --> 00:31:27,254 line:0
by snapshotting the attachments
prior rendering.


506
00:31:28,622 --> 00:31:31,859 line:-2
We are very excited
to bring Apple Silicon to the Mac.


507
00:31:32,593 --> 00:31:36,530 line:-2
This means that your applications
will be more power efficient


508
00:31:36,597 --> 00:31:38,799 line:-1
and run faster out of the box.


509
00:31:39,566 --> 00:31:42,736 line:-2
We can't wait to see
how much faster they will run


510
00:31:42,803 --> 00:31:45,372 line:-2
once you start optimizing
for Apple Silicon.


511
00:31:45,439 --> 00:31:49,243 line:-2
This will also enable you
to use brand-new features on the Mac


512
00:31:49,309 --> 00:31:51,678 line:-1
that were not possible before,


513
00:31:51,745 --> 00:31:54,681 line:-2
such as programmable blending,
tile shaders,


514
00:31:54,748 --> 00:31:56,717 line:-1
memoryless frame buffers, and more.


515
00:31:58,252 --> 00:32:03,891 line:-2
And finally, this transition aligns
the technology used on Mac platforms


516
00:32:03,957 --> 00:32:05,826 line:-1
with existing Apple platforms.


517
00:32:06,660 --> 00:32:09,863 line:-2
That means that you can easily share
a common code base


518
00:32:09,930 --> 00:32:11,665 line:-1
across all Apple products.


519
00:32:12,900 --> 00:32:14,902 line:-1
And this makes it even easier to bring


520
00:32:14,968 --> 00:32:18,272 line:-2
all your iPad and iPhone applications
to the Mac.


521
00:32:20,174 --> 00:32:24,311 line:-2
Apple Silicon Macs
brings up new opportunities for you.


522
00:32:24,378 --> 00:32:26,280 line:-1
At the beginning of this session,


523
00:32:26,346 --> 00:32:29,483 line:-2
we showed how Games gets
amazing graphics performance


524
00:32:29,550 --> 00:32:31,118 line:-1
while playing DiRT Rally.


525
00:32:31,752 --> 00:32:33,353 line:-1
On Apple GPUs,


526
00:32:33,420 --> 00:32:37,391 line:-2
even the most demanding pro applications
will get great performance.


527
00:32:38,325 --> 00:32:42,095 line:-2
As an example, I would like to show you
a video of Cinema4D.


528
00:32:43,197 --> 00:32:46,934 line:-2
This is recorded live
on an Apple Silicon Mac.


529
00:32:47,734 --> 00:32:51,872 line:-2
Note that it is also running
the original x86 binary


530
00:32:51,939 --> 00:32:53,640 line:-1
and a Rosetta translation.


531
00:32:54,341 --> 00:32:58,846 line:-2
In this video, the application
is rendering a high polygon model


532
00:32:58,912 --> 00:33:02,349 line:-2
in real time
with realistic camera properties


533
00:33:02,416 --> 00:33:07,187 line:-2
such as user-specified aperture,
f-stop and focal point.


534
00:33:07,254 --> 00:33:10,257 line:-2
Enjoy how smooth it runs
on Apple Silicon Mac


535
00:33:10,324 --> 00:33:12,960 line:-2
while rendering
a graphics-demanding scene.


536
00:33:14,061 --> 00:33:18,565 line:-2
Where does this all fit in the transition
process to Apple Silicon Macs?


537
00:33:19,566 --> 00:33:22,769 line:-2
At this point,
your application should look great


538
00:33:22,836 --> 00:33:26,573 line:0
without Metal work-arounds
running on new macOS SDK.


539
00:33:27,040 --> 00:33:29,743 line:0
But your journey should not stop here.


540
00:33:30,444 --> 00:33:35,082 line:0
To take your application to the next level
and greatly improve performance,


541
00:33:35,148 --> 00:33:37,217 line:0
make sure to check out the session


542
00:33:37,284 --> 00:33:40,721 line:0
"Optimize Metal Performance
for Apple Silicon Macs."


543
00:33:42,089 --> 00:33:43,090 line:-1
Thank you.

