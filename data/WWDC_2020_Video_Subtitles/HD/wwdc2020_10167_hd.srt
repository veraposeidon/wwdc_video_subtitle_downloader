1
00:00:03,836 --> 00:00:06,540 line:-1
Hello and welcome to WWDC.


2
00:00:08,876 --> 00:00:10,511 line:0
Hi, my name's Andy.


3
00:00:10,577 --> 00:00:13,747 line:0
I'll be talking to you about how
to "Safely Manage Pointers in Swift."


4
00:00:13,814 --> 00:00:18,552 line:-2
This session builds directly
on "Unsafe Swift" also from WWDC 20.


5
00:00:18,619 --> 00:00:21,221 line:0
In that session,
we defined unsafe operations


6
00:00:21,288 --> 00:00:23,757 line:0
as having undefined behavior
on some input.


7
00:00:24,224 --> 00:00:26,693 line:-2
In this talk,
I'll delve deeper into some details


8
00:00:26,760 --> 00:00:29,563 line:-2
of programming Swift
outside the usual safety zone.


9
00:00:30,297 --> 00:00:32,566 line:-2
These aren't the kind of details
that application programmers


10
00:00:32,633 --> 00:00:33,834 line:-1
typically need to worry about.


11
00:00:33,901 --> 00:00:37,771 line:-2
Managing pointers safely means knowing
all the different ways they can be unsafe.


12
00:00:38,172 --> 00:00:40,574 line:-2
I'll spend most of our time here
on type safety.


13
00:00:40,641 --> 00:00:44,344 line:-2
This is a source of undefined behavior
in C that tends to be poorly understood.


14
00:00:44,811 --> 00:00:48,215 line:-2
I'll explain the APIs that give Swift
the same low-level capabilities


15
00:00:48,649 --> 00:00:51,385 line:-2
and explain how to use them
to avoid that undefined behavior.


16
00:00:51,451 --> 00:00:54,221 line:-2
Pointer safety can be looked at
as a series of levels.


17
00:00:54,955 --> 00:00:55,956 line:-1
Each level down,


18
00:00:56,023 --> 00:00:59,059 line:-2
you take more responsibility
for the correctness of your code.


19
00:00:59,626 --> 00:01:02,963 line:-2
So it's recommended that you write code
at the highest safety level possible.


20
00:01:03,897 --> 00:01:05,566 line:-1
The first level is safe code.


21
00:01:06,266 --> 00:01:09,036 line:-2
A major goal of Swift
is providing new ways of writing code


22
00:01:09,102 --> 00:01:11,138 line:-1
that don't require any unsafe constructs.


23
00:01:11,205 --> 00:01:12,973 line:-1
Swift has a robust type system


24
00:01:13,040 --> 00:01:15,542 line:-2
that provides a lot of flexibility
and performance.


25
00:01:16,009 --> 00:01:18,846 line:-2
Swift's collection APIs,
slices and iterators


26
00:01:18,912 --> 00:01:21,849 line:-2
provide much of the functionality
you may have wanted from pointers.


27
00:01:22,115 --> 00:01:25,018 line:-2
And not using pointers at all
is a great strategy for code safety.


28
00:01:25,452 --> 00:01:27,087 line:-1
But another important goal of Swift


29
00:01:27,154 --> 00:01:29,823 line:-2
is performant interoperability
with unsafe languages.


30
00:01:30,290 --> 00:01:33,460 line:-2
To do that, Swift needs to provide
low-level expressibility


31
00:01:33,527 --> 00:01:35,128 line:-1
in the form of unsafe APIs.


32
00:01:35,629 --> 00:01:39,233 line:-2
These are denoted by the prefix "Unsafe"
in their type or function name.


33
00:01:39,299 --> 00:01:41,935 line:-2
Swift's UnsafePointer
lets you take responsibility


34
00:01:42,002 --> 00:01:45,873 line:-2
for some of the dangers of using pointers
without worrying about type safety.


35
00:01:45,939 --> 00:01:48,408 line:-2
If you need to work with raw memory
as a sequence of bytes,


36
00:01:48,475 --> 00:01:50,410 line:-1
Swift provides UnsafeRawPointer.


37
00:01:50,944 --> 00:01:52,813 line:-1
Loading and storing values with raw memory


38
00:01:52,880 --> 00:01:55,816 line:-2
gives you the responsibility
for knowing the layout of types.


39
00:01:56,450 --> 00:01:59,419 line:0
At the deepest level,
Swift provides a few APIs


40
00:01:59,486 --> 00:02:01,054 line:0
for binding memory to types.


41
00:02:01,121 --> 00:02:03,724 line:0
It's only by using
one of these lowest level APIs


42
00:02:03,790 --> 00:02:05,959 line:0
that you take full responsibility
away from Swift


43
00:02:06,026 --> 00:02:07,995 line:0
for managing the safety of pointer types.


44
00:02:08,461 --> 00:02:10,764 line:-2
Let me explain
what I mean by levels of safety.


45
00:02:11,665 --> 00:02:15,302 line:-2
Safe code isn't necessarily correct code,
but it does behave predictably.


46
00:02:15,369 --> 00:02:19,373 line:0
In most cases, if a programming error
could lead to unpredictable behavior,


47
00:02:19,439 --> 00:02:20,908 line:0
then the compiler catches it.


48
00:02:21,375 --> 00:02:23,777 line:0
For errors that can't be caught
at compile time,


49
00:02:23,844 --> 00:02:27,848 line:0
runtime checks guarantee that the program
crashes immediately with a diagnostic.


50
00:02:28,415 --> 00:02:30,717 line:0
It won't continue past
an incorrect assumption.


51
00:02:31,718 --> 00:02:34,488 line:0
So safe code is really
about error enforcement.


52
00:02:35,088 --> 00:02:38,225 line:-2
If you don't use any Swift types
or APIs that are marked unsafe


53
00:02:38,759 --> 00:02:40,727 line:-1
and you take care to manage thread safety,


54
00:02:40,994 --> 00:02:43,497 line:-2
then you know that predictable behavior
is fully enforced.


55
00:02:44,064 --> 00:02:47,501 line:-2
In unsafe Swift code, predictable behavior
is not fully enforced,


56
00:02:47,568 --> 00:02:49,503 line:-1
so you take on extra responsibility.


57
00:02:49,937 --> 00:02:52,105 line:-2
Testing still provides
helpful diagnostics.


58
00:02:52,573 --> 00:02:55,776 line:-2
But the level of diagnostics depends
on the level of safety you've chosen.


59
00:02:55,843 --> 00:02:59,479 line:-2
Unsafe standard library APIs
have assertions in debug builds


60
00:02:59,546 --> 00:03:01,648 line:-1
that catch certain kinds of invalid input.


61
00:03:02,015 --> 00:03:04,518 line:-2
Adding your own preconditions
to verify unsafe assumptions


62
00:03:04,585 --> 00:03:05,919 line:-1
is also good practice.


63
00:03:06,353 --> 00:03:08,021 line:0
You can test with more runtime checks


64
00:03:08,088 --> 00:03:10,591 line:-2
by enabling sanitizers,
like the address sanitizer.


65
00:03:11,091 --> 00:03:14,728 line:-2
Sanitizer diagnostics are a great
time-saver by pinpointing bugs


66
00:03:15,262 --> 00:03:17,197 line:0
but they don't catch
all undefined behavior.


67
00:03:17,564 --> 00:03:19,333 line:0
When errors are not uncovered
during testing,


68
00:03:19,399 --> 00:03:21,902 line:0
they can lead
to unexpected runtime behavior.


69
00:03:21,969 --> 00:03:23,637 line:0
That could be a hard to debug crash


70
00:03:23,704 --> 00:03:25,873 line:0
that occurs
far from the source of the problem.


71
00:03:25,939 --> 00:03:28,575 line:0
Or worse than a crash,
your program could do the wrong thing,


72
00:03:28,642 --> 00:03:29,877 line:0
even corrupting user data.


73
00:03:29,943 --> 00:03:33,580 line:-2
A crash is a bad experience,
but corrupting or losing data is worse.


74
00:03:33,647 --> 00:03:36,350 line:0
The further down you venture
into unsafe territory,


75
00:03:36,750 --> 00:03:38,585 line:0
the harder it is to find those mistakes,


76
00:03:38,652 --> 00:03:40,654 line:0
and the more confusing
the symptoms may be.


77
00:03:40,721 --> 00:03:43,624 line:0
Symptoms may not even show up
until long after the bug was introduced.


78
00:03:44,191 --> 00:03:47,794 line:-2
Let's look at pointers to understand
some of the ways that code can be unsafe.


79
00:03:47,861 --> 00:03:50,364 line:-2
Swift is designed to be programmed
without using pointers,


80
00:03:50,430 --> 00:03:52,499 line:-2
and looking at why they're unsafe
will make it clear


81
00:03:52,566 --> 00:03:54,434 line:-1
why avoiding them is a good strategy.


82
00:03:54,935 --> 00:03:58,338 line:-2
But if you do need to directly
access memory using low-level APIs,


83
00:03:58,906 --> 00:04:02,309 line:-2
it's also useful to know how to manage
different aspects of safety yourself.


84
00:04:02,376 --> 00:04:04,945 line:-2
You may need to
point to the storage for a variable,


85
00:04:05,445 --> 00:04:09,082 line:-2
to the elements of an array,
or to memory that you allocated directly.


86
00:04:09,483 --> 00:04:13,187 line:-2
Before you can point to that object,
it needs a stable memory location.


87
00:04:13,253 --> 00:04:16,223 line:-2
The stable storage that you point to
has a limited lifetime,


88
00:04:16,589 --> 00:04:18,291 line:-1
either because it goes out of scope


89
00:04:18,358 --> 00:04:20,627 line:-2
or because you directly
deallocate the memory.


90
00:04:21,028 --> 00:04:23,764 line:-2
However,
your pointer value has its own lifetime.


91
00:04:23,830 --> 00:04:26,633 line:-2
When the pointer's lifetime
exceeds the storage lifetime,


92
00:04:27,100 --> 00:04:29,136 line:-1
any attempt to access it is undefined.


93
00:04:29,203 --> 00:04:32,472 line:-2
This is the primary reason that pointers
are unsafe, but not the only one.


94
00:04:33,207 --> 00:04:35,676 line:-2
Objects can be composed
of a sequence of elements.


95
00:04:36,009 --> 00:04:38,345 line:-2
Pointers are allowed to move
to different memory addresses


96
00:04:38,412 --> 00:04:40,080 line:-1
by adding offsets to the pointer.


97
00:04:40,147 --> 00:04:42,482 line:-2
That's an efficient way
to address different elements.


98
00:04:42,549 --> 00:04:44,785 line:-2
But adding or subtracting
too large of an offset


99
00:04:44,852 --> 00:04:47,487 line:-2
points to memory
that doesn't belong to the same object.


100
00:04:47,721 --> 00:04:51,258 line:-2
Accessing a pointer that has exceeded
its object's boundary is undefined.


101
00:04:51,325 --> 00:04:54,027 line:-2
For this talk,
we'll focus on another aspect of safety


102
00:04:54,094 --> 00:04:55,362 line:-1
that's easily overlooked.


103
00:04:56,029 --> 00:04:57,431 line:-1
Pointers have their own types,


104
00:04:57,497 --> 00:04:59,666 line:-2
distinct from the types
of values in memory.


105
00:05:00,267 --> 00:05:02,169 line:-2
How do we ensure those types
are consistent,


106
00:05:02,236 --> 00:05:03,770 line:-1
and what happens if they aren't?


107
00:05:04,571 --> 00:05:07,774 line:-2
When we ask for a pointer
to storage of type Int16,


108
00:05:07,841 --> 00:05:09,776 line:-1
we get back a pointer to Int16.


109
00:05:09,843 --> 00:05:10,878 line:-1
So far so good.


110
00:05:11,311 --> 00:05:14,414 line:-2
As we'll see, it's pretty hard to get
a pointer to the wrong type in Swift.


111
00:05:14,681 --> 00:05:18,051 line:-2
Now let's say we manage to overwrite
the same memory with a different type,


112
00:05:18,318 --> 00:05:19,319 line:-1
now Int32.


113
00:05:19,786 --> 00:05:22,856 line:-2
At that point, we'll have a pointer
to the correct Int32 type,


114
00:05:23,357 --> 00:05:25,926 line:-2
but our Int16 pointer
could still be hanging around.


115
00:05:26,560 --> 00:05:29,630 line:-2
Accessing the old pointer of type Int16
is undefined behavior


116
00:05:30,030 --> 00:05:33,066 line:-2
because the pointer type and
the in-memory type are now inconsistent.


117
00:05:33,133 --> 00:05:34,434 line:-1
You might be wondering,


118
00:05:34,501 --> 00:05:37,371 line:-2
"How can undefined behavior
be worse than a program crash,


119
00:05:37,437 --> 00:05:39,606 line:-1
and why would pointer types cause that?"


120
00:05:39,673 --> 00:05:42,276 line:-2
To understand,
let's look at some very unsafe code.


121
00:05:43,277 --> 00:05:45,345 line:-2
I don't expect anyone
to write code like this,


122
00:05:45,412 --> 00:05:48,081 line:-2
but you may be surprised
at what Swift code can look like


123
00:05:48,148 --> 00:05:51,218 line:-2
when it's ported from C,
and still calls parts of the old C code.


124
00:05:51,285 --> 00:05:53,654 line:-2
Code that does scary things
is supposed to look scary,


125
00:05:53,720 --> 00:05:57,024 line:-2
but we don't need to understand all these
low-level types yet to see the problem.


126
00:05:57,691 --> 00:06:00,661 line:-2
Imagine we have a collage struct
that holds a stand-alone pointer


127
00:06:00,727 --> 00:06:02,129 line:-1
to some image data in memory


128
00:06:02,563 --> 00:06:04,565 line:-1
and another property for the image count.


129
00:06:05,032 --> 00:06:06,834 line:-1
Maybe this type was imported from C.


130
00:06:08,435 --> 00:06:11,905 line:-2
We also have a function, addImages,
that writes image data into memory


131
00:06:11,972 --> 00:06:13,440 line:0
and increases an image count.


132
00:06:14,975 --> 00:06:16,677 line:0
When we call addImages,


133
00:06:16,743 --> 00:06:19,680 line:0
we want it to update the image count
in our collage struct,


134
00:06:19,947 --> 00:06:23,217 line:0
but there's a mismatch between
our struct's imageCount type, Int,


135
00:06:23,717 --> 00:06:26,119 line:0
and the function argument's
pointer to UInt32.


136
00:06:27,454 --> 00:06:30,624 line:0
The safe thing to do would be to create
a new count variable of the correct type


137
00:06:30,691 --> 00:06:32,459 line:0
and use Swift's integer conversions.


138
00:06:33,193 --> 00:06:37,364 line:0
Instead, this complex line of code creates
a pointer directly into our struct.


139
00:06:37,998 --> 00:06:42,069 line:0
Later, the code needs to read the image
count again to pass it to saveImages.


140
00:06:42,736 --> 00:06:45,072 line:0
The problem is, at runtime,
this count could be zero,


141
00:06:45,138 --> 00:06:48,008 line:0
meaning that the program
has silently lost all the images.


142
00:06:49,142 --> 00:06:53,046 line:0
By giving the count property an Int type
and the pointer a UInt32 type,


143
00:06:53,514 --> 00:06:55,949 line:0
we've signaled to the compiler
that those values reside


144
00:06:56,016 --> 00:06:57,417 line:0
in different memory objects.


145
00:06:57,751 --> 00:07:00,621 line:0
The compiler does not see
any updates to an Int object,


146
00:07:00,687 --> 00:07:03,657 line:0
so it could just reuse
the initialization value of zero.


147
00:07:03,724 --> 00:07:05,659 line:-1
In practice, the compiler is forgiving,


148
00:07:05,726 --> 00:07:08,095 line:-2
so such a small example
probably won't go wrong.


149
00:07:08,795 --> 00:07:10,697 line:-1
But we can't predict what will happen.


150
00:07:11,331 --> 00:07:14,768 line:-2
To the compiler, type information
is a fact that assumptions are based on.


151
00:07:14,835 --> 00:07:16,837 line:-1
Once the compiler makes a bad assumption,


152
00:07:16,904 --> 00:07:20,941 line:-2
that can percolate through the compiler's
pipeline and show up in surprising ways.


153
00:07:21,542 --> 00:07:24,811 line:0
So, two versions of the compiler
can cause different program behavior.


154
00:07:25,546 --> 00:07:28,048 line:-2
Pointer type bugs
can cause your program to misbehave


155
00:07:28,115 --> 00:07:29,983 line:-1
in ways that are worse than crashing.


156
00:07:30,250 --> 00:07:33,720 line:-2
But what makes them more insidious
is that it's rare for them to be observed.


157
00:07:34,054 --> 00:07:37,324 line:-2
So, a program may appear to work fine
while a bug lingers in the code for years


158
00:07:37,391 --> 00:07:38,792 line:-1
without anyone noticing.


159
00:07:38,859 --> 00:07:41,962 line:-2
Someone might later make a safe
and seemingly innocuous change


160
00:07:42,029 --> 00:07:43,931 line:-1
to the source that exposes the problem.


161
00:07:43,997 --> 00:07:46,300 line:-2
Or it may show up
after a regular compiler update,


162
00:07:46,366 --> 00:07:48,468 line:-2
so your program starts
behaving differently


163
00:07:48,535 --> 00:07:50,204 line:-1
without anyone changing the code.


164
00:07:50,938 --> 00:07:53,640 line:-2
The challenge of pointer type safety
predates Swift.


165
00:07:54,441 --> 00:07:56,376 line:-2
Knowing how to use
pointer types correctly in C


166
00:07:56,443 --> 00:07:58,212 line:-2
requires deep knowledge
of the language spec.


167
00:07:59,346 --> 00:08:00,681 line:-1
You can find those discussions


168
00:08:00,747 --> 00:08:03,517 line:-2
under the terms "strict aliasing"
and "type punning."


169
00:08:04,084 --> 00:08:06,720 line:-2
Fortunately, you're not expected
to understand those rules


170
00:08:06,787 --> 00:08:08,789 line:-1
to be able to use Swift pointers safely.


171
00:08:09,623 --> 00:08:11,992 line:-2
It is common to pass pointers
from Swift into C though,


172
00:08:12,059 --> 00:08:15,829 line:-2
so Swift pointers need to be at least
as strict as C to safely interoperate.


173
00:08:16,196 --> 00:08:17,531 line:-1
Swift's UnsafePointer


174
00:08:17,598 --> 00:08:20,501 line:-2
gives you most of the low-level
capabilities of C pointers.


175
00:08:20,834 --> 00:08:24,605 line:-2
In exchange, you need to manage
object lifetime and object boundaries.


176
00:08:24,671 --> 00:08:27,040 line:-2
The "Unsafe Swift" talk
explains how to do this.


177
00:08:27,541 --> 00:08:30,444 line:-2
But you do not need
to take responsibility for type safety.


178
00:08:31,144 --> 00:08:34,181 line:-2
UnsafePointer's generic type parameter
is enforced at compile time,


179
00:08:34,248 --> 00:08:35,549 line:-1
making it a type-safe API.


180
00:08:36,216 --> 00:08:38,485 line:-2
Let's look at Swift's rules
for pointer type safety


181
00:08:38,552 --> 00:08:39,785 line:-1
to see why this works.


182
00:08:40,220 --> 00:08:42,289 line:-1
UnsafePointer's type parameter indicates


183
00:08:42,356 --> 00:08:44,858 line:-2
the type of value expected
to be held in memory.


184
00:08:44,925 --> 00:08:46,560 line:-1
We call this a typed pointer.


185
00:08:46,627 --> 00:08:49,396 line:-2
In Swift, the rule for typed pointers
is strict and simple.


186
00:08:49,463 --> 00:08:51,298 line:-1
Conceptually, the memory state includes


187
00:08:51,365 --> 00:08:53,534 line:-2
the type
that a memory location is bound to.


188
00:08:53,867 --> 00:08:56,570 line:-2
That memory location
can only hold values of that type.


189
00:08:56,637 --> 00:09:01,008 line:-2
As a type-safe API, UnsafePointer only
reads values of that type from memory,


190
00:09:01,074 --> 00:09:04,444 line:-2
and UnsafeMutablePointer only reads
or writes values of that type.


191
00:09:05,779 --> 00:09:08,815 line:0
It may be natural to think
that pointer types won't matter,


192
00:09:08,882 --> 00:09:11,451 line:0
as long as the bytes are laid out
in memory correctly.


193
00:09:11,752 --> 00:09:14,688 line:0
And in C, it's not uncommon
to cast pointers to different types,


194
00:09:14,755 --> 00:09:17,624 line:0
with both pointers continuing
to refer to the same memory.


195
00:09:18,225 --> 00:09:21,595 line:0
Whether that's actually legal in C
depends on various special cases.


196
00:09:22,763 --> 00:09:24,431 line:0
In Swift, accessing a pointer


197
00:09:24,498 --> 00:09:27,901 line:0
whose type parameter does not match
its memory location's bound type


198
00:09:27,968 --> 00:09:29,469 line:0
is always undefined behavior.


199
00:09:29,903 --> 00:09:30,971 line:0
To guard against this,


200
00:09:31,038 --> 00:09:34,174 line:0
Swift does not allow casting pointers
in the familiar C style.


201
00:09:34,241 --> 00:09:38,178 line:0
This way, pointer types are enforced
at compile time by Swift's type system.


202
00:09:38,245 --> 00:09:40,514 line:0
There's no need to store
extra runtime information,


203
00:09:40,581 --> 00:09:43,817 line:0
extra type information in memory
or perform extra runtime checks.


204
00:09:43,884 --> 00:09:47,421 line:-2
Let's look at how memory is bound to
a type and where typed pointers come from.


205
00:09:47,487 --> 00:09:49,223 line:0
If you declare a variable of type Int


206
00:09:49,289 --> 00:09:51,291 line:0
and ask for a pointer
to the variable's storage,


207
00:09:51,358 --> 00:09:54,728 line:0
you'll get back a pointer-to-Int
consistent with the variable declaration.


208
00:09:55,028 --> 00:09:57,431 line:0
Array storage is bound
to the array element type.


209
00:09:57,731 --> 00:10:00,400 line:0
And of course, asking for a pointer
into array storage


210
00:10:00,467 --> 00:10:02,569 line:0
gives you a pointer
to the array's element type.


211
00:10:03,070 --> 00:10:05,072 line:0
You can also allocate memory directly


212
00:10:05,138 --> 00:10:08,942 line:-2
by calling the static allocate method
on UnsafeMutablePointer.


213
00:10:09,476 --> 00:10:11,945 line:-2
Allocation binds memory
to its type parameter


214
00:10:12,513 --> 00:10:14,781 line:-2
and returns a typed pointer
to the new memory.


215
00:10:15,482 --> 00:10:18,185 line:-2
This is different from pointers
to variables and arrays


216
00:10:18,619 --> 00:10:20,420 line:-1
because, as the state diagram shows,


217
00:10:20,754 --> 00:10:22,422 line:-1
memory is already bound to a type


218
00:10:22,756 --> 00:10:25,425 line:-2
even though it doesn't hold
any initialized values yet.


219
00:10:25,692 --> 00:10:27,895 line:-2
You can use the typed pointer
that allocation gives you


220
00:10:27,961 --> 00:10:30,230 line:-2
to initialize memory
only to the correct type.


221
00:10:30,564 --> 00:10:33,333 line:-2
In the initialized state,
memory can be reassigned.


222
00:10:33,867 --> 00:10:37,304 line:-2
Assignment implicitly deinitializes
the previous in-memory value


223
00:10:37,671 --> 00:10:40,474 line:-2
and reinitializes memory
to a new value of the same type.


224
00:10:41,241 --> 00:10:44,044 line:-2
You can deinitialize memory
using the same typed pointer.


225
00:10:44,444 --> 00:10:47,281 line:-2
At that point,
memory is still bound to the same type,


226
00:10:47,347 --> 00:10:49,016 line:-1
but it's now safe to deallocate.


227
00:10:49,816 --> 00:10:51,218 line:-1
With variable and array storage,


228
00:10:51,285 --> 00:10:53,287 line:-2
these steps are automatically
handled by Swift.


229
00:10:53,353 --> 00:10:56,190 line:-2
With direct allocation,
you take responsibility


230
00:10:56,256 --> 00:11:00,594 line:-2
for managing memory's initialized state,
but Swift still ensures type safety.


231
00:11:00,661 --> 00:11:03,230 line:-2
Since typed pointers
follow simple, strict rules,


232
00:11:03,797 --> 00:11:05,732 line:-2
you generally
won't have two active pointers


233
00:11:05,799 --> 00:11:08,302 line:-2
to the same memory location
that disagree on the type.


234
00:11:08,769 --> 00:11:10,838 line:-2
But let's see what happens
with composite types.


235
00:11:11,471 --> 00:11:15,676 line:0
In this example, we have a block of memory
that contains values of type MyStruct.


236
00:11:16,243 --> 00:11:18,278 line:0
We can either get a pointer
to the outer struct


237
00:11:18,345 --> 00:11:19,947 line:0
or a pointer to its property,


238
00:11:20,013 --> 00:11:22,382 line:0
and those pointers are both valid
at the same time.


239
00:11:22,449 --> 00:11:26,153 line:0
We can access either one without changing
the type that memory is bound to.


240
00:11:26,220 --> 00:11:28,989 line:-2
This still obeys the same basic rule
for pointer safety


241
00:11:29,556 --> 00:11:31,658 line:-2
because when memory is bound
to a composite type,


242
00:11:31,725 --> 00:11:34,161 line:-2
it's also effectively bound
to the members of that type,


243
00:11:34,228 --> 00:11:35,729 line:-1
as they're laid out in memory.


244
00:11:36,797 --> 00:11:39,600 line:-2
Swift's typed pointers
give you direct access to memory,


245
00:11:39,666 --> 00:11:41,768 line:-2
but only within the confines
of type safety.


246
00:11:41,835 --> 00:11:44,071 line:-2
You can't have two typed pointers
to the same memory


247
00:11:44,137 --> 00:11:45,272 line:-1
that disagree on the type.


248
00:11:45,339 --> 00:11:48,342 line:-2
So, if your goal is to reinterpret
bytes of memory as different types,


249
00:11:48,408 --> 00:11:50,210 line:-1
then you need use a lower-level API.


250
00:11:51,478 --> 00:11:54,281 line:-2
UnsafeRawPointer lets you refer
to a sequence of bytes


251
00:11:54,348 --> 00:11:57,150 line:-2
without specifying the type of values
they may represent.


252
00:11:57,818 --> 00:11:59,620 line:-1
You take control over memory layout.


253
00:12:00,287 --> 00:12:03,323 line:-2
With a raw pointer,
you interpret bytes as typed values


254
00:12:03,390 --> 00:12:04,958 line:-1
when you load them from memory.


255
00:12:05,325 --> 00:12:08,395 line:-2
Consider a block of memory
that's initialized to Int64


256
00:12:08,462 --> 00:12:09,630 line:-1
using a typed pointer.


257
00:12:10,030 --> 00:12:12,132 line:-2
It's always possible
to cast from a typed pointer


258
00:12:12,199 --> 00:12:13,300 line:-1
down to a raw pointer.


259
00:12:13,800 --> 00:12:17,538 line:-2
Operations on that raw pointer
only see the sequence of bytes in memory.


260
00:12:17,604 --> 00:12:19,473 line:-1
The memory's bound type is irrelevant.


261
00:12:19,540 --> 00:12:21,675 line:-2
You can ask that raw pointer
to load any type.


262
00:12:21,742 --> 00:12:24,044 line:-2
It does that by reading
the required number of bytes


263
00:12:24,111 --> 00:12:26,280 line:-2
and assembling them
into the requested type.


264
00:12:26,613 --> 00:12:29,249 line:0
For example, when we call load as UInt32,


265
00:12:29,683 --> 00:12:33,353 line:0
four bytes are loaded from the current
address generating a UInt32 value.


266
00:12:33,720 --> 00:12:35,622 line:0
It's even okay to load a smaller type,


267
00:12:35,689 --> 00:12:38,458 line:0
as long as you account
for the target platform's endianness.


268
00:12:38,792 --> 00:12:41,895 line:-2
You can also use a raw pointer
to write a value's bytes into memory.


269
00:12:41,962 --> 00:12:46,200 line:-2
Storing bytes is asymmetric with loading
because it modifies the in-memory value.


270
00:12:46,266 --> 00:12:48,368 line:-1
Unlike assignment using a typed pointer,


271
00:12:48,435 --> 00:12:51,872 line:-2
storing raw bytes does not deinitialize
the previous value in memory.


272
00:12:51,939 --> 00:12:53,473 line:-1
So it's now your responsibility


273
00:12:53,540 --> 00:12:56,610 line:-2
to make sure the memory doesn't
contain any object references.


274
00:12:56,677 --> 00:12:59,346 line:0
In this example,
calling storeBytes on a raw pointer


275
00:12:59,780 --> 00:13:02,249 line:0
extracts four bytes from a UInt32 value,


276
00:13:02,616 --> 00:13:05,919 line:0
writing them into the upper four bytes
of an in-memory Int64 value.


277
00:13:06,720 --> 00:13:08,355 line:0
When the bytes are written to memory,


278
00:13:08,422 --> 00:13:10,757 line:0
they're reinterpreted
as the memory's bound type.


279
00:13:10,824 --> 00:13:13,660 line:0
So the typed pointer that already points
to the in-memory value


280
00:13:13,727 --> 00:13:15,295 line:0
can still be used to access it.


281
00:13:16,129 --> 00:13:19,233 line:0
We cannot cast a raw pointer
back into a typed pointer


282
00:13:19,299 --> 00:13:22,035 line:0
because doing that would conflict
with the memory's bound type.


283
00:13:22,269 --> 00:13:25,305 line:0
In this case, we would end up
with both a pointer to Int64


284
00:13:25,706 --> 00:13:28,675 line:0
and a pointer to UInt32
to overlapping memory.


285
00:13:29,076 --> 00:13:31,945 line:-2
Casting from a typed pointer
is not the only way to get a raw pointer.


286
00:13:32,012 --> 00:13:35,215 line:-2
The withUnsafeBytes API
exposes a variable storage


287
00:13:35,282 --> 00:13:37,784 line:-2
as a raw buffer
for the duration of its closure.


288
00:13:38,151 --> 00:13:41,522 line:-2
UnsafeRawBufferPointer
is a collection of bytes,


289
00:13:41,588 --> 00:13:44,925 line:-2
just like UnsafeBufferPointer
is a collection of typed values.


290
00:13:45,259 --> 00:13:48,529 line:-2
Here, the buffer count is the size
in bytes of the variable's type.


291
00:13:48,595 --> 00:13:50,697 line:0
The collection index is a byte offset,


292
00:13:50,764 --> 00:13:54,234 line:0
and reading the indexed element
gives you a UInt8 value for that byte.


293
00:13:55,002 --> 00:13:57,471 line:0
You can also modify
a variable's raw storage.


294
00:13:58,105 --> 00:14:01,308 line:-2
withUnsafeMutableBytes
gives you a collection of mutable bytes


295
00:14:01,808 --> 00:14:04,912 line:0
so you can store UInt8 values
at specific byte offsets.


296
00:14:05,312 --> 00:14:08,282 line:-2
And just like array
has a withUnsafeBufferPointer method,


297
00:14:08,849 --> 00:14:10,751 line:-1
it also has a withUnsafeBytes method


298
00:14:10,817 --> 00:14:13,487 line:-2
that exposes the raw storage
for the array elements.


299
00:14:13,554 --> 00:14:17,257 line:-2
The buffer size will be the array's count
multiplied by the element stride.


300
00:14:17,591 --> 00:14:20,427 line:-2
Some of those bytes could be padding
for element alignment.


301
00:14:21,028 --> 00:14:24,565 line:-2
Foundation's data type is often used
to pass around a collection of bytes.


302
00:14:24,631 --> 00:14:26,600 line:-1
Data also has a withUnsafeBytes method


303
00:14:26,667 --> 00:14:30,003 line:-2
that exposes the underlying raw pointer
for the duration of a closure.


304
00:14:30,070 --> 00:14:33,740 line:-2
Here, we use that
to read a specific element type, UInt32,


305
00:14:33,807 --> 00:14:35,042 line:-1
at a chosen byte offset.


306
00:14:35,776 --> 00:14:37,644 line:-1
You can allocate raw memory directly


307
00:14:37,711 --> 00:14:41,915 line:-2
by calling the static allocate method
on UnsafeMutableRawPointer.


308
00:14:42,349 --> 00:14:44,117 line:-1
Here you take on the responsibility


309
00:14:44,184 --> 00:14:46,653 line:-2
to compute the memory size
and alignment in bytes.


310
00:14:47,254 --> 00:14:48,555 line:-1
After raw allocation,


311
00:14:49,022 --> 00:14:51,992 line:0
the memory state is neither initialized
nor bound to a type.


312
00:14:52,426 --> 00:14:54,428 line:0
To initialize memory with a raw pointer,


313
00:14:54,795 --> 00:14:57,764 line:0
you need to specify the type of values
that memory will hold.


314
00:14:57,831 --> 00:15:01,301 line:0
Initialization binds memory to that type
and returns a typed pointer.


315
00:15:01,902 --> 00:15:05,005 line:0
The transition to initialized memory
only goes in one direction.


316
00:15:05,072 --> 00:15:06,240 line:0
To deinitialize memory,


317
00:15:06,306 --> 00:15:08,509 line:0
you need to know the type
of in-memory values.


318
00:15:08,575 --> 00:15:11,144 line:0
So there's no way
to deinitialize with a raw pointer.


319
00:15:11,211 --> 00:15:14,648 line:0
You can deinitialize using the typed
pointer returned by initialization.


320
00:15:14,715 --> 00:15:17,618 line:0
We already saw the memory state diagram
for typed pointers.


321
00:15:17,684 --> 00:15:20,320 line:0
You can use the raw pointer
to deallocate the memory


322
00:15:20,387 --> 00:15:22,489 line:0
as long as it's in an uninitialized state.


323
00:15:22,789 --> 00:15:25,726 line:0
Deallocation doesn't care
if a memory is bound to a type or not.


324
00:15:25,792 --> 00:15:29,329 line:-2
Memory allocation with typed pointers
is safer and more convenient,


325
00:15:29,396 --> 00:15:30,797 line:-1
so that should be preferred.


326
00:15:31,365 --> 00:15:34,902 line:-2
But here's an example of why you might
want to allocate raw storage instead.


327
00:15:34,968 --> 00:15:37,070 line:0
Let's say we want to store unrelated types


328
00:15:37,137 --> 00:15:40,207 line:0
in the same contiguous block of memory
with variable length.


329
00:15:40,274 --> 00:15:43,043 line:0
After computing the total size
in bytes and the alignment,


330
00:15:43,110 --> 00:15:45,012 line:0
we call the raw version of allocate.


331
00:15:45,379 --> 00:15:48,282 line:0
That gives us a raw pointer
to a contiguous block of bytes.


332
00:15:48,615 --> 00:15:51,018 line:0
Now we can initialize part of that memory
as the header,


333
00:15:51,084 --> 00:15:52,819 line:0
giving us a pointer to the header type.


334
00:15:53,854 --> 00:15:55,622 line:0
After adding the header's byte offset,


335
00:15:55,689 --> 00:15:58,058 line:0
we can initialize
the remaining bytes to integers.


336
00:15:58,125 --> 00:16:00,027 line:0
That gives us a separate typed pointer


337
00:16:00,093 --> 00:16:02,362 line:0
to the region of memory
holding only integers.


338
00:16:02,763 --> 00:16:04,665 line:0
This storage allocation technique is great


339
00:16:04,731 --> 00:16:07,768 line:0
for implementing standard library types
like Set and Dictionary,


340
00:16:07,835 --> 00:16:09,903 line:0
but not usually something
you want to reach for.


341
00:16:09,970 --> 00:16:12,372 line:0
In general, raw pointers
are a kind of power tool


342
00:16:12,439 --> 00:16:14,608 line:0
that are good for implementing
high performance data structures,


343
00:16:14,675 --> 00:16:16,777 line:-1
but we don't want to expose them too much.


344
00:16:17,144 --> 00:16:20,180 line:-2
Fiddling with byte offsets
and data alignment is very tricky.


345
00:16:20,647 --> 00:16:23,317 line:-2
The more likely case
where you'll want to use a raw pointer


346
00:16:23,383 --> 00:16:26,220 line:-2
is when you have a buffer of bytes
that's externally generated,


347
00:16:26,286 --> 00:16:29,022 line:-2
and you want to decode those bytes
into Swift types.


348
00:16:29,089 --> 00:16:31,892 line:-2
Using UnsafeRawBufferPointer's
load API,


349
00:16:31,959 --> 00:16:34,928 line:-2
we first read a descriptor
to determine the sizes and types


350
00:16:34,995 --> 00:16:36,129 line:-1
of subsequent data.


351
00:16:36,196 --> 00:16:39,967 line:0
We follow up with more calls to
the load API at increasing byte offsets,


352
00:16:40,033 --> 00:16:43,403 line:0
each time specifying whatever type
we want to decode from the stream.


353
00:16:43,837 --> 00:16:46,807 line:-2
Raw pointers retain
an important level of type safety.


354
00:16:46,874 --> 00:16:50,110 line:-2
You take responsibility for memory layout
at the point that they're used,


355
00:16:50,177 --> 00:16:52,746 line:-2
but they don't affect when its legal
to use typed pointers,


356
00:16:52,813 --> 00:16:55,182 line:-2
so using raw pointers
does not make it more dangerous


357
00:16:55,249 --> 00:16:57,451 line:-1
to use the same memory and typed pointers.


358
00:16:57,518 --> 00:17:01,855 line:-2
At the deepest level, Swift provides APIs
that expose memory's bound type.


359
00:17:01,922 --> 00:17:03,457 line:-1
When you use these APIs,


360
00:17:03,524 --> 00:17:06,326 line:-2
you're taking all the responsibility
for pointer type safety.


361
00:17:06,393 --> 00:17:07,828 line:-1
Before jumping into these,


362
00:17:07,895 --> 00:17:10,230 line:-2
see if you can use one
of the higher-level APIs instead.


363
00:17:10,664 --> 00:17:13,666 line:-2
You'll know when you're circumventing
the enforcement of pointer types


364
00:17:13,733 --> 00:17:15,801 line:-2
because you'll need
to explicitly call an API


365
00:17:15,868 --> 00:17:17,637 line:-1
that refers to memory's bound type.


366
00:17:18,805 --> 00:17:20,707 line:-1
The danger of circumventing type safety


367
00:17:20,773 --> 00:17:23,443 line:-2
is that you can easily introduce
undefined behavior


368
00:17:23,510 --> 00:17:26,180 line:-2
somewhere else in the code
where typed pointers are used.


369
00:17:27,446 --> 00:17:29,416 line:-1
There's still just one rule to follow:


370
00:17:29,716 --> 00:17:33,187 line:-2
access to a typed pointer needs to agree
with the memory's bound type.


371
00:17:33,987 --> 00:17:36,156 line:-2
It is a simple rule,
but it's not easy to follow


372
00:17:36,223 --> 00:17:39,626 line:-2
because different parts of the code
all need to agree on memory type,


373
00:17:40,127 --> 00:17:42,095 line:-2
and the compiler
won't be able to guide you.


374
00:17:42,162 --> 00:17:45,566 line:-2
Let's look at some of the reasons
you might use such a dangerous API,


375
00:17:45,632 --> 00:17:48,268 line:-2
and pay attention
to why each of these uses is safe.


376
00:17:48,936 --> 00:17:51,905 line:-2
In rare cases,
code may not preserve a typed pointer.


377
00:17:53,040 --> 00:17:54,908 line:-1
What if we just have the raw pointer,


378
00:17:55,175 --> 00:17:57,945 line:-2
but we know with certainty
what type the memory is bound to?


379
00:17:58,312 --> 00:18:00,514 line:-2
We should be able to tell Swift
we know what we're doing


380
00:18:00,581 --> 00:18:02,049 line:-1
and get back our typed pointer.


381
00:18:02,482 --> 00:18:05,686 line:-2
In this example, we have a container
that holds raw memory,


382
00:18:06,186 --> 00:18:08,288 line:-2
but we also have a variable,
pointsToInt,


383
00:18:08,355 --> 00:18:11,258 line:-2
telling us whether the memory
can only hold integer values.


384
00:18:11,592 --> 00:18:14,294 line:-2
Calling assumingMemoryBound-to
on our raw pointer


385
00:18:14,361 --> 00:18:16,430 line:-1
and giving it the Int type as an argument


386
00:18:16,730 --> 00:18:18,832 line:-1
gives us back a typed pointer to integers.


387
00:18:19,399 --> 00:18:22,069 line:-2
We know this is safe because
when we allocated the memory,


388
00:18:22,135 --> 00:18:23,437 line:-1
it was bound to type Int.


389
00:18:23,837 --> 00:18:27,207 line:0
Only call assumingMemoryBound-to
when you can guarantee the memory


390
00:18:27,274 --> 00:18:29,409 line:0
will already be bound
to the type you want.


391
00:18:29,476 --> 00:18:31,144 line:0
It's not checked at runtime.


392
00:18:31,211 --> 00:18:33,847 line:0
It's just a way to ask the compiler
to make an assumption,


393
00:18:33,914 --> 00:18:36,350 line:0
so you're on the hook
for the correctness of that assumption.


394
00:18:36,817 --> 00:18:39,520 line:-2
Here's another example
where we need assumingMemoryBound-to.


395
00:18:39,586 --> 00:18:42,523 line:-2
This time we're calling the C API
pthread_create.


396
00:18:42,589 --> 00:18:46,793 line:-2
First we initialize a context pointer
with our custom ThreadContext type.


397
00:18:46,860 --> 00:18:50,330 line:-2
When we call pthread_create,
we pass it our context pointer.


398
00:18:50,397 --> 00:18:53,800 line:-2
But when pthread_create calls back
to our start routine in a new thread,


399
00:18:54,001 --> 00:18:55,569 line:-1
it only gives us a raw pointer.


400
00:18:56,203 --> 00:18:59,373 line:-2
The C function declares
a void star argument to the callback,


401
00:18:59,873 --> 00:19:02,910 line:-2
which gets imported
as UnsafeMutableRawPointer.


402
00:19:02,976 --> 00:19:04,811 line:-1
That sort of thing happens in C sometimes,


403
00:19:04,878 --> 00:19:07,147 line:-2
and there's no way
to make it generally type-safe.


404
00:19:07,214 --> 00:19:10,551 line:-2
In this case, we do know it's safe
to recover a typed context pointer


405
00:19:10,617 --> 00:19:12,452 line:-1
by calling assumingMemoryBound-to


406
00:19:12,853 --> 00:19:14,721 line:-2
because that's the type
we just bound memory to


407
00:19:14,788 --> 00:19:16,690 line:-1
when we allocated it a few lines above.


408
00:19:16,757 --> 00:19:20,027 line:-2
In the last couple examples,
the original pointer type was erased.


409
00:19:20,694 --> 00:19:22,496 line:-1
Sometimes we have a typed pointer,


410
00:19:22,563 --> 00:19:25,299 line:-2
but it's at the wrong level
in a composition of types.


411
00:19:25,832 --> 00:19:28,769 line:-2
Here we have a function
that takes a pointer to integers.


412
00:19:28,836 --> 00:19:30,237 line:-1
If we have a tuple of Ints,


413
00:19:30,304 --> 00:19:33,640 line:-2
we should be able to pass a pointer to
the tuple's elements into that function.


414
00:19:33,974 --> 00:19:37,578 line:-2
To get a pointer into the tuple's storage,
we need to call withUnsafePointer.


415
00:19:37,644 --> 00:19:40,013 line:-2
But that gives us back a pointer
to the tuple type,


416
00:19:40,080 --> 00:19:42,349 line:-2
which is incompatible
with our function type.


417
00:19:42,416 --> 00:19:44,685 line:-2
Memory can only be bound
to one type at a time,


418
00:19:44,751 --> 00:19:47,087 line:-2
but since the tuple type
is a composite type,


419
00:19:47,154 --> 00:19:50,324 line:-2
binding memory to a tuple type
also binds it to the element types.


420
00:19:50,390 --> 00:19:54,094 line:-2
So, we know using a pointer to integers
for the tuple's storage is type-safe,


421
00:19:54,695 --> 00:19:57,898 line:-2
but we need to use a type-unsafe API
to get that pointer type.


422
00:19:57,965 --> 00:19:59,600 line:-1
First we construct a raw pointer,


423
00:19:59,666 --> 00:20:02,169 line:-2
deliberately erasing the type
of our tuple pointer.


424
00:20:02,703 --> 00:20:04,538 line:-1
Then we can use assumingMemoryBound-to,


425
00:20:04,605 --> 00:20:07,708 line:0
just like we did before,
to create a pointer to integers.


426
00:20:08,308 --> 00:20:10,477 line:0
Lowering a pointer down
to a member type like this


427
00:20:10,544 --> 00:20:13,013 line:0
requires knowing the layout
of the composite type.


428
00:20:13,313 --> 00:20:14,982 line:0
Swift's implementation does guarantee


429
00:20:15,048 --> 00:20:17,551 line:0
that tuples whose elements
are all the same type


430
00:20:17,618 --> 00:20:20,554 line:0
are laid out in a standard pattern,
one value after another,


431
00:20:20,621 --> 00:20:22,589 line:0
according to the stride
of the element type.


432
00:20:22,656 --> 00:20:25,158 line:-2
Let's look at how this applies
to struct properties.


433
00:20:25,759 --> 00:20:28,462 line:-2
Once again, we have a function
that takes a pointer to integers.


434
00:20:28,529 --> 00:20:32,232 line:-2
This time, instead of a tuple,
we have a struct with an integer property.


435
00:20:32,299 --> 00:20:35,702 line:-2
withUnsafePointer gives us
a typed pointer to our outer struct.


436
00:20:35,769 --> 00:20:37,638 line:-1
Using the MemoryLayout API,


437
00:20:37,704 --> 00:20:40,407 line:-2
we compute the byte offset
of the value property.


438
00:20:40,474 --> 00:20:42,743 line:-2
By casting the struct pointer
down to a raw pointer


439
00:20:42,809 --> 00:20:44,411 line:-1
and adding that byte offset,


440
00:20:44,478 --> 00:20:46,580 line:-2
we get a raw pointer
to the value property.


441
00:20:46,947 --> 00:20:50,217 line:-2
A property's memory is always bound
to the property's declared type,


442
00:20:50,284 --> 00:20:52,286 line:-2
so it's safe to call
assumingMemoryBound-to


443
00:20:52,352 --> 00:20:53,954 line:-1
to get a pointer to an integer.


444
00:20:54,021 --> 00:20:57,057 line:0
In general, the layout
of struct properties is not guaranteed,


445
00:20:57,491 --> 00:20:59,393 line:0
so when you get a pointer
to a struct property,


446
00:20:59,459 --> 00:21:02,663 line:0
you can only use it to point
to a single value for that property.


447
00:21:02,729 --> 00:21:05,032 line:-2
Pointing to struct properties is common,
so, fortunately,


448
00:21:05,098 --> 00:21:07,968 line:-2
there's an easy alternative
that avoids unsafe APIs.


449
00:21:08,035 --> 00:21:10,170 line:-2
When you pass the property
as an inout argument,


450
00:21:10,237 --> 00:21:13,140 line:-2
the compiler implicitly converts it
to the unsafe pointer type


451
00:21:13,207 --> 00:21:15,108 line:-1
declared for that function argument.


452
00:21:15,175 --> 00:21:17,277 line:-2
assumingMemoryBound-to
tells the compiler


453
00:21:17,344 --> 00:21:20,013 line:-2
to make an unchecked assumption
about the memory's bound type.


454
00:21:20,080 --> 00:21:23,383 line:-2
The bindMemory API actually lets you
change memory's bound type.


455
00:21:23,450 --> 00:21:26,086 line:-2
If the memory location
was not already bound to a type,


456
00:21:26,153 --> 00:21:28,055 line:-1
it just binds the type for the first time.


457
00:21:28,121 --> 00:21:31,191 line:-2
If the memory is already bound to a type,
then it rebinds the type,


458
00:21:31,258 --> 00:21:34,061 line:-2
and whatever values were in memory
take on the new type.


459
00:21:34,461 --> 00:21:37,865 line:-2
Say we allocate a block of memory
to hold two UInt16 values.


460
00:21:38,165 --> 00:21:40,534 line:-2
Then we ask for a raw pointer
to that block of memory.


461
00:21:40,601 --> 00:21:42,769 line:-2
By calling bindMemory
on that raw pointer,


462
00:21:42,836 --> 00:21:46,106 line:-2
we change the type in place
to a single Int32 value.


463
00:21:46,173 --> 00:21:47,708 line:-1
This is just a bitwise conversion,


464
00:21:47,774 --> 00:21:51,311 line:-2
so you don't get any of the safety checks
that happen with normal type conversion.


465
00:21:51,378 --> 00:21:53,580 line:-2
In fact,
nothing needs to happen at runtime.


466
00:21:54,081 --> 00:21:56,316 line:-2
bindMemory is really a declaration
to the compiler


467
00:21:56,383 --> 00:21:58,852 line:-2
that the type has changed
at that memory location.


468
00:21:59,319 --> 00:22:01,421 line:0
bindMemory returns an Int32 pointer


469
00:22:01,488 --> 00:22:03,323 line:0
that should be used
to access the memory now.


470
00:22:03,390 --> 00:22:05,993 line:0
Accessing the old UInt16 pointer
is undefined.


471
00:22:06,660 --> 00:22:08,095 line:0
At any single point in the program,


472
00:22:08,161 --> 00:22:10,664 line:0
a memory location
is only bound to a single type.


473
00:22:10,731 --> 00:22:13,867 line:-2
Changing the memory's bound type
doesn't physically modify memory,


474
00:22:13,934 --> 00:22:16,403 line:-2
but you should still think of it
as changing a global property


475
00:22:16,470 --> 00:22:17,471 line:-1
of the memory state.


476
00:22:17,938 --> 00:22:19,873 line:-1
This isn't type-safe for two reasons.


477
00:22:19,940 --> 00:22:22,442 line:-2
First, it reinterprets
the raw bytes in place.


478
00:22:22,509 --> 00:22:24,678 line:-2
So, just like
when you're using a raw pointer,


479
00:22:24,745 --> 00:22:26,613 line:-2
you're taking responsibility
away from Swift


480
00:22:26,680 --> 00:22:28,382 line:-1
for the layout of types in memory.


481
00:22:28,749 --> 00:22:31,685 line:-2
But rebinding memory is more dangerous
than using raw pointers


482
00:22:31,752 --> 00:22:34,521 line:-2
because it also invalidates
existing typed pointers.


483
00:22:34,588 --> 00:22:36,089 line:-1
Their pointer address is still valid,


484
00:22:36,156 --> 00:22:39,426 line:-2
but accessing them is undefined
while memory is bound to the wrong type.


485
00:22:39,760 --> 00:22:42,629 line:-2
When you have a pointer into storage
for an object with a declared type,


486
00:22:42,696 --> 00:22:45,032 line:-2
like variables, arrays,
and other collection types,


487
00:22:45,098 --> 00:22:48,502 line:-2
using that pointer to rebind memory
can invalidate the object itself.


488
00:22:48,969 --> 00:22:52,806 line:-2
The bindMemory API is really
a low-level language primitive in Swift.


489
00:22:53,307 --> 00:22:55,075 line:-1
It's not intended for regular code.


490
00:22:55,943 --> 00:22:59,713 line:-2
In reality, though, there are situations
where you want to rebind the memory type.


491
00:23:00,347 --> 00:23:02,716 line:-2
This happens when you have
multiple external APIs


492
00:23:02,783 --> 00:23:04,985 line:-1
that disagree on the type of some data,


493
00:23:05,052 --> 00:23:07,254 line:-2
and you want to avoid
copying the data back and forth.


494
00:23:07,321 --> 00:23:09,556 line:-2
It's something that tends
to come up with C APIs


495
00:23:09,623 --> 00:23:12,392 line:-2
where pointer type safety
was not carefully considered.


496
00:23:12,459 --> 00:23:15,362 line:-2
Here we have a function
that takes a UInt8 pointer,


497
00:23:15,429 --> 00:23:17,631 line:-2
and we have pointer
into memory of type Int8.


498
00:23:18,031 --> 00:23:19,466 line:-1
Swift enforces pointer types,


499
00:23:19,533 --> 00:23:22,035 line:-2
so it won't let us pass that pointer
into that function.


500
00:23:22,102 --> 00:23:25,973 line:-2
We could allocate a new block of memory
with the correct type and copy the data.


501
00:23:26,340 --> 00:23:29,109 line:-2
That's safe
with regard to pointer types but slower.


502
00:23:29,176 --> 00:23:32,279 line:-2
Since we only need to reinterpret memory
for the duration of a call,


503
00:23:32,346 --> 00:23:35,148 line:-2
we can use Swift's
withMemoryRebound to API.


504
00:23:35,716 --> 00:23:38,952 line:-2
Just like with UnsafePointer,
withMemoryRebound to


505
00:23:39,019 --> 00:23:42,489 line:-2
gives you a pointer that's guaranteed
to be valid for the scope of its closure.


506
00:23:42,556 --> 00:23:44,825 line:-2
We know it's safe to rebind memory
within the closure


507
00:23:44,892 --> 00:23:48,061 line:0
because our Int8 pointer
isn't used anywhere inside the closure.


508
00:23:48,128 --> 00:23:49,329 line:0
When the closure returns,


509
00:23:49,396 --> 00:23:53,233 line:0
withMemoryRebound to rebinds memory
back to the original Int8 type.


510
00:23:53,300 --> 00:23:56,637 line:0
This makes it independent of typed
pointer access in surrounding code.


511
00:23:56,703 --> 00:23:58,038 line:0
We can prove it's safe to use


512
00:23:58,105 --> 00:24:00,440 line:0
just by reasoning about the code
within the closure.


513
00:24:00,741 --> 00:24:03,810 line:-2
The withMemoryRebound to API
makes binding memory safe


514
00:24:03,877 --> 00:24:05,612 line:-1
with respect to surrounding code,


515
00:24:05,679 --> 00:24:07,247 line:-1
but it has some strict limitations.


516
00:24:07,314 --> 00:24:10,250 line:-2
Because of these, you still may
need to call bindMemory directly.


517
00:24:10,317 --> 00:24:13,720 line:-2
When you do that, use the same
technique to reason about safety.


518
00:24:13,787 --> 00:24:16,590 line:-2
Only use bindMemory to get a pointer
within a controlled scope


519
00:24:16,657 --> 00:24:19,760 line:-2
where you know the code isn't accessing
the same memory with an old pointer.


520
00:24:19,826 --> 00:24:23,096 line:-2
When the scope ends, make sure
to rebind memory back to the original type


521
00:24:23,163 --> 00:24:25,132 line:-2
before other code
can access the same memory


522
00:24:25,199 --> 00:24:27,134 line:-1
using a previously obtained pointer.


523
00:24:27,201 --> 00:24:29,570 line:-1
Let's recap the memory-binding APIs.


524
00:24:30,003 --> 00:24:32,005 line:-2
assumingMemoryBound-to
is the intended way


525
00:24:32,072 --> 00:24:34,308 line:-2
to recover a typed pointer
from a raw pointer.


526
00:24:34,374 --> 00:24:37,878 line:-2
It's dangerous because you need to know
the memory is already bound to that type.


527
00:24:38,145 --> 00:24:39,847 line:-1
bindMemory is a low-level primitive


528
00:24:39,913 --> 00:24:41,982 line:-2
that changes the memory's
bound type state.


529
00:24:42,416 --> 00:24:45,152 line:-2
It's especially dangerous
because it can cause undefined behavior


530
00:24:45,219 --> 00:24:47,855 line:0
when typed pointers are accessed
elsewhere in the code.


531
00:24:47,921 --> 00:24:50,190 line:0
withMemoryRebound to is a much safer way


532
00:24:50,257 --> 00:24:52,593 line:0
to temporarily bind memory
when it's necessary.


533
00:24:52,659 --> 00:24:55,462 line:0
It's useful for calling C APIs
that disagree on types


534
00:24:55,863 --> 00:24:57,764 line:0
without copying the underlying memory.


535
00:24:58,765 --> 00:25:00,868 line:-2
The most common misuse
of the bindMemory API


536
00:25:00,934 --> 00:25:03,203 line:-2
is simply to read a different type
from memory.


537
00:25:03,270 --> 00:25:06,773 line:-2
This code calls bindMemory to get
a pointer of the type it wants to read.


538
00:25:06,840 --> 00:25:09,343 line:-2
That typed pointer
is only needed to read a value.


539
00:25:09,943 --> 00:25:11,879 line:-2
But in the process
of creating that pointer,


540
00:25:11,945 --> 00:25:15,148 line:-2
we've changed memory state
and probably invalidated other pointers.


541
00:25:15,215 --> 00:25:17,184 line:-1
When you just want to reinterpret a type,


542
00:25:17,251 --> 00:25:19,920 line:-2
UnsafeRawPointer's load API
is a solution


543
00:25:19,987 --> 00:25:22,055 line:-1
that avoids the pitfalls of pointer type.


544
00:25:22,122 --> 00:25:24,825 line:-2
You only need to take responsibility
for memory layout.


545
00:25:25,092 --> 00:25:26,994 line:-1
The solution works wherever you need it,


546
00:25:27,060 --> 00:25:30,631 line:0
so if you have a typed pointer to the
memory, you can cast it to a raw pointer.


547
00:25:30,898 --> 00:25:33,567 line:0
And if you have a variable,
an array, or a Data object,


548
00:25:34,034 --> 00:25:37,738 line:0
the withUnsafeBytes method
directly gives you access to a raw buffer.


549
00:25:37,804 --> 00:25:39,740 line:-2
Let's say you want to view
a region of memory


550
00:25:39,806 --> 00:25:42,409 line:-2
as sequence of elements
with a specific element type,


551
00:25:43,110 --> 00:25:45,913 line:-2
but the underlying storage
is exposed as a raw pointer


552
00:25:45,979 --> 00:25:48,916 line:-2
and may be viewed as different types
by different parts of the code.


553
00:25:48,982 --> 00:25:51,618 line:-2
You could easily create a wrapper
around that raw pointer


554
00:25:51,685 --> 00:25:53,187 line:-1
to preserve your element type.


555
00:25:53,253 --> 00:25:54,721 line:-1
Let's call it a BufferView.


556
00:25:54,788 --> 00:25:56,490 line:-1
We'll add the Unsafe prefix to the name,


557
00:25:56,557 --> 00:25:58,425 line:-2
so we don't need to
automatically manage memory


558
00:25:58,492 --> 00:26:00,928 line:-2
and we'll limit boundary checks
to the debug build.


559
00:26:00,994 --> 00:26:02,930 line:-1
To create a BufferView over a raw buffer,


560
00:26:02,996 --> 00:26:05,199 line:-2
we compute the number of elements
that fit in the buffer


561
00:26:05,265 --> 00:26:06,667 line:-1
based on the element stride.


562
00:26:07,100 --> 00:26:09,570 line:-2
And of course,
we add preconditions to verify


563
00:26:09,636 --> 00:26:11,972 line:-2
the buffer has the correct number
of bytes and alignment.


564
00:26:12,039 --> 00:26:15,142 line:-2
Now, to read an indexed element,
we just compute its byte offset


565
00:26:15,209 --> 00:26:17,611 line:-2
and ask the raw buffer
to load our element type.


566
00:26:17,678 --> 00:26:21,281 line:-2
Since loading from raw memory
is safe with respect to pointer types,


567
00:26:21,348 --> 00:26:24,318 line:-2
we don't need to worry about
how other code views the same memory.


568
00:26:24,384 --> 00:26:27,821 line:-2
Our BufferView lets us reinterpret
the sequence of bytes safely,


569
00:26:27,888 --> 00:26:31,358 line:-2
while retaining the element type,
so there's no need to use a typed pointer.


570
00:26:31,425 --> 00:26:34,962 line:-2
To end, let's review our strategies
for handling pointer types.


571
00:26:35,028 --> 00:26:38,198 line:-2
The best strategy is to avoid
using pointers whenever you can.


572
00:26:39,666 --> 00:26:41,468 line:-1
In the rare case you need to reinterpret


573
00:26:41,535 --> 00:26:43,704 line:-2
the same memory location
as a different type,


574
00:26:43,770 --> 00:26:45,172 line:-1
you should choose carefully.


575
00:26:46,006 --> 00:26:49,276 line:-2
Since typed pointers always need to match
the memory's bound type,


576
00:26:49,743 --> 00:26:52,045 line:-2
it's best not to use them
to reinterpret types.


577
00:26:52,946 --> 00:26:54,515 line:-1
This can be hard to remember though


578
00:26:54,581 --> 00:26:57,518 line:-2
because C code often handles this
by casting pointer types.


579
00:26:58,685 --> 00:27:02,389 line:-2
Instead, Swift provides APIs based
on raw pointers for that purpose.


580
00:27:03,390 --> 00:27:05,893 line:-2
These are useful APIs
even in pure Swift code.


581
00:27:06,660 --> 00:27:09,830 line:-2
For example, you may need to
decode values from a byte stream.


582
00:27:10,664 --> 00:27:12,966 line:-2
Or you might implement
a container like Set or Dictionary


583
00:27:13,033 --> 00:27:15,302 line:-2
that holds different types
in contiguous memory.


584
00:27:15,369 --> 00:27:18,639 line:-2
I hope you enjoyed hearing
about pointer type safety in Swift


585
00:27:18,705 --> 00:27:21,175 line:-2
and can see
it's not as mysterious as it may look.


586
00:27:21,508 --> 00:27:22,676 line:-1
Thanks for watching.

