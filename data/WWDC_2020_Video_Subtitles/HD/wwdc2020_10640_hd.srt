1
00:00:03,670 --> 00:00:06,840 line:-1
Hello and welcome to WWDC.


2
00:00:08,542 --> 00:00:12,846 line:0
Hi, everyone. I'm Brandon Walkin,
a designer on the Apple Design Team.


3
00:00:12,913 --> 00:00:16,283 line:-2
I'll be joined later
by other designers on the team:


4
00:00:16,350 --> 00:00:20,721 line:-1
Marcos Alonso, CC Wan, and Dylan Edwards.


5
00:00:20,787 --> 00:00:24,157 line:-2
We're going to talk about how to design
for the new pointer in iPadOS.


6
00:00:24,224 --> 00:00:25,792 line:-1
Today, we're going to talk about


7
00:00:25,859 --> 00:00:28,061 line:-2
the design principles
behind the new pointer,


8
00:00:28,128 --> 00:00:30,330 line:-2
go behind the scenes
and take a look at how it works


9
00:00:30,397 --> 00:00:32,198 line:-1
and the different effects you can use.


10
00:00:32,266 --> 00:00:34,635 line:-2
Then we'll talk about
the appearance of the pointer,


11
00:00:34,701 --> 00:00:38,405 line:-2
how to make a custom pointer shape,
using pointer interactions,


12
00:00:38,472 --> 00:00:41,842 line:-2
and how to make your app work great
with gestures on the trackpad.


13
00:00:41,909 --> 00:00:45,145 line:-2
Let's start off with some of the thinking
behind the new pointer.


14
00:00:47,381 --> 00:00:51,818 line:0
The iPad works great with touch,
so why would we want to add pointing?


15
00:00:51,885 --> 00:00:54,454 line:0
Well, one of the reasons is ergonomics.


16
00:00:54,521 --> 00:00:56,356 line:-1
Adding trackpad capability


17
00:00:56,423 --> 00:00:58,892 line:-2
allows people to have
a more comfortable experience


18
00:00:58,959 --> 00:01:01,828 line:-2
where they can leave their hands
on the same plane as the keyboard,


19
00:01:01,895 --> 00:01:04,965 line:-2
instead of having to frequently reach up
to touch the screen.


20
00:01:05,032 --> 00:01:07,367 line:-2
We also wanted to make
editing text easier.


21
00:01:07,434 --> 00:01:10,070 line:-2
Editing text
requires a lot of fine manipulation,


22
00:01:10,137 --> 00:01:12,506 line:-2
and since the finger
is a coarse-grained input,


23
00:01:12,573 --> 00:01:15,342 line:-2
it's more difficult to position
the text cursor and make a selection


24
00:01:15,409 --> 00:01:17,945 line:-1
compared to using a trackpad or a mouse.


25
00:01:18,011 --> 00:01:21,715 line:-2
What's the best way to let people
control the interface using the trackpad?


26
00:01:21,782 --> 00:01:26,086 line:-2
iPad is unique in that its interface
was fundamentally designed for touch.


27
00:01:26,153 --> 00:01:31,058 line:-2
Hit areas are generous so they can support
being easily tapped with the finger,


28
00:01:31,124 --> 00:01:35,529 line:-2
and buttons are spaced further apart
to avoid accidental mis-taps.


29
00:01:35,596 --> 00:01:38,932 line:-2
We looked at just bringing the traditional
arrow pointer over from the Mac,


30
00:01:38,999 --> 00:01:41,735 line:-1
but that didn't feel quite right on iPadOS


31
00:01:41,802 --> 00:01:44,538 line:-2
where the entire operating system
and every app


32
00:01:44,605 --> 00:01:47,841 line:-2
is designed to be used
by an input the size of a fingertip.


33
00:01:47,908 --> 00:01:52,212 line:-2
You'd be using a high-precision tool
to interact with low-precision controls.


34
00:01:52,813 --> 00:01:56,316 line:-2
This got us thinking more deeply
about the concept of precision.


35
00:01:56,383 --> 00:02:00,854 line:-2
The traditional arrow pointer can move
very precisely over the whole screen.


36
00:02:00,921 --> 00:02:03,557 line:-1
This is great for certain tasks.


37
00:02:03,624 --> 00:02:08,294 line:-2
Say you're making a marquee selection
to edit a particular section of an image,


38
00:02:08,362 --> 00:02:11,765 line:-2
or maybe you're trying to select some text
from the middle of a paragraph.


39
00:02:11,832 --> 00:02:14,468 line:-2
In these cases,
it's helpful to have very precise control


40
00:02:14,535 --> 00:02:16,136 line:-1
over where the pointer is onscreen


41
00:02:16,203 --> 00:02:18,839 line:-2
so you can place it
just where you want it.


42
00:02:18,906 --> 00:02:22,009 line:-2
But this high level of precision
also has some downsides.


43
00:02:22,075 --> 00:02:25,045 line:-2
Most of us are experts at using mice
and trackpads


44
00:02:25,112 --> 00:02:28,015 line:-2
and aren't conscious of this,
but the traditional pointer


45
00:02:28,081 --> 00:02:31,185 line:-2
actually requires
a lot of physical dexterity to use.


46
00:02:31,251 --> 00:02:34,922 line:-2
Say you're trying to click a button
and you quickly move the pointer there


47
00:02:34,988 --> 00:02:39,593 line:-2
but end up clicking just a few pixels
above the button and nothing happens.


48
00:02:39,660 --> 00:02:42,129 line:-2
Or maybe you end up clicking
between two buttons,


49
00:02:42,196 --> 00:02:44,464 line:-1
and neither is activated.


50
00:02:44,531 --> 00:02:47,601 line:-2
Or say you intend
to click the pause button


51
00:02:47,668 --> 00:02:50,537 line:-2
and end up
rewinding to the beginning of the track.


52
00:02:50,604 --> 00:02:53,073 line:-2
Let's take a close look
at what's happening here.


53
00:02:53,140 --> 00:02:57,077 line:-2
There are two independent layers
that are interacting with each other:


54
00:02:57,144 --> 00:02:59,746 line:-2
the interface layer
and the pointing layer.


55
00:02:59,813 --> 00:03:03,083 line:-2
The traditional pointer
moves at pixel-level precision.


56
00:03:03,150 --> 00:03:06,220 line:-2
You can place it
on any pixel of the interface.


57
00:03:06,286 --> 00:03:10,057 line:-2
But the underlying interface
is built out of three button regions.


58
00:03:10,123 --> 00:03:13,560 line:-2
It only cares which of the three
playback buttons you click,


59
00:03:13,627 --> 00:03:16,530 line:-2
not the precise pixel coordinate
you click on a button.


60
00:03:17,331 --> 00:03:20,634 line:-2
There's an inconsistency
between the precision of the pointer


61
00:03:20,701 --> 00:03:23,070 line:-1
and the precision required by the app.


62
00:03:23,136 --> 00:03:25,772 line:-2
So, while people
generally think about the pointer


63
00:03:25,839 --> 00:03:29,009 line:-2
in terms of giving you increased precision
compared to touch,


64
00:03:29,076 --> 00:03:32,746 line:-2
in this case, it's helpful to actually
reduce the precision of the pointer


65
00:03:32,813 --> 00:03:34,815 line:-1
to match the user interface.


66
00:03:34,882 --> 00:03:38,318 line:-2
This concept of dynamically adjusting
the precision of the pointer


67
00:03:38,385 --> 00:03:43,190 line:0
to match the precision of the interface
is called adaptive precision.


68
00:03:43,257 --> 00:03:45,492 line:0
Let's look at
how adaptive precision works.


69
00:03:46,260 --> 00:03:48,795 line:-1
The pointer starts off as a circle.


70
00:03:48,862 --> 00:03:51,798 line:-2
This is its default state
when the pointing system isn't aware


71
00:03:51,865 --> 00:03:55,302 line:-2
of any particular level of precision
of the interface around it.


72
00:03:57,004 --> 00:03:59,339 line:-1
It's sized to match a fingertip,


73
00:03:59,406 --> 00:04:03,610 line:-2
since everything you're interacting with
on iPad must be usable with touch.


74
00:04:03,677 --> 00:04:06,446 line:-2
When you move the pointer
to a group of buttons,


75
00:04:06,513 --> 00:04:10,250 line:-2
the pointer will adjust itself
to match the precision of the buttons.


76
00:04:10,317 --> 00:04:13,053 line:-2
As I move the pointer
into the group of buttons,


77
00:04:13,120 --> 00:04:14,721 line:-1
it snaps itself to the button


78
00:04:14,788 --> 00:04:17,524 line:-2
while morphing its shape
to the shape of the button.


79
00:04:17,591 --> 00:04:21,894 line:-2
The change in shape indicates
its new reduced level of precision.


80
00:04:21,962 --> 00:04:25,799 line:-2
As I move between them, the pointer
will always snap itself to a button,


81
00:04:25,866 --> 00:04:28,836 line:-2
making it clear
exactly which one I'm interacting with.


82
00:04:29,570 --> 00:04:31,438 line:-1
This feedback you get from the pointer


83
00:04:31,505 --> 00:04:34,174 line:-2
reduces the likelihood
that you'll mis-click.


84
00:04:34,575 --> 00:04:37,144 line:-2
You'll also notice
that the pointer highlights the element


85
00:04:37,211 --> 00:04:38,579 line:-1
rather than obscuring it.


86
00:04:39,713 --> 00:04:42,716 line:-2
A traditional pointer is drawn
over the entire interface,


87
00:04:42,783 --> 00:04:45,319 line:-2
often obscuring the control
you're interacting with.


88
00:04:45,953 --> 00:04:48,755 line:0
We thought it was important to have
the controls you're interacting with


89
00:04:48,822 --> 00:04:50,557 line:0
completely unobstructed.


90
00:04:50,624 --> 00:04:53,360 line:-2
In fact,
when the pointer snaps to a control,


91
00:04:53,427 --> 00:04:56,530 line:-2
the pointer actually moves
along the Z-axis


92
00:04:56,597 --> 00:05:01,301 line:-2
from being in front of the app to being
behind the button's icon or label.


93
00:05:01,368 --> 00:05:04,238 line:0
This lets people see
the true color of the icon.


94
00:05:04,304 --> 00:05:06,840 line:0
The icon on the left
with the pointer behind it


95
00:05:06,907 --> 00:05:09,243 line:0
has the brightness level
that the designer intended.


96
00:05:10,010 --> 00:05:12,980 line:-2
Now, let's look at how
the pointer interacts with text.


97
00:05:13,981 --> 00:05:17,084 line:-2
You may have run into this issue before,
where you try to select some text


98
00:05:17,150 --> 00:05:20,521 line:-2
and you end up selecting the line
just above or below


99
00:05:20,587 --> 00:05:22,189 line:-1
the one you're aiming for.


100
00:05:22,256 --> 00:05:24,725 line:-2
Here I'm trying to select
the word "environment"


101
00:05:24,791 --> 00:05:26,994 line:-2
but I've started my click
just slightly too high


102
00:05:27,060 --> 00:05:28,962 line:-1
and selected the line above.


103
00:05:29,029 --> 00:05:30,197 line:-1
Why does this happen?


104
00:05:30,264 --> 00:05:33,567 line:-2
Well, the traditional I-beam pointer
moves up and down


105
00:05:33,634 --> 00:05:38,272 line:-2
at pixel-level precision,
letting you click on individual pixels.


106
00:05:38,338 --> 00:05:43,710 line:-2
However, the text view behind it
only cares about line-level precision:


107
00:05:43,777 --> 00:05:46,680 line:-2
which specific line of text
you're clicking on.


108
00:05:46,747 --> 00:05:48,582 line:-1
Let's zoom in a little closer.


109
00:05:48,649 --> 00:05:51,652 line:-2
There's an invisible boundary
just above the line of text


110
00:05:51,718 --> 00:05:55,923 line:-2
where if I move my pointer
just a single pixel over the boundary,


111
00:05:55,989 --> 00:05:59,593 line:-2
the text view will think
I'm interacting with the line above.


112
00:05:59,660 --> 00:06:01,795 line:-2
This inconsistency
between the input precision


113
00:06:01,862 --> 00:06:03,197 line:-1
and the interface precision


114
00:06:03,263 --> 00:06:06,233 line:-2
is what leads people to mis-click
and select the wrong text.


115
00:06:06,300 --> 00:06:08,468 line:-2
Now let's unify
the precision of the pointer


116
00:06:08,535 --> 00:06:11,605 line:-2
and the text view together
with adaptive precision.


117
00:06:12,372 --> 00:06:14,541 line:-1
As the pointer moves over the text view,


118
00:06:14,608 --> 00:06:17,578 line:-2
it morphs from the circle pointer
to a beam shape


119
00:06:17,644 --> 00:06:20,013 line:-1
that matches the line height of the text,


120
00:06:20,080 --> 00:06:22,449 line:-1
its new level of vertical precision.


121
00:06:22,516 --> 00:06:26,153 line:-2
As you move the pointer up and down,
it snaps to each line of text,


122
00:06:26,220 --> 00:06:28,956 line:-2
making it clear
which line you're interacting with.


123
00:06:29,022 --> 00:06:32,159 line:-2
In fact, the pointing system
makes it impossible


124
00:06:32,226 --> 00:06:35,529 line:-2
to place the pointer in
an ambiguous position between two lines.


125
00:06:36,430 --> 00:06:38,632 line:-2
You can give the pointer
a different amount of precision


126
00:06:38,699 --> 00:06:40,267 line:-1
for each axis.


127
00:06:40,334 --> 00:06:43,737 line:-2
So, when you move horizontally,
we give you pixel-level precision


128
00:06:43,804 --> 00:06:46,306 line:-2
so you can place the insertion point
just where you want it


129
00:06:46,373 --> 00:06:47,708 line:-1
and make your selection.


130
00:06:49,409 --> 00:06:53,614 line:-2
So, we showed how the pointer
snaps to buttons and lines of text.


131
00:06:53,680 --> 00:06:58,418 line:-2
You get both of these behaviors for free
if you use our standard UIKit controls.


132
00:06:58,485 --> 00:07:02,489 line:-2
But let's look at an example of when
you'd want to use adaptive precision


133
00:07:02,556 --> 00:07:04,958 line:-1
in a view that's custom for your app.


134
00:07:05,025 --> 00:07:09,663 line:-2
Here, we have a scheduling app that
lets you manage events over a day view.


135
00:07:09,730 --> 00:07:12,966 line:-2
You make new events
by clicking and dragging on the day view.


136
00:07:13,033 --> 00:07:14,635 line:-1
It's common for these types of interfaces


137
00:07:14,701 --> 00:07:17,671 line:-2
to round the start times of the events
to 15-minute intervals.


138
00:07:19,139 --> 00:07:22,876 line:-2
So, instead of your click and drag
starting a meeting at 9:41, for example,


139
00:07:22,943 --> 00:07:24,811 line:-1
which is an odd time to start a meeting,


140
00:07:24,878 --> 00:07:27,881 line:-2
it'll round it to a more common start time
of 9:45.


141
00:07:28,815 --> 00:07:32,085 line:-2
While this is a helpful behavior,
it often results in errors


142
00:07:32,152 --> 00:07:34,955 line:-2
where you're trying to make an event
that starts at a certain time.


143
00:07:35,656 --> 00:07:38,292 line:-2
Say you're trying to make an event
that starts at 2:30,


144
00:07:38,358 --> 00:07:41,662 line:-2
but the interface ends up interpreting
that click as 2:15,


145
00:07:41,728 --> 00:07:44,298 line:-1
resulting in a frustrating experience.


146
00:07:44,364 --> 00:07:46,033 line:-1
It turns out what's happening here


147
00:07:46,099 --> 00:07:48,969 line:-2
is exactly the same issue
as with the text view.


148
00:07:49,503 --> 00:07:52,739 line:-2
Just like with the text view,
the vertical precision of the pointer


149
00:07:52,806 --> 00:07:56,310 line:-2
is different than the vertical precision
of the interface.


150
00:07:56,376 --> 00:08:00,013 line:-2
The pointer is letting you start a drag
at any pixel onscreen,


151
00:08:00,080 --> 00:08:04,685 line:-2
but the interface only accepts drags
starting within 15-minute blocks.


152
00:08:04,751 --> 00:08:08,021 line:-2
And the boundaries of these blocks
aren't exposed to you,


153
00:08:08,088 --> 00:08:10,457 line:-1
so it's not clear what'll happen on click.


154
00:08:10,524 --> 00:08:13,193 line:-2
And from a design perspective,
it may be distracting


155
00:08:13,260 --> 00:08:16,430 line:-2
to visualize these regions
using divider lines or hover states.


156
00:08:17,097 --> 00:08:18,765 line:-1
Let's use adaptive precision


157
00:08:18,832 --> 00:08:22,135 line:-2
to customize the precision of the pointer
to match the day view.


158
00:08:22,202 --> 00:08:23,904 line:-1
Now as you move up and down,


159
00:08:23,971 --> 00:08:27,374 line:-2
the pointer is always snapped
to a 15-minute interval,


160
00:08:27,441 --> 00:08:30,410 line:-2
making it clear
what time the event will begin.


161
00:08:30,477 --> 00:08:34,715 line:-2
When you move quickly, you can
just barely tell that it's snapping.


162
00:08:34,780 --> 00:08:36,149 line:-1
But when you slow down,


163
00:08:36,216 --> 00:08:39,453 line:-2
you really feel it snap
to those time blocks.


164
00:08:39,520 --> 00:08:43,657 line:-2
Here, adaptive precision makes it easy to
start an event at just the time you want,


165
00:08:43,724 --> 00:08:47,461 line:-2
and reduces potential errors
you'd see with a traditional pointer.


166
00:08:47,528 --> 00:08:49,196 line:0
So that's adaptive precision.


167
00:08:50,397 --> 00:08:53,567 line:0
Now let's take a look at how
the pointer works behind the scenes.


168
00:08:53,634 --> 00:08:58,705 line:-2
When you move the pointer around onscreen,
you're actually moving two pointers:


169
00:08:58,772 --> 00:09:00,440 line:-1
the one you see onscreen,


170
00:09:00,507 --> 00:09:04,945 line:-2
and an invisible one that tracks
the true position of the pointer.


171
00:09:05,012 --> 00:09:07,147 line:-1
We call this the model pointer.


172
00:09:07,848 --> 00:09:12,519 line:-2
The model pointer is used to decide
which item the pointer is hovering over,


173
00:09:12,586 --> 00:09:14,421 line:-2
and it takes advantage
of the generous padding


174
00:09:14,488 --> 00:09:16,390 line:-1
that buttons have on iPadOS


175
00:09:16,456 --> 00:09:18,525 line:-2
to make them easier to tap
with the finger.


176
00:09:18,592 --> 00:09:20,260 line:-1
Let’s see this in action.


177
00:09:21,028 --> 00:09:25,199 line:-2
Once the true pointer position
reaches the edge of the button’s hit area,


178
00:09:25,265 --> 00:09:28,302 line:-2
it begins to move
and resize to highlight the button.


179
00:09:29,236 --> 00:09:33,006 line:-2
This effect of animating the pointer
towards the button is called "snapping."


180
00:09:34,074 --> 00:09:37,544 line:-2
Now, the pointer doesn’t actually move
to the center of the button at this point,


181
00:09:37,611 --> 00:09:39,246 line:-1
though it may appear that way.


182
00:09:39,313 --> 00:09:43,617 line:-2
The true position of the pointer
still remains on the edge of the button,


183
00:09:43,684 --> 00:09:46,653 line:-2
and this is indicated
with a parallax effect.


184
00:09:46,720 --> 00:09:50,324 line:-2
We do this so the amount
the true pointer position moves onscreen


185
00:09:50,390 --> 00:09:53,961 line:-2
is always based on how much movement
you apply to the trackpad,


186
00:09:54,027 --> 00:09:55,762 line:-1
making it feel more predictable.


187
00:09:57,064 --> 00:09:59,533 line:-2
As you move the pointer
along a set of buttons,


188
00:09:59,600 --> 00:10:02,202 line:-2
the visible pointer
will animate to the next button


189
00:10:02,269 --> 00:10:07,207 line:-2
once the true pointer position
reaches the edge of the button’s hit area.


190
00:10:07,274 --> 00:10:11,612 line:-2
Once you lift your finger,
the pointer centers itself on the control.


191
00:10:11,678 --> 00:10:13,947 line:-1
This is called "re-centering."


192
00:10:14,014 --> 00:10:16,416 line:-2
Re-centering makes it easier
to click the button


193
00:10:16,483 --> 00:10:19,453 line:-2
when you put your finger
back down on the trackpad.


194
00:10:19,520 --> 00:10:22,422 line:-2
If you place a traditional pointer
near the edge of a button,


195
00:10:22,489 --> 00:10:24,057 line:-1
release your finger, and click,


196
00:10:24,124 --> 00:10:26,493 line:-2
it’s possible the finger
may roll slightly,


197
00:10:26,560 --> 00:10:28,695 line:-1
moving the pointer off of the button.


198
00:10:28,762 --> 00:10:31,765 line:-2
The pointer then auto-hides
after a short delay.


199
00:10:32,699 --> 00:10:34,868 line:-2
We found that
if the pointer persisted onscreen,


200
00:10:34,935 --> 00:10:38,972 line:-2
it would remind people to perform
their next interaction using the trackpad,


201
00:10:39,039 --> 00:10:41,742 line:-1
rather than with touch or the Pencil.


202
00:10:41,808 --> 00:10:44,711 line:-2
We want people to feel like they can
fluidly move between different inputs


203
00:10:44,778 --> 00:10:46,246 line:-1
without thinking about it.


204
00:10:46,313 --> 00:10:49,116 line:-1
In fact, there are many places on iPadOS


205
00:10:49,183 --> 00:10:51,919 line:-2
where you can use touch
and the pointer simultaneously.


206
00:10:51,985 --> 00:10:56,123 line:-2
For example, with one hand, you can use
the pointer to pick up an app icon,


207
00:10:56,190 --> 00:10:58,425 line:-2
and with the other,
you can swipe on the touchscreen


208
00:10:58,492 --> 00:10:59,860 line:-1
to move it to another page.


209
00:10:59,927 --> 00:11:04,031 line:-2
This is a huge advantage
to having both input methods available.


210
00:11:04,097 --> 00:11:07,668 line:-2
For your app, think about how users
will switch between different inputs,


211
00:11:07,734 --> 00:11:10,904 line:-2
and even try to use multiple
at the same time.


212
00:11:10,971 --> 00:11:14,041 line:-2
Now let’s look at how the pointer
moves around the screen.


213
00:11:14,107 --> 00:11:16,376 line:-1
The macOS pointer moves at a speed


214
00:11:16,443 --> 00:11:19,313 line:-2
that you can customize
to what feels right for you.


215
00:11:19,379 --> 00:11:21,114 line:-1
But it gets a little extra speed boost


216
00:11:21,181 --> 00:11:23,817 line:-2
with something called
an acceleration curve.


217
00:11:23,884 --> 00:11:26,987 line:-2
The acceleration curve
moves the pointer a longer distance


218
00:11:27,054 --> 00:11:29,656 line:-2
the faster you move your finger
on the trackpad.


219
00:11:29,723 --> 00:11:33,093 line:0
Here, I’m swiping slowly
and swiping quickly


220
00:11:33,160 --> 00:11:36,563 line:0
over the same physical distance
on the trackpad.


221
00:11:36,630 --> 00:11:39,132 line:-2
We’ve carefully tuned
the acceleration curve on the Mac


222
00:11:39,199 --> 00:11:40,367 line:-1
to work just right


223
00:11:40,434 --> 00:11:43,237 line:-1
and we’re using that same curve on iPadOS.


224
00:11:43,303 --> 00:11:46,406 line:-2
But sometimes, the boost you get
from the acceleration curve


225
00:11:46,473 --> 00:11:50,377 line:-2
just isn’t enough to quickly move
the pointer to where you want it.


226
00:11:50,444 --> 00:11:52,346 line:-1
For instance, with a traditional pointer,


227
00:11:52,412 --> 00:11:54,615 line:-2
to move it all the way
over to the Settings icon,


228
00:11:54,681 --> 00:11:58,886 line:-2
I need to perform
two separate swipes on the trackpad.


229
00:11:58,952 --> 00:12:01,622 line:-2
I wish I could get there
in just one swipe,


230
00:12:01,688 --> 00:12:04,391 line:-2
but if we made
the acceleration curve stronger,


231
00:12:04,458 --> 00:12:09,296 line:-2
or increased the speed of the pointer,
it could make it hard to control.


232
00:12:09,363 --> 00:12:12,266 line:-2
On iPadOS,
we solve this by adding inertia.


233
00:12:12,332 --> 00:12:15,469 line:-2
Inertia makes it easy
to move long distances


234
00:12:15,536 --> 00:12:17,704 line:-1
with a small amount of physical input.


235
00:12:17,771 --> 00:12:21,375 line:-2
Similar to how you can flick to scroll
a long distance on the touchscreen.


236
00:12:21,441 --> 00:12:25,779 line:0
Now with just one flick on the trackpad,
I can reach the button.


237
00:12:26,747 --> 00:12:28,549 line:-1
When we were building the pointer,


238
00:12:28,615 --> 00:12:31,451 line:-2
we liked being able
to flick to target controls,


239
00:12:31,518 --> 00:12:34,388 line:-2
but we found that
based on the speed of your swipe,


240
00:12:34,454 --> 00:12:38,559 line:0
sometimes the pointer would overshoot
or undershoot the control.


241
00:12:38,625 --> 00:12:41,228 line:-2
Wouldn’t it be great
if the pointer could just figure out


242
00:12:41,295 --> 00:12:44,631 line:-2
which control you were aiming for
and move there automatically?


243
00:12:44,698 --> 00:12:48,502 line:-2
Well, the new pointer has something
called magnetism that does just that.


244
00:12:48,569 --> 00:12:51,138 line:-1
Magnetism scans the interface


245
00:12:51,205 --> 00:12:53,707 line:-2
to find the control
you most likely want to target.


246
00:12:55,008 --> 00:12:57,845 line:0
Let’s go back in time to see how it works.


247
00:12:57,911 --> 00:12:59,780 line:0
At this point, I’m mid-swipe


248
00:12:59,847 --> 00:13:02,482 line:0
and my finger
is still touching the trackpad.


249
00:13:03,283 --> 00:13:06,520 line:0
The moment I lift my finger
from the trackpad,


250
00:13:06,587 --> 00:13:11,458 line:-2
the pointing system immediately calculates
where the pointer would have landed


251
00:13:11,525 --> 00:13:13,994 line:-1
if it continued moving with inertia.


252
00:13:14,895 --> 00:13:16,630 line:-1
We know that there isn’t a target there,


253
00:13:16,697 --> 00:13:21,735 line:-2
so we start scanning around that position
in circles up to a fixed radius.


254
00:13:22,436 --> 00:13:25,038 line:-2
We’ll find the nearest target
in the direction of your swipe


255
00:13:25,105 --> 00:13:27,708 line:-1
and automatically move the pointer there.


256
00:13:27,774 --> 00:13:31,278 line:-2
Since the Settings icon
is the closest snappable element


257
00:13:31,345 --> 00:13:36,216 line:-2
to the projected position that is also
in the direction of the pointer,


258
00:13:36,283 --> 00:13:38,585 line:-1
we move the pointer there automatically


259
00:13:38,652 --> 00:13:41,188 line:-2
the moment you lift your finger
from the trackpad.


260
00:13:41,255 --> 00:13:45,058 line:-2
We put a lot of work
into tuning this to feel just right.


261
00:13:45,125 --> 00:13:48,095 line:-2
Ideally, people aren’t even aware
that this is happening.


262
00:13:48,161 --> 00:13:50,397 line:-2
The pointer just
magically reads their mind


263
00:13:50,464 --> 00:13:52,232 line:-1
and does the right thing.


264
00:13:52,299 --> 00:13:54,768 line:-2
And what’s great is,
any control in your app


265
00:13:54,835 --> 00:13:58,772 line:-2
that supports pointer snapping
gets magnetism for free.


266
00:13:58,839 --> 00:14:02,609 line:-2
We just learned about
why we added a pointer to iPadOS,


267
00:14:02,676 --> 00:14:04,978 line:-1
the power of adaptive precision,


268
00:14:05,045 --> 00:14:07,714 line:-2
and went behind the scenes
to look at how the pointer works


269
00:14:07,781 --> 00:14:12,085 line:-2
with snapping, re-centering,
inertia, and magnetism.


270
00:14:12,152 --> 00:14:14,188 line:-1
Now I’m going to pass it off to Marcos,


271
00:14:14,254 --> 00:14:17,758 line:-2
who’s going to talk about how you can
use pointer effects in your app.


272
00:14:18,525 --> 00:14:20,961 line:-1
Thanks, Brandon. Hi, everyone.


273
00:14:21,028 --> 00:14:22,796 line:-2
In this section,
we're going to have a look


274
00:14:22,863 --> 00:14:24,865 line:-2
at the different pointer effects
you can use


275
00:14:24,932 --> 00:14:27,801 line:-1
when adding trackpad support to your apps.


276
00:14:27,868 --> 00:14:31,338 line:-2
When the iPadOS pointer
hovers over an interactive element,


277
00:14:31,405 --> 00:14:33,907 line:-2
both the appearance
and the behavior of the pointer


278
00:14:33,974 --> 00:14:36,376 line:-1
and the interactive element become one,


279
00:14:36,443 --> 00:14:39,446 line:-2
bringing focus to the item
that is being targeted.


280
00:14:39,513 --> 00:14:42,449 line:-2
We refer to this integration
of pointer and content


281
00:14:42,516 --> 00:14:43,650 line:-1
as a pointer effect,


282
00:14:43,717 --> 00:14:47,154 line:-2
and it changes
based on context and content type.


283
00:14:47,221 --> 00:14:50,490 line:-2
iPadOS provides three pointer effects
you can use


284
00:14:50,557 --> 00:14:53,327 line:-2
to bring focus
to the interactive elements in your app.


285
00:14:53,393 --> 00:14:55,896 line:-2
So, when adding pointer support
to your apps,


286
00:14:55,963 --> 00:15:00,000 line:-2
you can use one of the provided effects,
you can modify them to suit your app,


287
00:15:00,067 --> 00:15:02,803 line:-2
or design a completely new one
if you desire so.


288
00:15:03,570 --> 00:15:06,240 line:-2
The first effect we provide
is called highlight effect.


289
00:15:06,306 --> 00:15:10,344 line:-2
This effect is used for small controls
that don’t have a background,


290
00:15:10,410 --> 00:15:11,545 line:-1
and it’s the default effect


291
00:15:11,612 --> 00:15:14,781 line:-2
for bar buttons and tab bars,
for instance.


292
00:15:14,848 --> 00:15:18,585 line:-2
When the pointer hovers over a control,
it becomes the control's background


293
00:15:18,652 --> 00:15:21,722 line:-2
by moving behind it
while adopting a lighter color.


294
00:15:22,122 --> 00:15:25,259 line:-2
When the control gets selected,
its contents scale up


295
00:15:25,325 --> 00:15:28,562 line:-2
and move with the pointer
with a gentle parallax effect.


296
00:15:28,629 --> 00:15:30,764 line:-2
A light effect
connected to the pointer movement


297
00:15:30,831 --> 00:15:33,367 line:-1
is added on top to highlight the object.


298
00:15:33,433 --> 00:15:37,938 line:-2
And on click, the three layers scale down
and move to the object center.


299
00:15:40,207 --> 00:15:42,543 line:-2
The next effect we provide
is the lift effect.


300
00:15:42,609 --> 00:15:45,379 line:-2
You might want to use it
for medium-sized elements


301
00:15:45,445 --> 00:15:46,747 line:-1
that already have a background.


302
00:15:47,548 --> 00:15:49,516 line:-1
The pointer transforms into the element,


303
00:15:49,583 --> 00:15:52,352 line:-2
highlighting it
without obscuring its contents.


304
00:15:52,419 --> 00:15:55,088 line:-1
Examples of this effect in iPadOS


305
00:15:55,155 --> 00:15:58,492 line:-2
are the app icons
or the Control Center modules.


306
00:15:58,559 --> 00:16:01,962 line:-2
When the pointer approaches a control,
it disappears behind it.


307
00:16:02,029 --> 00:16:06,099 line:-2
The object appears lifted
by scaling up and adding a shadow,


308
00:16:06,166 --> 00:16:10,637 line:-2
and the color of the item bleeds around it
and illuminates the background behind it.


309
00:16:10,704 --> 00:16:14,374 line:-2
Let’s look at how the effect works
when an object gets selected.


310
00:16:15,042 --> 00:16:16,243 line:-1
These are the different layers


311
00:16:16,310 --> 00:16:19,880 line:-2
that are added on top
and below the selected element.


312
00:16:19,947 --> 00:16:24,985 line:-2
A soft, specular highlight is added
on top of the element to illuminate it.


313
00:16:25,052 --> 00:16:26,954 line:-1
The element itself is scaled up


314
00:16:27,020 --> 00:16:30,190 line:-2
and its colors bleed around it,
covering its surroundings.


315
00:16:30,257 --> 00:16:32,759 line:-1
This light effect is called radiosity.


316
00:16:32,826 --> 00:16:35,829 line:0
And lastly, a shadow is projected
under the element


317
00:16:35,896 --> 00:16:38,432 line:0
to give the illusion
the element is floating above the screen.


318
00:16:39,199 --> 00:16:42,402 line:-2
The specular light is used
to highlight the selected object,


319
00:16:42,469 --> 00:16:43,804 line:-1
but it has a second purpose.


320
00:16:44,438 --> 00:16:45,472 line:-1
The position of the light


321
00:16:45,539 --> 00:16:48,375 line:-2
shows the actual position of the pointer
under the hood,


322
00:16:48,442 --> 00:16:50,944 line:-2
as you can see
with the dashed circle here.


323
00:16:51,011 --> 00:16:53,847 line:-2
The specular light
shows you where the pointer is


324
00:16:53,914 --> 00:16:57,484 line:-2
and connects your gestures
with the movement on the screen.


325
00:16:57,551 --> 00:17:00,621 line:-2
The strength of the light
is based on the object size too.


326
00:17:00,687 --> 00:17:03,357 line:-2
It gets bigger and brighter
for bigger elements


327
00:17:03,423 --> 00:17:05,726 line:-2
where the position of the pointer
is harder to see,


328
00:17:05,791 --> 00:17:08,362 line:-2
and gets smaller
or it’s not visible at all


329
00:17:08,428 --> 00:17:10,396 line:-1
for smaller objects that don’t require it.


330
00:17:10,464 --> 00:17:14,233 line:-2
This is automatically done by the system
so you don’t have to worry about it.


331
00:17:15,669 --> 00:17:17,838 line:-2
The last effect we provide
is called hover.


332
00:17:17,905 --> 00:17:20,406 line:-1
It is generally used for larger objects


333
00:17:20,473 --> 00:17:24,243 line:-2
that would behave poorly if the pointer
were to morph into their shape.


334
00:17:24,310 --> 00:17:27,414 line:-2
When the pointer hovers over an object
that uses this effect,


335
00:17:27,481 --> 00:17:30,617 line:-2
the object changes its appearance
to show it's being focused,


336
00:17:30,684 --> 00:17:35,189 line:-2
and the cursor retains its default shape
and remains visible on top of the object.


337
00:17:37,491 --> 00:17:39,426 line:-1
This effect is highly customizable


338
00:17:39,493 --> 00:17:43,096 line:-2
and it can be just a scale of the object,
and a shadow to lift it,


339
00:17:43,163 --> 00:17:47,034 line:-2
a color tint added to the object,
or any combination of the three.


340
00:17:47,100 --> 00:17:49,236 line:-1
So, how do you use the different effects?


341
00:17:49,303 --> 00:17:52,239 line:-2
Let’s have a look at how to pick
the best effect for your app


342
00:17:52,306 --> 00:17:53,540 line:-1
and how to use it.


343
00:17:54,408 --> 00:17:56,610 line:-2
The main rule
when picking a pointer effect


344
00:17:56,677 --> 00:17:58,745 line:-1
is to try the automatic effect first.


345
00:17:58,812 --> 00:18:00,414 line:-1
When using the automatic effect,


346
00:18:00,480 --> 00:18:04,084 line:-2
the system uses a combination of rules
like the object type and location,


347
00:18:04,151 --> 00:18:07,654 line:-2
and the object size and shape
to decide the best effect for it.


348
00:18:08,455 --> 00:18:10,324 line:-1
These rules can change in the future,


349
00:18:10,390 --> 00:18:14,494 line:-2
so using the automatic effect
ensures your app will always look good.


350
00:18:14,561 --> 00:18:16,897 line:-1
Using the automatic effect is very easy.


351
00:18:16,964 --> 00:18:18,665 line:-1
Just pick "automatic"


352
00:18:18,732 --> 00:18:22,736 line:-2
when assigning a UIPointerEffect
for your interactive element.


353
00:18:22,803 --> 00:18:25,405 line:0
For more technical
and implementation details,


354
00:18:25,472 --> 00:18:28,342 line:0
check out the talk
"Build for the iPadOS Pointer"


355
00:18:28,408 --> 00:18:30,511 line:0
from this year’s WWDC.


356
00:18:30,577 --> 00:18:33,614 line:-2
But the automatic effect
is not always the right solution.


357
00:18:33,680 --> 00:18:36,049 line:0
Like in this example from the Books app.


358
00:18:36,650 --> 00:18:39,286 line:0
The bookmark icon on the right
has its own background


359
00:18:39,353 --> 00:18:42,656 line:0
and it seems like the lift effect
should be the appropriate one for it.


360
00:18:42,723 --> 00:18:44,258 line:0
But because it’s in a toolbar


361
00:18:44,324 --> 00:18:46,660 line:0
next to other buttons
that use the highlight effect,


362
00:18:46,727 --> 00:18:49,496 line:0
it feels out of place
and we shouldn’t use it.


363
00:18:49,563 --> 00:18:53,100 line:0
The right thing to do in this case
is to use the highlight effect.


364
00:18:53,166 --> 00:18:54,234 line:0
The highlight effect


365
00:18:54,301 --> 00:18:57,771 line:0
will make the button look consistent
with the other buttons around it.


366
00:18:57,838 --> 00:18:59,540 line:-1
You should try to be consistent


367
00:18:59,606 --> 00:19:01,975 line:-2
when designing
the size of your objects too.


368
00:19:02,042 --> 00:19:05,345 line:0
Like in this example,
we have three buttons side-by-side,


369
00:19:05,412 --> 00:19:08,982 line:0
but their highlight background size
is not consistent.


370
00:19:09,049 --> 00:19:13,187 line:0
This discrepancy will look bad
when the pointer moves over them.


371
00:19:13,253 --> 00:19:18,225 line:0
So make sure the objects in the same group
have a consistent size between them.


372
00:19:18,292 --> 00:19:20,928 line:0
For toolbar-sized buttons,
like in this example,


373
00:19:20,994 --> 00:19:24,031 line:0
we recommend using a height of 37 points.


374
00:19:24,097 --> 00:19:27,534 line:-2
Effect consistency
is not always the right choice, though.


375
00:19:27,601 --> 00:19:29,369 line:-1
For instance, when we were designing


376
00:19:29,436 --> 00:19:31,805 line:-2
the pointer behavior
for segmented controls,


377
00:19:31,872 --> 00:19:33,373 line:-1
we arrived to the conclusion


378
00:19:33,440 --> 00:19:36,476 line:-2
that mixing effects was
the right thing to do in this situation.


379
00:19:36,543 --> 00:19:40,013 line:0
So, even though "Day" and "Month"
use the highlight effect


380
00:19:40,080 --> 00:19:42,082 line:0
and get a rounded rectangle around them,


381
00:19:42,149 --> 00:19:46,420 line:0
when focused, using the highlight effect
for the selected option


382
00:19:46,486 --> 00:19:47,988 line:0
looks out of place.


383
00:19:48,055 --> 00:19:49,723 line:-1
In general, you should try to avoid


384
00:19:49,790 --> 00:19:52,159 line:-2
the highlight effect
around rectangular objects.


385
00:19:52,226 --> 00:19:55,996 line:0
The right thing to do in this case
is to use the lift effect


386
00:19:56,063 --> 00:19:59,399 line:0
so the selected option appears lifted
above the control around it.


387
00:20:00,334 --> 00:20:01,602 line:-1
The hit region of your objects


388
00:20:01,668 --> 00:20:05,038 line:-2
will determine the area
your pointer effect is active,


389
00:20:05,105 --> 00:20:07,307 line:-2
and you should make sure
it’s the right size.


390
00:20:07,374 --> 00:20:09,643 line:-2
If the hit region is too small,
it can make people feel


391
00:20:09,710 --> 00:20:12,913 line:-2
that they have to be extra precise
when interacting with the element.


392
00:20:13,981 --> 00:20:17,384 line:-2
On the other hand,
when an element’s hit region is too large,


393
00:20:17,451 --> 00:20:19,319 line:-2
people can feel
that it takes a lot of effort


394
00:20:19,386 --> 00:20:21,588 line:-1
to pull the pointer away from the element.


395
00:20:21,655 --> 00:20:25,058 line:-2
So try to define a region
that feels comfortable.


396
00:20:25,125 --> 00:20:28,228 line:-2
In general, it works well
to add about 12 points of padding


397
00:20:28,295 --> 00:20:30,130 line:-1
around elements that include a bezel,


398
00:20:30,898 --> 00:20:34,401 line:-2
and about 24 points
around elements without a bezel.


399
00:20:34,468 --> 00:20:37,538 line:-2
An extended hit region
will also make your apps more comfortable


400
00:20:37,604 --> 00:20:39,706 line:-1
when using the touchscreen.


401
00:20:39,773 --> 00:20:42,676 line:-2
A common issue
when defining your hit region


402
00:20:42,743 --> 00:20:44,645 line:-1
is leaving a gap between objects.


403
00:20:45,212 --> 00:20:48,649 line:-2
This will make the pointer morph back
into the circular shape between them,


404
00:20:48,715 --> 00:20:51,518 line:-1
creating an unnecessary animation.


405
00:20:51,585 --> 00:20:54,488 line:-2
So make sure your hit region
extends between your objects,


406
00:20:54,555 --> 00:20:56,056 line:-1
leaving no gap between them.


407
00:20:56,123 --> 00:20:58,659 line:-2
That way, the pointer
will flow nicely between them.


408
00:20:58,725 --> 00:21:02,196 line:-2
This change will make your apps
work much better with touch too.


409
00:21:02,796 --> 00:21:05,532 line:-2
A common problem
when adopting the lift effect


410
00:21:05,599 --> 00:21:07,668 line:-1
is the extended shadow around it.


411
00:21:07,734 --> 00:21:11,338 line:0
Because the app was not designed
for the extended size of the object,


412
00:21:11,405 --> 00:21:15,509 line:0
the shadow might get clipped
by other UI elements around it.


413
00:21:15,576 --> 00:21:18,245 line:0
So make sure that the objects
that adopt the lift effect


414
00:21:18,312 --> 00:21:20,047 line:0
are on top of their surrounding layers


415
00:21:20,113 --> 00:21:22,716 line:0
to ensure the shadow
is rendered correctly.


416
00:21:22,783 --> 00:21:24,618 line:-1
Next, we're going to have a look


417
00:21:24,685 --> 00:21:28,188 line:-2
at how to customize and combine
the pointer effects in your app.


418
00:21:28,689 --> 00:21:30,858 line:-1
When using the highlight and lift effects,


419
00:21:30,924 --> 00:21:34,561 line:-2
you can specify the size
and corner radius of your object.


420
00:21:34,628 --> 00:21:38,832 line:-2
If your object has a circular shape
or the corner radius is not 8 points,


421
00:21:38,899 --> 00:21:42,169 line:-2
it is very important that you provide
the correct corner radius,


422
00:21:42,236 --> 00:21:45,172 line:-1
otherwise it will not render correctly.


423
00:21:45,239 --> 00:21:48,108 line:-2
When using the hover effect,
your object can scale up


424
00:21:48,175 --> 00:21:52,145 line:-2
or have a shadow when it is highlighted,
like we see in this example.


425
00:21:52,212 --> 00:21:55,816 line:-2
Both the scale effect and the shadow
can be turned on and off


426
00:21:55,883 --> 00:21:59,119 line:-2
so you can pick the right combination
that matches your app design.


427
00:21:59,186 --> 00:22:01,788 line:-2
But in general,
we don't recommend using the shadow


428
00:22:01,855 --> 00:22:03,423 line:-1
if you are not scaling your object.


429
00:22:03,490 --> 00:22:06,860 line:-2
Another effect you can combine with hover
is tinting.


430
00:22:06,927 --> 00:22:09,663 line:-2
You can use it to highlight objects
you don't want to scale,


431
00:22:09,730 --> 00:22:12,266 line:-1
as you can see here for Notifications.


432
00:22:12,332 --> 00:22:13,667 line:-1
When tinting is turned on,


433
00:22:13,734 --> 00:22:18,405 line:-2
it will add a special material on top
or below the object and change its color.


434
00:22:18,472 --> 00:22:22,676 line:-2
This material can be dark or light
depending on your Dark Mode settings.


435
00:22:24,278 --> 00:22:25,779 line:-1
When using the hover effect,


436
00:22:25,846 --> 00:22:28,715 line:-2
you can provide a custom shape
for your pointer too.


437
00:22:28,782 --> 00:22:31,051 line:-2
The pointer will morph
from the default circle


438
00:22:31,118 --> 00:22:34,321 line:-2
into the provided shape
when it hovers over your object,


439
00:22:34,388 --> 00:22:37,758 line:-2
like the I-beam pointer we use
for text on iPadOS.


440
00:22:37,824 --> 00:22:40,494 line:-2
Custom pointers can show you
extra information


441
00:22:40,561 --> 00:22:44,798 line:-2
about a specific region on the screen,
or a change in the pointer behavior.


442
00:22:44,865 --> 00:22:48,569 line:-2
We're going to learn a lot more
about custom pointers in the next section.


443
00:22:49,136 --> 00:22:52,072 line:-2
If we visualize the actual position
of the pointer,


444
00:22:52,139 --> 00:22:55,909 line:-2
we can see how the I-beam tries to stay
in the center of the text field.


445
00:22:55,976 --> 00:22:59,746 line:-2
This effect is called snapping,
and creates a magnetic attraction


446
00:22:59,813 --> 00:23:02,449 line:-2
that pulls the pointer
to the center of the object.


447
00:23:02,516 --> 00:23:04,484 line:-1
It increases the precision of the pointer


448
00:23:04,551 --> 00:23:08,488 line:-2
and creates a more comfortable experience
when interacting with your app controls.


449
00:23:09,556 --> 00:23:11,658 line:-1
You can use this effect in your apps too.


450
00:23:11,725 --> 00:23:14,828 line:-2
Adding snapping to controls
helps you be more precise


451
00:23:14,895 --> 00:23:18,165 line:-2
and simplifies common tasks
like grabbing small handlers,


452
00:23:18,232 --> 00:23:19,800 line:-1
as you can see in this example.


453
00:23:20,234 --> 00:23:22,870 line:-2
Just remember,
you should never enable snapping


454
00:23:22,936 --> 00:23:25,038 line:-1
if you are not providing a custom pointer.


455
00:23:25,372 --> 00:23:27,574 line:-2
So we just had a look
at the three pointer effects


456
00:23:27,641 --> 00:23:29,643 line:-1
provided by iPadOS:


457
00:23:29,710 --> 00:23:32,613 line:-1
highlight, lift, and hover.


458
00:23:32,679 --> 00:23:37,317 line:-2
Remember, you should try to use
the automatic effect whenever possible.


459
00:23:37,384 --> 00:23:42,656 line:-2
Be consistent picking the pointer effects
and designing your object's shape.


460
00:23:42,723 --> 00:23:47,094 line:-2
Extend your object's hit region
to make it more comfortable to use.


461
00:23:47,160 --> 00:23:49,396 line:-1
Remember, when using the lift effect,


462
00:23:49,463 --> 00:23:53,300 line:-2
you have to provide the correct size
and corner radius.


463
00:23:53,367 --> 00:23:54,868 line:-1
And if you use the hover effect,


464
00:23:54,935 --> 00:23:59,406 line:-2
you can enable a scale, a shadow
or a tint color for your object.


465
00:23:59,740 --> 00:24:01,842 line:-2
I hope this section gave you
a good overview


466
00:24:01,909 --> 00:24:04,645 line:-2
of the different pointer effects
provided by iPadOS,


467
00:24:04,711 --> 00:24:06,413 line:-1
and how to successfully use them


468
00:24:06,480 --> 00:24:09,082 line:-2
to create a great pointer experience
for your apps.


469
00:24:09,149 --> 00:24:10,350 line:-1
That's all from me.


470
00:24:10,417 --> 00:24:12,252 line:-1
I'm going to pass it over to CC


471
00:24:12,319 --> 00:24:14,988 line:-2
who is going to show you how to design
a great pointer for your app.


472
00:24:15,055 --> 00:24:16,390 line:-1
Thank you.


473
00:24:16,857 --> 00:24:19,393 line:-1
Thank you, Marcos. Hi, everyone.


474
00:24:19,459 --> 00:24:21,995 line:-2
I'm going to talk about
the pointer appearance


475
00:24:22,062 --> 00:24:24,231 line:-1
and how to design a custom pointer.


476
00:24:24,298 --> 00:24:27,434 line:0
First, let's look at the pointer material.


477
00:24:28,268 --> 00:24:30,737 line:-1
The pointer in iPadOS has a material


478
00:24:30,804 --> 00:24:34,007 line:-2
that constantly adapts
to the background color smoothly.


479
00:24:34,074 --> 00:24:38,545 line:-2
It provides optimal contrast at all times
without being distracting.


480
00:24:38,612 --> 00:24:43,317 line:-2
When the background color changes,
so will the pointer's color.


481
00:24:43,383 --> 00:24:47,554 line:-2
This material maintains contrast
without obscuring the background.


482
00:24:47,621 --> 00:24:51,625 line:-2
That is because when people
are using the iPad with the trackpad,


483
00:24:51,692 --> 00:24:56,029 line:-2
we want the pointer to be there
to show the location of interaction,


484
00:24:56,096 --> 00:24:58,866 line:-2
but it shouldn't draw
too much attention to itself


485
00:24:58,932 --> 00:25:00,934 line:-1
and take away from the content.


486
00:25:01,802 --> 00:25:06,139 line:-2
However, the pointer should
indicate intention when it's needed.


487
00:25:06,206 --> 00:25:10,244 line:-2
In this case, when the pointer
is transformed into a button shape,


488
00:25:10,310 --> 00:25:12,546 line:-1
not only does it change its shape,


489
00:25:12,613 --> 00:25:18,685 line:-2
but the color of it also becomes lighter
to provide good legibility to the label.


490
00:25:18,752 --> 00:25:21,655 line:-1
On top of that, when people click,


491
00:25:21,722 --> 00:25:24,691 line:-1
the circle scales down and becomes darker


492
00:25:24,758 --> 00:25:28,762 line:-2
to provide a satisfying feedback
for the click action.


493
00:25:29,396 --> 00:25:31,765 line:-2
These are examples
of the pointer's material


494
00:25:31,832 --> 00:25:33,467 line:-1
adapting to its function.


495
00:25:33,534 --> 00:25:39,039 line:-2
And all of these color adaptations
are provided by the system automatically.


496
00:25:39,439 --> 00:25:42,910 line:-2
Next, we are going to look
at the pointer shape.


497
00:25:43,510 --> 00:25:45,212 line:-1
As Brandon mentioned earlier,


498
00:25:45,279 --> 00:25:48,582 line:-2
the pointer shape is a circle
that represents touch.


499
00:25:48,649 --> 00:25:52,319 line:-2
The size of it relates well
with the touch-based UI elements.


500
00:25:52,386 --> 00:25:55,022 line:-2
The circle shape
provides a perfect foundation


501
00:25:55,088 --> 00:25:58,292 line:-1
for it to transform into any shape.


502
00:25:58,358 --> 00:25:59,860 line:-1
In the previous example,


503
00:25:59,927 --> 00:26:03,630 line:-2
the pointer transformed from a circle
to a rounded rectangle


504
00:26:03,697 --> 00:26:06,099 line:-1
to highlight the button.


505
00:26:06,166 --> 00:26:09,736 line:-2
This is our first type
of pointer shape transformation:


506
00:26:09,803 --> 00:26:13,106 line:-1
from a circle to a rounded rectangle.


507
00:26:13,173 --> 00:26:15,475 line:-1
And it's not just for buttons.


508
00:26:15,542 --> 00:26:19,513 line:-2
The circle can transform
to a vertical bar for an I-beam,


509
00:26:19,580 --> 00:26:23,283 line:-2
a horizontal pill
to highlight the top status region,


510
00:26:23,350 --> 00:26:25,953 line:-1
or to highlight a grabber.


511
00:26:26,019 --> 00:26:29,223 line:-2
These are all considered
the rectangle type


512
00:26:29,289 --> 00:26:31,725 line:-1
of pointer transformation.


513
00:26:31,792 --> 00:26:33,694 line:-1
The second type of transformation


514
00:26:33,760 --> 00:26:37,631 line:-2
is when the circle morphs
into any arbitrary shape.


515
00:26:37,698 --> 00:26:39,533 line:-1
This can be used to inform people


516
00:26:39,600 --> 00:26:43,103 line:-2
when there is a change of functionality
or precision.


517
00:26:44,438 --> 00:26:48,008 line:-2
For example,
the pointer can turn into a cross shape


518
00:26:48,075 --> 00:26:52,880 line:-2
to indicate an area
with a higher level of precision.


519
00:26:52,946 --> 00:26:55,749 line:-2
It can also transform
into a pair of triangles


520
00:26:55,816 --> 00:26:59,620 line:-2
to inform people
the direction of a drag movement,


521
00:26:59,686 --> 00:27:02,389 line:-1
or when the Command key is held down


522
00:27:02,456 --> 00:27:05,392 line:-2
and the function
of the pointer is modified.


523
00:27:06,827 --> 00:27:09,630 line:0
Both of these transformations
are available


524
00:27:09,696 --> 00:27:12,566 line:0
with their corresponding APIs.


525
00:27:12,900 --> 00:27:17,037 line:-2
If the pointer is going to morph
from a circle to a rectangle shape,


526
00:27:17,104 --> 00:27:19,239 line:-1
apply the top API.


527
00:27:19,306 --> 00:27:24,444 line:-2
If it is changing to a more complex shape,
use the bottom one.


528
00:27:24,511 --> 00:27:27,581 line:0
And check out the talk
“Build for the iPadOS Pointer”


529
00:27:27,648 --> 00:27:31,251 line:0
for more details on how to use these APIs.


530
00:27:32,019 --> 00:27:36,523 line:-2
Now let's talk about how to design
a great custom pointer.


531
00:27:36,957 --> 00:27:40,894 line:-2
As we just learned,
the pointer in iPadOS has many ways


532
00:27:40,961 --> 00:27:43,197 line:-1
to morph its color and shape.


533
00:27:43,263 --> 00:27:46,400 line:-2
These behaviors provide the pointer
with the flexibility


534
00:27:46,466 --> 00:27:50,504 line:-2
to fully adapt to its context
at any given moment.


535
00:27:50,571 --> 00:27:54,641 line:-2
When we design a new custom shape for it,
we should keep in mind


536
00:27:54,708 --> 00:27:59,279 line:-2
this characteristic
of a constant state of transformation.


537
00:28:00,948 --> 00:28:04,952 line:-2
So how do we design
a great custom shape for the pointer?


538
00:28:05,018 --> 00:28:10,190 line:0
First, make sure your custom shape
is simple and easy to understand.


539
00:28:10,257 --> 00:28:12,392 line:0
The shape of the pointer informs people


540
00:28:12,459 --> 00:28:15,362 line:0
the action they can take
in the current context.


541
00:28:15,429 --> 00:28:17,698 line:0
For example, in Keynote,


542
00:28:17,764 --> 00:28:20,334 line:0
the pointer transforms
into a pair of arrows


543
00:28:20,400 --> 00:28:25,072 line:0
that show the directions in which
people can drag a selection handle.


544
00:28:26,273 --> 00:28:30,077 line:0
If people cannot instantly understand
your custom pointer,


545
00:28:30,143 --> 00:28:32,980 line:0
they're likely to waste time
trying to figure it out.


546
00:28:33,413 --> 00:28:37,584 line:0
Second, use solid shapes
as much as possible.


547
00:28:37,651 --> 00:28:41,622 line:0
Remember, the pointer color
is constantly changing.


548
00:28:41,688 --> 00:28:45,759 line:0
A solid shape will maintain legibility
and make it easy to read.


549
00:28:47,060 --> 00:28:49,863 line:0
A shape with strokes
will be difficult to read.


550
00:28:49,930 --> 00:28:54,501 line:-2
But if it happens
that you cannot use a solid fill shape,


551
00:28:54,568 --> 00:28:56,603 line:-1
use heavy strokes


552
00:28:56,670 --> 00:29:01,308 line:0
and make sure the stroke weight
is thick enough to maintain visual weight.


553
00:29:02,509 --> 00:29:06,380 line:0
It will be difficult to see the pointer
if the stroke is too thin.


554
00:29:06,446 --> 00:29:11,485 line:0
And don't forget to use a size
that is similar to the default pointer.


555
00:29:11,552 --> 00:29:14,788 line:-2
The size of the custom shape
should visually balance


556
00:29:14,855 --> 00:29:19,293 line:-2
with the default pointer,
which is a 19-point circle.


557
00:29:19,359 --> 00:29:23,197 line:-2
In other words,
if you have a shape that is narrow,


558
00:29:23,263 --> 00:29:27,801 line:-2
you may want to make it bigger
to maintain a similar visual weight.


559
00:29:27,868 --> 00:29:31,271 line:-2
In this example,
the cross mark is 24 points


560
00:29:31,338 --> 00:29:34,107 line:-1
compared to the 19-point circle.


561
00:29:34,174 --> 00:29:38,011 line:0
Keep in mind that the pointer will morph
from its default state


562
00:29:38,078 --> 00:29:39,813 line:0
to the custom state.


563
00:29:39,880 --> 00:29:43,817 line:0
If the custom pointer is too small,
it may get lost.


564
00:29:43,884 --> 00:29:47,354 line:0
And if there is a big size difference
between the two states,


565
00:29:47,421 --> 00:29:50,858 line:0
the transformation can become jarring
and distracting.


566
00:29:50,924 --> 00:29:54,695 line:0
Now, when you design your custom pointer,


567
00:29:54,761 --> 00:29:57,531 line:0
make sure the shape
communicates its intention


568
00:29:57,598 --> 00:29:59,700 line:0
as directly as possible.


569
00:30:00,367 --> 00:30:02,035 line:-1
Here is an example.


570
00:30:02,102 --> 00:30:05,839 line:0
Say if you are designing an app
to read and highlight text,


571
00:30:05,906 --> 00:30:11,011 line:0
instead of using a marker pen glyph
as the custom highlight pointer,


572
00:30:11,078 --> 00:30:14,481 line:0
a better solution
is to show the marker tip shape.


573
00:30:14,548 --> 00:30:17,651 line:0
In this case,
the shape not only informs people


574
00:30:17,718 --> 00:30:20,120 line:0
the height of the text selection,


575
00:30:20,187 --> 00:30:22,589 line:0
but also resembles the I-beam,


576
00:30:22,656 --> 00:30:27,794 line:0
which implies all the system behaviors
of adaptive precision and snapping.


577
00:30:27,861 --> 00:30:32,232 line:0
The shape of the marker tip
has the same anchor point as the circle,


578
00:30:32,299 --> 00:30:35,602 line:0
resulting in a nice transition
between the two shapes.


579
00:30:35,969 --> 00:30:40,073 line:0
Speaking of anchor points,
when designing a custom pointer,


580
00:30:40,140 --> 00:30:43,410 line:0
we should also make sure
the anchor point matches well.


581
00:30:44,144 --> 00:30:48,048 line:-2
If your custom shape is a circle,
a simple geometric shape,


582
00:30:48,115 --> 00:30:50,417 line:-1
or a symmetrical shape,


583
00:30:50,484 --> 00:30:52,886 line:-2
it's natural to see
the point of interaction


584
00:30:52,953 --> 00:30:54,922 line:-1
as the center of these shapes.


585
00:30:55,889 --> 00:31:00,160 line:-2
If the shape is directional,
or with a specific focus area,


586
00:31:00,227 --> 00:31:04,131 line:-2
we will need the anchor point set
to match the intent.


587
00:31:04,198 --> 00:31:09,603 line:-2
However, it also means the transformation
will appear to be off-centered.


588
00:31:09,670 --> 00:31:13,440 line:-2
It would be nice to think of other ways
to indicate these functions,


589
00:31:13,507 --> 00:31:16,577 line:-2
and maintain the center anchor point
as much as possible


590
00:31:16,643 --> 00:31:19,646 line:-1
for a nice experience.


591
00:31:19,713 --> 00:31:24,718 line:-2
In this example, instead of using
an eyedropper glyph as our custom pointer,


592
00:31:24,785 --> 00:31:29,156 line:-2
we can use a target shape
for precise color sampling.


593
00:31:29,223 --> 00:31:33,861 line:-2
Lastly, a couple of things to keep in mind
when designing a custom pointer.


594
00:31:33,927 --> 00:31:36,930 line:-2
Make sure you apply
standard pointer behaviors


595
00:31:36,997 --> 00:31:39,132 line:-1
on your custom pointer.


596
00:31:39,199 --> 00:31:42,536 line:-2
For example,
if buttons in a custom navigation bar


597
00:31:42,603 --> 00:31:47,174 line:-2
don't use the standard highlight effect,
people might think they are broken.


598
00:31:48,775 --> 00:31:52,479 line:-2
Apply similar functions
to similar pointers.


599
00:31:52,546 --> 00:31:56,350 line:-2
For example,
if your app helps people draw,


600
00:31:56,416 --> 00:32:01,388 line:-2
every drawing area in it
should have a similar pointer experience


601
00:32:01,455 --> 00:32:06,059 line:-2
so that people can apply the knowledge
they gain in one area to the others.


602
00:32:07,494 --> 00:32:13,000 line:-2
Last but not least, try not to create
unnecessary custom pointers.


603
00:32:13,066 --> 00:32:16,503 line:-2
People notice when the appearance
of the pointer changes,


604
00:32:16,570 --> 00:32:19,573 line:-1
and they expect the change to be useful.


605
00:32:19,640 --> 00:32:22,543 line:-2
Creating a purely decorative
pointer effect


606
00:32:22,609 --> 00:32:28,348 line:-2
can distract and even irritate people
without providing any practical value.


607
00:32:28,415 --> 00:32:32,920 line:-2
All right, we just learned about
the pointer material, pointer shape,


608
00:32:32,986 --> 00:32:35,556 line:-1
and how to design a great custom pointer.


609
00:32:35,622 --> 00:32:37,691 line:-1
I'm sure you can create a pointer


610
00:32:37,758 --> 00:32:40,661 line:-2
that makes your app
feel native and intuitive


611
00:32:40,727 --> 00:32:43,630 line:-1
when people experience it with a trackpad.


612
00:32:44,164 --> 00:32:47,501 line:-2
Now I'm going to pass it
to my colleague Dylan.


613
00:32:47,568 --> 00:32:50,604 line:-2
He is going to talk about
pointer interactions.


614
00:32:50,671 --> 00:32:51,939 line:-1
Thanks, CC.


615
00:32:52,005 --> 00:32:54,775 line:-2
Let's talk about
all the new interactive behaviors


616
00:32:54,842 --> 00:32:56,810 line:-1
your app can gain with the pointer.


617
00:32:56,877 --> 00:33:00,747 line:0
Let's start by talking about
increasing precision in your app.


618
00:33:00,814 --> 00:33:04,418 line:0
The presence of a pointer means
that people can now interact with your app


619
00:33:04,484 --> 00:33:07,988 line:0
with much greater precision
than previously possible with the finger.


620
00:33:08,055 --> 00:33:10,090 line:-2
So how do we let them
take advantage of this


621
00:33:10,157 --> 00:33:12,960 line:-1
without redesigning our apps entirely?


622
00:33:13,026 --> 00:33:15,662 line:-2
We can use the pointer
to do finer-grained selection,


623
00:33:15,729 --> 00:33:19,800 line:-2
as well as adding quicker interactivity
to smaller elements of your interface.


624
00:33:19,867 --> 00:33:25,472 line:-2
A great example of finer-grained selection
is the text-editing experience on iOS.


625
00:33:25,539 --> 00:33:29,176 line:-2
As shown here, you can use
the low-precision input of your finger


626
00:33:29,243 --> 00:33:31,578 line:-2
to perform text selection
on a word boundary,


627
00:33:31,645 --> 00:33:34,982 line:-2
and then use the drag handles
to carefully adjust your selection.


628
00:33:35,048 --> 00:33:37,384 line:-2
But with the high-precision input
of the pointer,


629
00:33:37,451 --> 00:33:39,486 line:-1
this interaction is a bit different.


630
00:33:39,553 --> 00:33:42,189 line:-2
As Brandon described,
the narrow beam pointer


631
00:33:42,256 --> 00:33:44,791 line:-2
makes it easy to see
exactly where you're selecting,


632
00:33:44,858 --> 00:33:47,060 line:-1
while we also snap it to the current line


633
00:33:47,127 --> 00:33:48,862 line:-2
and grow its height
to match the line height,


634
00:33:48,929 --> 00:33:51,265 line:-1
reducing the ambiguity of its position.


635
00:33:51,798 --> 00:33:55,769 line:-2
Because of this high precision
and low ambiguity afforded by the pointer,


636
00:33:55,836 --> 00:34:00,307 line:-2
we can begin selecting with
character-level precision immediately.


637
00:34:00,374 --> 00:34:04,011 line:-2
Consider places in your app where
you might need a more precise pointer,


638
00:34:04,077 --> 00:34:07,314 line:-2
or where you can use snapping
to aid people in navigating your UI,


639
00:34:07,381 --> 00:34:08,916 line:-1
and strive to always use a pointer


640
00:34:08,982 --> 00:34:12,085 line:-2
that matches the precision necessary
for the current task,


641
00:34:12,152 --> 00:34:14,588 line:-1
defaulting to the circle when necessary.


642
00:34:14,655 --> 00:34:19,326 line:-2
You can find another case of this type
of precise input here in Numbers.


643
00:34:19,393 --> 00:34:22,429 line:-2
Using our finger,
we can tap to select a column header


644
00:34:22,496 --> 00:34:25,098 line:-2
and then drag a finger
on the exposed drag handle


645
00:34:25,165 --> 00:34:27,400 line:-1
to resize a column.


646
00:34:27,467 --> 00:34:29,436 line:-1
But with the precision of pointer input,


647
00:34:29,503 --> 00:34:33,739 line:-2
we can actually expose a control
that isn't available with the finger.


648
00:34:33,806 --> 00:34:37,010 line:-2
Rather than selecting a column
to expose a resize handle,


649
00:34:37,077 --> 00:34:40,714 line:-2
we can move the pointer directly
to the small divider between columns


650
00:34:40,781 --> 00:34:42,014 line:-1
and begin dragging,


651
00:34:42,081 --> 00:34:45,385 line:-2
again avoiding the need
to first make an imprecise selection


652
00:34:45,452 --> 00:34:46,719 line:-1
to achieve our goal.


653
00:34:46,786 --> 00:34:49,422 line:-2
It's important to note
that neither of these examples


654
00:34:49,489 --> 00:34:51,558 line:-1
adds new functionality for the pointer,


655
00:34:51,625 --> 00:34:54,061 line:-1
but rather they use the added precision


656
00:34:54,127 --> 00:34:57,431 line:-2
to make this functionality
easier to use with the pointer.


657
00:34:57,497 --> 00:34:59,700 line:-2
You should avoid
updating your app's layout,


658
00:34:59,766 --> 00:35:01,134 line:-1
increasing density,


659
00:35:01,201 --> 00:35:04,004 line:-2
or introducing features
that only work with the pointer,


660
00:35:04,071 --> 00:35:06,240 line:-1
but instead use the pointer's precision


661
00:35:06,306 --> 00:35:09,076 line:-2
to make using your app quicker
and more intuitive.


662
00:35:09,142 --> 00:35:13,013 line:0
The pointer clearly enables
new possibilities with precise input,


663
00:35:13,080 --> 00:35:15,082 line:0
but that's only half the story.


664
00:35:15,148 --> 00:35:17,251 line:0
The pointer system really shines


665
00:35:17,317 --> 00:35:20,521 line:0
when you make great use
of adaptive precision.


666
00:35:20,587 --> 00:35:24,124 line:-2
Let's take a look at how you can make
your larger, low-precision interfaces


667
00:35:24,191 --> 00:35:25,993 line:-1
work wonderfully with the pointer too.


668
00:35:26,593 --> 00:35:30,364 line:-2
Adopting pointer effects in places
where high precision isn't necessary


669
00:35:30,430 --> 00:35:33,033 line:-2
still can vastly improve the experience
of your app.


670
00:35:33,100 --> 00:35:37,437 line:-2
A great example is the interface
in Reminders for creating a new list.


671
00:35:37,504 --> 00:35:39,940 line:-2
These are approximately
finger-sized targets,


672
00:35:40,007 --> 00:35:42,342 line:-2
a UI that already works great
with the finger,


673
00:35:42,409 --> 00:35:45,879 line:-2
but adding the lift effect to these
creates a fun and easy-to-use picker


674
00:35:45,946 --> 00:35:48,248 line:-2
that gives exactly
the amount of precision required.


675
00:35:48,315 --> 00:35:52,519 line:-2
Consider places in your app that
adjacent controls can use pointer effects


676
00:35:52,586 --> 00:35:55,889 line:-2
to gain great visual feedback
and snapping behaviors.


677
00:35:55,956 --> 00:35:59,626 line:-2
As Marcos described previously,
in cases of even larger UI


678
00:35:59,693 --> 00:36:01,795 line:-2
that may behave poorly
with a morphing pointer,


679
00:36:01,862 --> 00:36:03,797 line:-1
you can still adopt a hover effect.


680
00:36:03,864 --> 00:36:05,232 line:-1
This isn't just for show.


681
00:36:05,299 --> 00:36:07,801 line:-2
It can provide a lot of information
about precision.


682
00:36:08,235 --> 00:36:11,805 line:-2
The Calendar app often has events
much larger than a finger.


683
00:36:11,872 --> 00:36:15,442 line:-2
While you might think such a coarse UI
doesn't need to adapt to the pointer,


684
00:36:15,509 --> 00:36:19,780 line:-2
this is actually an excellent place to add
a hover effect to indicate interactivity


685
00:36:19,847 --> 00:36:23,217 line:-2
and disambiguate
in cases of overlapping events.


686
00:36:23,283 --> 00:36:26,520 line:0
Now I'd like to share how the unique
characteristics of pointer input


687
00:36:26,587 --> 00:36:29,456 line:0
can accelerate
some of the interactions in your app.


688
00:36:29,523 --> 00:36:34,127 line:-2
The pointer's presence on the screen
serves as a great indicator of intent.


689
00:36:34,194 --> 00:36:37,331 line:-2
We can use this new information
to speed up interactions


690
00:36:37,397 --> 00:36:39,933 line:-1
that previously would have required a tap.


691
00:36:40,000 --> 00:36:42,069 line:-2
Now that we know
the position of the pointer,


692
00:36:42,135 --> 00:36:43,971 line:-1
we know that hovering over a region


693
00:36:44,037 --> 00:36:46,240 line:-2
means a person is likely
to interact with it,


694
00:36:46,306 --> 00:36:48,609 line:-1
and our app can respond proactively.


695
00:36:49,476 --> 00:36:53,213 line:-2
For instance, the Books app makes use
of the hover position of the pointer


696
00:36:53,280 --> 00:36:55,649 line:-1
to control the visibility of its toolbars.


697
00:36:55,716 --> 00:36:59,186 line:-2
We can hide the bar interface
while reading to reduce distraction,


698
00:36:59,253 --> 00:37:01,822 line:-2
but immediately reveal it
when the pointer moves over it,


699
00:37:01,889 --> 00:37:04,725 line:-2
removing the need
for a click to hide and show.


700
00:37:05,726 --> 00:37:07,995 line:-1
The pointer's movement, or lack thereof,


701
00:37:08,061 --> 00:37:10,831 line:-2
can also be a helpful hint
to update our UI.


702
00:37:10,898 --> 00:37:13,433 line:-2
In a full-screen experience
or media playback,


703
00:37:13,500 --> 00:37:17,771 line:-2
you might wish to automatically hide UI
after a period of inactivity.


704
00:37:17,838 --> 00:37:20,974 line:-2
In these cases,
pointer movement is a clear indication


705
00:37:21,041 --> 00:37:23,243 line:-2
that someone wants to interact
with your interface,


706
00:37:23,310 --> 00:37:25,279 line:-1
and can be used to reveal your controls.


707
00:37:25,646 --> 00:37:30,250 line:-2
Because pointing devices can scroll
with a dedicated gesture or scroll wheel,


708
00:37:30,317 --> 00:37:33,820 line:-2
your app can instantaneously respond
to a click and drag


709
00:37:33,887 --> 00:37:36,790 line:-2
to implement things
like instantaneous drag-and-drop,


710
00:37:36,857 --> 00:37:40,260 line:-1
or drag-select, as we see here in Pages.


711
00:37:40,327 --> 00:37:42,763 line:-2
Previously,
these interactions required you


712
00:37:42,829 --> 00:37:45,232 line:-2
to press and hold and wait
with your finger


713
00:37:45,299 --> 00:37:48,168 line:-2
to disambiguate between
scrolling with a single finger


714
00:37:48,235 --> 00:37:49,703 line:-1
and dragging on the content.


715
00:37:49,770 --> 00:37:53,640 line:-2
Now let's take a step beyond the way
the pointer interacts with your app,


716
00:37:53,707 --> 00:37:55,843 line:-2
and think about how the people
using your app


717
00:37:55,909 --> 00:37:58,645 line:-2
interact with the trackpad itself
through gestures.


718
00:37:59,012 --> 00:38:02,916 line:0
While one-finger interaction is largely
reserved for pointing and clicking,


719
00:38:02,983 --> 00:38:05,385 line:0
and three-finger gestures
are reserved by the system


720
00:38:05,452 --> 00:38:07,187 line:0
for actions like multitasking,


721
00:38:07,254 --> 00:38:10,224 line:0
your app can make use
of two-finger gestures on the trackpad.


722
00:38:10,290 --> 00:38:13,760 line:-2
We'll automatically enable
two-finger scrolling for scroll views,


723
00:38:13,827 --> 00:38:16,730 line:-2
but you may wish to provide
more custom interactions.


724
00:38:16,797 --> 00:38:19,233 line:-1
Be sure to design your trackpad gestures


725
00:38:19,299 --> 00:38:22,035 line:-2
with a relationship
to your touchscreen gestures


726
00:38:22,102 --> 00:38:25,339 line:-2
to create a consistent experience
across input modes.


727
00:38:25,405 --> 00:38:27,407 line:-1
When adding gestures to the trackpad,


728
00:38:27,474 --> 00:38:31,778 line:-2
we should always treat them as happening
relative to the pointer in your app.


729
00:38:31,845 --> 00:38:35,649 line:0
This means that gestures should be
performed on the view under your pointer.


730
00:38:35,716 --> 00:38:40,220 line:0
In this example, the pointer is moved
between the left and right scroll views,


731
00:38:40,287 --> 00:38:43,390 line:0
and the scroll gesture is always
performed on the appropriate view.


732
00:38:43,457 --> 00:38:45,192 line:-1
Taking this a bit further,


733
00:38:45,259 --> 00:38:48,562 line:-2
let's take a look
at how two-finger gestures behave in Maps.


734
00:38:49,162 --> 00:38:52,199 line:-2
As expected,
the map scrolls with two fingers


735
00:38:52,266 --> 00:38:53,600 line:-1
when the pointer is above it,


736
00:38:53,667 --> 00:38:56,436 line:-2
and the card scrolls
when the pointer is above it.


737
00:38:56,503 --> 00:39:00,807 line:-2
But Maps also allows using two fingers
to zoom and rotate.


738
00:39:00,874 --> 00:39:02,876 line:-1
This brings us to another detail


739
00:39:02,943 --> 00:39:05,379 line:-2
about gestures behaving
relative to the pointer.


740
00:39:05,445 --> 00:39:09,650 line:-2
As we zoom and rotate,
the view remains anchored to the pointer.


741
00:39:09,716 --> 00:39:13,820 line:-2
This keeps the pointer in a fixed position
relative to the map below,


742
00:39:13,887 --> 00:39:16,290 line:-2
no different
than if I had performed this gesture


743
00:39:16,356 --> 00:39:19,226 line:-2
with my fingers on the touchscreen
centered on the pointer.


744
00:39:19,293 --> 00:39:22,029 line:-2
Because the two-finger gestures
are intended to act


745
00:39:22,095 --> 00:39:23,597 line:-1
relative to the pointer,


746
00:39:23,664 --> 00:39:26,867 line:-2
it follows that you should be able
to use these gestures directly


747
00:39:26,934 --> 00:39:28,302 line:-1
on a focused element.


748
00:39:28,869 --> 00:39:32,606 line:-2
Think about places in your app
that allow dragging with a finger today


749
00:39:32,673 --> 00:39:35,375 line:-2
that could be adapted
to a two-finger trackpad drag.


750
00:39:35,442 --> 00:39:40,914 line:0
Another capability of trackpads and mice
is the ability to offer a secondary click.


751
00:39:40,981 --> 00:39:44,518 line:0
This can be exposed
via a two-finger click on a trackpad,


752
00:39:44,585 --> 00:39:46,720 line:-1
a secondary button on a mouse,


753
00:39:46,787 --> 00:39:49,156 line:-2
or even holding the control key
and clicking,


754
00:39:49,223 --> 00:39:51,725 line:-2
but the important fact
that these all have in common


755
00:39:51,792 --> 00:39:55,429 line:-2
is that they're all fast
and just about as easy as a regular click.


756
00:39:56,129 --> 00:39:58,765 line:-2
This means
we can instantaneously perform an action


757
00:39:58,832 --> 00:40:02,102 line:-2
that would have otherwise required
a long press or a special mode


758
00:40:02,169 --> 00:40:04,705 line:-2
to distinguish it
from a regular tap with the finger.


759
00:40:05,372 --> 00:40:09,343 line:-2
By default, we use this
to immediately show context menus.


760
00:40:09,409 --> 00:40:11,211 line:-1
This is an accelerator for an action


761
00:40:11,278 --> 00:40:13,313 line:-2
that would have otherwise required
a long press.


762
00:40:13,747 --> 00:40:17,150 line:-2
You'll get this for free in your app,
but in your custom interfaces,


763
00:40:17,217 --> 00:40:19,086 line:-1
you may want to consider the places


764
00:40:19,152 --> 00:40:23,323 line:-2
that an accelerated or alternate action
is appropriate for a secondary click.


765
00:40:23,390 --> 00:40:24,892 line:-1
So we've learned a lot today.


766
00:40:25,259 --> 00:40:27,160 line:-1
We've learned about adaptive precision,


767
00:40:27,227 --> 00:40:29,830 line:-2
how to customize the pointer
and its effects,


768
00:40:29,897 --> 00:40:32,065 line:-2
and how to make use
of pointer interactions


769
00:40:32,132 --> 00:40:34,067 line:-1
and gestures in your app.


770
00:40:34,134 --> 00:40:37,104 line:-2
These are all small pieces
when viewed individually,


771
00:40:37,171 --> 00:40:40,874 line:-2
adopting pointer effects to provide
the right amount of precision


772
00:40:40,941 --> 00:40:43,143 line:-1
and improve ergonomics,


773
00:40:43,210 --> 00:40:46,480 line:-2
integrating hover
to let your app respond to intent,


774
00:40:47,648 --> 00:40:50,684 line:-1
responding fluidly to two-finger gestures,


775
00:40:51,585 --> 00:40:55,122 line:-2
accelerating interactions
with secondary click,


776
00:40:55,189 --> 00:40:58,592 line:-2
and applying custom pointer shapes
that allow precision


777
00:40:58,659 --> 00:41:01,628 line:-1
while using snapping to improve accuracy.


778
00:41:02,196 --> 00:41:08,502 line:-2
But these small pieces combine to form
a whole, powerful, functional system


779
00:41:08,569 --> 00:41:10,871 line:-2
that allows you to build
highly responsive,


780
00:41:10,938 --> 00:41:12,873 line:-1
understandable interfaces,


781
00:41:12,940 --> 00:41:16,443 line:-2
combining unprecedented precision
with ease of use.


782
00:41:16,510 --> 00:41:18,545 line:-1
We hope you take what you've learned today


783
00:41:18,612 --> 00:41:21,515 line:-2
to elevate your already excellent
touchscreen apps


784
00:41:21,582 --> 00:41:24,751 line:-2
and make them even more powerful
with the pointer.


785
00:41:24,818 --> 00:41:25,886 line:-1
Thank you.

