1
00:00:03,804 --> 00:00:06,740 line:-1
Hello and welcome to WWDC.


2
00:00:08,642 --> 00:00:11,678 line:0
Hi. I'm Brent
from the Swift Compiler team.


3
00:00:11,745 --> 00:00:14,715 line:0
I'm gonna talk to you today about
how to make your Objective-C frameworks


4
00:00:14,781 --> 00:00:16,583 line:0
work really nicely in Swift.


5
00:00:16,650 --> 00:00:19,553 line:-2
We first introduced Swift
six years ago this month.


6
00:00:20,220 --> 00:00:22,489 line:-2
Since then,
something amazing has happened.


7
00:00:22,556 --> 00:00:24,725 line:-2
Most of you
have turned into Swift developers.


8
00:00:25,392 --> 00:00:29,696 line:-2
But Apple's platforms spent a very long
time as Objective-C-only platforms,


9
00:00:30,130 --> 00:00:32,566 line:-2
and a lot of you couldn't adopt Swift
right away.


10
00:00:33,166 --> 00:00:35,836 line:-2
So, many of you still have
a lot of Objective-C code today


11
00:00:35,903 --> 00:00:38,405 line:-2
that's increasingly being used
by Swift clients.


12
00:00:39,773 --> 00:00:42,543 line:-2
We understand that
because Apple is in the same boat.


13
00:00:43,177 --> 00:00:46,480 line:-2
We probably have more Objective-C
frameworks than anyone in the world.


14
00:00:46,547 --> 00:00:50,417 line:-2
So, we designed Swift to not only import
our Objective-C frameworks,


15
00:00:50,484 --> 00:00:54,454 line:-2
but also to automatically translate them
into more idiomatic Swift APIs.


16
00:00:55,122 --> 00:00:57,624 line:-2
We designed in ways
to customize the translation


17
00:00:57,691 --> 00:01:00,160 line:-2
by adding macros and keywords
to your header files.


18
00:01:01,461 --> 00:01:04,197 line:-2
And we built in the ability
to extend Objective-C frameworks


19
00:01:04,263 --> 00:01:05,966 line:-1
with custom Swift code


20
00:01:06,033 --> 00:01:10,437 line:-2
to wrap existing APIs or add new ones
that can't be expressed in Objective-C.


21
00:01:11,738 --> 00:01:16,210 line:-2
Best of all, we designed all of this
to work not just for us, but for you.


22
00:01:16,844 --> 00:01:18,278 line:-1
That's my topic for today.


23
00:01:18,912 --> 00:01:22,482 line:-2
I'm going to teach you the techniques
that Apple's Objective-C frameworks use


24
00:01:22,549 --> 00:01:24,651 line:-2
to improve how they're imported
into Swift.


25
00:01:25,586 --> 00:01:29,323 line:-2
And to do that, I'll be using
a little framework I call SpaceKit.


26
00:01:30,190 --> 00:01:31,792 line:-1
Let's take a look at it.


27
00:01:33,794 --> 00:01:37,497 line:-2
SpaceKit is an Objective-C framework
which has a few model APIs


28
00:01:37,564 --> 00:01:40,534 line:-2
for describing
NASA's early, crude space program.


29
00:01:40,601 --> 00:01:46,106 line:-2
So it can describe, you know, astronauts,
missions, rockets and so on.


30
00:01:46,173 --> 00:01:47,941 line:-1
If I look at the headers,


31
00:01:48,008 --> 00:01:50,077 line:-2
it's clear that this is
an Objective-C framework


32
00:01:50,143 --> 00:01:53,580 line:-2
full of #import directives,
@interface blocks,


33
00:01:53,647 --> 00:01:55,182 line:-1
methods with selectors.


34
00:01:55,749 --> 00:01:57,851 line:-1
But if I import it into Swift,


35
00:01:57,918 --> 00:02:01,588 line:-2
the compiler will automatically
translate it into a Swift API,


36
00:02:01,655 --> 00:02:04,591 line:-2
and I can see what that API will look like
right in Xcode


37
00:02:04,658 --> 00:02:07,261 line:-2
by looking at the header's
generated interface.


38
00:02:07,327 --> 00:02:10,197 line:-2
All I need to do
is open the Related Items menu


39
00:02:10,264 --> 00:02:11,865 line:-1
in the top left of the editor...


40
00:02:12,866 --> 00:02:15,302 line:-2
go down
to the Generated Interface submenu...


41
00:02:16,303 --> 00:02:18,639 line:-1
and then ask for the Swift 5 interface,


42
00:02:18,705 --> 00:02:21,975 line:-2
since 5.3 is the Swift version
in Xcode 12.


43
00:02:22,042 --> 00:02:25,345 line:-2
And what I end up with is basically
what a Swift header file would look like


44
00:02:25,412 --> 00:02:26,947 line:-1
if Swift had header files.


45
00:02:27,548 --> 00:02:29,616 line:-1
You can see that it has this class,


46
00:02:29,683 --> 00:02:33,654 line:-2
there's some initializers,
some properties, some methods.


47
00:02:33,720 --> 00:02:37,991 line:-2
But I don't see the bodies of these
declarations, just the interfaces.


48
00:02:38,058 --> 00:02:40,827 line:-2
This is a really valuable tool
to understand what Swift will see


49
00:02:40,894 --> 00:02:42,496 line:-1
when it imports this framework.


50
00:02:43,864 --> 00:02:46,767 line:-2
I'm going to be showing you
a lot of SpaceKit's generated interfaces,


51
00:02:46,834 --> 00:02:49,736 line:-2
these sort of pseudo headers,
throughout this talk.


52
00:02:50,737 --> 00:02:52,306 line:-1
If you poke around a little in them,


53
00:02:52,372 --> 00:02:54,775 line:-2
you'll see that Swift
is already doing some great stuff for you.


54
00:02:55,442 --> 00:02:58,045 line:-2
For instance, these parameters
were all NSString


55
00:02:58,111 --> 00:03:00,547 line:-1
and NSDate objects in Objective-C,


56
00:03:00,614 --> 00:03:03,951 line:-2
but the compiler has bridged them
into the structs you would use in Swift.


57
00:03:05,118 --> 00:03:08,188 line:-2
It's imported init methods
as initializers,


58
00:03:08,255 --> 00:03:11,692 line:-2
rewritten method names
into a style closer to Swift


59
00:03:11,758 --> 00:03:14,628 line:-2
and turned methods that follow
the Objective-C error handling convention


60
00:03:14,695 --> 00:03:16,430 line:-1
into throwing members.


61
00:03:16,496 --> 00:03:19,466 line:-2
But there's also some room
to improve this framework.


62
00:03:19,533 --> 00:03:22,836 line:-2
The API is peppered
with these implicitly unwrapped optionals.


63
00:03:23,637 --> 00:03:27,007 line:-2
The "Any" in "AnyHashable" types
in these collections are really vague.


64
00:03:28,108 --> 00:03:31,912 line:-2
This throwing method
will sometimes throw when it shouldn't.


65
00:03:31,979 --> 00:03:34,681 line:-2
And this method's name
may not quite be perfect.


66
00:03:36,149 --> 00:03:39,720 line:-2
Looking elsewhere, these two initializers
seem oddly redundant.


67
00:03:40,621 --> 00:03:44,358 line:-2
And this NSError information
will be difficult to use with try-catch.


68
00:03:46,026 --> 00:03:47,528 line:-1
And if you move away from objects


69
00:03:47,594 --> 00:03:49,830 line:-2
and take a look
at a more C-style part of SpaceKit,


70
00:03:49,897 --> 00:03:51,865 line:-2
you'll see more work
that needs to be done.


71
00:03:53,000 --> 00:03:56,870 line:-2
This type used NS_ENUM, so it comes in
as a very nice Swift enum.


72
00:03:57,638 --> 00:04:00,674 line:-2
But these collections of string constants
could use the same treatment.


73
00:04:01,542 --> 00:04:04,178 line:-2
And one of these constants
has straight-up vanished.


74
00:04:05,145 --> 00:04:09,082 line:-2
These free-floating utility functions
aren't ideal for Swift,


75
00:04:09,149 --> 00:04:12,019 line:-2
and this UInt result
will be a pain to work with.


76
00:04:12,653 --> 00:04:16,023 line:-2
I'm going to walk you through
how to improve all of that.


77
00:04:16,089 --> 00:04:19,593 line:-2
I'll show you how to specify the types
in your APIs more precisely


78
00:04:19,660 --> 00:04:22,329 line:-2
to help your Swift clients
use your framework correctly.


79
00:04:23,263 --> 00:04:25,732 line:-2
I'll talk about two very important
Objective-C conventions


80
00:04:25,799 --> 00:04:28,135 line:-1
that Swift assumes your APIs will follow.


81
00:04:29,036 --> 00:04:31,038 line:-1
I'll teach you how to correct situations


82
00:04:31,104 --> 00:04:34,241 line:-2
where Swift might not import things
that Objective-C can access.


83
00:04:35,142 --> 00:04:37,578 line:-2
And I'll help you put
the finishing touches on your framework


84
00:04:37,644 --> 00:04:39,880 line:-2
and make it feel
like a good Swift citizen.


85
00:04:40,480 --> 00:04:42,015 line:-1
So, let's get started...


86
00:04:42,783 --> 00:04:44,852 line:0
with those implicitly unwrapped optionals


87
00:04:44,918 --> 00:04:47,187 line:0
that appeared virtually everywhere
in the API.


88
00:04:47,254 --> 00:04:50,991 line:0
They leave really important aspects
of your framework's behavior undeclared.


89
00:04:51,658 --> 00:04:55,128 line:0
So, where did they come from,
and how do we get rid of them?


90
00:04:55,195 --> 00:04:58,699 line:0
Objective-C pointer types,
including id-types and blocks,


91
00:04:58,765 --> 00:05:01,602 line:0
can have a valid value
or they can have zero value,


92
00:05:01,668 --> 00:05:03,570 line:0
which we call "null" or "nil."


93
00:05:03,637 --> 00:05:08,175 line:-2
This is a lot like Swift's optional type,
which can either have value or be nil,


94
00:05:08,242 --> 00:05:12,746 line:-2
except that in Objective-C,
every pointer type is effectively optional


95
00:05:12,813 --> 00:05:15,816 line:-2
and every nonpointer type
is effectively nonoptional.


96
00:05:15,883 --> 00:05:17,484 line:-1
But, of course, a lot of the time,


97
00:05:17,551 --> 00:05:20,320 line:-2
a property or method
won't actually handle a nil input


98
00:05:20,387 --> 00:05:22,489 line:-1
or won't ever return a nil result.


99
00:05:22,556 --> 00:05:25,392 line:-2
So, when Swift imports
an Objective-C pointer type,


100
00:05:25,459 --> 00:05:28,629 line:-2
by default, it marks it
as an implicitly unwrapped optional


101
00:05:28,695 --> 00:05:32,900 line:-2
to tell you that this value could be nil,
but Swift isn't sure if it ever really is.


102
00:05:33,934 --> 00:05:37,538 line:-2
Fortunately, Objective-C provides
two nullability annotations,


103
00:05:37,604 --> 00:05:39,640 line:-1
nonnull and nullable,


104
00:05:39,706 --> 00:05:42,009 line:-2
which let you say
whether nil is a sensible value


105
00:05:42,075 --> 00:05:45,546 line:-2
for a particular property,
method parameter or method result.


106
00:05:46,513 --> 00:05:48,715 line:-2
Objective-C doesn't enforce
these annotations.


107
00:05:48,782 --> 00:05:50,551 line:-1
They just document your intent.


108
00:05:51,151 --> 00:05:52,886 line:-1
But Swift picks up this information


109
00:05:52,953 --> 00:05:55,856 line:-2
and uses it to decide
whether to make a type optional or not.


110
00:05:57,291 --> 00:06:00,928 line:-2
You apply these annotations
by editing your Objective-C header files.


111
00:06:01,995 --> 00:06:05,799 line:-2
In a property, the annotation goes
in a list of the property's attributes.


112
00:06:06,533 --> 00:06:10,771 line:0
In a method parameter or result type,
it goes right before the type's name.


113
00:06:12,339 --> 00:06:15,609 line:-2
So, let's say you're starting
with this name property.


114
00:06:15,676 --> 00:06:19,246 line:-2
You decide that instances of this class
may not always have a name,


115
00:06:19,313 --> 00:06:21,415 line:-1
so you add the nullable annotation


116
00:06:21,481 --> 00:06:24,451 line:-2
and the type in the generated interface
changes to optional.


117
00:06:24,918 --> 00:06:29,356 line:-2
Great. But then you hit "build"
and you start seeing new warnings appear.


118
00:06:30,090 --> 00:06:32,459 line:-1
Don't panic. You didn't break anything.


119
00:06:32,526 --> 00:06:34,094 line:-1
What happened is Xcode noticed


120
00:06:34,161 --> 00:06:37,164 line:-2
that you started using
nullability annotations in this header,


121
00:06:37,231 --> 00:06:39,066 line:-2
so it starts telling you
about all the places


122
00:06:39,132 --> 00:06:40,801 line:-1
that you still need to fill them in.


123
00:06:42,169 --> 00:06:44,204 line:-1
So that gives you a nice workflow.


124
00:06:44,271 --> 00:06:46,607 line:-2
Add the first annotation
somewhere in the header,


125
00:06:46,673 --> 00:06:49,176 line:-1
then work through it one warning at a time


126
00:06:49,243 --> 00:06:52,646 line:-2
filling in either "nullable" or "nonnull"
until all the warnings are gone.


127
00:06:54,147 --> 00:06:57,651 line:-2
Once you've done that, there's one more
clean-up step you should do--


128
00:06:57,718 --> 00:07:01,188 line:-2
add the NS_ASSUME_NONNULL_BEGIN macro
at the top of the file


129
00:07:01,255 --> 00:07:03,156 line:-1
and the matching end macro at the bottom,


130
00:07:03,957 --> 00:07:06,226 line:-1
then delete all the nonnulls between them.


131
00:07:06,693 --> 00:07:08,695 line:-1
This just cleans up the file a little


132
00:07:08,762 --> 00:07:10,898 line:-2
so that whenever you see
one of these keywords,


133
00:07:10,964 --> 00:07:13,600 line:-2
it always indicates
you'll get an optional in Swift.


134
00:07:14,201 --> 00:07:17,337 line:-2
When you're adding these,
occasionally you'll come across a case


135
00:07:17,404 --> 00:07:20,874 line:-2
where these annotations don't work,
like this constant.


136
00:07:20,941 --> 00:07:23,477 line:-2
If you try to put
the nonnull annotation in front of it,


137
00:07:23,544 --> 00:07:25,179 line:-1
you'll get a compiler error


138
00:07:25,245 --> 00:07:28,649 line:-2
and the generated interface
probably won't display at all.


139
00:07:28,715 --> 00:07:31,451 line:-2
The annotations I showed you
work with methods and properties,


140
00:07:31,518 --> 00:07:36,223 line:-2
but anywhere else, like constants
or global functions or blocks,


141
00:07:36,290 --> 00:07:39,560 line:-2
you'll have to use the qualifier versions
of these annotations instead.


142
00:07:40,427 --> 00:07:42,829 line:-2
These start with an underscore
and a capital letter,


143
00:07:42,896 --> 00:07:46,133 line:-2
and they work on any pointer type
anywhere in Objective-C.


144
00:07:46,200 --> 00:07:49,036 line:0
You'll also need these
for pointer-to-pointer types.


145
00:07:49,102 --> 00:07:52,639 line:0
In that case, you'll specify one keyword
for each level of the pointer,


146
00:07:52,706 --> 00:07:57,077 line:0
so you can say that the inner pointer
can be nil, but the outer one can't be,


147
00:07:57,144 --> 00:08:01,248 line:0
and Swift will nest the optional and
unsafe mutable pointer types correctly.


148
00:08:01,315 --> 00:08:05,052 line:-2
So, going back to our global,
we apply the underscore qualifier,


149
00:08:05,118 --> 00:08:08,422 line:-2
and it becomes nonoptional in Swift
just like we wanted.


150
00:08:09,323 --> 00:08:13,694 line:-2
When you're doing this, you need to be
careful that your annotations are correct.


151
00:08:13,760 --> 00:08:15,696 line:-2
For instance,
maybe you glance over this header


152
00:08:15,762 --> 00:08:19,633 line:-2
and you decide, "Of course every mission
is going to have a capsule.


153
00:08:19,700 --> 00:08:22,035 line:-1
Let's make the capsule property nonnull."


154
00:08:22,102 --> 00:08:24,404 line:-2
But it turns out later
that there was a mission


155
00:08:24,471 --> 00:08:26,139 line:-1
where they didn't launch a capsule,


156
00:08:26,206 --> 00:08:29,076 line:-2
and you do model that
by setting the capsule to nil.


157
00:08:29,142 --> 00:08:32,246 line:-2
In other words,
the nonnull annotation was wrong.


158
00:08:32,312 --> 00:08:34,948 line:-2
So, what's gonna happen
when Objective-C returns "nil"


159
00:08:35,015 --> 00:08:37,751 line:-2
for a value Swift thinks
can't be optional?


160
00:08:37,818 --> 00:08:41,688 line:-2
Well, if it's an NSString or NSArray
on the Objective-C side,


161
00:08:41,755 --> 00:08:43,490 line:-1
there's a special case.


162
00:08:43,557 --> 00:08:45,759 line:-1
You get an empty Swift string or array.


163
00:08:46,660 --> 00:08:49,696 line:-2
That could be a problem here
because SpaceKit expects the string


164
00:08:49,763 --> 00:08:54,434 line:-2
to equal one of its SKCapsule constants,
and none of those equal empty string,


165
00:08:55,302 --> 00:08:58,238 line:-2
so you'll end up with a value
that you might not handle correctly.


166
00:08:59,473 --> 00:09:01,742 line:-1
For other types, it can get a lot weirder.


167
00:09:02,676 --> 00:09:04,945 line:-1
You can end up with an invalid object,


168
00:09:05,012 --> 00:09:08,015 line:-2
something you usually can only get
from unsafe operations.


169
00:09:09,082 --> 00:09:11,952 line:-2
If it's an Objective-C object,
you might not even notice


170
00:09:12,019 --> 00:09:14,488 line:-2
because Objective-C method calls
ignore nils.


171
00:09:14,555 --> 00:09:17,591 line:-2
But in some cases, you'll crash
with a null pointer dereference


172
00:09:17,658 --> 00:09:19,526 line:-1
or get other unexpected behavior,


173
00:09:19,960 --> 00:09:22,763 line:-2
and the compiler doesn't promise anything
about what happens,


174
00:09:22,829 --> 00:09:25,532 line:-2
so switching to release mode
or changing Xcode versions


175
00:09:25,599 --> 00:09:27,734 line:-2
could change the symptoms
of this kind of bug.


176
00:09:29,303 --> 00:09:32,873 line:-2
The important point is when you write
in the header that something can't be nil,


177
00:09:32,940 --> 00:09:35,709 line:-2
Swift doesn't force-unwrap it,
so you won't see a crash


178
00:09:35,776 --> 00:09:37,511 line:-1
at the place where it returned nil.


179
00:09:38,445 --> 00:09:40,814 line:-2
Swift doesn't second-guess
your Objective-C headers.


180
00:09:40,881 --> 00:09:42,549 line:-1
It believes what they tell it.


181
00:09:43,116 --> 00:09:47,221 line:-2
The good news is the Objective-C compiler
and the Clang Static Analyzer


182
00:09:47,287 --> 00:09:49,556 line:-1
also look at nullability annotations


183
00:09:49,623 --> 00:09:52,626 line:-2
and can point out many violations
in your Objective-C code.


184
00:09:53,227 --> 00:09:54,862 line:-1
So, if you say something can't be nil,


185
00:09:54,928 --> 00:09:57,297 line:-2
but you have Objective-C code
that makes it nil,


186
00:09:57,364 --> 00:09:59,666 line:-2
these tools might tell you
that something's amiss.


187
00:09:59,733 --> 00:10:02,002 line:-2
Once you finish adding
nullability annotations,


188
00:10:02,069 --> 00:10:05,672 line:-2
it's a good idea to look for new warnings
or static analyzer results


189
00:10:05,739 --> 00:10:07,908 line:-2
in both the framework's
implementation files


190
00:10:07,975 --> 00:10:10,444 line:-2
and any Objective-C clients
you have access to.


191
00:10:10,511 --> 00:10:13,013 line:-2
Those results could indicate
that you have mis-annotated,


192
00:10:13,080 --> 00:10:16,517 line:-2
or they could be telling you about subtle
bugs that you never knew were there.


193
00:10:16,583 --> 00:10:20,354 line:-2
But suppose you see some warnings
or analyzer results


194
00:10:20,420 --> 00:10:23,657 line:-2
and can't quite decide
if they can actually happen.


195
00:10:23,724 --> 00:10:25,993 line:-2
Or you just had
some really complicated old code


196
00:10:26,059 --> 00:10:29,363 line:-2
and you can't figure out if there's
an edge case where it will return nil.


197
00:10:29,930 --> 00:10:31,265 line:-1
What should you do then?


198
00:10:31,698 --> 00:10:35,702 line:-2
Well, earlier I mentioned the nonnull
and nullable annotations.


199
00:10:35,769 --> 00:10:38,839 line:-2
There's actually a third option
called null unspecified


200
00:10:38,906 --> 00:10:42,509 line:-2
which makes Swift import the value
as an implicitly unwrapped optional.


201
00:10:42,576 --> 00:10:44,178 line:-1
You should use this in all the places


202
00:10:44,244 --> 00:10:46,580 line:-2
you'd use an implicitly unwrapped
optional in Swift,


203
00:10:46,647 --> 00:10:50,350 line:-2
like values that are only nil
very early in an object's life cycle.


204
00:10:50,417 --> 00:10:53,287 line:-2
But you can also use it
when you think an API can't return nil


205
00:10:53,353 --> 00:10:54,621 line:-1
but you're not sure,


206
00:10:54,688 --> 00:10:58,091 line:-2
that way Swift clients can still use
the result without unwrapping it.


207
00:10:58,158 --> 00:11:00,294 line:-2
But if the framework
does end up returning nil,


208
00:11:00,360 --> 00:11:02,396 line:-2
you'll reliably get a crash
at the use site


209
00:11:02,462 --> 00:11:05,732 line:-2
instead of maybe getting
some impossible-seeming misbehavior


210
00:11:05,799 --> 00:11:06,934 line:-1
sometime later.


211
00:11:07,768 --> 00:11:11,772 line:-2
We've gone through our project and we've
added all of the nullability annotations.


212
00:11:11,839 --> 00:11:14,842 line:-2
Great. Next we'd like to deal
with this array of "Any"


213
00:11:14,908 --> 00:11:17,244 line:-2
and other collections
that aren't bridging very well.


214
00:11:17,878 --> 00:11:20,647 line:-2
It turns out Objective-C
supports a generic syntax


215
00:11:20,714 --> 00:11:22,349 line:-1
that's a lot like Swift's,


216
00:11:22,416 --> 00:11:25,986 line:-2
so if you make it an NSArray
of SKAstronauts in Objective-C,


217
00:11:26,053 --> 00:11:28,755 line:-2
you'll get a Swift array of SKAstronauts
in Swift.


218
00:11:28,822 --> 00:11:31,491 line:-2
This also works with NSSet
and NSDictionary,


219
00:11:31,558 --> 00:11:33,660 line:-1
so it can really improve a lot of APIs.


220
00:11:34,127 --> 00:11:37,364 line:-2
Next, let's go take a look
at a different area of the project.


221
00:11:37,431 --> 00:11:40,968 line:-2
Here we have a function
called SKRocketStageCount,


222
00:11:41,034 --> 00:11:43,971 line:-2
and, like you'd expect from the name,
it returns a count.


223
00:11:44,037 --> 00:11:47,708 line:-2
Since a count can't be negative,
it returns it as an NSUInteger,


224
00:11:47,774 --> 00:11:50,344 line:-2
which means that in Swift,
it returns a UInt,


225
00:11:50,410 --> 00:11:53,180 line:-2
and that means this function
breaks a Swift convention.


226
00:11:53,780 --> 00:11:57,918 line:-2
In both Objective-C and Swift,
it's conventional to use unsigned types


227
00:11:57,985 --> 00:12:00,020 line:-2
when an integer represents
a collection of bits


228
00:12:00,087 --> 00:12:02,890 line:-2
and you want to perform bitwise operations
on those bits,


229
00:12:02,956 --> 00:12:07,127 line:-2
or do some other computation where
signed arithmetic might get in the way.


230
00:12:07,194 --> 00:12:08,929 line:-2
Usually,
when you're working at this level,


231
00:12:08,996 --> 00:12:11,932 line:-2
you care about the exact number of bits
in the value.


232
00:12:11,999 --> 00:12:17,437 line:-2
NSUInteger's size varies by architecture,
so people rarely use it in this way.


233
00:12:17,504 --> 00:12:21,775 line:-2
Rather, the main reason people use
NSUInteger in Objective-C


234
00:12:21,842 --> 00:12:25,045 line:-2
is to indicate that a number's value
is never negative.


235
00:12:25,112 --> 00:12:28,282 line:-2
Objective-C enables this style
with automatic conversions


236
00:12:28,348 --> 00:12:30,751 line:-1
and carefully designed overflow behaviors,


237
00:12:30,817 --> 00:12:33,987 line:-2
but these exact features
can cause serious security bugs,


238
00:12:34,054 --> 00:12:35,822 line:-1
so Swift doesn't include them.


239
00:12:35,889 --> 00:12:40,227 line:-2
Instead, Swift requires you to explicitly
convert unsigned types to signed


240
00:12:40,294 --> 00:12:42,062 line:-1
if you wanted signed arithmetic,


241
00:12:42,129 --> 00:12:46,133 line:-2
and stops execution if unsigned arithmetic
would produce a negative result.


242
00:12:46,200 --> 00:12:49,403 line:-2
This makes it more difficult
to mix Int and UInt in Swift


243
00:12:49,469 --> 00:12:53,340 line:-2
the way you might mix NSInteger
and NSUInteger in Objective-C.


244
00:12:54,074 --> 00:12:57,377 line:-2
So, the conventional Swift style
is to just not do that.


245
00:12:58,145 --> 00:13:03,383 line:-2
Instead, idiomatic Swift APIs use Int,
even for values that are never negative.


246
00:13:05,285 --> 00:13:07,521 line:-2
For Apple's frameworks,
we applied a blanket rule


247
00:13:07,588 --> 00:13:10,824 line:-2
that all NSUIntegers turn into Ints
when Swift imports them.


248
00:13:11,825 --> 00:13:14,728 line:-2
For your frameworks, it's your choice
whether to update your headers


249
00:13:14,795 --> 00:13:18,365 line:-2
to use NSInteger or not,
but we recommend that you do.


250
00:13:19,066 --> 00:13:21,201 line:-2
It makes very little difference
in Objective-C,


251
00:13:21,268 --> 00:13:23,403 line:-1
but it has a huge impact in Swift.


252
00:13:24,438 --> 00:13:28,775 line:-2
If we look at the broader context, there's
a bigger problem with this function,


253
00:13:28,842 --> 00:13:31,712 line:-2
and it's that clients can misuse it
very easily.


254
00:13:31,778 --> 00:13:34,281 line:-2
The SKRocketStageCount function
is supposed to be used


255
00:13:34,348 --> 00:13:36,517 line:-1
with these SKRocket constants.


256
00:13:36,583 --> 00:13:39,987 line:-2
That's what the matching names
are supposed to indicate.


257
00:13:40,053 --> 00:13:43,156 line:-2
But Swift doesn't know that
because what Swift sees


258
00:13:43,223 --> 00:13:45,292 line:-1
is this function takes a string.


259
00:13:45,359 --> 00:13:46,860 line:-1
These constants are all strings,


260
00:13:46,927 --> 00:13:49,630 line:-2
but there are a heck
of a lot more strings out there too.


261
00:13:49,696 --> 00:13:51,899 line:-2
And if you pass one of those
to SKRocketStageCount,


262
00:13:51,965 --> 00:13:53,834 line:-1
it probably won't do anything good.


263
00:13:54,501 --> 00:13:57,004 line:-2
In a pure Swift framework,
you could prevent this.


264
00:13:57,070 --> 00:13:59,606 line:-2
You'd just turn these constants
into an enum or a struct


265
00:13:59,673 --> 00:14:01,708 line:-1
with a raw value of type String,


266
00:14:01,775 --> 00:14:04,111 line:-2
and then change the function
to take only that type.


267
00:14:04,178 --> 00:14:07,047 line:-2
You could do that to SpaceKit
by wrapping these APIs by hand,


268
00:14:07,114 --> 00:14:09,016 line:-1
but there's a much easier way.


269
00:14:10,150 --> 00:14:13,687 line:-2
First, you introduce a new typedef
to group the constants together


270
00:14:13,754 --> 00:14:17,090 line:-2
and change all the places
involving the constants to use that.


271
00:14:17,157 --> 00:14:20,561 line:-1
By itself, this does practically nothing.


272
00:14:20,627 --> 00:14:23,597 line:-2
A typedef gets imported as a type-alias
in Swift,


273
00:14:23,664 --> 00:14:27,467 line:-2
and in both languages, that's just
an exact synonym for the original type.


274
00:14:27,534 --> 00:14:29,636 line:-1
But that's just a preparatory step.


275
00:14:31,004 --> 00:14:34,741 line:-2
Next you add the NS_STRING_ENUM macro
after the typedef.


276
00:14:34,808 --> 00:14:37,778 line:-2
This dramatically reshapes
the typedef in Swift.


277
00:14:37,845 --> 00:14:41,748 line:-2
It now imports as a struct
with the constants nested inside it,


278
00:14:41,815 --> 00:14:45,519 line:-2
making something that looks and feels
just like an enum with a raw string value.


279
00:14:46,653 --> 00:14:49,790 line:-2
And most importantly,
it means that the StageCount function


280
00:14:49,857 --> 00:14:51,825 line:-1
no longer takes arbitrary strings.


281
00:14:51,892 --> 00:14:55,362 line:-2
It only takes instances of SKRocket.
Mission accomplished.


282
00:14:56,496 --> 00:15:00,067 line:-2
You can use this feature
to define your own custom string enums,


283
00:15:00,133 --> 00:15:02,402 line:-2
but Apple's frameworks
define a lot of them too.


284
00:15:03,103 --> 00:15:05,639 line:-2
I've listed a few common ones
from Foundation here,


285
00:15:05,706 --> 00:15:09,243 line:-2
but there are least 50
in the iOS SDK alone.


286
00:15:09,309 --> 00:15:11,512 line:-2
It'd be a good idea to look
for NSString parameters


287
00:15:11,578 --> 00:15:14,448 line:-2
or constants in your APIs,
which really ought to be one of these,


288
00:15:14,515 --> 00:15:16,016 line:-1
and update them to match.


289
00:15:16,083 --> 00:15:19,486 line:-2
Next, let's talk about some ways
that you could get into trouble


290
00:15:19,553 --> 00:15:22,055 line:-2
by not following Objective-C conventions
correctly


291
00:15:22,122 --> 00:15:23,624 line:-1
when Swift assumes that you will.


292
00:15:24,157 --> 00:15:26,927 line:-2
When you look at the generated interface
for SKAstronaut,


293
00:15:26,994 --> 00:15:28,929 line:-1
you see something kind of funny.


294
00:15:28,996 --> 00:15:30,931 line:-1
This class has two initializers.


295
00:15:31,532 --> 00:15:35,302 line:-2
Both of them are passed a person's name,
but in two slightly different forms.


296
00:15:36,036 --> 00:15:39,606 line:-2
One takes a PersonNameComponents,
a Foundation type that has properties


297
00:15:39,673 --> 00:15:41,608 line:-1
for things like given name and surname.


298
00:15:42,176 --> 00:15:44,378 line:-1
The other take a string labeled "name."


299
00:15:44,444 --> 00:15:48,515 line:-2
It stands to reason that one of these
initializers probably calls the other.


300
00:15:48,582 --> 00:15:53,053 line:-2
And yet if you subclass SKAstronaut,
Swift will make you override both of them.


301
00:15:53,120 --> 00:15:54,855 line:-1
That seems a little unnecessary.


302
00:15:55,689 --> 00:15:58,759 line:-2
But there's actually a second issue
with this class's initializers,


303
00:15:58,825 --> 00:16:01,461 line:-2
one that isn't visible
in the generated interface.


304
00:16:02,162 --> 00:16:04,331 line:-2
If you look in SKAstronaut's
code completion,


305
00:16:04,398 --> 00:16:07,100 line:-2
you'll see a third initializer
with no parameters.


306
00:16:07,167 --> 00:16:09,336 line:-1
This init isn't in the generated interface


307
00:16:09,403 --> 00:16:11,772 line:-2
and it's not in
the original header either.


308
00:16:11,839 --> 00:16:14,274 line:-1
It seems like it came from outer space.


309
00:16:14,341 --> 00:16:17,377 line:-2
But in fact it came from here,
from the super class.


310
00:16:18,278 --> 00:16:21,648 line:-1
SKAstronaut inherited it from NSObject,


311
00:16:21,715 --> 00:16:25,853 line:-2
and even though your clients can call it,
it may not actually work properly.


312
00:16:25,919 --> 00:16:28,455 line:-2
These two problems
have the same root cause.


313
00:16:29,389 --> 00:16:31,758 line:-2
In Objective-C,
there's a convention for initializers


314
00:16:31,825 --> 00:16:34,361 line:-2
which makes sure
the clients know how to write a subclass


315
00:16:34,428 --> 00:16:36,563 line:-2
that will always
get initialized correctly.


316
00:16:37,497 --> 00:16:40,234 line:-2
The convention divides initializers
into two categories--


317
00:16:40,300 --> 00:16:42,269 line:-1
designated and convenience.


318
00:16:42,970 --> 00:16:45,339 line:-2
You need to override
all of the designated initializers


319
00:16:45,405 --> 00:16:48,175 line:-2
to make it safe to inherit
the convenience initializers.


320
00:16:48,675 --> 00:16:52,946 line:-2
Now, if you're thinking,
"Gosh, this sounds really familiar..."


321
00:16:54,081 --> 00:16:56,149 line:-1
that's because it is.


322
00:16:56,216 --> 00:16:59,753 line:-2
Swift classes use the same basic model
for their initializers.


323
00:16:59,820 --> 00:17:01,989 line:-1
There are some differences in the details.


324
00:17:02,055 --> 00:17:04,491 line:-2
For example, you mark
the designated inits in one language


325
00:17:04,558 --> 00:17:06,560 line:-1
and the convenience inits in the other.


326
00:17:06,627 --> 00:17:09,363 line:-2
But Swift classes have these
same two categories of initializers,


327
00:17:09,429 --> 00:17:11,698 line:-1
and they work in basically the same way.


328
00:17:12,665 --> 00:17:16,002 line:-2
But unfortunately, the biggest difference
between the languages here


329
00:17:16,069 --> 00:17:20,941 line:-2
is that in Objective-C, designated
initializers are not a language rule.


330
00:17:21,008 --> 00:17:23,944 line:-2
They're a convention
that each class must choose to follow


331
00:17:24,011 --> 00:17:26,747 line:-2
by marking at least one initializer
as designated.


332
00:17:27,347 --> 00:17:30,117 line:-1
And many Objective-C classes don't opt in.


333
00:17:30,184 --> 00:17:32,986 line:-2
This means that clients don't know
how to subclass your class.


334
00:17:33,720 --> 00:17:37,357 line:-2
That's not great for any class,
but it's especially bad for frameworks


335
00:17:37,424 --> 00:17:39,593 line:-2
because then clients have to read
your source code


336
00:17:39,660 --> 00:17:43,163 line:-2
or reverse engineer your behavior
or just guess,


337
00:17:43,230 --> 00:17:45,899 line:-2
and those are all good ways
to end up with buggy subclasses.


338
00:17:46,600 --> 00:17:50,737 line:-2
That's bad enough, but it also means
that you, the frameworks maintainer,


339
00:17:50,804 --> 00:17:53,907 line:-2
don't get warnings if you forget
to override something you want to.


340
00:17:54,842 --> 00:17:58,111 line:-2
If a client uses an initializer
that you forgot to override,


341
00:17:58,178 --> 00:18:01,481 line:-2
that means your class gets skipped over
during initialization.


342
00:18:01,548 --> 00:18:05,385 line:-2
So, ivars you thought would always refer
to an object will be nil instead.


343
00:18:06,486 --> 00:18:09,289 line:-2
And even if you did override
everything you needed to,


344
00:18:09,356 --> 00:18:12,292 line:-2
mistakes are so common
that clients can't really be sure of that.


345
00:18:12,826 --> 00:18:17,030 line:-2
So, the first step in fixing this problem
will be to opt in to this convention


346
00:18:17,097 --> 00:18:19,967 line:-2
by marking your designated initializers
in your headers.


347
00:18:20,868 --> 00:18:24,004 line:-2
If you're not sure which initializers
should be designated,


348
00:18:24,071 --> 00:18:25,739 line:-1
take a look at the implementation.


349
00:18:26,373 --> 00:18:30,544 line:-2
Typically, designated initializers
will call an init with "super,"


350
00:18:30,611 --> 00:18:33,013 line:-2
convenience initializers
will call one with "self."


351
00:18:33,847 --> 00:18:36,083 line:-2
So, by looking at their bodies,
you can determine


352
00:18:36,149 --> 00:18:38,852 line:-2
that an init With Name Components
should be designated,


353
00:18:38,919 --> 00:18:40,921 line:-1
and init With Names should be convenience.


354
00:18:42,155 --> 00:18:44,558 line:-2
With that in mind,
you can go back to the header file


355
00:18:44,625 --> 00:18:48,829 line:-2
and mark the designated initializers
with NS_DESIGNATED_INITIALIZER


356
00:18:48,896 --> 00:18:51,932 line:-2
while leaving
the convenience initializers unchanged.


357
00:18:51,999 --> 00:18:55,035 line:-2
In SpaceKit, you'll mark
init With Name Components as designated,


358
00:18:55,102 --> 00:18:56,904 line:-1
while leaving init With Name alone.


359
00:18:57,838 --> 00:19:01,675 line:-2
Once we're done, Swift will recognize that
init Name is a convenience initializer


360
00:19:01,742 --> 00:19:03,510 line:-1
and mark it with a convenience keyword.


361
00:19:04,611 --> 00:19:06,813 line:-2
At this point,
you may start seeing warnings


362
00:19:06,880 --> 00:19:08,982 line:-1
in your Objective-C implementation files


363
00:19:09,049 --> 00:19:12,653 line:-2
about superclass designated initializers
that you need to override.


364
00:19:13,487 --> 00:19:15,222 line:-1
These were latent bugs.


365
00:19:15,289 --> 00:19:16,690 line:-1
If someone had used one of them,


366
00:19:16,757 --> 00:19:19,226 line:-2
your object
wouldn't have been initialized correctly.


367
00:19:21,094 --> 00:19:23,497 line:-2
If you want your class to support
any of these initializers,


368
00:19:23,564 --> 00:19:25,866 line:-1
just go ahead and implement them normally.


369
00:19:25,933 --> 00:19:27,401 line:-1
But if you don't,


370
00:19:27,467 --> 00:19:30,637 line:-2
implement an override
that calls does Not Recognize Selector.


371
00:19:31,438 --> 00:19:32,806 line:-1
Then go back to the header file


372
00:19:32,873 --> 00:19:35,576 line:-2
and declare it
with the NS_UNAVAILABLE attribute.


373
00:19:35,642 --> 00:19:38,846 line:-2
Then do the same thing for any superclass
convenience initializers


374
00:19:38,912 --> 00:19:40,914 line:-2
since they might call
the one you disabled.


375
00:19:41,415 --> 00:19:45,686 line:-2
Marking these initializers as unavailable
is the equivalent to not inheriting them,


376
00:19:45,752 --> 00:19:47,421 line:-1
which is what Swift would do automatically


377
00:19:47,487 --> 00:19:50,457 line:-2
if you didn't override
a designated initializer.


378
00:19:50,524 --> 00:19:53,427 line:-2
With these changes,
your Swift and your Objective-C clients


379
00:19:53,493 --> 00:19:55,629 line:-1
will now know which initializers will work


380
00:19:55,696 --> 00:19:58,498 line:-2
and which ones they need to override
in their subclasses.


381
00:19:58,565 --> 00:19:59,933 line:-1
That's a win all around.


382
00:20:00,734 --> 00:20:04,004 line:-2
Next, let's talk about
the Objective-C error handling convention.


383
00:20:04,071 --> 00:20:07,374 line:-2
Earlier, I said this method might throw
when it shouldn't.


384
00:20:08,308 --> 00:20:11,311 line:-2
This doc comment,
or rather the behavior it describes,


385
00:20:11,378 --> 00:20:13,113 line:-1
is the reason.


386
00:20:13,180 --> 00:20:14,815 line:-1
A lot of Objective-C developers


387
00:20:14,882 --> 00:20:17,684 line:-2
misunderstand
the error handling convention.


388
00:20:17,751 --> 00:20:20,554 line:-2
They think that if a method
wants to signal failure,


389
00:20:20,621 --> 00:20:24,191 line:-2
it has to return "false"
and set the error to a nonnil value.


390
00:20:25,158 --> 00:20:27,995 line:-2
A "false" return alone, they think,
isn't a failure.


391
00:20:28,061 --> 00:20:30,831 line:-1
It's just false or nil or whatever.


392
00:20:32,466 --> 00:20:34,835 line:-1
But that isn't actually the convention.


393
00:20:34,902 --> 00:20:38,872 line:-2
The convention is, if a method returns
a false value, that's a failure


394
00:20:38,939 --> 00:20:40,874 line:-1
even if the error value is "nil."


395
00:20:41,608 --> 00:20:44,411 line:-2
We really don't recommend
leaving the error "nil"


396
00:20:44,478 --> 00:20:46,914 line:-2
because then your caller
has no idea what happened.


397
00:20:46,980 --> 00:20:50,017 line:-2
But if you do,
a "false" return is still a failure.


398
00:20:50,617 --> 00:20:51,818 line:-1
When Swift generates a call


399
00:20:51,885 --> 00:20:54,655 line:-2
to an Objective-C method it has imported
with throws,


400
00:20:54,721 --> 00:20:57,357 line:-2
it assumes that the method
will follow this rule correctly,


401
00:20:57,424 --> 00:21:00,360 line:-2
so it always throws
if the method returns "false."


402
00:21:00,761 --> 00:21:03,997 line:-2
Swift doesn't allow you to throw "nil,"
so if there is no error,


403
00:21:04,064 --> 00:21:06,533 line:-2
Swift throws
a nonpublic Foundation error type.


404
00:21:07,334 --> 00:21:11,004 line:-2
Because the type is not public,
you can't write a catch statement for it.


405
00:21:11,839 --> 00:21:16,944 line:-2
But if you see this type and case in logs,
the debugger or error messages,


406
00:21:17,010 --> 00:21:19,546 line:-2
it means that some Objective-C code
either returned "false"


407
00:21:19,613 --> 00:21:23,116 line:-2
even though it didn't fail,
or it failed but didn't tell you why.


408
00:21:24,618 --> 00:21:27,855 line:-2
So let's think about how that applies
to this SpaceKit method.


409
00:21:27,921 --> 00:21:30,290 line:-2
Its documentation says
that it can return "false"


410
00:21:30,357 --> 00:21:33,460 line:-2
in a situation where it has skipped work,
but hasn't actually failed.


411
00:21:34,895 --> 00:21:36,797 line:-2
But Swift assumes
that a false return value


412
00:21:36,864 --> 00:21:38,432 line:-1
means it should throw an error,


413
00:21:38,498 --> 00:21:40,567 line:-1
and since the method didn't set an error,


414
00:21:40,634 --> 00:21:43,637 line:-2
it'll be one of those internal Foundation
"nil errors" I mentioned.


415
00:21:43,704 --> 00:21:45,005 line:-1
What can you do about that?


416
00:21:45,072 --> 00:21:46,974 line:-1
Well, you have a few options.


417
00:21:47,708 --> 00:21:50,310 line:-2
The easiest is to simply remove
the special case


418
00:21:50,377 --> 00:21:52,179 line:-1
so that false always means failure


419
00:21:52,246 --> 00:21:54,648 line:-2
and the method follows
the convention properly.


420
00:21:54,715 --> 00:21:56,083 line:-1
But that's probably not workable


421
00:21:56,149 --> 00:21:58,118 line:-2
if clients actually need
to detect this case.


422
00:21:58,552 --> 00:22:01,488 line:-1
An alternative is to use NS_SWIFT_NOTHROW


423
00:22:01,555 --> 00:22:04,224 line:-2
to tell Swift that you're not following
the error convention.


424
00:22:04,291 --> 00:22:06,159 line:-2
Swift will then import the method
the normal way


425
00:22:06,226 --> 00:22:08,295 line:-2
and you can write
error handling code manually.


426
00:22:09,062 --> 00:22:10,864 line:-2
This still leaves the method
kind of broken,


427
00:22:10,931 --> 00:22:13,100 line:-2
but it might be a good solution
if you're also planning


428
00:22:13,166 --> 00:22:15,969 line:-2
to deprecate the method
and write a better replacement.


429
00:22:17,504 --> 00:22:20,440 line:-2
Whether or not you kept
the original around in deprecated form,


430
00:22:20,507 --> 00:22:23,510 line:-2
that better replacement would need
to change the method's signature


431
00:22:23,577 --> 00:22:25,846 line:-2
so that it can follow
the error handling convention


432
00:22:25,913 --> 00:22:28,081 line:-2
while returning the extra information
another way.


433
00:22:28,782 --> 00:22:30,751 line:-2
For instance, you could add
a Boolean out parameter


434
00:22:30,817 --> 00:22:33,220 line:-2
to say whether the file
was actually saved.


435
00:22:33,287 --> 00:22:36,456 line:-2
Then the return value can be used
the way the error convention specifies.


436
00:22:36,857 --> 00:22:39,059 line:-2
That's not perfect,
but it's about the best you can do


437
00:22:39,126 --> 00:22:40,494 line:-1
from just Objective-C.


438
00:22:41,328 --> 00:22:44,531 line:-2
But if you want to go a little further
and write a bit of Swift code,


439
00:22:44,598 --> 00:22:46,733 line:-2
you can get perfect Swift import
from this method.


440
00:22:47,467 --> 00:22:48,769 line:-1
Let me show you how.


441
00:22:50,804 --> 00:22:53,307 line:-2
So, let's take a look at the header
for SKMission.


442
00:22:53,907 --> 00:22:56,243 line:-2
You can see I've been updating it
as we go along


443
00:22:56,310 --> 00:22:58,278 line:-1
and now it has the old deprecated method


444
00:22:58,912 --> 00:23:01,048 line:-2
plus the new method
with the extra parameter


445
00:23:02,015 --> 00:23:03,383 line:-1
so it follows the convention.


446
00:23:04,351 --> 00:23:05,519 line:-1
Great.


447
00:23:06,153 --> 00:23:08,255 line:-1
Now, let's write the better Swift version.


448
00:23:08,322 --> 00:23:11,058 line:-2
To start, I need to add
a Swift file to my project


449
00:23:11,124 --> 00:23:12,659 line:-1
so I can put my Swift method in it.


450
00:23:13,393 --> 00:23:15,729 line:-2
I'll do that the same way
I'd add an Objective-C file,


451
00:23:15,796 --> 00:23:17,698 line:-1
but choosing the Swift template instead.


452
00:23:24,037 --> 00:23:25,973 line:-2
I don't need to import
SpaceKit in this file


453
00:23:26,039 --> 00:23:28,242 line:-2
because it's already
part of the framework.


454
00:23:28,308 --> 00:23:31,745 line:-2
But it doesn't automatically see
every bit of Objective-C in SpaceKit.


455
00:23:32,479 --> 00:23:34,982 line:-2
What happens is that Swift
automatically imports everything


456
00:23:35,048 --> 00:23:37,184 line:-1
in SpaceKit's umbrella header.


457
00:23:37,251 --> 00:23:40,320 line:-2
The umbrella header is the header
with the same name as the framework,


458
00:23:40,387 --> 00:23:42,723 line:-1
so for this framework it's SpaceKit.h.


459
00:23:46,360 --> 00:23:47,427 line:-1
Since the umbrella header


460
00:23:47,494 --> 00:23:49,997 line:-2
imports all of the public headers
in this framework,


461
00:23:50,063 --> 00:23:52,966 line:-2
my Swift file will see everything
declared in all of those headers.


462
00:23:53,634 --> 00:23:56,370 line:-2
It's always a good practice to have
an umbrella header in a framework,


463
00:23:56,436 --> 00:23:59,806 line:-2
but it's especially important
in a framework that'll be used from Swift.


464
00:24:00,407 --> 00:24:02,809 line:-2
App and test targets
don't have umbrella headers,


465
00:24:02,876 --> 00:24:05,979 line:-2
so Xcode offers to add
a special bridging header to those targets


466
00:24:06,046 --> 00:24:07,447 line:-1
that serves this function.


467
00:24:07,981 --> 00:24:10,217 line:-2
Quick aside here,
there's one public header


468
00:24:10,284 --> 00:24:12,319 line:-2
that I shouldn't import
in the umbrella header.


469
00:24:15,889 --> 00:24:17,491 line:-1
And that's the generated header.


470
00:24:17,558 --> 00:24:20,327 line:-2
The SpaceKit-Swift header
which declares anything I mark


471
00:24:20,394 --> 00:24:22,663 line:-1
with @objc in Swift.


472
00:24:22,729 --> 00:24:25,599 line:-2
The problem is that this forms
a circular dependency.


473
00:24:26,633 --> 00:24:28,569 line:-1
Swift can't make the generated header


474
00:24:28,635 --> 00:24:30,904 line:-2
without first importing everything
in my umbrella header.


475
00:24:31,672 --> 00:24:34,474 line:-2
So, if the umbrella header
imports the generated header,


476
00:24:34,541 --> 00:24:38,045 line:-2
then Swift will try to read this file
that it hasn't generated yet.


477
00:24:38,612 --> 00:24:41,448 line:0
And that will just ruin your whole day.


478
00:24:42,850 --> 00:24:46,019 line:-2
So, don't import the generated header
in your other headers,


479
00:24:46,086 --> 00:24:47,821 line:-1
only in your implementation files.


480
00:24:51,191 --> 00:24:53,160 line:-2
Even though it's not
in the umbrella header,


481
00:24:53,227 --> 00:24:55,128 line:-2
Objective-C clients
who have modules enabled


482
00:24:55,195 --> 00:24:57,097 line:-1
will automatically import it anyway,


483
00:24:57,164 --> 00:24:58,932 line:-1
so it should all just work out.


484
00:24:58,999 --> 00:25:00,868 line:-1
Anyway, back to the task at hand.


485
00:25:02,369 --> 00:25:04,171 line:-1
I'll extend SKMission...


486
00:25:06,507 --> 00:25:08,942 line:-1
to add a new method called save to,


487
00:25:09,009 --> 00:25:11,178 line:-1
which both throws and returns a Bool.


488
00:25:11,778 --> 00:25:14,081 line:-1
I couldn't return the Bool in Objective-C


489
00:25:14,147 --> 00:25:17,150 line:-2
because the Objective-C error convention
takes over the return value.


490
00:25:17,751 --> 00:25:19,686 line:-1
But that's an Objective-C convention.


491
00:25:20,954 --> 00:25:23,490 line:-2
In a Swift method,
the return value is totally separate


492
00:25:23,557 --> 00:25:25,392 line:-2
from whether or not
the method threw an error,


493
00:25:25,459 --> 00:25:27,027 line:-1
so there's no problem with this.


494
00:25:27,094 --> 00:25:28,829 line:-1
Now, let's implement this.


495
00:25:28,896 --> 00:25:32,332 line:-2
First, I'll need a Bool variable
to receive the wasDirty value.


496
00:25:34,501 --> 00:25:36,570 line:-1
Next, I'll call the Objective-C method


497
00:25:37,671 --> 00:25:40,007 line:-2
and finally, I'll return
the wasDirty value.


498
00:25:40,807 --> 00:25:42,476 line:-1
Hit "Build" and...


499
00:25:42,976 --> 00:25:44,845 line:-1
Oops, I have a type error.


500
00:25:45,779 --> 00:25:47,281 line:-1
What happened?


501
00:25:49,616 --> 00:25:51,285 line:-1
Well, on some of our platforms,


502
00:25:51,351 --> 00:25:53,554 line:-1
Swift's Bool and Objective-C's Bool


503
00:25:53,620 --> 00:25:56,323 line:-2
actually have a slightly different
memory representation.


504
00:25:56,390 --> 00:25:59,760 line:-2
Normally, Swift inserts
a little conversion to smooth this over.


505
00:26:00,160 --> 00:26:02,963 line:-2
But here, you're trying to take
a pointer to a Swift Bool


506
00:26:03,030 --> 00:26:04,965 line:-1
and pass it off to Objective-C


507
00:26:05,032 --> 00:26:07,234 line:-2
so that Objective-C
can directly read and write it.


508
00:26:08,268 --> 00:26:10,571 line:-2
There's no way for Swift
to insert a conversion there,


509
00:26:10,637 --> 00:26:13,540 line:-1
so instead it uses a type called ObjCBool,


510
00:26:13,607 --> 00:26:16,510 line:-2
which matches the Objective-C
Bool representation.


511
00:26:17,144 --> 00:26:18,712 line:-1
So, to make this work...


512
00:26:20,814 --> 00:26:23,417 line:-2
I need to change
the variable's type to ObjCBool.


513
00:26:25,552 --> 00:26:27,254 line:-1
And then, in the return statement...


514
00:26:29,122 --> 00:26:31,892 line:-2
use its bool Value property
to return a Swift Bool.


515
00:26:33,727 --> 00:26:35,629 line:-1
Build and...


516
00:26:37,631 --> 00:26:39,233 line:-1
Great. This works.


517
00:26:40,033 --> 00:26:41,902 line:-1
But I can make it a little better.


518
00:26:44,004 --> 00:26:47,508 line:-2
You see, even though I have
this great new method for our Swift users,


519
00:26:48,342 --> 00:26:50,811 line:-2
the Objective-C one
is still available to them.


520
00:26:51,745 --> 00:26:55,415 line:-2
Swift clients might get confused
and wonder which one they should use,


521
00:26:55,482 --> 00:26:57,417 line:-1
so it'd be better to hide it from them.


522
00:26:58,685 --> 00:27:01,822 line:-2
But I don't want to stop
Objective-C clients from using it


523
00:27:01,889 --> 00:27:04,091 line:-2
and I don't want
to totally block Swift either


524
00:27:04,157 --> 00:27:06,960 line:-2
because this method I just wrote
still needs to use it.


525
00:27:08,061 --> 00:27:09,663 line:-1
So, what I can do is...


526
00:27:09,730 --> 00:27:11,565 line:-1
I go over to the SKMission header...


527
00:27:12,933 --> 00:27:14,501 line:-1
and I annotate the method


528
00:27:15,435 --> 00:27:17,571 line:-1
with NS_REFINED_FOR_SWIFT.


529
00:27:19,406 --> 00:27:22,176 line:-2
What NS_REFINED_FOR_SWIFT does
is very simple.


530
00:27:22,709 --> 00:27:24,044 line:-1
It adds two underscores


531
00:27:24,111 --> 00:27:26,013 line:-2
to the beginning
of the method's Swift name.


532
00:27:26,980 --> 00:27:29,583 line:-2
When Xcode sees something
with a leading underscore,


533
00:27:29,650 --> 00:27:31,585 line:-1
it usually hides it from editor features


534
00:27:31,652 --> 00:27:34,188 line:-2
like code completion
and generated interfaces.


535
00:27:34,755 --> 00:27:38,959 line:-2
So, if I build the project now,
I'll get an error in my Swift code.


536
00:27:39,626 --> 00:27:40,827 line:-1
Let's take a look at it.


537
00:27:43,997 --> 00:27:48,135 line:-2
Swift complains that save to
doesn't have a wasDirty parameter.


538
00:27:49,236 --> 00:27:52,172 line:-2
This means the NS_REFINED_FOR_SWIFT
macro is working.


539
00:27:52,239 --> 00:27:55,409 line:-2
Swift doesn't think the method
I'm trying to call is named save to.


540
00:27:55,475 --> 00:27:57,778 line:-2
It now thinks it's
underscore underscore save to.


541
00:27:58,812 --> 00:28:00,647 line:-1
And if I use code completion,


542
00:28:01,748 --> 00:28:04,618 line:-2
there's no sign of the wasDirty version
of the method there either.


543
00:28:05,552 --> 00:28:09,389 line:-2
But even though I can't see the method
in the code completions,


544
00:28:09,456 --> 00:28:12,492 line:-2
if I add two underscores
before the name and build again...


545
00:28:13,560 --> 00:28:15,195 line:-1
it works.


546
00:28:15,796 --> 00:28:18,398 line:-2
Now, our Swift clients will use
this really nice wrapper


547
00:28:18,465 --> 00:28:20,167 line:-1
that still calls the Objective-C method,


548
00:28:20,234 --> 00:28:22,603 line:-2
but gives it an interface
we couldn't have achieved


549
00:28:22,669 --> 00:28:24,004 line:-1
from Objective-C alone.


550
00:28:24,972 --> 00:28:26,006 line:-1
You can use this technique


551
00:28:26,073 --> 00:28:29,309 line:-2
whenever an API could be expressed
more nicely in Swift.


552
00:28:29,943 --> 00:28:33,347 line:-2
Next, let's look at a problem
you might see in your framework.


553
00:28:33,413 --> 00:28:37,150 line:-2
Swift goes to great lengths to import
everything it can from your headers,


554
00:28:37,217 --> 00:28:39,486 line:-2
but when it can't figure out
how to import something,


555
00:28:39,553 --> 00:28:41,221 line:-1
it'll skip over it and move on.


556
00:28:41,622 --> 00:28:44,458 line:-2
This usually happens when there's
no good or natural way


557
00:28:44,525 --> 00:28:47,661 line:-2
to automatically translate
an Objective-C feature into Swift.


558
00:28:48,228 --> 00:28:50,864 line:-2
For example, Swift will skip over
functions or methods


559
00:28:50,931 --> 00:28:53,233 line:-1
which use C's variadic parameters


560
00:28:53,300 --> 00:28:56,637 line:-2
and struct members which declare
a C array of unknown size.


561
00:28:58,005 --> 00:28:59,573 line:-1
If a forward declaration,


562
00:28:59,640 --> 00:29:02,476 line:-2
like an @class
or @protocol with a semicolon,


563
00:29:02,543 --> 00:29:04,144 line:-1
appears in a header file,


564
00:29:04,211 --> 00:29:06,914 line:-2
but the class or protocol
is never fully declared,


565
00:29:06,980 --> 00:29:10,017 line:-2
Swift won't have enough information
about that type to import it


566
00:29:10,717 --> 00:29:13,020 line:-2
and it may end up dropping
methods, properties


567
00:29:13,086 --> 00:29:16,356 line:-2
or even entire categories
that try to use one of these types.


568
00:29:18,058 --> 00:29:21,428 line:-2
If Swift sees two inconsistent
declarations for the same thing,


569
00:29:21,495 --> 00:29:25,132 line:-2
it will often skip over both of them
rather than guess which one it should use.


570
00:29:26,033 --> 00:29:29,169 line:-2
In Xcode 12, Clang is now better
at detecting these conflicts.


571
00:29:29,670 --> 00:29:32,873 line:-2
So if you see types or methods
suddenly disappear when you upgrade,


572
00:29:32,940 --> 00:29:34,641 line:-1
that might be something to investigate.


573
00:29:36,076 --> 00:29:39,479 line:-2
And finally, Swift imports
some macros, but not all.


574
00:29:40,147 --> 00:29:42,583 line:-2
And this is where SpaceKit
runs into trouble.


575
00:29:43,083 --> 00:29:45,752 line:-2
Earlier, we turned a group
of string constants into a type


576
00:29:45,819 --> 00:29:48,222 line:-1
using NS_STRING_ENUM.


577
00:29:48,288 --> 00:29:51,091 line:-2
SpaceKit actually has
two sets of constants like this


578
00:29:51,158 --> 00:29:53,827 line:-2
and we'd like to give the other set
the same treatment.


579
00:29:53,894 --> 00:29:57,364 line:-2
But these are defined with macros
and there's a problem.


580
00:29:57,431 --> 00:29:58,999 line:-1
One of them has been jettisoned.


581
00:29:59,800 --> 00:30:01,034 line:-1
What happened?


582
00:30:01,101 --> 00:30:04,371 line:-2
Well, Swift can't import
every macro you might write.


583
00:30:05,372 --> 00:30:07,808 line:-2
A macro is basically
just a snippet of text


584
00:30:07,875 --> 00:30:10,244 line:-2
that can be used anywhere
in your Objective-C source code.


585
00:30:11,044 --> 00:30:14,815 line:-2
The same macro could mean different things
when it's used in different places


586
00:30:14,882 --> 00:30:18,519 line:-2
and there's no way for Swift to figure out
how a macro was meant to be used.


587
00:30:18,585 --> 00:30:21,989 line:-2
But Swift does recognize macros
which match certain patterns


588
00:30:22,055 --> 00:30:23,891 line:-1
that are often used to declare constants.


589
00:30:24,725 --> 00:30:27,895 line:-2
When it sees one of these,
it imports it as a Swift constant.


590
00:30:28,362 --> 00:30:32,466 line:-2
The first three SKCapsule macros
fit one of the patterns Swift recognizes,


591
00:30:32,533 --> 00:30:34,201 line:-1
a single string literal,


592
00:30:34,268 --> 00:30:36,203 line:-1
so Swift imports them as constants.


593
00:30:37,171 --> 00:30:39,706 line:-2
But the fourth macro
substitutes in another macro,


594
00:30:39,773 --> 00:30:41,708 line:-2
then concatenates
the string literal to it.


595
00:30:42,476 --> 00:30:45,112 line:-2
Swift doesn't fully understand
how macro substitution


596
00:30:45,179 --> 00:30:47,247 line:-2
could interact
with other Objective-C features,


597
00:30:47,915 --> 00:30:49,783 line:-1
so it allows you to name another macro


598
00:30:49,850 --> 00:30:53,053 line:-2
or have other things in the macro,
but not both.


599
00:30:53,120 --> 00:30:55,622 line:-2
Since Swift doesn't recognize
the pattern of code,


600
00:30:55,689 --> 00:30:57,791 line:-1
it skips this macro and moves on.


601
00:30:58,692 --> 00:31:02,029 line:-2
There are a bunch of ways
you could fix this unimportable macro.


602
00:31:02,095 --> 00:31:04,298 line:-2
The simplest would be
to just form the string literal


603
00:31:04,364 --> 00:31:05,566 line:-1
in the same way as the others.


604
00:31:06,366 --> 00:31:08,569 line:-2
But if you want to turn these
into string enum cases,


605
00:31:08,635 --> 00:31:10,771 line:-2
it'd be better to convert them
into real constants.


606
00:31:11,738 --> 00:31:13,273 line:-1
Then, you can string enum them,


607
00:31:13,340 --> 00:31:16,076 line:-2
just like the SKRocket constants
and be on your way.


608
00:31:18,078 --> 00:31:22,282 line:-2
Okay. So, at this point,
you've strengthened your types,


609
00:31:22,349 --> 00:31:24,318 line:-1
you fixed up some incorrect code


610
00:31:24,384 --> 00:31:26,787 line:-2
and you've made sure everything
that should be visible is.


611
00:31:27,988 --> 00:31:29,289 line:-1
Now comes the fun part.


612
00:31:29,857 --> 00:31:31,325 line:-1
Polishing and improving the framework


613
00:31:31,391 --> 00:31:33,794 line:-2
so it feels as nice as possible
to Swift clients.


614
00:31:34,661 --> 00:31:36,430 line:-1
I'll start with some naming.


615
00:31:36,997 --> 00:31:40,667 line:-2
Swift's method naming conventions
are a little different from Objective-C's.


616
00:31:41,468 --> 00:31:43,470 line:-1
Both languages use relatively long names


617
00:31:43,537 --> 00:31:45,339 line:-1
where every argument is labeled,


618
00:31:45,405 --> 00:31:47,608 line:-2
but Swift's names
tend to be a little shorter


619
00:31:47,674 --> 00:31:50,043 line:-2
and omit information
that's obvious from the types.


620
00:31:51,111 --> 00:31:53,547 line:-2
There's also a technical difference
between the two languages.


621
00:31:54,214 --> 00:31:56,550 line:-1
In Swift, each method has a base name


622
00:31:56,617 --> 00:31:58,986 line:-2
and by default every argument
also has a label.


623
00:31:59,887 --> 00:32:02,723 line:-2
Objective-C selectors essentially
just have argument labels


624
00:32:02,789 --> 00:32:04,358 line:-1
without a separate base name.


625
00:32:04,424 --> 00:32:06,326 line:-2
So the information that would be
in the base name


626
00:32:06,393 --> 00:32:08,695 line:-1
is included in the first argument label.


627
00:32:09,329 --> 00:32:10,731 line:-1
To help you with these differences,


628
00:32:10,797 --> 00:32:13,200 line:-2
Swift automatically renames
your Objective-C methods


629
00:32:13,267 --> 00:32:14,801 line:-1
when it imports them.


630
00:32:14,868 --> 00:32:18,405 line:-2
It strips off prefixes and suffixes
that match type names


631
00:32:18,472 --> 00:32:21,375 line:-2
and it uses a table
of English grammar and vocabulary


632
00:32:21,441 --> 00:32:23,810 line:-2
to figure out how to split
the first portion of the selector


633
00:32:23,877 --> 00:32:25,646 line:-1
into a base name and argument label.


634
00:32:26,313 --> 00:32:28,215 line:-1
The results are usually pretty good,


635
00:32:28,282 --> 00:32:31,685 line:-2
but this is basically a computer program
making aesthetic judgments,


636
00:32:32,286 --> 00:32:35,222 line:-2
so it'll sometimes make decisions
you disagree with.


637
00:32:35,289 --> 00:32:37,891 line:-2
For instance, many developers
would say this method selector


638
00:32:37,958 --> 00:32:39,626 line:-1
hasn't been split correctly.


639
00:32:39,693 --> 00:32:43,297 line:-2
The word "flown" should be part
of the argument label, not the base name,


640
00:32:43,363 --> 00:32:45,966 line:-2
because the method fetches
a list of previous missions


641
00:32:46,033 --> 00:32:49,069 line:-2
and they are the missions
flown by a particular astronaut.


642
00:32:50,170 --> 00:32:53,173 line:-2
Not every developer will agree,
but it's a judgment call.


643
00:32:53,974 --> 00:32:57,744 line:-2
To fix it, you'd put
the NS_SWIFT_NAME macro after the method,


644
00:32:57,811 --> 00:32:59,880 line:-2
passing it the base name
and argument labels


645
00:32:59,947 --> 00:33:01,415 line:-1
the way you would write them in Swift


646
00:33:01,481 --> 00:33:03,851 line:-2
if you were trying to refer
to the method without calling it.


647
00:33:05,018 --> 00:33:07,521 line:-2
Swift will then import the method
with the name you specified


648
00:33:07,588 --> 00:33:10,023 line:-2
instead of the one
it would generate itself.


649
00:33:10,090 --> 00:33:12,626 line:-1
But NS_SWIFT_NAME is not just for methods.


650
00:33:12,693 --> 00:33:14,561 line:-1
It can be applied to nearly anything.


651
00:33:15,662 --> 00:33:17,497 line:-1
For instance, take this enum.


652
00:33:18,265 --> 00:33:20,634 line:-2
Swift has already done
a pretty good job with it.


653
00:33:20,701 --> 00:33:23,971 line:-2
Because the author used NS_ENUM,
it imports as a Swift enum.


654
00:33:24,738 --> 00:33:27,941 line:-2
But if we want to tweak the name a bit,
NS_SWIFT_NAME can do that.


655
00:33:28,675 --> 00:33:33,113 line:-2
Now, you could use NS_SWIFT_NAME
to remove the SK prefix from the name,


656
00:33:33,180 --> 00:33:35,282 line:-2
but we don't actually recommend
you do that.


657
00:33:36,083 --> 00:33:39,319 line:-2
A lot of Objective-C type names
combine the framework's prefix


658
00:33:39,386 --> 00:33:43,557 line:-2
with a word like "query" or "record"
that would be too vague on its own.


659
00:33:44,358 --> 00:33:46,226 line:-2
You would need to add
something else to the name


660
00:33:46,293 --> 00:33:48,529 line:-2
to make up for the precision lost
by deleting the prefix.


661
00:33:50,464 --> 00:33:53,133 line:-2
What it's best used for
with types, though, is nesting them.


662
00:33:54,134 --> 00:33:56,203 line:-2
For instance,
if there was an SKFuel class


663
00:33:56,270 --> 00:33:58,405 line:-1
that this SKFuelKind enum went with,


664
00:33:58,906 --> 00:34:01,542 line:-1
you could change it to be SKFuel.Kind,


665
00:34:01,608 --> 00:34:04,044 line:-2
which is probably what you would call
this type in Swift.


666
00:34:05,612 --> 00:34:07,781 line:-2
Another good use is with libraries
whose type names


667
00:34:07,848 --> 00:34:09,583 line:-1
look totally different from Swift types.


668
00:34:10,317 --> 00:34:13,320 line:-2
Like the lowercase type names
you sometimes see in C libraries.


669
00:34:14,221 --> 00:34:15,688 line:-1
NS_SWIFT_NAME can also be used


670
00:34:15,755 --> 00:34:18,125 line:-2
with global constants,
variables and functions.


671
00:34:18,824 --> 00:34:20,827 line:-1
For example, we can apply NS_SWIFT_NAME


672
00:34:20,893 --> 00:34:23,163 line:-1
to the SKFuelKind To String function


673
00:34:23,230 --> 00:34:25,899 line:-2
to not only remove
the extra information from its name,


674
00:34:25,966 --> 00:34:28,235 line:-1
but also add an argument label,


675
00:34:28,302 --> 00:34:30,771 line:-2
something Objective-C
doesn't support on functions.


676
00:34:32,306 --> 00:34:35,708 line:-2
But now we've actually entered
some really interesting territory


677
00:34:35,775 --> 00:34:38,277 line:-2
because, when applied
to global constants and variables,


678
00:34:38,344 --> 00:34:40,313 line:-1
and especially global functions,


679
00:34:40,380 --> 00:34:43,317 line:-2
NS_SWIFT_NAME gains
some astonishing superpowers


680
00:34:43,382 --> 00:34:45,985 line:-2
that can dramatically reshape
how clients use your framework.


681
00:34:46,719 --> 00:34:50,190 line:-2
To start with, you can turn
a global function into a static method


682
00:34:50,257 --> 00:34:52,226 line:-1
by specifying the type's Objective-C name,


683
00:34:52,292 --> 00:34:54,928 line:-2
followed by a dot
and then the static method's name.


684
00:34:56,597 --> 00:34:59,666 line:-2
Then, you can turn it
into an instance method instead


685
00:34:59,733 --> 00:35:01,735 line:-2
by changing
one of the argument labels to "self"


686
00:35:01,802 --> 00:35:04,271 line:-2
so Swift knows where to pass
the instance you called it on.


687
00:35:05,539 --> 00:35:08,575 line:-2
And then you can turn
that method into a property


688
00:35:08,642 --> 00:35:10,077 line:-1
by putting "getter" in front of it.


689
00:35:10,577 --> 00:35:13,413 line:-2
You can do the same thing with a setter
to create a mutable property.


690
00:35:15,182 --> 00:35:18,352 line:-2
Apply these techniques across
an entire framework full of functions


691
00:35:18,418 --> 00:35:21,922 line:-2
and you can dramatically reshape
its whole API surface.


692
00:35:21,989 --> 00:35:25,125 line:-2
If you've used Core Graphics
in both Objective-C and Swift,


693
00:35:25,192 --> 00:35:27,327 line:-1
you probably know what I mean.


694
00:35:27,394 --> 00:35:30,664 line:-2
We applied this renaming capability
to hundreds of global functions


695
00:35:30,731 --> 00:35:33,066 line:-2
to convert them into methods,
properties and initializers


696
00:35:33,133 --> 00:35:34,601 line:-1
which are much easier to use.


697
00:35:36,003 --> 00:35:37,871 line:-1
Now, at this point, you must be wondering


698
00:35:37,938 --> 00:35:39,873 line:-2
if there's anything
NS_SWIFT_NAME can't do.


699
00:35:40,641 --> 00:35:41,875 line:-1
Well, there is.


700
00:35:42,676 --> 00:35:44,378 line:-2
Even though you renamed
this global function


701
00:35:44,444 --> 00:35:46,813 line:-2
into an instance property
named "description,"


702
00:35:46,880 --> 00:35:48,382 line:-1
you can't use NS_SWIFT_NAME


703
00:35:48,448 --> 00:35:51,218 line:-2
to conform the type
to the CustomStringConvertible protocol,


704
00:35:51,752 --> 00:35:53,387 line:-1
which would make Swift use that property


705
00:35:53,453 --> 00:35:55,722 line:-1
to convert SKFuel.Kinds into strings.


706
00:35:55,789 --> 00:36:00,260 line:-2
But you can add that conformance
using one line of custom Swift code.


707
00:36:00,327 --> 00:36:01,962 line:-1
So, let's do that.


708
00:36:03,330 --> 00:36:05,532 line:-2
The one line of code
I need to add is this.


709
00:36:05,599 --> 00:36:07,868 line:-1
I write an extension to SKFuel.Kind...


710
00:36:08,969 --> 00:36:12,172 line:-2
and conform it
to the CustomStringConvertible protocol.


711
00:36:12,239 --> 00:36:14,308 line:-1
And since my Objective-C header


712
00:36:14,374 --> 00:36:17,477 line:-2
already provided a description property
using NS_SWIFT_NAME...


713
00:36:19,279 --> 00:36:21,748 line:-1
That's it. There is no step three.


714
00:36:22,316 --> 00:36:25,853 line:-2
I've only demonstrated very simple uses
of custom Swift code,


715
00:36:25,919 --> 00:36:29,389 line:-2
but you can write any Swift-only APIs
you want in these Swift files.


716
00:36:30,257 --> 00:36:32,593 line:-1
For instance, you could import SwiftUI


717
00:36:32,659 --> 00:36:36,663 line:-2
and write SwiftUI views that use AppKit
or UIKit views from your framework.


718
00:36:36,730 --> 00:36:39,933 line:-2
Or you could take an API that uses
something like a completion handler


719
00:36:40,000 --> 00:36:42,536 line:-2
and write a wrapper that returns
a Combine Future instead.


720
00:36:42,970 --> 00:36:45,305 line:-1
We can and have given entire sessions


721
00:36:45,372 --> 00:36:48,775 line:-2
about using these technologies
with Swift classes and types,


722
00:36:48,842 --> 00:36:52,112 line:-2
and nothing really changes when you
use them in a mixed-language framework.


723
00:36:52,746 --> 00:36:55,115 line:-2
So, rather than try to give you
a crash course,


724
00:36:55,182 --> 00:36:57,851 line:-2
I'll point you to some relevant sessions
on SwiftUI and Combine


725
00:36:57,918 --> 00:36:59,353 line:-1
and leave the rest to you.


726
00:36:59,920 --> 00:37:02,656 line:-2
Finally, let's talk
about error code enums.


727
00:37:03,457 --> 00:37:04,858 line:-1
Like many frameworks,


728
00:37:04,925 --> 00:37:08,028 line:-2
SpaceKit needs some custom error codes
it can use with NSError.


729
00:37:08,729 --> 00:37:11,398 line:-2
To keep them from colliding
with other frameworks' errors,


730
00:37:11,465 --> 00:37:13,634 line:-2
it declares a string constant
with an error domain


731
00:37:13,700 --> 00:37:16,203 line:-2
and then an NS_ENUM
with the specific error codes.


732
00:37:16,970 --> 00:37:19,106 line:-1
Now, looking at this generated interface,


733
00:37:19,173 --> 00:37:21,742 line:-2
you might be thinking,
"What's the problem here?'


734
00:37:22,643 --> 00:37:25,646 line:-2
You declared a string constant
and it came in as a string constant.


735
00:37:26,313 --> 00:37:29,283 line:-2
You declared an NS_ENUM
and it came in as a Swift enum


736
00:37:29,349 --> 00:37:32,786 line:-2
with all the cases and codes intact
and even the names correctly shortened.


737
00:37:33,420 --> 00:37:35,889 line:-2
And really, there's no problem
with the interface itself.


738
00:37:37,558 --> 00:37:38,825 line:-1
The problem becomes more clear


739
00:37:38,892 --> 00:37:40,861 line:-2
when you think about
how you would actually use it.


740
00:37:41,562 --> 00:37:43,497 line:-2
For instance,
let's say you launch a mission


741
00:37:43,564 --> 00:37:45,199 line:-1
and if the launch is aborted,


742
00:37:45,265 --> 00:37:48,168 line:-2
you want to make sure the rescue squad
goes and gets the astronauts.


743
00:37:48,235 --> 00:37:50,103 line:-1
That's gonna look roughly like this.


744
00:37:50,170 --> 00:37:51,738 line:-1
You call mission.launch,


745
00:37:51,805 --> 00:37:54,408 line:-2
then you want to catch the error
if it's a launch Aborted error.


746
00:37:55,142 --> 00:37:58,078 line:-2
But what does that catch clause
actually look like?


747
00:37:58,145 --> 00:38:01,849 line:-2
Well, we're going to need to extract
the domain and code from the error,


748
00:38:01,915 --> 00:38:04,384 line:-2
so first we have to catch it
as an NSError.


749
00:38:05,352 --> 00:38:09,022 line:-2
Next, we need to make sure
the error is in the SKErrorDomain,


750
00:38:09,089 --> 00:38:11,458 line:-2
not some other domain
that might use the same error code


751
00:38:11,525 --> 00:38:12,860 line:-1
for something different.


752
00:38:13,861 --> 00:38:17,464 line:-2
Then we'll need to convert the error code
from an int to an SKErrorCode.


753
00:38:18,098 --> 00:38:21,168 line:-2
And finally, we can check
if it's the case we wanted.


754
00:38:21,235 --> 00:38:24,571 line:-2
Looking at all these checks together,
this is, um...


755
00:38:25,539 --> 00:38:28,041 line:-2
not something I'd want to make
my users write.


756
00:38:29,276 --> 00:38:32,279 line:-2
It shouldn't take this much effort
just to match an error.


757
00:38:33,814 --> 00:38:35,649 line:-1
If you had written SpaceKit in Swift


758
00:38:35,716 --> 00:38:37,784 line:-1
and this had been a Swift error enum,


759
00:38:37,851 --> 00:38:40,254 line:-2
you could do the same thing
in less than a line.


760
00:38:40,320 --> 00:38:42,256 line:-1
Just name the error type and the case


761
00:38:42,322 --> 00:38:44,725 line:-2
and Swift matches them
against the thrown error.


762
00:38:44,791 --> 00:38:46,326 line:-1
That's way better.


763
00:38:46,393 --> 00:38:49,296 line:-2
But, of course, you don't have
a Swift error enum.


764
00:38:49,363 --> 00:38:52,666 line:-2
You have an Objective-C enum
and an error domain constant.


765
00:38:53,667 --> 00:38:56,670 line:-2
Can you turn those into something
similar to a Swift error enum?


766
00:38:57,504 --> 00:39:00,707 line:-1
You can, and really it couldn't be easier.


767
00:39:01,341 --> 00:39:04,978 line:-2
All you need to do is replace
NS_ENUM with NS_ERROR_ENUM.


768
00:39:05,846 --> 00:39:08,849 line:-2
Then replace the raw type
with the error domain constant.


769
00:39:10,050 --> 00:39:12,386 line:-2
This has an enormous effect
on the error code enum.


770
00:39:13,587 --> 00:39:16,323 line:-1
SKErrorCode gets nested inside SKError,


771
00:39:16,390 --> 00:39:18,525 line:-1
a new type Swift invents from whole cloth.


772
00:39:19,660 --> 00:39:21,595 line:-1
In the Xcode generated interface,


773
00:39:21,662 --> 00:39:25,032 line:-2
you'll see that the enum has
all of the error codes as its cases


774
00:39:25,098 --> 00:39:28,569 line:-2
and they're also repeated
as static constants on the struct,


775
00:39:28,635 --> 00:39:31,271 line:-2
and there's a static constant
for the domain, too.


776
00:39:32,339 --> 00:39:34,975 line:-1
But SKError also conforms to Error,


777
00:39:35,042 --> 00:39:37,711 line:-2
so you can throw and catch it
just like a native Swift error.


778
00:39:38,846 --> 00:39:40,414 line:-1
It has initializers and properties


779
00:39:40,480 --> 00:39:42,516 line:-2
for the error code
and user info dictionary.


780
00:39:43,483 --> 00:39:46,153 line:-2
And the error code enum
has a tilde-equal operator.


781
00:39:46,920 --> 00:39:49,923 line:-2
This is the matching operator
used by case and catch clauses.


782
00:39:50,591 --> 00:39:53,427 line:-2
Here, it says that if you're
switching or catching an error,


783
00:39:53,493 --> 00:39:56,430 line:-1
you can match it against an SKErrorCode.


784
00:39:56,496 --> 00:39:58,498 line:-2
The match succeeds
only if the error domain


785
00:39:58,565 --> 00:40:00,534 line:-1
and error code are both correct.


786
00:40:00,601 --> 00:40:03,637 line:-2
Since SKError has those
static code constants on it,


787
00:40:03,704 --> 00:40:06,373 line:-2
you can write
catch SKError.launch Aborted


788
00:40:06,440 --> 00:40:07,774 line:-1
and Swift will use this operator


789
00:40:07,841 --> 00:40:09,877 line:-2
to match the error
against that error code.


790
00:40:10,377 --> 00:40:13,680 line:-2
These parts of SKError aren't visible
in the generated interface


791
00:40:13,747 --> 00:40:16,083 line:-2
because the Swift compiler
synthesizes them.


792
00:40:16,683 --> 00:40:18,218 line:-1
But they're there for you to use


793
00:40:18,285 --> 00:40:21,188 line:-2
and they make Objective-C error codes
work pretty nicely in Swift.


794
00:40:21,722 --> 00:40:24,791 line:-2
And the only thing you have to do
to get all this is change two identifiers.


795
00:40:25,425 --> 00:40:26,894 line:-1
Not bad for a one-line diff.


796
00:40:28,195 --> 00:40:30,864 line:-2
But I want to go back to where we started
with these error codes


797
00:40:30,931 --> 00:40:32,533 line:-1
and think about a bigger lesson.


798
00:40:33,500 --> 00:40:36,570 line:-2
There is no obvious sign of a problem
in the generated interface.


799
00:40:37,771 --> 00:40:40,340 line:-2
It's only when you saw
how SKErrorCode would be used


800
00:40:40,407 --> 00:40:43,110 line:-2
that you realized
there was room for improvement.


801
00:40:43,177 --> 00:40:46,780 line:-2
All through this talk,
I've been showing you generated interfaces


802
00:40:46,847 --> 00:40:50,450 line:-2
because they're a good way to see
how Swift is importing your headers.


803
00:40:50,517 --> 00:40:52,219 line:-1
But generated interfaces


804
00:40:52,286 --> 00:40:54,955 line:-2
are just a tool for understanding
what's in the framework.


805
00:40:55,022 --> 00:40:57,357 line:-2
What really matters is the calls
your clients will write


806
00:40:57,424 --> 00:40:58,692 line:-1
when they try to use it.


807
00:40:59,193 --> 00:41:00,994 line:-1
So, when you're working on a framework,


808
00:41:01,061 --> 00:41:03,130 line:-2
you should look
at the generated interface,


809
00:41:03,197 --> 00:41:05,599 line:-1
but you should think about the use sites.


810
00:41:05,666 --> 00:41:07,534 line:-1
Imagine them in your mind's eye.


811
00:41:07,601 --> 00:41:09,503 line:-1
Scribble them on a whiteboard.


812
00:41:09,570 --> 00:41:11,171 line:-1
Tinker with them in a playground.


813
00:41:11,238 --> 00:41:13,040 line:-1
Codify them in a test.


814
00:41:13,607 --> 00:41:15,442 line:-2
Your clients will love
or hate your framework


815
00:41:15,509 --> 00:41:17,344 line:-1
based on the code they write with it,


816
00:41:17,411 --> 00:41:19,546 line:-2
not the interface they see
when they Command-click.


817
00:41:20,747 --> 00:41:22,049 line:-1
So, to sum up.


818
00:41:23,116 --> 00:41:25,018 line:-1
If you have an Objective-C framework,


819
00:41:25,085 --> 00:41:27,454 line:-2
you can make it work really nicely
for Swift clients


820
00:41:27,521 --> 00:41:30,691 line:-2
with just header annotations
and sometimes a little bit of Swift code.


821
00:41:32,192 --> 00:41:34,394 line:-2
When you're doing this,
look for opportunities


822
00:41:34,461 --> 00:41:37,531 line:-2
to present stronger,
more specific types to Swift clients.


823
00:41:38,732 --> 00:41:40,834 line:-2
And make sure you're following
Objective-C conventions


824
00:41:40,901 --> 00:41:42,836 line:-2
so that Swift will use
your framework correctly.


825
00:41:44,571 --> 00:41:47,241 line:0
And even though Xcode shows you
the generated interface,


826
00:41:47,307 --> 00:41:50,511 line:0
look beyond that and think
about how your APIs will be used.


827
00:41:51,111 --> 00:41:52,613 line:0
That's what should drive your design.


828
00:41:54,548 --> 00:41:55,649 line:0
If you want more information,


829
00:41:55,716 --> 00:41:58,886 line:0
the Swift documentation has a section
called "Language Interoperability"


830
00:41:58,952 --> 00:42:02,523 line:0
which digs into all of these features
and more in greater detail.


831
00:42:02,589 --> 00:42:06,360 line:0
If you want to get a more concrete feel
for what makes a Swift API idiomatic,


832
00:42:06,426 --> 00:42:09,429 line:0
the "API Design Guidelines"
describe some of the principles and rules


833
00:42:09,496 --> 00:42:11,698 line:0
recommended by the Swift
core team and community.


834
00:42:12,332 --> 00:42:15,102 line:0
And the session "Behind the Scenes
of the Xcode Build Process"


835
00:42:15,169 --> 00:42:17,971 line:0
digs deep into how Swift
imports Objective-C headers


836
00:42:18,038 --> 00:42:19,940 line:0
and how Xcode builds mixed frameworks.


837
00:42:20,974 --> 00:42:23,677 line:0
It's particularly relevant
if Swift seems to be missing


838
00:42:23,744 --> 00:42:25,445 line:0
some of your Objective-C
framework's headers


839
00:42:25,512 --> 00:42:27,047 line:0
or just won't import it at all.


840
00:42:28,215 --> 00:42:29,850 line:-1
So, thank you for your time


841
00:42:29,917 --> 00:42:33,120 line:-2
and I hope this helps you launch
something stellar.

