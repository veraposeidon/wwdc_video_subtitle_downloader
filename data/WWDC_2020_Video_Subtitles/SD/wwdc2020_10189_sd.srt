1
00:00:03,937 --> 00:00:06,707 line:-1
Hello and welcome to WWDC.


2
00:00:08,007 --> 00:00:10,744 line:0
My name is Richard Cooper,
and this session is all about


3
00:00:10,811 --> 00:00:13,380 line:0
how you can make your applications
more secure,


4
00:00:13,447 --> 00:00:16,250 line:0
protecting the data and resources
users entrust to you.


5
00:00:16,683 --> 00:00:17,751 line:-1
Here at Apple,


6
00:00:17,818 --> 00:00:21,321 line:-2
we're passionate about ensuring
applications handle data correctly,


7
00:00:21,388 --> 00:00:23,457 line:-1
respecting users' privacy,


8
00:00:23,524 --> 00:00:26,360 line:-2
and that software is designed
to be robust against attack


9
00:00:26,426 --> 00:00:28,829 line:-2
to ensure that
that effort isn't undermined.


10
00:00:28,896 --> 00:00:32,598 line:-2
My team works with software
and hardware teams within Apple


11
00:00:32,665 --> 00:00:35,235 line:-2
to help them improve the security
of what we're building


12
00:00:35,302 --> 00:00:37,538 line:-2
and find issues in things
we've already built.


13
00:00:38,705 --> 00:00:41,642 line:-2
We'd like to share with you
some of the techniques we found useful.


14
00:00:42,042 --> 00:00:44,711 line:-2
In this talk,
we're going to cover some ideas


15
00:00:44,778 --> 00:00:48,515 line:-2
about how you can think about security
in the context of your application.


16
00:00:49,917 --> 00:00:52,819 line:-2
To do this, we're going to talk about
threat modeling,


17
00:00:52,886 --> 00:00:55,255 line:-1
how to identify untrusted data,


18
00:00:55,322 --> 00:00:58,125 line:-2
and go over some common mistakes
we see people making.


19
00:00:58,559 --> 00:01:00,160 line:-1
To help visualize the problem,


20
00:01:00,227 --> 00:01:04,164 line:-2
we're going to use a simple hypothetical
application called Loose Leaf.


21
00:01:04,965 --> 00:01:06,567 line:-1
We've got high hopes for Loose Leaf


22
00:01:06,633 --> 00:01:08,902 line:-2
and expect it to become
the leading social platform


23
00:01:08,969 --> 00:01:11,572 line:-1
for hot, cold and bubble tea drinkers.


24
00:01:11,638 --> 00:01:13,140 line:-1
Perhaps even coffee too.


25
00:01:14,908 --> 00:01:18,378 line:-2
To make this happen,
we're gonna support these great features:


26
00:01:18,445 --> 00:01:22,115 line:-2
We want social networking so you can
share your activity with the world,


27
00:01:22,850 --> 00:01:26,019 line:-2
the ability to use the camera
to take photos to post


28
00:01:26,086 --> 00:01:28,655 line:-2
but also to create
live-action pouring videos.


29
00:01:29,489 --> 00:01:31,992 line:-1
We also want to support private tea clubs,


30
00:01:32,059 --> 00:01:34,294 line:-2
allowing you to talk
with just your friends.


31
00:01:34,795 --> 00:01:37,664 line:-2
Finally, we're going to have the ability
to support longer form reviews,


32
00:01:37,731 --> 00:01:39,199 line:-1
pairings, etcetera.


33
00:01:39,933 --> 00:01:41,768 line:-1
Whilst it's quite a simple example,


34
00:01:41,835 --> 00:01:44,805 line:-2
it has many features
in common with popular applications.


35
00:01:44,872 --> 00:01:47,608 line:-2
The first thing you want to do
when looking at your app


36
00:01:47,674 --> 00:01:50,110 line:-2
is to stand back
and think about the threat model.


37
00:01:50,677 --> 00:01:53,580 line:-2
Threat modeling is the process
of thinking about what can go wrong


38
00:01:53,647 --> 00:01:55,482 line:-1
in the context of security,


39
00:01:55,549 --> 00:01:59,620 line:-2
and it is important, as it allows you
to consider what risks you face


40
00:01:59,686 --> 00:02:01,722 line:-1
and what you can do to mitigate them.


41
00:02:02,556 --> 00:02:05,459 line:-2
We're not going to describe
a specific formal process,


42
00:02:05,526 --> 00:02:06,827 line:-1
as for many developers,


43
00:02:06,894 --> 00:02:09,630 line:-2
learning and following one
simply wouldn't be practical.


44
00:02:10,731 --> 00:02:14,768 line:-2
Instead, we're going to describe some
strategies you can use for threat modeling


45
00:02:14,835 --> 00:02:17,437 line:-2
and which will help you think about
security and risk.


46
00:02:17,504 --> 00:02:18,972 line:-1
So, how do we do this?


47
00:02:19,907 --> 00:02:23,310 line:-2
One of the key things
your application has are assets.


48
00:02:24,945 --> 00:02:27,981 line:-2
These aren't the assets you would find
in an Xcode asset catalog,


49
00:02:28,048 --> 00:02:32,386 line:-2
but the things the user might consider
valuable, sensitive, or private.


50
00:02:32,452 --> 00:02:34,788 line:-1
Camera and microphone, location data,


51
00:02:34,855 --> 00:02:37,357 line:-1
contact information, and photos and files


52
00:02:37,424 --> 00:02:39,993 line:-1
are all really good examples of assets,


53
00:02:40,060 --> 00:02:42,663 line:-2
and why we've been working hard
over the last few years


54
00:02:42,729 --> 00:02:45,666 line:-2
to provide platform-level protection
of many of these things.


55
00:02:46,366 --> 00:02:47,701 line:-1
As a general rule,


56
00:02:47,768 --> 00:02:51,104 line:-2
if the user was required to grant access,
it's an asset.


57
00:02:52,139 --> 00:02:55,509 line:-2
In doing so,
they are delegating control of it to you,


58
00:02:55,576 --> 00:02:58,245 line:-2
so you need to concern yourself
with how to protect it.


59
00:02:58,745 --> 00:03:01,715 line:-2
But there are other things
which also represent assets.


60
00:03:03,150 --> 00:03:06,520 line:-2
Opinions and views which users
enter into your application


61
00:03:06,587 --> 00:03:08,488 line:-1
are a hugely important asset.


62
00:03:09,423 --> 00:03:11,658 line:-1
Whilst platform protection can help,


63
00:03:11,725 --> 00:03:14,695 line:-2
it's a class of asset
where you need to be particularly careful


64
00:03:14,761 --> 00:03:17,130 line:-1
and ensure to adopt those protections.


65
00:03:17,197 --> 00:03:20,968 line:-2
Now, no threat model would be complete
without attackers.


66
00:03:22,402 --> 00:03:24,238 line:-1
These can be the obvious ones:


67
00:03:24,304 --> 00:03:26,473 line:-2
criminals who want to steal
from your users


68
00:03:26,540 --> 00:03:29,142 line:-2
or competitors
who want to undermine your platform,


69
00:03:29,676 --> 00:03:32,613 line:-2
but we should also consider
other classes of attacker


70
00:03:32,679 --> 00:03:34,781 line:-1
who might have different levels of access.


71
00:03:35,315 --> 00:03:38,652 line:-2
Romantic partners and family members
are good examples of these.


72
00:03:39,720 --> 00:03:43,156 line:-2
So you should ask yourself, "How do I
protect against these attackers?"


73
00:03:44,525 --> 00:03:45,592 line:-1
This is important,


74
00:03:45,659 --> 00:03:49,162 line:-2
as they often have vastly different levels
of access to a device,


75
00:03:49,229 --> 00:03:51,798 line:-2
both physically
and through shared accounts.


76
00:03:52,366 --> 00:03:55,702 line:-2
Whilst you might not think Loose Leaf
is interesting to these attackers,


77
00:03:55,769 --> 00:03:59,640 line:-2
if we have access to useful assets
and are as successful as we intend to be,


78
00:03:59,706 --> 00:04:01,241 line:-1
we can become a target.


79
00:04:01,742 --> 00:04:05,479 line:-2
Attackers regularly attack social media,
banking, productivity,


80
00:04:05,546 --> 00:04:08,982 line:-2
dating apps, and even games,
so nobody is immune.


81
00:04:11,185 --> 00:04:13,687 line:-1
In general, who the attacker is


82
00:04:13,754 --> 00:04:16,790 line:-2
is actually less important
than what capability they have


83
00:04:16,857 --> 00:04:19,059 line:-1
and how that can be used to affect us.


84
00:04:19,892 --> 00:04:23,397 line:-2
To help us visualize
what data the attacker can control


85
00:04:23,463 --> 00:04:27,568 line:-2
and where it goes in our application,
we recommend doing a data flow diagram.


86
00:04:27,935 --> 00:04:30,971 line:-2
To start, draw out
where the data stores in your system are.


87
00:04:32,272 --> 00:04:35,542 line:-2
In our case, we've got some information
hosted on our website.


88
00:04:35,609 --> 00:04:38,979 line:-2
We're going to use that for public posts,
account information, etcetera.


89
00:04:40,480 --> 00:04:43,417 line:-2
Some information
is also stored in CloudKit,


90
00:04:43,483 --> 00:04:45,919 line:-2
allowing us to have
decentralized tea clubs...


91
00:04:47,221 --> 00:04:51,525 line:-2
and a cache, which is going to store
local versions of posts and images.


92
00:04:51,592 --> 00:04:54,127 line:-1
Ultimately, these are gonna be the places


93
00:04:54,194 --> 00:04:56,864 line:-2
where user sensitive information
is persisted.


94
00:04:57,865 --> 00:05:01,401 line:0
Next, we should add in system resources
we leverage.


95
00:05:01,468 --> 00:05:03,737 line:0
We should also think about other ways


96
00:05:03,804 --> 00:05:06,573 line:0
data might be able to make its way
into our application.


97
00:05:07,708 --> 00:05:12,279 line:-2
In our case, we have a URL handler,
which allows links to be passed to us.


98
00:05:13,680 --> 00:05:15,048 line:-1
Finally, we need to decide


99
00:05:15,115 --> 00:05:17,718 line:-2
where the security boundaries
should be in our system.


100
00:05:18,585 --> 00:05:20,721 line:-1
Placement of these is really important,


101
00:05:20,787 --> 00:05:23,924 line:-2
as it provides the basis
for all the decisions we're gonna make


102
00:05:23,991 --> 00:05:26,393 line:-1
about what we do and don't trust.


103
00:05:26,793 --> 00:05:29,296 line:-1
The key question to ask yourself here is,


104
00:05:29,363 --> 00:05:32,199 line:-2
where can attackers influence
my application,


105
00:05:32,266 --> 00:05:34,568 line:-1
what data is attacker-controlled,


106
00:05:34,635 --> 00:05:38,172 line:-2
and how can they use that
to gain access to our assets?


107
00:05:39,006 --> 00:05:41,575 line:0
In our case,
we're going to place a boundary here,


108
00:05:41,642 --> 00:05:43,877 line:0
between the system resources and our app.


109
00:05:45,345 --> 00:05:48,715 line:-2
Whilst we trust the system,
the content is uncontrolled.


110
00:05:49,683 --> 00:05:53,921 line:-2
For example, a file selected by the user
might have come from an untrusted source,


111
00:05:53,987 --> 00:05:56,757 line:-2
so if we process its content,
we need to be careful.


112
00:05:58,025 --> 00:06:01,528 line:-2
Custom document formats being
a great example of where this can happen.


113
00:06:03,163 --> 00:06:06,366 line:-2
Other local applications
are also untrusted to us,


114
00:06:06,433 --> 00:06:09,169 line:-2
so we'll place a security boundary
at the URL handler,


115
00:06:09,236 --> 00:06:11,505 line:-1
as the data provided may be malicious.


116
00:06:12,773 --> 00:06:14,575 line:-1
We're also going to place another boundary


117
00:06:14,641 --> 00:06:17,611 line:-2
between our app
and all of its remote assets.


118
00:06:17,678 --> 00:06:21,415 line:-2
Even though it's our code which should've
written the data into these remote stores,


119
00:06:21,815 --> 00:06:23,550 line:-1
that might not be the case.


120
00:06:23,617 --> 00:06:27,087 line:-2
An attacker may have written software
to craft a malicious post.


121
00:06:27,487 --> 00:06:30,691 line:-2
With this understanding of
where attackers can influence our system,


122
00:06:30,757 --> 00:06:33,994 line:-2
we should think about architectural ways
to secure it.


123
00:06:34,061 --> 00:06:36,196 line:-1
This is particularly relevant here,


124
00:06:36,763 --> 00:06:39,666 line:-2
on the connection between our app
and our website.


125
00:06:41,034 --> 00:06:43,070 line:-2
We at Apple have provided
a generic mechanism


126
00:06:43,136 --> 00:06:46,907 line:-2
for strengthening these connections
called App Transport Security.


127
00:06:48,509 --> 00:06:52,980 line:-2
ATS ensures that all connections
your application makes via the URL system


128
00:06:53,046 --> 00:06:57,217 line:-2
offer sufficient protection to user data
as it transfers over the Internet.


129
00:06:57,618 --> 00:07:00,387 line:-2
ATS is on by default,
but to make use of it,


130
00:07:00,454 --> 00:07:03,290 line:-2
you need to ensure
you use the higher level APIs


131
00:07:03,357 --> 00:07:05,492 line:-1
like NSURLSession and friends.


132
00:07:06,927 --> 00:07:09,429 line:-2
As such,
you should make development policies


133
00:07:09,496 --> 00:07:12,266 line:-1
to ensure their use over lower-level APIs.


134
00:07:13,600 --> 00:07:17,104 line:-2
You also want to make sure you don't ship
with any ATS features disabled


135
00:07:17,171 --> 00:07:18,438 line:-1
in your Info.plist.


136
00:07:20,174 --> 00:07:24,511 line:-2
Equally, you want to think about
the format you use to store data,


137
00:07:24,578 --> 00:07:26,747 line:-1
both on the server and locally.


138
00:07:28,248 --> 00:07:30,250 line:-1
In general, you want to choose a format


139
00:07:30,317 --> 00:07:32,786 line:-2
which is simple to parse
and easy to validate.


140
00:07:34,021 --> 00:07:39,626 line:-2
plist and JSON are both good choices,
balancing flexibility against security.


141
00:07:39,693 --> 00:07:43,897 line:-2
Formats where you can perform
schema validation, though, are ideal,


142
00:07:43,964 --> 00:07:47,134 line:-2
as these provide strong checking
and centralized logic.


143
00:07:49,036 --> 00:07:52,673 line:-2
We also want to think about
how to protect user data in these stores.


144
00:07:52,739 --> 00:07:55,576 line:-2
Is CloudKit protection sufficient
for a tea club,


145
00:07:55,642 --> 00:07:59,012 line:-2
or should we also be manually encrypting
the data ourselves?


146
00:07:59,079 --> 00:08:00,981 line:-1
When we laid out our security boundaries,


147
00:08:01,048 --> 00:08:04,117 line:-2
we didn't place one
between the local cache and the app.


148
00:08:04,918 --> 00:08:08,922 line:-2
Our reasoning here is that we shall
validate the data on the way into the app,


149
00:08:08,989 --> 00:08:11,425 line:-2
and any locally-stored copy
can be trusted.


150
00:08:12,025 --> 00:08:15,128 line:-2
On iOS,
this is a strongly enforced guarantee,


151
00:08:15,195 --> 00:08:17,831 line:-2
as other apps can't change
our local files.


152
00:08:17,898 --> 00:08:19,967 line:-1
But on macOS, that's not true.


153
00:08:20,033 --> 00:08:22,870 line:-2
So we may need to reconsider
how we protect this data


154
00:08:22,936 --> 00:08:24,872 line:-1
if we plan to support macOS.


155
00:08:25,706 --> 00:08:28,909 line:-2
We should also think about
third-party dependencies.


156
00:08:28,976 --> 00:08:30,844 line:-1
What libraries are we using,


157
00:08:30,911 --> 00:08:33,413 line:-2
is their approach to security
consistent with ours,


158
00:08:33,480 --> 00:08:37,049 line:-2
and is testing sufficient to allow
quick updating of these dependencies?


159
00:08:37,116 --> 00:08:40,120 line:-2
Now that we've found ways to mitigate risk
architecturally,


160
00:08:40,187 --> 00:08:43,524 line:-2
let's have a look inside our application
at the implementation.


161
00:08:44,157 --> 00:08:47,628 line:0
In our app,
there are three main classes of object:


162
00:08:47,694 --> 00:08:50,797 line:0
those responsible for retrieving data
from external sources,


163
00:08:51,465 --> 00:08:55,802 line:0
those responsible for parsing that data
and converting it into a model,


164
00:08:56,770 --> 00:09:00,107 line:0
and those responsible
for displaying the data to the user.


165
00:09:03,377 --> 00:09:06,113 line:-2
What we want to do
is identify which is which,


166
00:09:06,180 --> 00:09:08,515 line:-1
and where the highest risk areas are,


167
00:09:08,582 --> 00:09:11,051 line:-2
as these are the parts
which will most directly work


168
00:09:11,118 --> 00:09:13,120 line:-1
with attacker-controlled data,


169
00:09:13,187 --> 00:09:15,455 line:-2
and thus,
where we need to be most careful.


170
00:09:16,657 --> 00:09:20,394 line:-2
Data stored on remote servers
is one of our highest risks.


171
00:09:20,928 --> 00:09:24,698 line:-2
The information stored on our website
can be created by any attacker,


172
00:09:24,765 --> 00:09:27,000 line:-2
so we need to take a lot of care
when handling it.


173
00:09:27,801 --> 00:09:31,505 line:-2
Data in our tea club, though,
can only be modified by its members.


174
00:09:31,572 --> 00:09:33,073 line:-1
CloudKit ensures that.


175
00:09:34,041 --> 00:09:36,343 line:-2
Here,
the set of attackers is more restricted,


176
00:09:36,410 --> 00:09:37,811 line:-1
and so the level of risk


177
00:09:37,878 --> 00:09:40,948 line:-2
depends on which attackers we consider
part of our threat model.


178
00:09:41,748 --> 00:09:44,952 line:-2
We can now follow this data flow
through our system


179
00:09:45,886 --> 00:09:48,121 line:-1
and get a corresponding risk profile.


180
00:09:48,956 --> 00:09:52,759 line:-2
Components responsible
for transferring the data have some risk.


181
00:09:52,826 --> 00:09:54,394 line:-1
And this is particularly true


182
00:09:54,461 --> 00:09:57,497 line:-2
where you have an interactive connection
with an untrusted entity.


183
00:09:58,265 --> 00:10:02,469 line:-2
But those which process the data
and are responsible for its validation


184
00:10:02,536 --> 00:10:03,971 line:-1
are the highest risk.


185
00:10:04,571 --> 00:10:06,573 line:-1
Note we've excluded the servers here,


186
00:10:06,640 --> 00:10:08,709 line:-2
as they're out of scope
for this discussion.


187
00:10:09,943 --> 00:10:12,379 line:-1
We can do this process for our whole app


188
00:10:12,946 --> 00:10:15,048 line:-1
and get a view of where risk lives,


189
00:10:15,516 --> 00:10:17,317 line:-1
where we need to be most paranoid,


190
00:10:17,384 --> 00:10:19,419 line:-2
and where we're most likely
to make mistakes


191
00:10:19,486 --> 00:10:21,388 line:-1
which will result in security issues.


192
00:10:21,955 --> 00:10:22,956 line:-1
So to recap:


193
00:10:23,023 --> 00:10:25,692 line:-1
Identify what assets your system has


194
00:10:25,759 --> 00:10:28,262 line:-2
and think about how you can design
to protect them,


195
00:10:29,062 --> 00:10:32,566 line:-2
particularly how to protect your data
in transit and at rest.


196
00:10:34,268 --> 00:10:37,137 line:0
Identify where attackers
can influence your application,


197
00:10:37,538 --> 00:10:40,007 line:0
tracing that data through the system


198
00:10:40,073 --> 00:10:42,843 line:0
so you can understand
where the high-risk components are


199
00:10:42,910 --> 00:10:46,780 line:0
and can plan to mitigate issues
that might occur during implementation.


200
00:10:48,148 --> 00:10:52,386 line:-2
Now, over to Ryan
to talk a bit more about untrusted data.


201
00:10:52,786 --> 00:10:54,154 line:-1
Thanks, Coops.


202
00:10:54,221 --> 00:10:57,357 line:-2
So, before we even begin
to secure our applications,


203
00:10:57,424 --> 00:11:01,195 line:-2
we have to be able to identify
how untrusted data is getting in.


204
00:11:01,261 --> 00:11:04,031 line:-1
Well, what is untrusted data? It's simple.


205
00:11:04,464 --> 00:11:07,367 line:-2
We're gonna always assume
that external data is untrusted


206
00:11:07,434 --> 00:11:08,869 line:-1
unless you're in control of it.


207
00:11:08,936 --> 00:11:11,772 line:-2
And when you're not sure if
you're in control of it, assume the worst.


208
00:11:11,839 --> 00:11:13,674 line:-1
Let's see some simple examples now


209
00:11:13,740 --> 00:11:15,976 line:-2
of how untrusted data
can get into our apps.


210
00:11:16,877 --> 00:11:20,547 line:-2
You may not realize it,
but if your app uses custom URL handling,


211
00:11:20,614 --> 00:11:24,117 line:-2
the URL is completely untrusted
and can come from anywhere,


212
00:11:24,184 --> 00:11:27,621 line:-2
even from someone you don't expect
sending it to a user over iMessage.


213
00:11:28,322 --> 00:11:31,225 line:-2
Similarly,
if you have a custom document format,


214
00:11:31,291 --> 00:11:34,828 line:-2
there may be vulnerabilities in parsing it
that could compromise your application.


215
00:11:36,296 --> 00:11:40,300 line:0
The first action we want to take is to
figure out all the data entry points


216
00:11:40,367 --> 00:11:44,471 line:0
so we can begin to see how the untrusted
data is being handled by our application.


217
00:11:44,538 --> 00:11:46,907 line:0
Now that we've already done
our data flow diagram,


218
00:11:46,974 --> 00:11:48,809 line:0
we should have this information available.


219
00:11:49,243 --> 00:11:53,647 line:-2
This is just an example and is by no means
an exhaustive list of every entry point


220
00:11:53,714 --> 00:11:56,617 line:-2
that iOS and macOS
exposes to your application.


221
00:11:57,017 --> 00:12:01,121 line:0
Most commonly, our application probably
deals with some amount of networking.


222
00:12:01,188 --> 00:12:04,591 line:0
This represents the highest relative risk
for handling untrusted data,


223
00:12:04,658 --> 00:12:06,527 line:0
as an attacker can target a user


224
00:12:06,593 --> 00:12:09,563 line:0
without needing to be in
physical proximity to the user's device.


225
00:12:09,963 --> 00:12:13,800 line:-2
This can be in the form of
talking to your server over HTTPS,


226
00:12:13,867 --> 00:12:16,904 line:-2
peer-to-peer communication,
such as real-time video calling,


227
00:12:16,970 --> 00:12:19,206 line:-1
or even Bluetooth communication.


228
00:12:19,273 --> 00:12:21,675 line:-2
In our example,
Loose Leaf has a few features


229
00:12:21,742 --> 00:12:24,178 line:-2
which process untrusted data
from over the network.


230
00:12:24,244 --> 00:12:27,881 line:-2
And because we care about
the privacy and security of tea fanatics,


231
00:12:27,948 --> 00:12:31,818 line:-2
we've implemented end-to-end encryption
for all of our device-to-device messaging.


232
00:12:32,486 --> 00:12:35,789 line:-2
Now, we won't get into exactly how
to implement encrypted messaging,


233
00:12:35,856 --> 00:12:38,825 line:-2
but it's critical that we understand
an intrinsic property


234
00:12:38,892 --> 00:12:42,896 line:-2
of these types of security technologies
when we're developing secure applications.


235
00:12:43,330 --> 00:12:46,867 line:-2
Encryption does not imply
the message is trusted and valid.


236
00:12:46,934 --> 00:12:47,935 line:-1
To put that simply,


237
00:12:48,001 --> 00:12:51,371 line:-2
I can know with cryptographic guarantees
that the message is from my friend,


238
00:12:51,438 --> 00:12:53,807 line:-2
but that doesn't mean my friend
isn't trying to hack me.


239
00:12:53,874 --> 00:12:57,444 line:-2
The contents of an encrypted message
are still untrusted data.


240
00:12:57,511 --> 00:13:01,248 line:-2
Okay, so we know our application
gets some messages over the network.


241
00:13:01,648 --> 00:13:04,384 line:-2
And then typically
we'll do some message processing here.


242
00:13:04,451 --> 00:13:08,722 line:-2
That could be some decryption or verifying
a cryptographic signature, for example.


243
00:13:09,423 --> 00:13:10,724 line:-1
Then it will get to the point


244
00:13:10,791 --> 00:13:13,961 line:-2
where our application will want to read
the contents of that message.


245
00:13:14,027 --> 00:13:16,530 line:-2
And now our job
is to look at these messages


246
00:13:16,597 --> 00:13:19,533 line:-2
and figure out what's trusted,
what's untrusted,


247
00:13:19,600 --> 00:13:22,569 line:-2
and then we'll be able to see
how we're using the untrusted data.


248
00:13:23,103 --> 00:13:25,239 line:-1
So we might take a look at our protocol


249
00:13:25,305 --> 00:13:28,876 line:-2
and find that this sender e-mail address
is a verified sender address.


250
00:13:28,942 --> 00:13:31,778 line:-2
In our example,
this is cryptographically verified,


251
00:13:31,845 --> 00:13:34,982 line:-2
so it can't be spoofed and can't be
something that we don't expect.


252
00:13:35,048 --> 00:13:36,617 line:-1
So we can trust this.


253
00:13:37,951 --> 00:13:41,822 line:-2
Then we look at the message identifier
and find that it's partially controllable.


254
00:13:41,889 --> 00:13:44,024 line:-2
When we say
something is partially controllable,


255
00:13:44,091 --> 00:13:48,128 line:-2
we typically mean that it's bound to some
range of values or some specific type.


256
00:13:48,195 --> 00:13:50,631 line:-1
For example, this has to be a UUID,


257
00:13:50,697 --> 00:13:53,367 line:-2
but someone could still send us
any valid UUID.


258
00:13:54,668 --> 00:13:56,170 line:-1
Then we look at the message payload


259
00:13:56,236 --> 00:13:58,505 line:-2
and find that
it's completely sender-controlled.


260
00:13:58,572 --> 00:14:01,608 line:-2
This means that they can send us
any arbitrary message payload,


261
00:14:01,675 --> 00:14:04,745 line:-2
and it might not even be in the format
that our application expects.


262
00:14:05,512 --> 00:14:09,049 line:-2
So with anything that's sender-controlled,
we have to make sure that we validate


263
00:14:09,116 --> 00:14:11,752 line:-2
and sanitize this untrusted data
before using it.


264
00:14:12,352 --> 00:14:16,990 line:-2
Okay. So far, we've seen how to identify
and classify untrusted data.


265
00:14:17,057 --> 00:14:20,827 line:-2
Now, let's look at some common ways
for how untrusted data can be mishandled,


266
00:14:20,894 --> 00:14:24,164 line:-2
so you can learn how to find
bugs like these in your own applications.


267
00:14:25,165 --> 00:14:27,434 line:-2
We're gonna look
at a path traversal bug here,


268
00:14:27,501 --> 00:14:29,703 line:-2
which is a very common type
of security bug


269
00:14:29,770 --> 00:14:31,705 line:-1
that you may find in your own application.


270
00:14:32,539 --> 00:14:34,975 line:-1
Now, in Loose Leaf, we have the ability


271
00:14:35,042 --> 00:14:37,711 line:-2
to send photos of your tea latte art
to your friends,


272
00:14:37,778 --> 00:14:40,047 line:-2
and it looks like
this is the code that handles that.


273
00:14:41,114 --> 00:14:43,684 line:-2
In this example,
we're taking the downloaded photo,


274
00:14:43,750 --> 00:14:46,587 line:-2
and the goal here is to move that
into a temporary directory


275
00:14:46,653 --> 00:14:49,523 line:-2
so we can use it before the system
deletes the downloaded file.


276
00:14:50,424 --> 00:14:54,294 line:-2
The first thing we want to do is look at
what comes in to the method here.


277
00:14:54,361 --> 00:14:57,965 line:-2
Our goal is to figure out what's trusted,
what's untrusted,


278
00:14:58,031 --> 00:15:00,234 line:-2
and see how we're handling
the untrusted data.


279
00:15:01,368 --> 00:15:03,504 line:-1
So we take a look at our method here


280
00:15:03,570 --> 00:15:07,574 line:-2
and find that this incoming resource URL
is a random file name.


281
00:15:07,641 --> 00:15:09,309 line:-1
It's generated locally on the device


282
00:15:09,376 --> 00:15:11,378 line:-2
when the file is downloaded
from the Internet.


283
00:15:11,445 --> 00:15:14,381 line:-2
It can't be influenced by the sender,
so we can trust that.


284
00:15:15,649 --> 00:15:19,486 line:-2
Then we look at the fromID here.
That's the verified sender address.


285
00:15:19,553 --> 00:15:22,189 line:-2
In our example,
this is cryptographically verified,


286
00:15:22,256 --> 00:15:25,158 line:-2
and so it can't be spoofed
and it can't be something we don't expect.


287
00:15:25,225 --> 00:15:26,793 line:-1
So we can trust that.


288
00:15:28,161 --> 00:15:32,099 line:-2
Then we take a look at the name here,
and this is completely sender-controlled.


289
00:15:32,165 --> 00:15:34,201 line:-2
This is what they're telling us
the name of the file is,


290
00:15:34,268 --> 00:15:36,670 line:-2
but they can send us
any arbitrary string here.


291
00:15:36,737 --> 00:15:38,438 line:-1
So let's see how we're using it.


292
00:15:39,339 --> 00:15:42,276 line:-2
We take the name
and pass it into appendingPathComponent


293
00:15:42,342 --> 00:15:45,746 line:-2
to try and build this destination path
in our temporary directory.


294
00:15:45,812 --> 00:15:47,948 line:-1
What happens if they send us this string


295
00:15:48,015 --> 00:15:51,185 line:-2
with any number of these backtracking
components at the beginning of it?


296
00:15:51,652 --> 00:15:54,955 line:-2
Now they've managed to traverse
outside of our temporary directory,


297
00:15:55,022 --> 00:15:57,624 line:-2
and when we copy the file,
we'll be copying it into


298
00:15:57,691 --> 00:16:00,394 line:-2
whatever arbitrary location
the sender has given us.


299
00:16:00,460 --> 00:16:02,596 line:-1
So, obviously, this is pretty bad,


300
00:16:02,663 --> 00:16:04,798 line:-2
as it can overwrite
potentially sensitive files


301
00:16:04,865 --> 00:16:07,034 line:-1
accessible in our application's container.


302
00:16:07,935 --> 00:16:09,403 line:-1
So you might take a look and go,


303
00:16:09,469 --> 00:16:12,339 line:-2
"Okay, I'll just take
the lastPathComponent here."


304
00:16:12,406 --> 00:16:15,843 line:-2
And in this example, that would work.
It would give you the safe file name.


305
00:16:15,909 --> 00:16:19,646 line:-2
But it will also return this if the last
components are the backtracking ones.


306
00:16:19,713 --> 00:16:23,417 line:-2
So we can still potentially overwrite
sensitive files for our application.


307
00:16:24,718 --> 00:16:27,254 line:-2
Another mistake we can make
using lastPathComponent


308
00:16:27,321 --> 00:16:30,290 line:-2
is if you build the URL manually
using URLWithString,


309
00:16:30,357 --> 00:16:32,492 line:-2
because lastPathComponent
will still return this


310
00:16:32,559 --> 00:16:35,162 line:-2
if the slashes have been encoded
with percent encoding.


311
00:16:35,696 --> 00:16:38,799 line:-2
And when we go to use the URL,
it will decode the percent encoding,


312
00:16:38,866 --> 00:16:40,868 line:-2
so they've still managed
to make us traverse


313
00:16:40,934 --> 00:16:42,703 line:-1
outside of our intended directory.


314
00:16:44,004 --> 00:16:46,306 line:-1
So, what's the correct way to do this?


315
00:16:46,840 --> 00:16:49,910 line:-2
We'll take lastPathComponent
on the file name


316
00:16:49,977 --> 00:16:53,146 line:-2
and then make sure that there's
actually still a file name there.


317
00:16:53,213 --> 00:16:55,782 line:-2
We'll make sure it's not equal
to these special path components.


318
00:16:55,849 --> 00:16:58,585 line:-2
Otherwise we bail out
and refuse to process the file.


319
00:16:59,219 --> 00:17:02,389 line:-2
And we also have to make sure
to use fileURLWithPath,


320
00:17:02,456 --> 00:17:04,324 line:-1
which will add additional percent escapes


321
00:17:04,391 --> 00:17:07,194 line:-2
so we're not vulnerable to
these kinds of percent encoding attacks.


322
00:17:08,028 --> 00:17:09,963 line:-1
So, what have we learned from this?


323
00:17:10,631 --> 00:17:13,534 line:-2
Don't use remotely controllable parameters
in file paths.


324
00:17:13,599 --> 00:17:15,836 line:-1
It's so easy to get this wrong.


325
00:17:15,903 --> 00:17:18,137 line:-1
If you have to, use lastPathComponent


326
00:17:18,204 --> 00:17:22,742 line:-2
along with additional validation
and sanitization, as shown in our example.


327
00:17:23,743 --> 00:17:26,445 line:-2
And always make sure to use
fileURLWithPath,


328
00:17:26,512 --> 00:17:29,116 line:-2
which will add additional percent escapes
to your file paths


329
00:17:29,183 --> 00:17:31,718 line:-2
so you're not vulnerable
to these same percent encoding attacks.


330
00:17:32,152 --> 00:17:35,189 line:-2
But generally, just try and avoid
this pattern if you can.


331
00:17:35,255 --> 00:17:39,560 line:-2
Just use a temporary file path with
a locally-generated and random file name.


332
00:17:40,194 --> 00:17:42,329 line:-1
Some actions you can take right now


333
00:17:42,396 --> 00:17:44,698 line:-2
are to check for all uses
of untrusted strings


334
00:17:44,765 --> 00:17:47,234 line:-1
being passed into the following methods.


335
00:17:47,301 --> 00:17:49,903 line:-2
Another example
of mishandling untrusted data


336
00:17:49,970 --> 00:17:51,839 line:-1
is uncontrolled format strings.


337
00:17:52,506 --> 00:17:55,075 line:-2
So, we might have some method
like this in our application,


338
00:17:55,142 --> 00:17:57,244 line:-2
where we get a request message
from a device


339
00:17:57,311 --> 00:18:00,581 line:-2
and then generate a response from it
and send the response back to them.


340
00:18:01,348 --> 00:18:03,517 line:-1
We're going to do the same exercise here.


341
00:18:03,584 --> 00:18:05,085 line:-1
We want to look at our method


342
00:18:05,152 --> 00:18:08,155 line:-2
and figure out what's trusted
and what's not trusted,


343
00:18:08,222 --> 00:18:10,724 line:-2
and then figure out how we're using
the untrusted data.


344
00:18:11,692 --> 00:18:13,393 line:-1
So we look into it


345
00:18:13,460 --> 00:18:16,864 line:-2
and find out that this name
is the local user name on the device.


346
00:18:16,930 --> 00:18:20,267 line:-2
It's generated locally and can't be
influenced at all by the sender,


347
00:18:20,334 --> 00:18:21,635 line:-1
so we can trust this.


348
00:18:22,769 --> 00:18:26,139 line:-2
But then this request they're sending us
is again the sender-controlled payload.


349
00:18:26,206 --> 00:18:28,642 line:-2
They can send us
any arbitrary request message,


350
00:18:28,709 --> 00:18:30,177 line:-1
so we can't trust that.


351
00:18:31,144 --> 00:18:33,280 line:-2
So let's see how we're using
that parameter.


352
00:18:33,914 --> 00:18:35,849 line:-1
Well, we're taking the request,


353
00:18:35,916 --> 00:18:38,919 line:-2
and then we're grabbing this localized
format string off the request


354
00:18:38,986 --> 00:18:40,621 line:-1
and passing it to NSLocalizedString.


355
00:18:40,687 --> 00:18:43,690 line:-2
So the goal here is to generate
the correct response


356
00:18:43,757 --> 00:18:45,993 line:-2
in the user's local language
on the device.


357
00:18:47,027 --> 00:18:49,663 line:-2
But again,
this is just an arbitrary string,


358
00:18:49,730 --> 00:18:53,367 line:-2
so they can send us anything here,
even if we can't localize it.


359
00:18:53,433 --> 00:18:55,402 line:-1
Now when we pass it to string with format,


360
00:18:55,469 --> 00:18:58,305 line:-2
there won't be enough arguments here
to correctly format the string.


361
00:18:59,106 --> 00:19:00,574 line:-1
So what ends up happening is,


362
00:19:00,641 --> 00:19:02,643 line:-2
we'll actually be leaking the contents
of the stack


363
00:19:02,709 --> 00:19:04,511 line:-1
and sending that back to the person.


364
00:19:04,578 --> 00:19:06,647 line:-2
This can potentially reveal
sensitive information


365
00:19:06,713 --> 00:19:08,582 line:-1
from your application's memory,


366
00:19:08,649 --> 00:19:10,951 line:-2
or in some cases,
it can even allow an attacker


367
00:19:11,018 --> 00:19:13,520 line:-2
to take control over the execution
of your application.


368
00:19:13,987 --> 00:19:15,822 line:-1
So we definitely want to avoid this.


369
00:19:16,623 --> 00:19:18,559 line:-1
So what have we learned from this?


370
00:19:18,625 --> 00:19:22,229 line:-2
Never use or generate a format
string specifier from untrusted data.


371
00:19:22,296 --> 00:19:26,233 line:-2
There's actually no correct way
to do this, so just avoid this if you can.


372
00:19:26,300 --> 00:19:29,069 line:-2
Don't try and validate or filter
the format specifier either.


373
00:19:29,136 --> 00:19:30,537 line:-1
You'll probably get it wrong.


374
00:19:31,905 --> 00:19:35,342 line:-2
Make sure that you don't have the
format-security compiler flag disabled.


375
00:19:35,409 --> 00:19:37,077 line:-1
It is on by default,


376
00:19:37,144 --> 00:19:39,980 line:-2
but make sure you're not disabling it
for a section of code.


377
00:19:40,047 --> 00:19:43,417 line:-2
But we have to be aware
there are some cases this will not catch.


378
00:19:43,483 --> 00:19:46,820 line:-2
For example, the one we just looked at
won't actually give you a compiler warning


379
00:19:46,887 --> 00:19:49,456 line:-2
because in some cases,
the compiler can't do anything


380
00:19:49,523 --> 00:19:52,693 line:-2
to reason about the format string
if it's not a string literal.


381
00:19:53,694 --> 00:19:57,064 line:-2
You also have to be extra careful
with format strings in Swift,


382
00:19:57,130 --> 00:20:00,534 line:-2
because Swift doesn't have the level
of compiler validation for format strings


383
00:20:00,601 --> 00:20:02,469 line:-1
as C or Objective-C has.


384
00:20:03,170 --> 00:20:07,374 line:-2
So in Swift, you want to use
string interpolation wherever possible.


385
00:20:07,441 --> 00:20:09,743 line:-1
Sometimes you have to use format strings,


386
00:20:09,810 --> 00:20:12,179 line:-2
such as when you're building
these localized strings.


387
00:20:12,246 --> 00:20:15,382 line:-2
We just have to be extra vigilant
not to introduce bugs like this.


388
00:20:16,416 --> 00:20:18,585 line:-1
Some actions you can take right now


389
00:20:18,652 --> 00:20:21,021 line:-2
are to check for all uses
of untrusted strings


390
00:20:21,088 --> 00:20:24,124 line:-2
being passed into the following methods
as format specifiers.


391
00:20:24,191 --> 00:20:27,127 line:-2
So we've looked at
two common security issues so far


392
00:20:27,194 --> 00:20:30,631 line:-2
that are generally easy to find
when you know what you're searching for.


393
00:20:30,697 --> 00:20:32,766 line:-1
But it's not always straightforward.


394
00:20:33,333 --> 00:20:37,638 line:-2
A lot of the time you'll find logic issues
that untrusted data can take advantage of


395
00:20:37,704 --> 00:20:40,440 line:-2
to make your code flow
in unexpected directions.


396
00:20:40,507 --> 00:20:43,510 line:-2
The first one of these we'll look at
is state corruption issues.


397
00:20:44,545 --> 00:20:46,780 line:-1
In Loose Leaf, we've added the ability


398
00:20:46,847 --> 00:20:50,050 line:-2
to enter a live stream brewing session
with your tea club members.


399
00:20:50,117 --> 00:20:53,687 line:0
To do this, we follow an invite-based
session state machine here,


400
00:20:53,754 --> 00:20:56,156 line:0
where I can invite someone
to a brewing session,


401
00:20:56,223 --> 00:20:58,458 line:0
and if they accept,
we'll end up in this connected state,


402
00:20:58,525 --> 00:21:01,495 line:0
where I might share a live stream
from my device's camera.


403
00:21:02,829 --> 00:21:04,831 line:-1
Let's dive in a little deeper here


404
00:21:04,898 --> 00:21:07,868 line:-2
and look at what will transition us
between these states.


405
00:21:09,269 --> 00:21:11,505 line:-1
So I can send someone an invite,


406
00:21:11,572 --> 00:21:15,242 line:-2
and I'll end up in this inviting state
and they'll end up in the invited state.


407
00:21:16,176 --> 00:21:19,379 line:-2
If they accept the invite,
we'll both end up in this connected state


408
00:21:19,446 --> 00:21:22,149 line:-2
and might now share this connected
socket between our devices.


409
00:21:23,417 --> 00:21:25,485 line:-2
But what happens
if I send someone an invite


410
00:21:25,552 --> 00:21:27,754 line:-2
but also send them
an inviteAccept message?


411
00:21:27,821 --> 00:21:29,756 line:-1
Can I force them into this connected state


412
00:21:29,823 --> 00:21:32,759 line:-2
without them actually having
accepted our invitation?


413
00:21:32,826 --> 00:21:35,128 line:-2
Well, let's take a look
at the code here for this.


414
00:21:36,530 --> 00:21:40,234 line:-2
Now that we understand the difference
between trusted and untrusted data,


415
00:21:40,300 --> 00:21:42,870 line:-2
we should be able
to go through here quickly and see that


416
00:21:42,936 --> 00:21:46,373 line:-2
this is the verified sender address,
and I can trust this.


417
00:21:46,440 --> 00:21:49,610 line:-2
And this is the sender-controlled message,
so I can't trust that.


418
00:21:50,344 --> 00:21:53,280 line:-2
So what's happening here is
we're taking the type out of the message


419
00:21:53,347 --> 00:21:56,717 line:-2
and dispatching it to some other handler
based on the type of message.


420
00:21:57,451 --> 00:22:00,020 line:-2
But again, this comes
from the sender-controlled payload,


421
00:22:00,087 --> 00:22:02,523 line:-2
so they can still send us
any message type here.


422
00:22:02,589 --> 00:22:05,526 line:-2
Now, in this case, we want to look
at the inviteAccept message,


423
00:22:05,592 --> 00:22:07,294 line:-1
so let's jump into the handle there.


424
00:22:08,562 --> 00:22:10,898 line:-2
It looks like we're checking
that the session exists


425
00:22:10,964 --> 00:22:13,534 line:-2
based on the session identifier
that the sender gave us,


426
00:22:14,268 --> 00:22:16,236 line:-2
and then we're setting the state
to "connected."


427
00:22:16,303 --> 00:22:17,471 line:-1
It looks like in this case,


428
00:22:17,538 --> 00:22:20,674 line:-2
the sender can actually force us
into this connected state.


429
00:22:20,741 --> 00:22:22,910 line:-1
We're probably missing a check here.


430
00:22:23,410 --> 00:22:26,647 line:-2
We probably want to check
that we're actually in the inviting state


431
00:22:26,713 --> 00:22:30,317 line:-2
and are expecting to receive an "invite
accept" message before transitioning.


432
00:22:31,084 --> 00:22:34,087 line:-1
So, is this enough? Well, probably not.


433
00:22:34,688 --> 00:22:36,957 line:-2
There's probably some other checks
that we want to do,


434
00:22:37,024 --> 00:22:40,460 line:-2
some state invariant that has to be true
before proceeding.


435
00:22:40,527 --> 00:22:41,528 line:-1
So in this case,


436
00:22:41,595 --> 00:22:44,831 line:-2
we want to ensure that the inviteAccept
message that will transition us


437
00:22:44,898 --> 00:22:46,834 line:-2
is coming from someone
we actually invited.


438
00:22:48,135 --> 00:22:50,070 line:-1
So what have we learned here?


439
00:22:50,137 --> 00:22:54,041 line:-2
We want to define clear state invariants
that must be true before proceeding.


440
00:22:54,107 --> 00:22:57,811 line:-2
But as we saw, this can be really subtle
and easy to get wrong.


441
00:22:57,878 --> 00:22:59,813 line:-1
In our example, it wasn't just as simple


442
00:22:59,880 --> 00:23:01,915 line:-2
as checking
that we're in the correct state,


443
00:23:01,982 --> 00:23:05,085 line:-2
and there were other properties
we needed to validate before proceeding.


444
00:23:05,786 --> 00:23:07,487 line:-1
And we want to bail out early on


445
00:23:07,554 --> 00:23:10,190 line:-2
and refuse to proceed
if any of these checks fail,


446
00:23:10,257 --> 00:23:12,693 line:-2
as we don't want our code
to go in unexpected directions


447
00:23:12,759 --> 00:23:14,862 line:-1
that could potentially modify the state.


448
00:23:14,928 --> 00:23:19,066 line:-2
Another common logic bug you might find
is piggybacking on untrusted data.


449
00:23:19,867 --> 00:23:23,237 line:0
So in our application,
we might do a lot of message processing,


450
00:23:23,303 --> 00:23:26,340 line:0
where we take some JSON data
the sender gave us from over the network


451
00:23:26,406 --> 00:23:29,376 line:0
and create a dictionary from it
that has this remote entry on it.


452
00:23:30,911 --> 00:23:32,713 line:0
Then after we're done processing,


453
00:23:32,779 --> 00:23:35,749 line:0
we tack on this other entry
to the dictionary.


454
00:23:35,816 --> 00:23:38,819 line:0
And now you pass that dictionary
to another part of your application,


455
00:23:38,886 --> 00:23:41,555 line:0
perhaps to modify the UI or the database.


456
00:23:42,256 --> 00:23:45,859 line:-2
And when it gets to that part of
your application and it's time to use it,


457
00:23:45,926 --> 00:23:48,729 line:-2
now we have to figure out
what's trusted on it before we use it.


458
00:23:48,795 --> 00:23:51,231 line:-2
So you might take a look
at the dictionary and go,


459
00:23:51,298 --> 00:23:54,668 line:-2
"This is the remote entry. And I know
this is the sender-controlled entry


460
00:23:54,735 --> 00:23:57,204 line:-2
because I know
it's sent over the Internet.


461
00:23:57,271 --> 00:23:59,339 line:-1
But this other entry, can I trust that?"


462
00:23:59,406 --> 00:24:01,208 line:-1
Well, you might think you can,


463
00:24:01,275 --> 00:24:03,844 line:-2
because you know it's generated locally
by your application,


464
00:24:03,911 --> 00:24:05,779 line:-1
so it can't be sender-controlled.


465
00:24:06,280 --> 00:24:09,149 line:0
But it turns out,
of course we can't trust it


466
00:24:09,216 --> 00:24:11,185 line:0
because it comes
from the sender-controlled message.


467
00:24:11,251 --> 00:24:13,954 line:0
And they can give us this entry as well.


468
00:24:14,021 --> 00:24:17,558 line:0
And if they can force our application
to go down some unexpected path


469
00:24:17,624 --> 00:24:20,160 line:0
where it doesn't also tack on
this other entry,


470
00:24:20,227 --> 00:24:22,196 line:0
then when it gets time
to use this message,


471
00:24:22,262 --> 00:24:24,998 line:0
we have no idea
whether it came from the remote sender


472
00:24:25,065 --> 00:24:26,633 line:0
or if it was generated locally.


473
00:24:26,700 --> 00:24:28,969 line:0
So we have to assume
that we can't trust it.


474
00:24:30,003 --> 00:24:32,372 line:-1
Let's take a look at an example of this.


475
00:24:32,439 --> 00:24:36,076 line:-2
We've added the ability to react
to someone's live tea-brewing session,


476
00:24:36,143 --> 00:24:38,445 line:-2
and you can even attach
an image of your reaction


477
00:24:38,512 --> 00:24:40,013 line:-1
to show them what you think.


478
00:24:40,714 --> 00:24:43,917 line:-2
So it looks like we created
this Reaction object from the JSON data.


479
00:24:45,052 --> 00:24:46,920 line:-1
And if there was some image data attached,


480
00:24:46,987 --> 00:24:50,724 line:-2
we write it to a local file URL
during the message processing


481
00:24:50,791 --> 00:24:54,027 line:-2
and then set that as the imageURL
on the reaction object.


482
00:24:54,928 --> 00:24:57,497 line:-2
We then pass it to our ViewController
to display it.


483
00:24:57,564 --> 00:24:59,766 line:-2
So let's take a look
at what happens there.


484
00:25:00,534 --> 00:25:03,270 line:-2
If the imageURL is non-nil,
we'll display it...


485
00:25:04,538 --> 00:25:08,008 line:-2
then remove the image we wrote to disk
once it's finished displaying.


486
00:25:08,075 --> 00:25:11,211 line:-2
But because we're taking the imageURL
off of the same object


487
00:25:11,278 --> 00:25:13,146 line:-1
that's created with the untrusted data,


488
00:25:13,213 --> 00:25:16,283 line:-2
we've given an attacker
the ability to delete arbitrary files


489
00:25:16,350 --> 00:25:18,919 line:-2
that are accessible
from our application's container.


490
00:25:19,686 --> 00:25:22,756 line:-2
Because what will happen
if someone sends us this message


491
00:25:22,823 --> 00:25:25,225 line:-1
with the imageURL already set in it


492
00:25:25,292 --> 00:25:29,029 line:-2
is we'll skip over this block of code
because the image data wasn't set


493
00:25:29,930 --> 00:25:32,099 line:-1
and go straight to displaying it here.


494
00:25:32,766 --> 00:25:34,801 line:-1
But because the imageURL was set,


495
00:25:34,868 --> 00:25:37,271 line:-2
we'll try and show
whatever is at the file path,


496
00:25:37,337 --> 00:25:41,375 line:-2
but actually we'll end up deleting
whatever file was specified in the JSON.


497
00:25:42,176 --> 00:25:44,211 line:-1
So what have we learned from that?


498
00:25:44,278 --> 00:25:46,747 line:-2
You want to separate trusted
and untrusted data


499
00:25:46,813 --> 00:25:48,749 line:-1
into completely different objects.


500
00:25:48,815 --> 00:25:51,118 line:-2
Don't try and combine them
into a single object,


501
00:25:51,185 --> 00:25:53,654 line:-2
because what you'll be doing
is introducing ambiguity


502
00:25:53,720 --> 00:25:56,290 line:-1
between trusted and untrusted parameters.


503
00:25:56,356 --> 00:25:58,659 line:-2
We always want it to be very clear
what's untrusted


504
00:25:58,725 --> 00:26:01,094 line:-2
so that we can audit our use
of the untrusted data


505
00:26:01,161 --> 00:26:04,998 line:-2
and make sure it's always validated
and sanitized before we use it.


506
00:26:05,432 --> 00:26:08,335 line:-2
Now I'll hand it back over to Coops
to talk about NSCoding.


507
00:26:08,402 --> 00:26:10,037 line:-1
Thanks, Ryan.


508
00:26:10,103 --> 00:26:13,774 line:-2
NSCoding, and its more modern
NSSecureCoding companion,


509
00:26:13,841 --> 00:26:17,811 line:-2
have been around for a long time
and provide the valuable capability


510
00:26:17,878 --> 00:26:21,181 line:-2
to serialize and deserialize
complex graphs of objects.


511
00:26:22,149 --> 00:26:26,753 line:-2
It's the kind of thing we might use for
storing parsed data into our local cache,


512
00:26:26,820 --> 00:26:28,655 line:-1
or for a custom document format.


513
00:26:28,722 --> 00:26:31,291 line:-2
We're going to cover
some of the mistakes which we see


514
00:26:31,358 --> 00:26:34,928 line:-2
and which are particularly dangerous
if the archive comes from untrusted data.


515
00:26:36,530 --> 00:26:40,367 line:-1
To start, please stop using NSUnarchiver.


516
00:26:40,434 --> 00:26:42,336 line:-1
It's been deprecated for ages


517
00:26:42,402 --> 00:26:45,205 line:-2
and isn't suitable for data
coming from an untrusted source.


518
00:26:46,039 --> 00:26:49,343 line:-2
What you want to be using
is NSKeyedUnarchiver.


519
00:26:50,210 --> 00:26:54,581 line:-2
Much like NSUnarchiver, it allows you
to pack and unpack graphs of objects,


520
00:26:54,648 --> 00:26:56,984 line:-2
but it has the ability
to be used securely.


521
00:26:58,585 --> 00:27:01,755 line:-2
NSKeyedUnarchiver
has also been around for a while,


522
00:27:01,822 --> 00:27:03,824 line:-1
so there are deprecated ways of using it.


523
00:27:04,424 --> 00:27:06,593 line:-1
Many of you may be using it in these ways,


524
00:27:06,660 --> 00:27:10,597 line:-2
unaware that you're leaving your software
and your users exposed to attack.


525
00:27:10,664 --> 00:27:14,301 line:-2
The top set of methods here
are the ones you should be using.


526
00:27:14,368 --> 00:27:17,104 line:0
The bottom ones are all legacy,
and if you're still using,


527
00:27:17,171 --> 00:27:19,573 line:0
you should migrate away from
as soon as possible.


528
00:27:20,741 --> 00:27:23,010 line:-1
The naming of the two sets is very close,


529
00:27:23,076 --> 00:27:26,847 line:-2
but all the deprecated ones
are named "with" rather than "from."


530
00:27:26,914 --> 00:27:29,316 line:-1
The reason we deprecated these methods


531
00:27:29,383 --> 00:27:31,852 line:-2
is that they're incompatible
with secure coding.


532
00:27:31,919 --> 00:27:35,422 line:-2
You might not fully understand
what secure coding is,


533
00:27:35,489 --> 00:27:37,391 line:-1
so let's look at the problem it solves.


534
00:27:39,193 --> 00:27:40,861 line:-1
Without secure coding,


535
00:27:40,928 --> 00:27:44,965 line:-2
when you take an archive
and call unarchiveObjectWithData,


536
00:27:45,032 --> 00:27:47,134 line:-1
it unpacks an object graph for you.


537
00:27:48,001 --> 00:27:51,338 line:-2
In this example, we're expecting
to get back an array of strings.


538
00:27:52,806 --> 00:27:55,709 line:-2
The problem here
is that the types of objects created


539
00:27:55,776 --> 00:27:58,011 line:-1
are specified inside the archive.


540
00:27:58,545 --> 00:28:03,016 line:-2
If that comes from an untrusted source
or can be modified by an attacker,


541
00:28:03,083 --> 00:28:06,320 line:-2
any NSCoding-compliant object
can be returned.


542
00:28:07,921 --> 00:28:10,958 line:-2
What this means is an attacker
might modify the archive


543
00:28:11,024 --> 00:28:14,228 line:-2
and cause us to unpack
a completely unexpected class,


544
00:28:14,294 --> 00:28:15,829 line:-1
like WKWebView.


545
00:28:17,030 --> 00:28:20,601 line:-2
Although this object might not conform
to the interface we expect,


546
00:28:20,667 --> 00:28:22,736 line:-1
and you may even perform a type check,


547
00:28:23,270 --> 00:28:25,606 line:-1
a security issue still remains,


548
00:28:26,206 --> 00:28:30,310 line:-2
as any bugs reachable by an attacker
during the un-archiving of the class


549
00:28:30,377 --> 00:28:31,879 line:-1
will have triggered already.


550
00:28:32,479 --> 00:28:37,150 line:-2
Secure coding resolves these issues
by restricting the compatible classes


551
00:28:37,217 --> 00:28:40,420 line:-2
to those which implement
the secure coding protocol


552
00:28:40,487 --> 00:28:44,491 line:-2
and requires that you specify the classes
you expect at each call site.


553
00:28:45,926 --> 00:28:48,962 line:-2
This information is used
inside the KeyedUnarchiver


554
00:28:49,029 --> 00:28:52,132 line:-2
to perform validation
before the decoding is even attempted.


555
00:28:53,834 --> 00:28:56,570 line:-2
Doing this drastically reduces
the number of classes


556
00:28:56,637 --> 00:29:00,641 line:-2
which can be leveraged by an attacker
and thus reduces the attack surface.


557
00:29:01,975 --> 00:29:05,812 line:-2
But even with this, there are a number
of common mistakes we see.


558
00:29:05,879 --> 00:29:07,147 line:-1
Let's take a look at some.


559
00:29:08,382 --> 00:29:10,117 line:-1
In this simple example,


560
00:29:10,184 --> 00:29:13,353 line:-2
we're using secure coding
to retrieve an array of objects.


561
00:29:15,189 --> 00:29:19,560 line:-2
The issue here is that we've specified
NSObject in the allowedClasses set.


562
00:29:20,827 --> 00:29:24,398 line:-2
Secure coding will decode objects
which conform to its protocol


563
00:29:24,464 --> 00:29:29,436 line:-2
and are either in the allowedClasses set
or a subclass of one specified.


564
00:29:30,103 --> 00:29:32,906 line:-1
As all objects derive from NSObject,


565
00:29:32,973 --> 00:29:36,476 line:-2
this allows any secure coded object
to be decoded,


566
00:29:36,543 --> 00:29:40,380 line:-2
undermining the attack surface reduction
which secure coding gave us.


567
00:29:40,981 --> 00:29:43,784 line:-2
This is a simple example
which is easy to spot,


568
00:29:44,251 --> 00:29:47,020 line:-2
but we also see this happening
in more complex cases,


569
00:29:47,087 --> 00:29:50,357 line:-2
where class lists get passed
through multiple layers of framework


570
00:29:50,424 --> 00:29:53,093 line:-2
and end up being supplied
to a KeyedUnarchiver method.


571
00:29:55,229 --> 00:29:57,197 line:-1
Another similar pattern is this.


572
00:29:57,865 --> 00:29:59,933 line:-1
A string is decoded from the archive.


573
00:30:00,000 --> 00:30:04,204 line:-2
That string is then used to look up
a class via NSClassFromString,


574
00:30:05,072 --> 00:30:07,841 line:-2
the resulting class
used as the allowedClass


575
00:30:07,908 --> 00:30:09,710 line:-1
for the extraction of an object.


576
00:30:11,245 --> 00:30:13,847 line:-2
Hopefully
the issue here is obvious to people.


577
00:30:15,182 --> 00:30:18,318 line:-2
Both the className
and thus the resulting allowedClass


578
00:30:18,385 --> 00:30:19,987 line:-1
are under attacker control.


579
00:30:21,388 --> 00:30:25,225 line:-2
As such, they can easily pass the name
of a specific class


580
00:30:25,292 --> 00:30:29,363 line:-2
or even NSObject
and bypass the benefits of secure coding.


581
00:30:29,429 --> 00:30:31,398 line:-1
So how do we solve these problems?


582
00:30:32,299 --> 00:30:36,603 line:-2
If possible, simply use a restricted,
static set of classes,


583
00:30:36,670 --> 00:30:40,841 line:-2
making sure to avoid classes
which are the base for large hierarchies


584
00:30:40,908 --> 00:30:43,810 line:-2
to reduce the number of classes
available to an attacker.


585
00:30:44,278 --> 00:30:47,347 line:-2
What about the case where you do
want to support dynamic classes?


586
00:30:48,315 --> 00:30:52,653 line:-2
One of the most common places we see this
is where support for plug-ins is required.


587
00:30:53,987 --> 00:30:58,292 line:-2
In this case, we recommend creating
the allowedClass list dynamically,


588
00:30:58,358 --> 00:31:00,227 line:-1
but from trusted data.


589
00:31:00,661 --> 00:31:04,498 line:-2
The easiest way to do this
is where your plug-in supports a protocol.


590
00:31:04,898 --> 00:31:08,802 line:-2
Thus you can simply enumerate all
the classes that the runtime knows about


591
00:31:09,369 --> 00:31:12,172 line:-2
and create a set of those
which conform to the protocol.


592
00:31:13,674 --> 00:31:16,810 line:-2
This can then be safely used
with secure decoding,


593
00:31:17,177 --> 00:31:20,614 line:-2
as the class list is outside
the attacker's control.


594
00:31:21,148 --> 00:31:26,186 line:-2
To summarize, migrate your code away from
all the deprecated methods and classes,


595
00:31:26,954 --> 00:31:30,757 line:-2
avoid using NSObject
or overly generic base classes,


596
00:31:30,824 --> 00:31:34,094 line:-2
and use a static allowedClass list
wherever possible.


597
00:31:34,828 --> 00:31:37,865 line:-2
And when you can't,
generate it from trusted data.


598
00:31:39,800 --> 00:31:43,136 line:0
Another good alternative
is to avoid it completely


599
00:31:43,203 --> 00:31:45,072 line:0
and use things like Swift Codable


600
00:31:45,138 --> 00:31:50,010 line:0
or a less flexible encoding format
like plist, JSON or protobuf.


601
00:31:50,944 --> 00:31:53,146 line:0
You can act on this information right away


602
00:31:53,213 --> 00:31:55,682 line:0
by searching your codebase
for use of these items


603
00:31:55,749 --> 00:31:58,018 line:0
in areas which deal with untrusted data.


604
00:31:58,452 --> 00:32:01,822 line:-2
Another problem which plagues
high-risk code is memory corruption.


605
00:32:03,123 --> 00:32:06,460 line:-2
Whenever using Objective-C
or Swift's UnsafePointer,


606
00:32:06,527 --> 00:32:09,263 line:-2
it's possible to introduce
memory safety issues.


607
00:32:09,830 --> 00:32:13,333 line:-2
These are particularly prevalent
when parsing untrusted data,


608
00:32:13,400 --> 00:32:16,703 line:-2
be it from a buffer, a string,
or out of a structured archive.


609
00:32:18,071 --> 00:32:20,040 line:-1
Let's take a look at some examples.


610
00:32:21,141 --> 00:32:23,644 line:-2
As we've talked about already,
security issues arise


611
00:32:23,710 --> 00:32:26,313 line:-2
when untrusted data
is mistaken for trusted data.


612
00:32:27,681 --> 00:32:30,817 line:-2
In this example,
we're unpacking the CloudKit record


613
00:32:30,884 --> 00:32:32,486 line:-1
for a private tea club.


614
00:32:33,053 --> 00:32:37,024 line:-2
The first thing we do is copy the bytes
of the UUID into an iVar.


615
00:32:38,792 --> 00:32:43,363 line:-2
If we take a look at each element,
we can see that the CKRecord is trusted,


616
00:32:43,430 --> 00:32:45,365 line:-1
as it's generated by CloudKit.


617
00:32:45,766 --> 00:32:49,603 line:-2
But the data fields retrieved from it
are under attacker control.


618
00:32:49,670 --> 00:32:52,506 line:-2
So we can't trust that they contain
a fixed amount of data.


619
00:32:53,774 --> 00:32:58,011 line:-2
The problem here is that the length
of the data is under attackers' control,


620
00:32:58,078 --> 00:33:00,948 line:-1
but the size of the UUID iVar is fixed.


621
00:33:02,282 --> 00:33:07,354 line:-2
As such, if the supplied NSData
contains more than the UUID can hold,


622
00:33:07,988 --> 00:33:10,657 line:-2
attacker-controlled data
will be written out of bounds.


623
00:33:12,593 --> 00:33:16,430 line:-2
To see why this can be a problem,
we need to look at what will happen.


624
00:33:17,664 --> 00:33:19,967 line:-1
In the object which contains the UUID,


625
00:33:20,033 --> 00:33:23,704 line:-2
we can see that the next iVar
is the path to the local cache.


626
00:33:24,338 --> 00:33:27,875 line:-2
Now, this field isn't set
from the CloudKit record.


627
00:33:27,941 --> 00:33:30,777 line:-2
Thus,
overflowing the UUID allows an attacker


628
00:33:30,844 --> 00:33:33,747 line:-2
to gain control of a field
they shouldn't have the ability to.


629
00:33:34,515 --> 00:33:37,618 line:-2
The memcpy will cause
attacker-controlled data


630
00:33:37,684 --> 00:33:40,787 line:-1
to be written into UUID as intended,


631
00:33:40,854 --> 00:33:45,459 line:-2
but as the size is too great,
it will overflow into localCachePath.


632
00:33:46,894 --> 00:33:50,097 line:-2
With this, they can reconfigure
the cache for the group,


633
00:33:50,764 --> 00:33:52,499 line:-1
causing files to be downloaded


634
00:33:52,566 --> 00:33:54,868 line:-2
and overwriting
the users' local preferences.


635
00:33:55,569 --> 00:33:59,173 line:-2
Using various techniques,
attackers can use these kind of bugs


636
00:33:59,239 --> 00:34:01,275 line:-2
to get code execution
inside your application,


637
00:34:01,341 --> 00:34:03,810 line:-2
which gives them access
to all your users' data


638
00:34:03,877 --> 00:34:06,346 line:-2
and access to all the resources
that were granted to you.


639
00:34:07,080 --> 00:34:11,385 line:-2
The obvious fix for this
would be to use sizeof(_uuid),


640
00:34:11,451 --> 00:34:13,954 line:-1
but this exposes a different problem,


641
00:34:14,021 --> 00:34:17,056 line:-2
as, if the attacker supplies
less data than expected,


642
00:34:17,123 --> 00:34:19,592 line:-2
the memcpy will read
off the end of "data,"


643
00:34:19,659 --> 00:34:24,364 line:-2
causing other user secrets in memory
to be disclosed into the UUID field.


644
00:34:25,132 --> 00:34:28,034 line:-2
When the app syncs that information
back to the server,


645
00:34:28,101 --> 00:34:31,505 line:-2
it will encode that user data
and return it to the attacker.


646
00:34:32,873 --> 00:34:37,744 line:-2
The correct fix is to validate that
the object we retrieved is an NSData


647
00:34:37,811 --> 00:34:40,047 line:-1
and check its length is an exact match.


648
00:34:40,547 --> 00:34:43,217 line:-2
This prevents both
the overwrite of the destination


649
00:34:43,283 --> 00:34:45,052 line:-1
and the overread of the source.


650
00:34:46,620 --> 00:34:48,455 line:-1
Whilst this is a simple example,


651
00:34:48,522 --> 00:34:51,992 line:-2
extra care should always be taken
when parsing untrusted data,


652
00:34:52,492 --> 00:34:55,596 line:-2
particularly where the format
is complex or nested.


653
00:34:56,530 --> 00:34:58,265 line:-1
Always validate lengths,


654
00:34:58,332 --> 00:35:01,201 line:-2
as even casting a C structure
onto a buffer


655
00:35:01,268 --> 00:35:04,705 line:-2
will disclose user information
if there is insufficient data.


656
00:35:06,507 --> 00:35:10,310 line:-2
Another case where we need to be careful
is when dealing with integers,


657
00:35:10,377 --> 00:35:12,446 line:-1
as these have a habit of overflowing.


658
00:35:14,281 --> 00:35:16,884 line:-2
In this example,
further down the same method,


659
00:35:16,950 --> 00:35:20,053 line:-2
we extract an NSData
with UNICHAR characters


660
00:35:20,120 --> 00:35:22,256 line:-1
and a count from a separate field.


661
00:35:22,322 --> 00:35:25,792 line:-2
As before,
we should look at which data is trusted.


662
00:35:26,493 --> 00:35:29,830 line:-2
In this case,
both name and count are untrusted,


663
00:35:29,897 --> 00:35:32,199 line:-2
as they've come
from attacker-controlled data.


664
00:35:34,401 --> 00:35:38,338 line:-2
Now, the developer has foreseen the danger
of blindly trusting the count,


665
00:35:38,405 --> 00:35:41,241 line:-2
and so validates it
against the length of the data.


666
00:35:41,308 --> 00:35:42,609 line:-1
But there's a problem.


667
00:35:43,010 --> 00:35:46,513 line:-2
The attacker actually controls
both sides of this comparison,


668
00:35:46,580 --> 00:35:48,615 line:-1
and there exists a set of values


669
00:35:48,682 --> 00:35:51,852 line:-2
where the assumptions the developer made
are no longer correct.


670
00:35:53,620 --> 00:35:57,624 line:-2
In this case, if an attacker passes
a zero-length string for "name"


671
00:35:57,691 --> 00:36:00,127 line:-1
and 80 million hex for nameCount,


672
00:36:00,194 --> 00:36:03,330 line:-2
the integer will overflow
and the "if" statement will fail.


673
00:36:04,998 --> 00:36:08,302 line:-2
This will result in a very large read
off the end of "name,"


674
00:36:08,368 --> 00:36:10,337 line:-1
potentially disclosing user data.


675
00:36:10,737 --> 00:36:14,341 line:-2
The fix is to add
a comprehensive validation check,


676
00:36:14,408 --> 00:36:16,643 line:-1
checking the type and the length.


677
00:36:17,344 --> 00:36:19,246 line:-1
But most importantly,


678
00:36:19,313 --> 00:36:22,749 line:-2
use of the os_overflow method
to perform the arithmetic.


679
00:36:23,784 --> 00:36:26,854 line:-1
In this case, we've used os_mul_overflow.


680
00:36:26,920 --> 00:36:29,256 line:-1
For those which don't know about them,


681
00:36:29,323 --> 00:36:32,226 line:-2
os_overflow
is a really useful set of functions


682
00:36:32,292 --> 00:36:34,161 line:-1
which allow safe handling of numbers


683
00:36:34,228 --> 00:36:37,631 line:-2
and robust detection
of under- and overflow conditions.


684
00:36:37,698 --> 00:36:38,999 line:-1
Use is simple.


685
00:36:39,066 --> 00:36:43,270 line:-2
Just replace your arithmetic operation
with the relevant os_overflow method.


686
00:36:43,337 --> 00:36:47,107 line:-2
We've provided ones for add,
subtract and multiplication,


687
00:36:47,174 --> 00:36:49,676 line:-1
using both two and three parameters.


688
00:36:50,777 --> 00:36:53,013 line:-1
On overflow, they return non-zero.


689
00:36:53,614 --> 00:36:56,116 line:-1
Using these makes it easy to ensure


690
00:36:56,183 --> 00:36:58,952 line:-2
that calculations
using attacker-controlled values


691
00:36:59,019 --> 00:37:00,921 line:-1
can be performed safely.


692
00:37:01,889 --> 00:37:03,557 line:-1
So to summarize,


693
00:37:03,624 --> 00:37:06,994 line:-2
always validate length
and consider all cases.


694
00:37:07,060 --> 00:37:10,330 line:-2
Too big, too small,
it should be just right.


695
00:37:11,498 --> 00:37:14,868 line:-2
When working with numbers,
be wary of arithmetic,


696
00:37:14,935 --> 00:37:17,504 line:-2
as if you're not using
os_overflow functions,


697
00:37:17,571 --> 00:37:19,640 line:-1
there's a high risk you'll make a mistake.


698
00:37:21,141 --> 00:37:25,746 line:-2
Finally, seriously consider using Swift
for these high-risk code paths,


699
00:37:26,547 --> 00:37:29,116 line:-2
though remember to avoid the use
of UnsafePointer


700
00:37:29,183 --> 00:37:31,585 line:-2
and other raw memory
manipulation features.


701
00:37:31,652 --> 00:37:33,120 line:-1
In closing,


702
00:37:33,187 --> 00:37:37,191 line:-2
hopefully this talk has given you
some ideas of how to think about security


703
00:37:37,257 --> 00:37:40,093 line:-2
and some examples of common pitfalls
to try and avoid.


704
00:37:40,627 --> 00:37:44,398 line:-2
Security is a huge topic, and it's hard,
because as we've seen,


705
00:37:44,464 --> 00:37:47,968 line:-2
the smallest error can be enough
to compromise your entire application.


706
00:37:49,403 --> 00:37:53,207 line:-2
But by understanding where the risk is,
designing to mitigate it


707
00:37:53,273 --> 00:37:55,909 line:-2
and taking care
when handling untrusted data,


708
00:37:55,976 --> 00:37:59,112 line:-2
we can massively reduce the chances
of things going wrong.


709
00:37:59,179 --> 00:38:00,280 line:-1
Thanks for coming.

