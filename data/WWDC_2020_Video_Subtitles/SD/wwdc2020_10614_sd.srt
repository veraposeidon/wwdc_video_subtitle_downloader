1
00:00:03,836 --> 00:00:07,007 line:-1
Hello and welcome to WWDC.


2
00:00:09,243 --> 00:00:11,512 line:0
Hello. My name is James Kelly,


3
00:00:11,578 --> 00:00:14,848 line:0
and I'm a member of the Game Technologies
engineering team at Apple.


4
00:00:14,915 --> 00:00:17,951 line:-2
In this video, we'll be talking
about new game controller features


5
00:00:18,018 --> 00:00:20,487 line:-2
and changes coming
to our platforms this year,


6
00:00:20,554 --> 00:00:23,657 line:-2
and we'll give some advice on how
you can best adopt these new changes.


7
00:00:23,724 --> 00:00:26,226 line:-2
As a reminder,
the Game Controller framework


8
00:00:26,293 --> 00:00:28,762 line:-2
has a goal
to make it easy to add support for MFi


9
00:00:28,829 --> 00:00:33,667 line:-2
and select third-party game controllers
to your games on iOS, tvOS and macOS.


10
00:00:34,401 --> 00:00:37,271 line:-2
By abstracting controller hardware
through a common API,


11
00:00:37,337 --> 00:00:39,907 line:-2
the Game Controller framework
lets you write your code once


12
00:00:39,973 --> 00:00:43,177 line:-2
without you having to worry
about how that controller data is mapped.


13
00:00:43,243 --> 00:00:46,847 line:-2
This year, we're making sure
you can take advantage of and customize


14
00:00:46,914 --> 00:00:52,653 line:-2
the great features of game controllers
like haptics and rumble, motion, lights,


15
00:00:52,719 --> 00:00:55,856 line:-2
as well as unique inputs
like touch pads and paddles.


16
00:00:56,823 --> 00:01:00,027 line:-2
We'll also show how users
can remap their controllers globally


17
00:01:00,093 --> 00:01:03,363 line:-2
or tune it to their game
to get just the configuration they want.


18
00:01:03,430 --> 00:01:05,899 line:-2
Before we start,
we're excited to announce some additions


19
00:01:05,966 --> 00:01:07,835 line:-2
to our supported lineup
of great controllers.


20
00:01:07,901 --> 00:01:12,406 line:-2
First up, we've added support for the Xbox
Elite Wireless Controller Series 2.


21
00:01:12,472 --> 00:01:15,843 line:-2
It's got a really great feel, and it's
been highly requested by our users.


22
00:01:16,877 --> 00:01:20,814 line:-2
We're also really excited to announce
support for the Xbox Adaptive Controller.


23
00:01:20,881 --> 00:01:25,652 line:-2
This unique, extensible controller helps
to make gaming more accessible for all.


24
00:01:25,719 --> 00:01:28,755 line:-2
Developers are creating some great games
with controller support.


25
00:01:28,822 --> 00:01:32,726 line:0
Oceanhorn 2, Sonic Racing, Spyder
and LEGO Brawls


26
00:01:32,793 --> 00:01:35,195 line:-2
are some excellent examples
on Apple Arcade


27
00:01:35,262 --> 00:01:38,565 line:-2
and just a few of the games on
the App Store that support controllers.


28
00:01:38,632 --> 00:01:40,534 line:-1
By using the Game Controller framework,


29
00:01:40,601 --> 00:01:43,704 line:-2
these games automatically support
newly added controllers


30
00:01:43,770 --> 00:01:45,639 line:-1
like the Xbox Adaptive Controller


31
00:01:45,706 --> 00:01:48,609 line:-2
or the Xbox Elite Wireless Controller
Series 2.


32
00:01:49,676 --> 00:01:53,113 line:-2
Let's talk about changes coming to
the Game Controller framework this year


33
00:01:53,180 --> 00:01:55,415 line:-1
in support of these new controllers.


34
00:01:55,916 --> 00:01:58,886 line:-2
Let's start by talking
about how you can access the buttons


35
00:01:58,952 --> 00:02:00,721 line:-1
of these new controllers.


36
00:02:00,787 --> 00:02:03,690 line:-2
There's a new way
to access controller input this year,


37
00:02:03,757 --> 00:02:05,792 line:-1
GCPhysicalInputProfile,


38
00:02:05,859 --> 00:02:09,763 line:-2
which represents the collection of all
physical inputs available on a controller,


39
00:02:09,830 --> 00:02:13,500 line:-2
meaning its buttons, triggers, Dpads,
thumbsticks and so on.


40
00:02:14,034 --> 00:02:17,037 line:-2
We're calling this
the new extensible input API


41
00:02:17,104 --> 00:02:19,673 line:-2
as it allows your game
to dynamically query and support


42
00:02:19,740 --> 00:02:21,842 line:-1
all of a controller's inputs at runtime,


43
00:02:21,909 --> 00:02:24,978 line:-2
even nonstandard inputs,
like the DUALSHOCK 4's touch pad


44
00:02:25,045 --> 00:02:27,314 line:-2
or the Xbox Elite controller's
paddle buttons.


45
00:02:28,048 --> 00:02:31,151 line:-2
Every controller
now has a physical input profile.


46
00:02:31,218 --> 00:02:34,888 line:0
So, GCExtendedGamepad
and GCMicroGamepad


47
00:02:34,955 --> 00:02:38,559 line:0
have both been made subclasses
of this GCPhysicalInputProfile.


48
00:02:39,459 --> 00:02:42,095 line:0
You're encouraged to still check
for the presence of profiles


49
00:02:42,162 --> 00:02:43,830 line:0
like GCExtendedGamepad


50
00:02:43,897 --> 00:02:47,100 line:0
to filter out controllers
that don't have the buttons you need.


51
00:02:47,167 --> 00:02:49,169 line:0
You can then use
the physical input profile


52
00:02:49,236 --> 00:02:52,940 line:0
to access the controller's unique buttons,
like the DUALSHOCK 4's touch pad.


53
00:02:53,907 --> 00:02:57,744 line:-2
Let's take a look at a coding sample
to get a sense of these changes.


54
00:02:57,811 --> 00:02:59,713 line:-2
Let's say we want to add
some special shortcuts


55
00:02:59,780 --> 00:03:01,648 line:-1
for controllers with extra buttons.


56
00:03:02,516 --> 00:03:06,019 line:-2
First, we'll add an action that can
instantly trigger an attack combo


57
00:03:06,086 --> 00:03:08,956 line:-2
which would normally require
a combination of button presses.


58
00:03:09,823 --> 00:03:12,025 line:-2
We'll also track the buttons
on the controller


59
00:03:12,092 --> 00:03:14,461 line:-2
that we have
and have not mapped to actions.


60
00:03:15,662 --> 00:03:17,764 line:-2
Now let's look
at setupConnectedController


61
00:03:17,831 --> 00:03:20,133 line:-1
that is called when a controller connects.


62
00:03:20,200 --> 00:03:23,570 line:-2
We grab a reference to the physical
input profile on the controller.


63
00:03:23,637 --> 00:03:26,373 line:-2
Remember that every controller
will have this profile.


64
00:03:26,940 --> 00:03:29,610 line:-2
We have a helper function,
setupBasicControls,


65
00:03:29,676 --> 00:03:32,546 line:-2
that will set up all the standard controls
for the face buttons,


66
00:03:32,613 --> 00:03:35,315 line:-2
the left and right thumbsticks,
the Dpad, etcetera,


67
00:03:35,382 --> 00:03:37,684 line:-1
and it will also update mapped buttons.


68
00:03:38,552 --> 00:03:42,322 line:-2
Using that physical input profile,
we can then easily grab a reference


69
00:03:42,389 --> 00:03:46,527 line:-2
to a paddle button, if one exists,
and update our mappedButtons set.


70
00:03:47,461 --> 00:03:52,065 line:-2
Finally, we can look at all of the buttons
available on the physical input profile


71
00:03:52,132 --> 00:03:54,835 line:-2
and filter out any buttons
that have already been mapped.


72
00:03:54,902 --> 00:03:59,206 line:-2
We can use this to populate an in-game
mapping UI with a list of unused buttons.


73
00:04:01,241 --> 00:04:05,412 line:0
So, for ease of use, we've added two new
subclasses to the GCExtendedGamepad,


74
00:04:06,413 --> 00:04:10,150 line:0
GCDualShockGamepad,
and GCXboxGamepad.


75
00:04:11,084 --> 00:04:15,055 line:0
The DualShockGamepad exposes the touch
pad surface with two-finger tracking


76
00:04:15,122 --> 00:04:17,156 line:0
as well as the touch pad's button.


77
00:04:17,224 --> 00:04:19,927 line:0
The XboxGamepad
exposes the four paddle buttons


78
00:04:19,993 --> 00:04:22,296 line:0
of the Xbox Elite Wireless Controller.


79
00:04:22,996 --> 00:04:27,301 line:-2
Use extra buttons to augment your games
with additional convenience controls,


80
00:04:27,367 --> 00:04:30,671 line:-2
but avoid requiring these buttons
as other controllers don't have them.


81
00:04:31,805 --> 00:04:33,707 line:0
One quick note about the paddle buttons


82
00:04:33,774 --> 00:04:36,810 line:0
on the Xbox Elite
Wireless Controller Series 2.


83
00:04:36,877 --> 00:04:39,079 line:0
The controller supports
hardware button remapping


84
00:04:39,146 --> 00:04:42,516 line:0
which can be configured and then stored
in one of three profiles.


85
00:04:43,250 --> 00:04:47,354 line:0
The selected profile is indicated by the
three LEDs on the front of the controller.


86
00:04:48,088 --> 00:04:51,658 line:0
And due to how the controller sends data,
the paddle buttons will only work


87
00:04:51,725 --> 00:04:55,062 line:0
when the controller does not have
a button mapping profile selected,


88
00:04:55,128 --> 00:04:57,631 line:0
meaning that the three LEDs are unlit.


89
00:04:57,698 --> 00:04:59,199 line:-1
[vibrating]


90
00:04:59,266 --> 00:05:01,535 line:-2
Up next,
let's talk about haptics and rumble,


91
00:05:01,602 --> 00:05:04,137 line:-2
one of the most exciting additions
to the API this year.


92
00:05:05,806 --> 00:05:08,876 line:-2
Games coordinate visuals, sounds
and haptics from the controller


93
00:05:08,942 --> 00:05:10,377 line:-1
to more deeply immerse the player.


94
00:05:10,444 --> 00:05:14,648 line:-2
Great haptics can help give a sense
that your car is driving over gravel,


95
00:05:14,715 --> 00:05:16,750 line:-2
that your character
is walking through sand,


96
00:05:16,817 --> 00:05:19,052 line:-2
that you feel a recoil
in your trigger finger,


97
00:05:19,119 --> 00:05:21,989 line:-2
or even that a nearby explosion
is shaking your room.


98
00:05:22,689 --> 00:05:25,559 line:-2
Many of our supported controllers
can provide haptic feedback,


99
00:05:25,626 --> 00:05:29,062 line:-2
including the DUALSHOCK 4,
the Xbox Wireless Controller


100
00:05:29,129 --> 00:05:33,166 line:-2
and the Xbox Elite Wireless Controller,
and that feedback is programmable,


101
00:05:33,233 --> 00:05:34,902 line:-1
meaning that you have fine-grained control


102
00:05:34,968 --> 00:05:37,437 line:-2
over the low-level haptic feeling
that is played.


103
00:05:38,071 --> 00:05:41,308 line:-2
These controllers all use
different hardware for generating haptics.


104
00:05:41,375 --> 00:05:45,012 line:-2
So, let's talk about how you can
easily add haptic feedback to your game


105
00:05:45,078 --> 00:05:47,915 line:-2
without having to worry about
the physical details of each controller.


106
00:05:48,815 --> 00:05:52,052 line:-2
This year we're happy to add
Game Controller support to Core Haptics


107
00:05:52,119 --> 00:05:54,521 line:-2
on top of the existing
phone haptic support.


108
00:05:54,588 --> 00:05:58,659 line:-2
Core Haptics is a powerful API that allows
you to compose and play haptic patterns


109
00:05:58,725 --> 00:06:00,827 line:-1
to customize your app's haptic feedback.


110
00:06:01,395 --> 00:06:04,097 line:-2
In Core Haptics,
you can craft custom haptic patterns


111
00:06:04,164 --> 00:06:06,400 line:-2
from basic building blocks
called haptic events.


112
00:06:06,934 --> 00:06:09,102 line:-2
These patterns
can be created programmatically


113
00:06:09,169 --> 00:06:12,506 line:-2
or stored in Apple Haptic
and Audio Pattern-- or AHAP files.


114
00:06:13,707 --> 00:06:15,509 line:-1
After designing your haptic patterns,


115
00:06:15,576 --> 00:06:18,312 line:-2
you simply create pattern players
from a haptic engine


116
00:06:18,378 --> 00:06:19,880 line:-1
to play your haptic content.


117
00:06:20,948 --> 00:06:24,318 line:-2
Core Haptics and AHAP allows you to design
your haptic content once


118
00:06:24,384 --> 00:06:25,886 line:-1
and then play it everywhere,


119
00:06:25,953 --> 00:06:30,457 line:-2
be it a phone, a DUALSHOCK 4
or any one of our other supported devices.


120
00:06:30,991 --> 00:06:33,827 line:0
For more information on the details
of the Core Haptics framework,


121
00:06:33,894 --> 00:06:37,097 line:0
including some excellent examples
on how to design AHAP content,


122
00:06:37,164 --> 00:06:41,401 line:0
please watch "Introducing Core Haptics"
from WWDC 2019.


123
00:06:42,369 --> 00:06:44,805 line:-1
Let's look at a simple practical example.


124
00:06:44,872 --> 00:06:47,641 line:-2
Haptic feedback is a great way
to immerse players in a game


125
00:06:47,708 --> 00:06:50,077 line:-2
and let them really feel the impact
of their gameplay.


126
00:06:51,078 --> 00:06:54,047 line:-2
Let's say we have a player and an enemy
in an action game.


127
00:06:54,715 --> 00:06:56,283 line:-1
When the enemy attacks the player,


128
00:06:56,350 --> 00:06:59,386 line:-2
they're dealt damage
and the controller rumbles.


129
00:06:59,453 --> 00:07:01,355 line:-1
How do we achieve this in our game


130
00:07:01,421 --> 00:07:04,291 line:-2
using the Game Controller
and Core Haptics frameworks?


131
00:07:04,358 --> 00:07:07,261 line:-2
First, we need to design
our haptic content.


132
00:07:07,794 --> 00:07:11,765 line:-2
Here we've programmatically created
a haptic pattern called "enemy strike"


133
00:07:11,832 --> 00:07:14,134 line:-1
that will play when an enemy attacks.


134
00:07:14,201 --> 00:07:17,237 line:-2
We can then feed this data
into a CHHapticPattern.


135
00:07:18,105 --> 00:07:21,475 line:-2
Once we have our haptic content designed
and loaded into a pattern,


136
00:07:21,542 --> 00:07:23,210 line:-1
we can get ready to play it.


137
00:07:23,277 --> 00:07:25,312 line:-1
But how do we play it on a controller?


138
00:07:25,379 --> 00:07:27,781 line:-1
First, we need a GCController instance,


139
00:07:27,848 --> 00:07:30,884 line:-2
here representing the Xbox
Elite Controller shown on the right.


140
00:07:31,785 --> 00:07:34,021 line:-1
Next, we can create a CHHapticEngine


141
00:07:34,087 --> 00:07:38,091 line:-2
that targets the locations on a controller
that we'd like to play haptics on.


142
00:07:38,158 --> 00:07:39,893 line:-1
A haptic engine is just an object


143
00:07:39,960 --> 00:07:42,930 line:-2
that manages your apps' requests
to play haptic patterns.


144
00:07:43,564 --> 00:07:46,600 line:-2
Finally, we can create
a CHHapticPatternPlayer


145
00:07:46,667 --> 00:07:48,468 line:-1
from our engine and our pattern.


146
00:07:49,970 --> 00:07:51,972 line:0
Once we call start on this pattern player,


147
00:07:52,039 --> 00:07:54,007 line:0
our AHAP content
will play on our controller.


148
00:07:54,074 --> 00:07:55,709 line:0
In this case, just the handles.


149
00:07:57,044 --> 00:07:59,513 line:-1
You can even layer these pattern players.


150
00:07:59,580 --> 00:08:01,548 line:-2
The system
will automatically combine the haptics


151
00:08:01,615 --> 00:08:04,084 line:-2
from all active patterns for you
at runtime


152
00:08:04,151 --> 00:08:06,386 line:-2
allowing you to create
some really dynamic effects.


153
00:08:08,355 --> 00:08:10,557 line:0
So, how do you create a haptic engine?


154
00:08:10,624 --> 00:08:13,994 line:0
Simply call createEngineWithLocality
on a controller instance


155
00:08:14,061 --> 00:08:16,763 line:0
then pass in a GCHapticLocality.


156
00:08:16,830 --> 00:08:19,933 line:0
This locality defines
the physical locations on the controller


157
00:08:20,000 --> 00:08:21,535 line:0
that the haptic engine will target.


158
00:08:22,769 --> 00:08:25,472 line:0
The default haptic locality
is geared towards providing


159
00:08:25,539 --> 00:08:28,208 line:0
a haptic experience
that your users would expect.


160
00:08:28,275 --> 00:08:29,710 line:0
For example, on game controllers,


161
00:08:29,776 --> 00:08:32,412 line:0
the default locality
typically targets the handles.


162
00:08:33,480 --> 00:08:35,549 line:0
You can get more specific if you'd like.


163
00:08:35,616 --> 00:08:38,217 line:0
Here we're targeting
just the left impulse trigger.


164
00:08:38,885 --> 00:08:42,188 line:0
So, how do we put all this together?
Let's look at a code example.


165
00:08:43,190 --> 00:08:46,393 line:-2
We begin by creating an instance
of a CHHapticEngine,


166
00:08:46,460 --> 00:08:49,062 line:-2
one that targets the handles
of the active controller.


167
00:08:49,630 --> 00:08:52,933 line:-2
The engine is assigned to our member
variable so we can keep it around.


168
00:08:53,700 --> 00:08:55,569 line:-1
After creating the haptic engine,


169
00:08:55,636 --> 00:08:58,572 line:-2
we'll need to start it
and check for possible errors.


170
00:08:58,639 --> 00:09:00,007 line:-1
The engine will continue to run


171
00:09:00,073 --> 00:09:03,377 line:-2
until the application
or possible outside action stops it.


172
00:09:04,444 --> 00:09:06,213 line:-1
So, let's play some haptics.


173
00:09:06,280 --> 00:09:10,284 line:-2
Here's the function that executes when
the player is dealt damage by an enemy.


174
00:09:10,350 --> 00:09:13,053 line:-2
In this example,
you want to generate a haptic pattern


175
00:09:13,120 --> 00:09:15,656 line:-2
that scales with the amount of damage
that was dealt.


176
00:09:16,924 --> 00:09:19,526 line:-2
So, we have to create the pattern player
and its pattern


177
00:09:19,593 --> 00:09:22,296 line:-2
at the moment they're needed
to account for this damage.


178
00:09:23,697 --> 00:09:25,699 line:-1
Once the pattern player is created,


179
00:09:25,766 --> 00:09:28,669 line:-2
we start it
at time CHHapticTimeImmediate,


180
00:09:28,735 --> 00:09:31,538 line:-2
which indicates that we want to play it
with minimal latency.


181
00:09:32,172 --> 00:09:35,175 line:-2
If you had two separate haptic players
that you wanted to synchronize,


182
00:09:35,242 --> 00:09:37,477 line:-2
you would need to specify
an actual time here.


183
00:09:38,846 --> 00:09:42,082 line:-2
Notice that the app does not hold on
to the instance of the player.


184
00:09:42,149 --> 00:09:45,586 line:-2
Its pattern is guaranteed
to continue playing until it's finished,


185
00:09:45,652 --> 00:09:47,688 line:-1
so we can simply fire and forget it.


186
00:09:49,656 --> 00:09:52,059 line:-1
Let's look at creating a pattern player.


187
00:09:52,125 --> 00:09:55,362 line:-2
This method is responsible
for creating the custom haptic content


188
00:09:55,429 --> 00:09:57,231 line:-1
that will play when we take damage.


189
00:09:58,198 --> 00:10:02,636 line:-2
We'll create a continuous haptic event
that applies over a specified duration.


190
00:10:03,337 --> 00:10:05,572 line:-1
We'll give it a sharpness and intensity.


191
00:10:05,639 --> 00:10:08,141 line:-2
This will provide a nice baseline
of haptic feedback


192
00:10:08,208 --> 00:10:10,744 line:-2
regardless of how much damage
was done to the player.


193
00:10:11,445 --> 00:10:13,981 line:-1
Next, we create a transient haptic event.


194
00:10:14,047 --> 00:10:17,117 line:-2
These are brief impulses
that occur at a specific point in time,


195
00:10:17,184 --> 00:10:19,586 line:-2
such as the click you would feel
from toggling a switch.


196
00:10:20,787 --> 00:10:24,291 line:-2
Note that the transient events
don't have a specified duration.


197
00:10:24,358 --> 00:10:27,127 line:-2
They're just the shortest haptic event
that you can produce,


198
00:10:27,194 --> 00:10:30,931 line:-2
so the actual time a transient takes
will vary from controller to controller.


199
00:10:31,832 --> 00:10:34,468 line:-1
Again, we set the sharpness and intensity.


200
00:10:34,535 --> 00:10:36,203 line:-1
This time, we scale the intensity


201
00:10:36,270 --> 00:10:38,605 line:-2
by the amount of damage
that was dealt to the player.


202
00:10:39,907 --> 00:10:42,876 line:-2
Next, we create the pattern
containing these two events.


203
00:10:44,178 --> 00:10:47,781 line:0
Finally, we create the pattern player
from this pattern and return it.


204
00:10:48,549 --> 00:10:50,784 line:-1
Okay. So, now that you saw how easy it was


205
00:10:50,851 --> 00:10:53,153 line:-2
to generate haptic content
in Core Haptics,


206
00:10:53,220 --> 00:10:55,989 line:-2
let's talk about how you can transition
your existing rumble code


207
00:10:56,056 --> 00:10:57,524 line:-1
from other platforms.


208
00:10:58,091 --> 00:11:01,995 line:-2
In many existing games, haptics are tied
directly to the update loop.


209
00:11:02,062 --> 00:11:05,566 line:-2
This typically means that, every update,
the engine will set the intensity


210
00:11:05,632 --> 00:11:08,635 line:-2
of each physical actuator
on a game controller directly.


211
00:11:09,536 --> 00:11:13,373 line:-2
With this approach, the engine combines
different haptic effects each frame.


212
00:11:13,874 --> 00:11:15,709 line:-2
Let's talk
about how you can migrate a game


213
00:11:15,776 --> 00:11:18,111 line:-2
that uses this architecture
to Core Haptics.


214
00:11:19,913 --> 00:11:24,218 line:-2
Our goal is to update the intensities
of the controller's motors each frame.


215
00:11:24,284 --> 00:11:26,553 line:-2
To achieve this,
we'll need to create a pattern player


216
00:11:26,620 --> 00:11:28,422 line:-1
so we can send changes to it.


217
00:11:28,488 --> 00:11:30,157 line:-2
And then we'll create
a long-running pattern


218
00:11:30,224 --> 00:11:32,526 line:-2
with an initial haptic intensity
set to one.


219
00:11:33,827 --> 00:11:36,964 line:-2
In our update loop, we'll just change
the intensity of the motors.


220
00:11:38,165 --> 00:11:40,067 line:-1
To do this, we create a dynamic parameter


221
00:11:40,133 --> 00:11:43,003 line:-2
with a haptic intensity
we calculated for a given motor,


222
00:11:43,070 --> 00:11:44,905 line:-1
and then we send it to the pattern player.


223
00:11:45,772 --> 00:11:47,307 line:0
We can do this each frame.


224
00:11:47,374 --> 00:11:49,209 line:0
And as long as our updates
are fast enough,


225
00:11:49,276 --> 00:11:52,279 line:0
the user will feel a continuous change
in the haptic intensity.


226
00:11:53,347 --> 00:11:56,016 line:0
Let's take a quick look
at how we can achieve this in code.


227
00:11:57,551 --> 00:11:59,553 line:-2
Here, we're setting up
all the pieces you need


228
00:11:59,620 --> 00:12:02,456 line:-2
to be able to update your controller's
motors in your update loop.


229
00:12:03,090 --> 00:12:04,525 line:-1
We're setting up our pattern player,


230
00:12:04,591 --> 00:12:07,427 line:-2
which will later send new intensities
to each update.


231
00:12:09,029 --> 00:12:12,666 line:-2
In this function, we'll create
a long-running, continuous haptic event


232
00:12:12,733 --> 00:12:15,636 line:-2
with a haptic intensity
set to the max value of one.


233
00:12:16,436 --> 00:12:19,306 line:-2
We'll use the continuous event
to create a haptic pattern.


234
00:12:19,773 --> 00:12:23,477 line:-2
And finally, we'll create our pattern
player and start it immediately.


235
00:12:23,911 --> 00:12:26,713 line:-2
You'll need to hold onto this
as you'll be using it later.


236
00:12:27,681 --> 00:12:31,218 line:-2
Now, in our update loop,
we're also going to update our haptics.


237
00:12:32,085 --> 00:12:34,555 line:-2
This is where we update
the intensity of our motors.


238
00:12:35,189 --> 00:12:38,392 line:-2
We create a dynamic parameter
targeting haptic intensity.


239
00:12:39,693 --> 00:12:42,262 line:-2
These are similar to the parameters
used to generate events,


240
00:12:42,329 --> 00:12:45,499 line:-2
except these could be applied dynamically
to an already running pattern,


241
00:12:46,066 --> 00:12:49,002 line:-2
and they apply to the entire pattern,
not just the single event.


242
00:12:50,170 --> 00:12:52,239 line:-1
Here, hapticEngineMotorIntensity


243
00:12:52,306 --> 00:12:55,242 line:-2
represents the intensity of the motor
from zero to one


244
00:12:55,309 --> 00:12:57,544 line:-2
as calculated by the engine
for this frame.


245
00:12:58,111 --> 00:13:01,215 line:-2
This will act as a multiplier
on the pattern player's intensity.


246
00:13:02,549 --> 00:13:05,152 line:-2
We finish up by sending
our dynamic intensity parameter


247
00:13:05,219 --> 00:13:06,486 line:-1
to our pattern player.


248
00:13:07,621 --> 00:13:10,891 line:-2
Please note that this example only covers
one CHHapticEngine.


249
00:13:11,491 --> 00:13:13,794 line:-2
You will need to repeat
this approach for each motor


250
00:13:13,861 --> 00:13:16,663 line:-2
if you would like to control them
independently from one another.


251
00:13:18,165 --> 00:13:20,634 line:-2
Next up, let's talk about
some other features that we've added


252
00:13:20,701 --> 00:13:22,503 line:-1
to the Game Controller framework this year


253
00:13:22,569 --> 00:13:24,938 line:-2
that will help you fully utilize
the extended capabilities


254
00:13:25,005 --> 00:13:26,440 line:-1
of newly supported controllers.


255
00:13:27,841 --> 00:13:30,511 line:-2
Let’s start by looking at a situation
that single player games


256
00:13:30,577 --> 00:13:32,212 line:-1
frequently need to handle.


257
00:13:32,279 --> 00:13:35,148 line:-2
Your game launches, and you see
multiple controllers connected.


258
00:13:35,582 --> 00:13:37,284 line:-1
Particularly with the Apple TV,


259
00:13:37,351 --> 00:13:39,920 line:-2
it’s common to see the Siri Remote
and a game controller,


260
00:13:40,454 --> 00:13:42,256 line:-1
but which one should you take input from?


261
00:13:42,856 --> 00:13:45,726 line:-2
How do you know which controller
is currently being used by the player?


262
00:13:46,059 --> 00:13:49,229 line:0
You could register your controller
connection and disconnection handlers


263
00:13:49,296 --> 00:13:51,265 line:0
and manage the life cycles
of the controllers.


264
00:13:52,032 --> 00:13:54,601 line:0
But you still need to track
when a controller becomes active


265
00:13:54,668 --> 00:13:56,436 line:0
to update the UI and controls


266
00:13:56,503 --> 00:13:59,239 line:0
as the user switches
between input devices.


267
00:13:59,640 --> 00:14:02,910 line:-2
This is why we are introducing
some new API to handle this for you.


268
00:14:03,410 --> 00:14:05,946 line:-2
We've added the current property
to GCController,


269
00:14:06,013 --> 00:14:08,415 line:-2
which always returns
the most recently used controller


270
00:14:08,482 --> 00:14:10,617 line:-1
or nil if no controller is connected.


271
00:14:11,652 --> 00:14:14,288 line:-2
We've also added
two new notifications that you can observe


272
00:14:14,354 --> 00:14:17,057 line:-2
to properly respond
to the current controller changing,


273
00:14:17,124 --> 00:14:19,226 line:-1
GCControllerDidBecomeCurrent


274
00:14:19,293 --> 00:14:21,628 line:-1
and GCControllerDidStopBeingCurrent.


275
00:14:22,796 --> 00:14:25,899 line:-2
Single player games should adapt
to the currently active game controller


276
00:14:25,966 --> 00:14:27,234 line:-1
by using this property.


277
00:14:27,935 --> 00:14:29,536 line:-1
By listening to the notifications,


278
00:14:29,603 --> 00:14:32,940 line:-2
you can easily adapt your UI
to reflect the currently used controller.


279
00:14:34,508 --> 00:14:37,744 line:-2
Next, let's talk about the motion sensors
on the DualShock 4.


280
00:14:38,445 --> 00:14:40,447 line:-1
The DualShock 4 has a gyroscope,


281
00:14:40,514 --> 00:14:43,083 line:-2
meaning that it knows
its rotation rate and 3D space,


282
00:14:43,150 --> 00:14:45,452 line:-2
allowing for some great
game play possibilities.


283
00:14:46,887 --> 00:14:49,056 line:-2
One common technique
is to use the gyroscope


284
00:14:49,122 --> 00:14:50,924 line:-1
for fine-tuned camera aiming,


285
00:14:50,991 --> 00:14:53,093 line:-2
with the thumbsticks used
for more coarse aiming.


286
00:14:54,361 --> 00:14:56,496 line:-1
The DualShock 4 also has an accelerometer.


287
00:14:57,097 --> 00:14:59,032 line:-2
There are many ways
to use the accelerometer.


288
00:14:59,099 --> 00:15:01,435 line:-2
For example, you can detect
whether the controller is tilted


289
00:15:01,502 --> 00:15:04,238 line:-2
to the left or the right
for driving controls in a racing game


290
00:15:04,705 --> 00:15:08,909 line:-2
or you can interpret high, rapid shifts
in acceleration as a shake gesture


291
00:15:08,976 --> 00:15:10,644 line:-1
to make your player character attack.


292
00:15:12,079 --> 00:15:14,781 line:-2
We've introduced support
for the DualShock 4's motion sensors


293
00:15:14,848 --> 00:15:17,618 line:-1
via GCMotion, a property on GCController.


294
00:15:18,385 --> 00:15:21,688 line:-2
For those of you familiar with supporting
the Siri Remote on tvOS,


295
00:15:21,755 --> 00:15:24,324 line:-2
we're using the same API here,
but with a few tweaks.


296
00:15:25,526 --> 00:15:27,027 line:-1
When supporting the DualShock 4,


297
00:15:27,094 --> 00:15:29,963 line:-2
you need to manually
turn the motion sensors on and off


298
00:15:30,030 --> 00:15:31,031 line:-1
to preserve battery.


299
00:15:31,632 --> 00:15:34,501 line:-2
You can query whether you need
to manage the sensors yourself


300
00:15:34,568 --> 00:15:37,137 line:-2
or leave it up to the system,
like with the Siri Remote.


301
00:15:37,771 --> 00:15:41,742 line:-2
Set motion.sensorsActive
to toggle motion sensors on and off.


302
00:15:43,177 --> 00:15:45,946 line:0
Additionally, some controllers,
like the DualShock 4,


303
00:15:46,013 --> 00:15:48,582 line:0
do not separate gravity
from user acceleration


304
00:15:48,649 --> 00:15:51,418 line:0
and only report
the total acceleration of the controller.


305
00:15:52,219 --> 00:15:55,189 line:0
Query whether the connected controller
has the ability to separate


306
00:15:55,255 --> 00:15:57,024 line:0
gravity from user acceleration


307
00:15:57,090 --> 00:16:00,027 line:0
and if it doesn't,
use the total acceleration instead.


308
00:16:01,795 --> 00:16:04,932 line:-2
The next feature I wanna tell you about
is the DualShock 4's light bar.


309
00:16:05,766 --> 00:16:09,603 line:-2
It's usually used as a player indicator,
but you can also use it for game effects.


310
00:16:10,270 --> 00:16:12,372 line:-2
For example, it could flash
a different color


311
00:16:12,439 --> 00:16:14,041 line:-1
when the player walks into lava


312
00:16:14,107 --> 00:16:17,711 line:-2
or shine green, then yellow, then red
as the player loses health.


313
00:16:19,112 --> 00:16:21,448 line:-2
We've surfaced support
for the DualShock 4's light bar


314
00:16:21,515 --> 00:16:24,852 line:-2
via GCDeviceLight,
a property on GCController.


315
00:16:25,419 --> 00:16:28,355 line:-2
It's easy to change the color
of a DualShock 4 light bar,


316
00:16:28,422 --> 00:16:30,591 line:-1
just set the GCDeviceLight color value.


317
00:16:31,058 --> 00:16:32,893 line:-1
Here, we are setting the color to red.


318
00:16:33,994 --> 00:16:37,030 line:-2
Nowadays, many controllers are wireless
and may need charging.


319
00:16:37,397 --> 00:16:39,666 line:-2
We're making battery state
available to you


320
00:16:39,733 --> 00:16:41,268 line:-1
so that you can show it in your UI,


321
00:16:41,335 --> 00:16:43,604 line:-1
particularly in low-battery situations.


322
00:16:44,404 --> 00:16:48,509 line:-2
This is provided via GCDeviceBattery,
a property on GCController.


323
00:16:49,142 --> 00:16:52,412 line:-2
You can check the level of the battery,
as well as its charging state,


324
00:16:52,479 --> 00:16:55,048 line:-2
whether it's charging,
discharging or fully charged.


325
00:16:55,749 --> 00:16:58,385 line:-2
You can then use
Key-Value Observing, or KVO,


326
00:16:58,452 --> 00:17:00,587 line:-1
to monitor any changes to the battery.


327
00:17:01,655 --> 00:17:04,191 line:-2
Now, I'd like to introduce
my colleague, Hannah Gillis,


328
00:17:04,258 --> 00:17:06,159 line:-2
who will give some tips
on how to take advantage


329
00:17:06,226 --> 00:17:07,994 line:-1
of our new input remapping feature.


330
00:17:09,963 --> 00:17:11,231 line:0
Thanks, James.


331
00:17:11,298 --> 00:17:15,301 line:0
Let's talk about how you can indicate
that your app supports game controllers


332
00:17:15,368 --> 00:17:17,804 line:0
and the benefits that come along
when you do so.


333
00:17:18,605 --> 00:17:21,375 line:-2
There are a few reasons
to indicate controller support.


334
00:17:22,342 --> 00:17:26,113 line:-2
First, it surfaces information
on the App Store


335
00:17:26,180 --> 00:17:28,849 line:-1
and on Apple TV to communicate to users


336
00:17:28,916 --> 00:17:31,552 line:-2
when a controller is required
for an application.


337
00:17:32,819 --> 00:17:35,956 line:-2
A game controller badge
will be listed on the apps product page


338
00:17:36,023 --> 00:17:37,991 line:-1
to visually declare this info.


339
00:17:38,892 --> 00:17:41,161 line:-1
Second, indicating controller support


340
00:17:41,228 --> 00:17:44,398 line:-2
provides the ability
for input remapping in your application,


341
00:17:44,932 --> 00:17:46,567 line:-1
which I'll discuss shortly.


342
00:17:47,067 --> 00:17:48,836 line:-1
For these reasons, we highly recommend


343
00:17:48,902 --> 00:17:51,772 line:-2
you update your apps
for the best user experience.


344
00:17:53,473 --> 00:17:55,442 line:-1
To indicate controller support,


345
00:17:55,509 --> 00:17:59,079 line:-2
you should enable
the Game Controllers capability in Xcode.


346
00:18:00,147 --> 00:18:04,618 line:-2
This informs the system that your app
uses Game Controller features.


347
00:18:04,685 --> 00:18:08,789 line:-2
Once enabled, you can take advantage
of many associated benefits.


348
00:18:09,289 --> 00:18:13,393 line:-2
As mentioned, one of these benefits
is game controller input remapping.


349
00:18:14,094 --> 00:18:18,332 line:-2
And I'm excited to tell you
about this feature in both iOS and tvOS.


350
00:18:19,166 --> 00:18:22,736 line:-2
Have you ever played a game and wished
the buttons were configured differently?


351
00:18:23,470 --> 00:18:26,039 line:-2
For example, maybe you are
in an open world,


352
00:18:26,106 --> 00:18:29,743 line:-2
you have a controller in your hand
and want your character to look up.


353
00:18:29,810 --> 00:18:31,778 line:-1
What direction do you push the joystick?


354
00:18:32,246 --> 00:18:34,648 line:-1
Well, depending on your preference,


355
00:18:34,715 --> 00:18:37,150 line:-2
you might actually want
to invert the Y axis


356
00:18:37,217 --> 00:18:39,386 line:-1
if it better matches your intuition.


357
00:18:40,354 --> 00:18:42,523 line:-1
This is called input remapping


358
00:18:42,589 --> 00:18:43,857 line:-1
and it's incredibly powerful


359
00:18:43,924 --> 00:18:47,194 line:-2
for allowing users to customize
their gaming experience.


360
00:18:47,995 --> 00:18:51,398 line:-2
Additionally, it empowers
our accessibility community


361
00:18:51,465 --> 00:18:53,333 line:-1
to enjoy gaming the way they want.


362
00:18:54,067 --> 00:18:57,504 line:-1
In iOS 14 and tvOS 14,


363
00:18:57,571 --> 00:19:00,507 line:-2
we have created a method
to support input remapping


364
00:19:00,574 --> 00:19:03,544 line:-2
even if it's not built
directly into your app.


365
00:19:04,811 --> 00:19:08,148 line:-2
There are two ways you can
take advantage of input remapping.


366
00:19:08,215 --> 00:19:10,150 line:-1
The first is globally,


367
00:19:10,217 --> 00:19:12,119 line:-1
meaning any button customizations


368
00:19:12,186 --> 00:19:15,355 line:-2
will apply to all
game controller apps on your device.


369
00:19:16,256 --> 00:19:18,825 line:-1
The second is per-application.


370
00:19:18,892 --> 00:19:21,161 line:-2
It allows you to specify
different remapping


371
00:19:21,261 --> 00:19:22,930 line:-1
for an individual app.


372
00:19:23,864 --> 00:19:25,632 line:-1
Both of these options are available


373
00:19:25,699 --> 00:19:28,902 line:-2
if you've indicated
game controller support in Xcode.


374
00:19:29,636 --> 00:19:33,407 line:-2
Let's take a look at how a user
will experience input remapping.


375
00:19:33,473 --> 00:19:36,043 line:-1
In iOS 14, start by connecting


376
00:19:36,109 --> 00:19:38,712 line:-2
one of our supported game controllers
via Bluetooth.


377
00:19:39,947 --> 00:19:42,349 line:-1
Go to Settings and tap General,


378
00:19:43,183 --> 00:19:45,586 line:-1
where you will now see Game Controller.


379
00:19:46,620 --> 00:19:50,157 line:-2
Tap Game Controller to see
your currently connected device.


380
00:19:51,058 --> 00:19:53,527 line:-1
Then tap Customizations


381
00:19:53,594 --> 00:19:55,996 line:-2
to choose the button
you want to customize.


382
00:19:56,697 --> 00:20:00,200 line:-2
I want to remap the R1 button,
so I'll select that.


383
00:20:01,235 --> 00:20:03,370 line:-1
Let's remap this to the L1 button.


384
00:20:04,738 --> 00:20:06,440 line:-1
Now, if you go back,


385
00:20:06,507 --> 00:20:10,010 line:-2
you can see the R1 button
is remapped to the L1 button.


386
00:20:10,577 --> 00:20:12,746 line:-1
Remember our joystick example?


387
00:20:12,813 --> 00:20:15,115 line:-2
You can invert
the joystick axis here as well.


388
00:20:16,416 --> 00:20:18,452 line:-1
Simply click Left Stick


389
00:20:19,152 --> 00:20:21,455 line:-1
and then toggle Invert Vertically.


390
00:20:22,489 --> 00:20:25,292 line:-2
Now, let's say you want to add
custom remapping


391
00:20:25,359 --> 00:20:26,760 line:-1
for just one specific app.


392
00:20:27,227 --> 00:20:30,264 line:-1
You can do this by selecting Add App


393
00:20:30,697 --> 00:20:33,133 line:-2
and choosing one of your
game controller supported apps


394
00:20:33,200 --> 00:20:34,668 line:-1
to remap as needed.


395
00:20:35,102 --> 00:20:38,138 line:-2
These customizations will only apply
to the app you have selected


396
00:20:38,205 --> 00:20:41,141 line:-2
rather than all game controller apps
you might have.


397
00:20:42,276 --> 00:20:46,380 line:-2
We have input remapping available
in tvOS 14 as well.


398
00:20:46,446 --> 00:20:50,484 line:-2
It can be found under Settings,
Remotes and Devices, Bluetooth.


399
00:20:50,918 --> 00:20:53,253 line:-2
Then simply select
your connected controller


400
00:20:53,320 --> 00:20:54,588 line:-1
for customization.


401
00:20:56,123 --> 00:20:59,226 line:-2
So now that you know how global
and per-app input remapping


402
00:20:59,293 --> 00:21:02,796 line:-2
work for the user,
how can you adopt this in your game?


403
00:21:03,564 --> 00:21:06,266 line:-2
To support global remapping,
you simply need to use


404
00:21:06,333 --> 00:21:08,769 line:-2
the Game Controller framework
we reviewed earlier.


405
00:21:09,269 --> 00:21:11,338 line:-2
This ensures the benefit
of input remapping


406
00:21:11,405 --> 00:21:13,440 line:-1
across all apps on the device.


407
00:21:14,508 --> 00:21:16,376 line:-1
For per-application remapping,


408
00:21:16,443 --> 00:21:20,013 line:-2
you should additionally check the box
called Extended Gamepad


409
00:21:20,080 --> 00:21:22,449 line:-1
in the Game Controller section of Xcode.


410
00:21:23,383 --> 00:21:26,153 line:-2
This allows users to apply
unique customizations


411
00:21:26,220 --> 00:21:27,855 line:-1
to your app specifically.


412
00:21:28,856 --> 00:21:31,258 line:-1
If a user has applied input remapping,


413
00:21:31,325 --> 00:21:34,962 line:-2
you can make sure your in-game UI
and tutorials reflect this,


414
00:21:35,362 --> 00:21:38,799 line:-2
along with other controller scenarios
your player might encounter.


415
00:21:39,399 --> 00:21:43,070 line:-2
To enable this, we have added
game controller input glyphs


416
00:21:43,136 --> 00:21:45,739 line:-1
to SF Symbols in iOS 14.


417
00:21:46,340 --> 00:21:49,142 line:-2
You no longer need to generate
art assets on your own.


418
00:21:49,776 --> 00:21:52,312 line:-2
And Apple keeps this library
of glyphs accurate


419
00:21:52,379 --> 00:21:55,616 line:-2
for all controllers that are supported
today and in the future.


420
00:21:57,384 --> 00:21:58,952 line:-1
Like all SF Symbols,


421
00:21:59,019 --> 00:22:02,155 line:-2
you can choose different weights
for your game controller glyphs.


422
00:22:04,224 --> 00:22:06,894 line:-2
And to match the look
and feel of your game,


423
00:22:06,960 --> 00:22:09,096 line:-1
you can chose light and dark mode glyphs,


424
00:22:09,162 --> 00:22:11,832 line:-2
as well as tinted colors
to go with your design.


425
00:22:14,201 --> 00:22:17,371 line:0
To learn more, check out
"Introducing SF Symbols"


426
00:22:17,437 --> 00:22:20,107 line:0
from WWDC 2019.


427
00:22:22,109 --> 00:22:25,145 line:-2
To find the correct glyph
that matches the player's input,


428
00:22:25,212 --> 00:22:28,215 line:-2
you can look
at the SF Symbols name property


429
00:22:28,282 --> 00:22:30,417 line:-1
of the GCController element.


430
00:22:30,918 --> 00:22:33,554 line:-1
This works for the button, axis,


431
00:22:33,620 --> 00:22:36,590 line:-1
joystick, trigger or shoulder button.


432
00:22:38,692 --> 00:22:41,562 line:-2
Here, if I want to display
the corresponding glyph


433
00:22:41,628 --> 00:22:43,697 line:-1
for the classic Y button,


434
00:22:43,764 --> 00:22:45,966 line:-1
it'll return the Y in a circle glyph


435
00:22:46,033 --> 00:22:50,003 line:-2
if the input device is an MFi
or Xbox controller,


436
00:22:50,070 --> 00:22:52,406 line:-1
or the triangle in a circle glyph,


437
00:22:52,472 --> 00:22:55,008 line:-1
if the input device is a DualShock 4.


438
00:22:56,944 --> 00:23:00,914 line:-2
And, of course, we made sure
that the UI accurately reflects


439
00:23:00,981 --> 00:23:03,684 line:-2
any global or per-application
button remapping


440
00:23:03,750 --> 00:23:05,519 line:-1
your player has chosen to do.


441
00:23:07,554 --> 00:23:12,159 line:-2
For example, say the player
remaps the Y button to the X button,


442
00:23:12,226 --> 00:23:14,595 line:-2
when you reference
the Y button in your game,


443
00:23:14,661 --> 00:23:17,965 line:-2
it will display
the X in a circle glyph in the UI.


444
00:23:18,799 --> 00:23:21,735 line:-2
Your game and your UI
are easily responsive


445
00:23:21,802 --> 00:23:24,271 line:-1
to input remapping decisions like these.


446
00:23:26,139 --> 00:23:30,110 line:-2
And that wraps our section
on input remapping and UI glyphs.


447
00:23:30,177 --> 00:23:32,045 line:-1
Now, I'll pass it back to James.


448
00:23:33,113 --> 00:23:34,114 line:-1
Thanks, Hannah.


449
00:23:34,448 --> 00:23:37,251 line:-2
Okay, so let's summarize
what we've discussed in this video.


450
00:23:37,851 --> 00:23:40,287 line:-2
We talked about
how the extensible input API


451
00:23:40,354 --> 00:23:44,191 line:-2
can keep your controller support flexible
to any new controllers that may be added.


452
00:23:44,892 --> 00:23:47,728 line:-2
We went over Game Controller
and Core Haptics integration


453
00:23:47,794 --> 00:23:50,497 line:-2
that'll allow you to create
rich haptic and rumble experiences


454
00:23:50,564 --> 00:23:51,832 line:-1
on supported controllers.


455
00:23:52,466 --> 00:23:53,867 line:-1
We dove into how you can support


456
00:23:53,934 --> 00:23:55,836 line:-2
some of the more unique features
of controllers


457
00:23:55,903 --> 00:23:57,971 line:-1
like motion, light bar and battery.


458
00:23:58,639 --> 00:24:02,743 line:-2
We also went over the new input remapping
available on iOS and tvOS


459
00:24:02,809 --> 00:24:04,311 line:-1
and what that means for your game.


460
00:24:04,811 --> 00:24:06,713 line:-2
We talked about
new controller button glyphs


461
00:24:06,780 --> 00:24:08,749 line:-1
that have been added to SF symbols


462
00:24:08,815 --> 00:24:11,618 line:-2
and how you can use them to create
a polished and adaptive UI.


463
00:24:12,119 --> 00:24:15,589 line:-2
And finally, we showed how updating
your app's capabilities in Xcode


464
00:24:15,656 --> 00:24:17,558 line:-1
to indicate extended gamepad support


465
00:24:17,624 --> 00:24:19,226 line:-1
will badge your game in the App Store,


466
00:24:19,293 --> 00:24:21,328 line:-1
allow per-app input remapping,


467
00:24:21,395 --> 00:24:23,530 line:-2
and future-proof your game
for any new features


468
00:24:23,597 --> 00:24:25,132 line:-1
that rely on this capability.


469
00:24:26,366 --> 00:24:29,069 line:0
For more information
about this year's Game Controller update,


470
00:24:29,136 --> 00:24:31,972 line:0
please visit the developer site
for the Game Controller framework.


471
00:24:32,372 --> 00:24:34,141 line:0
If you are interested
in learning about adding


472
00:24:34,208 --> 00:24:35,909 line:0
keyboard and mouse support to your game,


473
00:24:35,976 --> 00:24:37,110 line:0
watch this year's talk


474
00:24:37,177 --> 00:24:39,880 line:0
on "Bring Keyboard
and Mouse Gaming to iPadOS."


475
00:24:41,381 --> 00:24:43,517 line:-2
That's it for this year's
Game Controllers update.


476
00:24:43,817 --> 00:24:44,818 line:-1
Thank you for watching.


477
00:24:45,185 --> 00:24:47,020 line:-1
We hope you found this information helpful


478
00:24:47,087 --> 00:24:48,956 line:-2
and that you use it to create
some awesome games


479
00:24:49,022 --> 00:24:50,390 line:-1
with Game Controller support.

