1
00:00:03,836 --> 00:00:07,374 line:-1
Hello and welcome to WWDC.


2
00:00:08,442 --> 00:00:09,877 line:0
My name is Kyle Piddington.


3
00:00:09,943 --> 00:00:13,347 line:0
I'm an engineer in Apple's GPU software
technology group.


4
00:00:13,413 --> 00:00:14,581 line:0
In this session,


5
00:00:14,648 --> 00:00:17,718 line:0
my colleague Ravi and I are going
to show you some of the new advancements


6
00:00:17,784 --> 00:00:21,088 line:0
to ship your new
or existing precompiled GPU code.


7
00:00:21,154 --> 00:00:23,290 line:-1
This talk will consist of four parts.


8
00:00:23,824 --> 00:00:25,659 line:-1
First up, I'll provide an overview


9
00:00:25,726 --> 00:00:28,161 line:-2
of Metal's current shader
compilation model.


10
00:00:28,729 --> 00:00:32,266 line:-2
Next, I'm going to introduce
Metal Binary Archives,


11
00:00:32,332 --> 00:00:35,068 line:-2
a new way for you to take control
over shader caching,


12
00:00:35,135 --> 00:00:38,906 line:-2
and ship precompiled GPU executables
to your users.


13
00:00:39,540 --> 00:00:43,377 line:-2
I'm excited to share the new support
for dynamic libraries in Metal.


14
00:00:43,443 --> 00:00:46,113 line:-2
This feature will allow you
to link your compute shaders


15
00:00:46,180 --> 00:00:48,415 line:-1
against utility libraries dynamically.


16
00:00:48,982 --> 00:00:51,585 line:-1
And finally, Ravi will present in detail


17
00:00:51,652 --> 00:00:53,620 line:-2
the set of tools that you have
in your toolchain


18
00:00:53,687 --> 00:00:55,756 line:-2
to make the most
out of these new features.


19
00:00:55,822 --> 00:00:57,024 line:-1
Let's get started.


20
00:00:58,058 --> 00:01:01,628 line:-2
We'll begin with a review of the shader
and pipeline compilation process


21
00:01:01,695 --> 00:01:02,729 line:-1
on Apple platforms.


22
00:01:03,197 --> 00:01:07,267 line:-2
As you know, the Metal Shading Language
is our programming language for shaders.


23
00:01:07,334 --> 00:01:11,371 line:-2
Metal compiles this code
into Apple's Intermediate Representation,


24
00:01:11,438 --> 00:01:12,739 line:-1
also known as AIR.


25
00:01:13,140 --> 00:01:19,046 line:-2
This can be done off-line in Xcode,
or at runtime on the target device itself.


26
00:01:22,482 --> 00:01:26,420 line:-2
Building off-line avoids the runtime cost
of compiling source code to AIR.


27
00:01:26,954 --> 00:01:30,290 line:-2
In both cases, however,
when creating pipeline state objects,


28
00:01:30,357 --> 00:01:33,894 line:-2
this intermediate representation
is further compiled on device


29
00:01:33,961 --> 00:01:38,031 line:-2
to generate machine-specific code
needed for each particular GPU.


30
00:01:39,166 --> 00:01:42,002 line:-2
This process occurs
for every pipeline state.


31
00:01:42,536 --> 00:01:45,706 line:-2
To accelerate recompilation
and recreation of pipelines,


32
00:01:45,772 --> 00:01:48,642 line:-2
we cache the Metal Function variants
produced in this step


33
00:01:48,709 --> 00:01:50,511 line:-1
for future pipeline creation.


34
00:01:51,144 --> 00:01:54,281 line:-2
This process is great,
and has served us well for many years.


35
00:01:54,848 --> 00:01:57,417 line:-2
But for games and apps
that adopt the Metal best practice


36
00:01:57,484 --> 00:02:01,655 line:-2
of building pipeline objects early on
to provide a hitch-free experience,


37
00:02:01,722 --> 00:02:05,058 line:-2
this process can potentially result
in long loading screens.


38
00:02:05,893 --> 00:02:07,961 line:-1
Additionally, under this model,


39
00:02:08,027 --> 00:02:09,663 line:-1
apps are unable to reuse


40
00:02:09,729 --> 00:02:14,134 line:-2
any previously-generated machine code
subroutines across pipeline state objects.


41
00:02:15,335 --> 00:02:19,006 line:-2
We've gathered feedback coming in
from our ecosystem of developers,


42
00:02:19,072 --> 00:02:21,408 line:-2
and have been able to identify
a concrete set of needs


43
00:02:21,475 --> 00:02:24,011 line:-2
that will enable you
to address these challenges.


44
00:02:24,077 --> 00:02:28,515 line:-2
You might want a way to save the entire
time of pipeline state compilation,


45
00:02:28,582 --> 00:02:31,885 line:-1
from source, to AIR, to a GPU binary.


46
00:02:32,352 --> 00:02:36,156 line:-2
You might also want a mechanism
that enables sharing common subroutines


47
00:02:36,223 --> 00:02:37,658 line:-1
and utility functions


48
00:02:37,724 --> 00:02:40,227 line:-2
without the need of compiling
the same code twice,


49
00:02:40,294 --> 00:02:42,696 line:-2
or having it loaded in memory
more than once.


50
00:02:44,064 --> 00:02:47,868 line:-2
Having the ability to ship apps that
already include the final compiled code


51
00:02:47,935 --> 00:02:50,470 line:-1
for executables as well as libraries


52
00:02:50,537 --> 00:02:54,508 line:-2
gives you the tools to provide a fantastic
first-time launch experience.


53
00:02:55,342 --> 00:02:57,778 line:-2
And allowing you to share
these executables and libraries


54
00:02:57,845 --> 00:03:00,914 line:-2
with other developers
make their development easier.


55
00:03:03,016 --> 00:03:07,321 line:-2
One of the ways we are addressing these
needs is via the Metal Binary Archives.


56
00:03:07,855 --> 00:03:09,489 line:-1
Since the beginnings of Metal,


57
00:03:09,556 --> 00:03:12,326 line:-2
apps have benefited
from a system-wide shader cache


58
00:03:12,392 --> 00:03:14,628 line:-1
that accelerates creating pipeline objects


59
00:03:14,695 --> 00:03:17,698 line:-2
that have been created
from previous runs of the application.


60
00:03:18,165 --> 00:03:19,800 line:-1
With Metal Binary Archives,


61
00:03:19,867 --> 00:03:23,904 line:-2
explicit control over pipeline state
caching is being provided to you.


62
00:03:25,672 --> 00:03:28,709 line:-2
This direct control over caching
gives you the opportunity


63
00:03:28,775 --> 00:03:31,778 line:-2
to manually collect compiled
pipeline state objects,


64
00:03:31,845 --> 00:03:34,982 line:-2
organize them into different archives
based off of usage or need,


65
00:03:35,048 --> 00:03:36,850 line:-1
and even harvest them from a device


66
00:03:36,917 --> 00:03:39,586 line:-2
and distribute them
to other compatible devices.


67
00:03:41,054 --> 00:03:44,391 line:-2
Binary Archives can be thought of
as any other asset type.


68
00:03:44,458 --> 00:03:47,628 line:-2
You have full control
over the Binary Archive lifetimes,


69
00:03:47,694 --> 00:03:49,897 line:-1
and these persist as long as desired.


70
00:03:50,764 --> 00:03:56,737 line:-2
Binary Archives are a feature
of the Metal GPU Families Apple3 and Mac1.


71
00:03:57,371 --> 00:03:59,473 line:-1
Creating a Binary Archive is simple.


72
00:03:59,540 --> 00:04:03,677 line:-2
For this feature, we created
a new descriptor type for Binary Archives.


73
00:04:04,178 --> 00:04:08,649 line:-2
I use this descriptor to create a new
Metal Binary Archive from the device.


74
00:04:09,783 --> 00:04:12,386 line:-1
This descriptor contains a URL property.


75
00:04:12,452 --> 00:04:16,322 line:-2
And this is used to determine
if I want to create a new, empty archive,


76
00:04:16,822 --> 00:04:19,358 line:-1
or if I want to load one from disk.


77
00:04:20,194 --> 00:04:24,464 line:-2
When we request a new archive be loaded,
this file will be memory-mapped in.


78
00:04:24,531 --> 00:04:27,367 line:-2
And we can immediately start
to use these loaded archives


79
00:04:27,434 --> 00:04:30,204 line:-2
to accelerate our subsequent
pipeline build requests.


80
00:04:32,539 --> 00:04:34,308 line:-1
The Binary Archive API


81
00:04:34,374 --> 00:04:37,845 line:-2
allows me to directly add pipelines
I'm interested in to the archive.


82
00:04:37,911 --> 00:04:42,149 line:-2
I can add Render, Compute,
and TileRender pipelines.


83
00:04:43,483 --> 00:04:46,920 line:-2
Adding a pipeline to the Binary Archive
causes a back-end compilation


84
00:04:46,987 --> 00:04:48,121 line:-1
of the shader source,


85
00:04:48,188 --> 00:04:51,258 line:-2
generating the machine code
to be stored in the archive.


86
00:04:51,758 --> 00:04:55,262 line:-2
Finally, once I'm done collecting all
the pipeline objects I'm interested in,


87
00:04:55,329 --> 00:04:58,732 line:-2
I call serializeToURL
to save the archive to disk.


88
00:04:59,132 --> 00:05:02,970 line:-2
Once I have my Binary Archives on disk,
I can harvest them from device


89
00:05:03,036 --> 00:05:05,506 line:-2
and deploy them
on other compatible devices


90
00:05:05,572 --> 00:05:08,008 line:-1
to accelerate their pipeline state builds.


91
00:05:09,142 --> 00:05:13,080 line:-2
The only requirement is that
these other devices have the same GPU


92
00:05:13,146 --> 00:05:15,749 line:-2
and are running the same
operating system build.


93
00:05:15,816 --> 00:05:17,117 line:-1
If there's a mismatch,


94
00:05:17,184 --> 00:05:20,220 line:-2
the metal framework will fall back
on runtime compilation


95
00:05:20,287 --> 00:05:21,755 line:-1
of the pipeline functions.


96
00:05:23,190 --> 00:05:25,659 line:-1
Once I have my Binary Archive populated,


97
00:05:25,726 --> 00:05:28,662 line:-2
reusing a cached pipeline
is straightforward.


98
00:05:29,296 --> 00:05:30,564 line:-1
When creating a pipeline,


99
00:05:30,631 --> 00:05:33,800 line:-2
I set the pipeline descriptor's
binaryArchives property


100
00:05:33,867 --> 00:05:35,102 line:-1
to an array of archives.


101
00:05:35,636 --> 00:05:39,339 line:-2
The framework will then search the array
linearly for the function binaries.


102
00:05:41,475 --> 00:05:44,745 line:-2
If the pipeline is found in any
of the Binary Archives on the list,


103
00:05:44,811 --> 00:05:46,213 line:-1
it will be returned to you,


104
00:05:46,280 --> 00:05:48,482 line:-1
avoiding the compilation process entirely


105
00:05:48,549 --> 00:05:51,185 line:-2
and will not impact
the Metal Shader Cache.


106
00:05:53,487 --> 00:05:55,622 line:-2
In the case
that the pipeline is not found,


107
00:05:55,689 --> 00:05:58,692 line:0
the OS's MTLCompilerService
will kick into gear


108
00:05:58,759 --> 00:06:02,763 line:0
and compile my AIR source
to machine code, return the results,


109
00:06:02,829 --> 00:06:05,566 line:0
and cache the results
in the Metal Shader Cache.


110
00:06:06,266 --> 00:06:07,968 line:-1
This process takes time,


111
00:06:08,035 --> 00:06:10,771 line:-2
but the pipeline will be cached
in the Metal Shader Cache


112
00:06:10,838 --> 00:06:13,874 line:-2
to accelerate any subsequent
pipeline build requests.


113
00:06:14,341 --> 00:06:16,043 line:-1
Now that I've gone over the workflow,


114
00:06:16,109 --> 00:06:18,545 line:-2
let's take a look at the API
to accomplish it.


115
00:06:18,946 --> 00:06:22,382 line:-2
First, I create
the MTLBinaryArchiveDescriptor.


116
00:06:22,916 --> 00:06:26,353 line:-2
This is used to determine whether
I want to create a new, empty archive


117
00:06:26,420 --> 00:06:28,121 line:-1
or to load an existing one.


118
00:06:28,689 --> 00:06:32,025 line:-2
Creating a Binary Archive is always done
from a descriptor.


119
00:06:34,161 --> 00:06:37,064 line:-1
In this case, I set the URL to nil.


120
00:06:37,130 --> 00:06:39,833 line:-2
The device will create a new,
empty archive.


121
00:06:41,268 --> 00:06:45,072 line:-2
Finally, I call the function
"makeBinaryArchive" to create it.


122
00:06:46,173 --> 00:06:50,277 line:-2
Next, I'll populate a Binary Archive
using pipeline descriptors.


123
00:06:50,344 --> 00:06:53,847 line:-2
I can add Render, Compute,
and TileRender descriptors


124
00:06:53,914 --> 00:06:55,315 line:-1
to the Binary Archive.


125
00:06:55,949 --> 00:06:58,685 line:-2
Reusing compiled functions
from a Binary Archive


126
00:06:58,752 --> 00:07:01,588 line:-2
allows me to skip
the back-end function compilation.


127
00:07:02,122 --> 00:07:05,158 line:-2
I can create my pipeline descriptors
just as I always have


128
00:07:05,225 --> 00:07:10,364 line:-2
and use the new binaryArchives property
to indicate which archives be searched.


129
00:07:10,731 --> 00:07:13,634 line:-2
I want to do this
before creating the pipeline.


130
00:07:14,835 --> 00:07:17,604 line:-2
Once you have collected all the pipelines
you are interested in,


131
00:07:17,671 --> 00:07:21,408 line:-2
you can serialize the Binary Archive
to a writable file location on disk,


132
00:07:21,475 --> 00:07:23,443 line:-1
using the method "serialize."


133
00:07:24,044 --> 00:07:29,283 line:-2
Here, I'm serializing the archive
to my application's "documents" directory.


134
00:07:29,917 --> 00:07:31,818 line:-1
On the next run of my app,


135
00:07:31,885 --> 00:07:33,954 line:-1
I can now deserialize the archive


136
00:07:34,021 --> 00:07:38,392 line:-2
to avoid recompiling the pipelines
that were previously added and serialized.


137
00:07:38,792 --> 00:07:41,528 line:-2
I simply set the URL
to point to the location


138
00:07:41,595 --> 00:07:44,598 line:-2
of an existing,
pre-populated cache on disk.


139
00:07:45,365 --> 00:07:48,302 line:-1
Now, one final note about archive search.


140
00:07:48,769 --> 00:07:50,103 line:-1
Depending on your use case,


141
00:07:50,170 --> 00:07:53,640 line:-2
you may find it helpful to be able
to short-circuit the fallback behavior


142
00:07:53,707 --> 00:07:56,877 line:-2
of compiling a pipeline
when it's not found in the archive.


143
00:07:57,344 --> 00:08:00,848 line:-2
In this case, you can specify
the pipeline compile option


144
00:08:00,914 --> 00:08:03,350 line:-1
FailOnBinaryArchiveMiss.


145
00:08:05,052 --> 00:08:07,821 line:-2
If the pipeline is found
in any of the archives,


146
00:08:07,888 --> 00:08:09,623 line:-1
it is returned to you as usual.


147
00:08:10,123 --> 00:08:14,428 line:-2
However, in the case that it is not found,
the device will return nil.


148
00:08:15,729 --> 00:08:19,933 line:-2
One use case I recommend is using
this workflow for debugging purposes.


149
00:08:20,367 --> 00:08:21,935 line:-1
Avoiding the compilation process


150
00:08:22,002 --> 00:08:24,872 line:-2
will let you diagnose any problems
in your app's logic,


151
00:08:24,938 --> 00:08:26,473 line:-1
or your archive's data.


152
00:08:26,907 --> 00:08:28,175 line:-1
Let's take a moment to discuss


153
00:08:28,242 --> 00:08:31,311 line:-2
the memory considerations
of using Binary Archives.


154
00:08:31,378 --> 00:08:33,746 line:-2
As mentioned before,
it is important to note


155
00:08:33,813 --> 00:08:36,783 line:-2
that the Binary Archive file
is memory-mapped in.


156
00:08:37,183 --> 00:08:40,020 line:-2
This means that we need to reserve a range
of virtual memory


157
00:08:40,087 --> 00:08:42,589 line:-1
in order to access the archive's contents.


158
00:08:42,655 --> 00:08:46,126 line:-2
This virtual memory range will be released
when you release your cache,


159
00:08:46,193 --> 00:08:48,595 line:-2
so it's important to close
any Binary Archives


160
00:08:48,662 --> 00:08:52,599 line:-2
that are no longer needed for optimal use
of the virtual address space.


161
00:08:54,134 --> 00:08:55,702 line:-1
When collecting new pipelines,


162
00:08:55,769 --> 00:08:58,505 line:-2
Binary Archives present
a similar memory footprint


163
00:08:58,572 --> 00:09:01,175 line:-1
to using the system's Metal Shader Cache.


164
00:09:01,241 --> 00:09:04,011 line:-2
But unlike when using
the Metal Shader Cache,


165
00:09:04,077 --> 00:09:06,146 line:-1
we have the chance to free up this memory.


166
00:09:06,813 --> 00:09:09,383 line:-2
Having explicit control
over archive lifetime


167
00:09:09,449 --> 00:09:12,686 line:-2
allows you to serialize and release
a Metal Binary Archive


168
00:09:12,753 --> 00:09:15,422 line:-2
when you are done collecting
pipeline state objects.


169
00:09:15,489 --> 00:09:18,659 line:-2
In addition, when you reuse
an existing archive,


170
00:09:18,725 --> 00:09:23,063 line:-2
the pipelines in this archive do not count
against your active app memory.


171
00:09:23,130 --> 00:09:26,166 line:-2
You can serialize,
and then reopen this archive


172
00:09:26,233 --> 00:09:28,735 line:-2
and only use it
for retrieving cached pipelines,


173
00:09:28,802 --> 00:09:32,372 line:-2
effectively freeing the memory
that was used in the collection process.


174
00:09:32,439 --> 00:09:36,109 line:-2
This is not possible when relying
on the system's Metal Shader Cache.


175
00:09:37,211 --> 00:09:39,112 line:-2
I'd like to wrap up this part
of the session


176
00:09:39,179 --> 00:09:42,749 line:-2
by discussing some of the best practices
for working with Binary Archives.


177
00:09:43,250 --> 00:09:45,919 line:-2
Although there is no size limit
for Binary Archives,


178
00:09:45,986 --> 00:09:49,890 line:-2
I recommend dividing your game assets
into several different caches.


179
00:09:51,058 --> 00:09:53,760 line:-2
Games are an excellent candidate
for breaking up caches


180
00:09:53,827 --> 00:09:57,698 line:-2
into frequently used pipelines
and per-level pipelines.


181
00:09:58,498 --> 00:10:00,834 line:-2
Dividing the cache
gives you the opportunity


182
00:10:00,901 --> 00:10:03,604 line:-2
to completely release
no-longer-needed caches.


183
00:10:04,238 --> 00:10:07,908 line:-2
This will free memory
in case we've collected any new pipelines,


184
00:10:07,975 --> 00:10:10,210 line:-2
as well as
the virtual memory range in use.


185
00:10:12,312 --> 00:10:13,547 line:-1
When following this guidance,


186
00:10:13,614 --> 00:10:16,216 line:-1
Binary Archives gives you granular control


187
00:10:16,283 --> 00:10:19,253 line:-2
and should be favored
over prewarming the Metal Shader Cache.


188
00:10:19,686 --> 00:10:23,423 line:-2
Modern apps often have too many unique
permutations of shader variants


189
00:10:23,490 --> 00:10:25,959 line:-2
that are generated based off
of user choices.


190
00:10:26,660 --> 00:10:30,531 line:-2
With Metal Binary Archives,
you can now capture them all at runtime.


191
00:10:32,132 --> 00:10:34,735 line:-2
Let's take a look how this all
comes together in practice.


192
00:10:34,801 --> 00:10:36,370 line:-1
We've partnered with Epic Games


193
00:10:36,436 --> 00:10:40,574 line:-2
to quantify exactly how reusing
a pre-harvested Binary Archive


194
00:10:40,641 --> 00:10:43,544 line:-2
can help improve
pipeline state object creation times,


195
00:10:43,610 --> 00:10:46,847 line:-2
as well as the developer workflow
in the context of Unreal Engine.


196
00:10:47,548 --> 00:10:48,582 line:-1
For this test,


197
00:10:48,649 --> 00:10:52,519 line:-2
we used the pipeline state workload
of a AAA title, Fortnite.


198
00:10:53,687 --> 00:10:55,322 line:-1
Fortnite is a large game.


199
00:10:55,389 --> 00:10:59,193 line:-2
It's got a big world and many character
and item customization options.


200
00:10:59,259 --> 00:11:01,995 line:-2
This makes for a large number
of shader function variants


201
00:11:02,062 --> 00:11:06,166 line:-2
and pipeline state objects,
over 11,000, in fact.


202
00:11:07,668 --> 00:11:10,003 line:-2
Epic Games follows
the Metal Best Practices


203
00:11:10,070 --> 00:11:13,507 line:-2
and compiles the needed
pipeline state objects at load time,


204
00:11:13,974 --> 00:11:16,176 line:-2
which allows minimizing hitching
at runtime


205
00:11:16,243 --> 00:11:19,513 line:-2
and delivers the smoothest experience
possible to users.


206
00:11:19,580 --> 00:11:23,417 line:-2
But apps, as we mentioned,
cannot benefit from the Metal Shader Cache


207
00:11:23,483 --> 00:11:24,918 line:-1
before it's been populated.


208
00:11:24,985 --> 00:11:27,287 line:-1
So the up-front compilation time adds up,


209
00:11:27,354 --> 00:11:31,091 line:-2
potentially making the first time launch
experience take longer than desired.


210
00:11:31,992 --> 00:11:34,728 line:-2
By pre-seeding a harvested
Metal Binary Archive


211
00:11:34,795 --> 00:11:38,398 line:-2
that had collected function variants
from 1,700 pipeline state objects,


212
00:11:38,465 --> 00:11:41,435 line:-2
we observed a massive speedup
in the creation times


213
00:11:41,502 --> 00:11:45,038 line:-2
when we compare against starting
with an empty Metal Shader Cache.


214
00:11:45,105 --> 00:11:48,775 line:-2
These results were measured on a six-core,
three gigahertz Mac Mini


215
00:11:48,842 --> 00:11:50,677 line:-1
with 32 gigabytes of RAM.


216
00:11:51,578 --> 00:11:53,647 line:0
When we focus on pipeline build times,


217
00:11:53,714 --> 00:11:57,551 line:0
we go from spending one minute
and 26 seconds building pipelines


218
00:11:57,618 --> 00:11:59,419 line:0
to just three seconds.


219
00:11:59,486 --> 00:12:02,523 line:0
Overall, a speedup of over 28 times.


220
00:12:04,958 --> 00:12:09,997 line:-2
To summarize, Metal Binary Archives allow
you to manually manage pipeline caches.


221
00:12:11,331 --> 00:12:15,202 line:-2
These can be harvested from a device
and deployed on other compatible devices


222
00:12:15,269 --> 00:12:18,238 line:-2
to dramatically reduce the pipeline
creation times


223
00:12:18,305 --> 00:12:20,908 line:-1
the first time a game or app is installed,


224
00:12:20,974 --> 00:12:23,510 line:-2
and after a device reboots
in the case of iOS.


225
00:12:24,811 --> 00:12:29,483 line:-2
AAA games and other apps bound by a very
large number of pipeline state objects


226
00:12:29,550 --> 00:12:33,086 line:-2
can benefit from this feature
to obtain extraordinary gains


227
00:12:33,153 --> 00:12:35,822 line:-2
in pipeline creation times
under these conditions.


228
00:12:37,791 --> 00:12:40,360 line:-2
Building and shipping
GPU executable binaries


229
00:12:40,427 --> 00:12:41,662 line:-1
with your application


230
00:12:41,728 --> 00:12:44,364 line:-2
allows you to accelerate
your first time launch experience


231
00:12:44,431 --> 00:12:46,600 line:-1
and cold-boot app experiences.


232
00:12:46,667 --> 00:12:48,969 line:-2
I hope you take advantage
of this new feature.


233
00:12:50,170 --> 00:12:52,372 line:-1
And that's it for Metal Binary Archives.


234
00:12:52,439 --> 00:12:54,575 line:-2
Next, I'm going to talk about
another new feature


235
00:12:54,641 --> 00:12:57,544 line:-2
we're bringing to the compilation model,
dynamic libraries.


236
00:12:58,645 --> 00:13:00,714 line:-1
Metal Dynamic Libraries are a new feature


237
00:13:00,781 --> 00:13:02,783 line:-2
that will allow you
to build well-abstracted


238
00:13:02,850 --> 00:13:06,086 line:-2
and reusable compute-shared library code
for your applications.


239
00:13:06,420 --> 00:13:10,457 line:-2
I'll be discussing the concept, execution,
and details of dynamic libraries.


240
00:13:11,658 --> 00:13:15,762 line:-2
Today, developers may choose to create
utility libraries of Metal functions


241
00:13:15,829 --> 00:13:17,297 line:-1
to compile with their kernels.


242
00:13:17,865 --> 00:13:21,168 line:-2
Off-line compilation can save time
while generating these libraries,


243
00:13:21,235 --> 00:13:24,638 line:-2
but there's still two costs that occur
when using a utility library.


244
00:13:26,406 --> 00:13:28,809 line:-2
Every app pays the cost
of generating machine code


245
00:13:28,876 --> 00:13:31,512 line:-1
for the utility library at PSO generation.


246
00:13:32,346 --> 00:13:36,783 line:0
In addition, compiling multiple pipelines
with the same utility library


247
00:13:36,850 --> 00:13:39,553 line:0
results in duplicated machine code
for subroutines.


248
00:13:40,387 --> 00:13:42,789 line:0
This can result in longer
pipeline load times


249
00:13:42,856 --> 00:13:46,660 line:0
due to back-end compilation
and increased GPU memory usage.


250
00:13:48,195 --> 00:13:51,532 line:-2
And this year, we're introducing
a solution to this problem,


251
00:13:51,598 --> 00:13:53,400 line:-1
the Metal Dynamic Library.


252
00:13:54,234 --> 00:13:58,405 line:-2
The Metal Dynamic Library enables you
to dynamically link, load


253
00:13:58,472 --> 00:14:01,341 line:-2
and share utility functions
in the form of machine code.


254
00:14:02,042 --> 00:14:04,845 line:-2
This code is reusable between multiple
compute pipelines,


255
00:14:04,912 --> 00:14:08,916 line:-2
eliminating duplicate compilation
and the storing of shared subroutines.


256
00:14:11,985 --> 00:14:15,022 line:-2
In addition,
much like the Metal Binary Archive,


257
00:14:15,088 --> 00:14:17,357 line:-1
the Metal Dynamic Library is serializable


258
00:14:17,424 --> 00:14:19,927 line:-2
and shippable as an asset
in your application.


259
00:14:21,261 --> 00:14:23,297 line:-1
Before we dive into the API,


260
00:14:23,363 --> 00:14:26,066 line:-2
let's talk about
what a Metal Dynamic Library is.


261
00:14:26,133 --> 00:14:29,436 line:-2
A Metal Dynamic Library is a collection
of exported functions


262
00:14:29,503 --> 00:14:32,206 line:-2
that can be called
from multiple compute pipelines.


263
00:14:32,773 --> 00:14:35,909 line:-2
Later, we will discuss which functions
in your dylib are exported


264
00:14:35,976 --> 00:14:37,244 line:-1
and how to manage them.


265
00:14:37,778 --> 00:14:40,113 line:-1
Unlike an executable Metal Library,


266
00:14:40,180 --> 00:14:42,950 line:-2
dynamic libraries cannot be used
to create MTLFunctions.


267
00:14:43,417 --> 00:14:47,688 line:-2
However, standard Metal Libraries
can import functions that are implemented


268
00:14:47,754 --> 00:14:48,822 line:-1
in a dynamic library.


269
00:14:50,457 --> 00:14:52,059 line:0
At pipeline creation time,


270
00:14:52,125 --> 00:14:55,495 line:0
the dynamic library is linked
to resolve any imported functions,


271
00:14:55,863 --> 00:14:59,166 line:0
much like a dynamic library's used
in a typical application.


272
00:15:00,234 --> 00:15:02,503 line:-2
So why might you want to use
dynamic libraries?


273
00:15:03,303 --> 00:15:05,205 line:-2
If your application
can be structured into,


274
00:15:05,272 --> 00:15:09,610 line:-2
or relies on a shared utility codebase,
dynamic libraries are for you.


275
00:15:09,977 --> 00:15:11,778 line:-1
Using dynamic libraries in your app


276
00:15:11,845 --> 00:15:15,549 line:-2
prevents recompiling and duplicating
machine code across pipeline states.


277
00:15:16,683 --> 00:15:19,052 line:-2
If you are interested in developing
Metal middleware,


278
00:15:19,119 --> 00:15:23,757 line:-2
dynamic libraries provide you the ability
to ship a utility library to your users.


279
00:15:24,324 --> 00:15:27,761 line:-2
Unlike before where you would have
to ship sources to developers,


280
00:15:27,828 --> 00:15:30,831 line:-2
or compile their code
with a static Metal Library,


281
00:15:31,164 --> 00:15:33,967 line:-2
a dynamic library can be provided
and updated


282
00:15:34,034 --> 00:15:37,638 line:-2
without requiring users
to rebuild their own metallib files.


283
00:15:38,338 --> 00:15:40,807 line:-2
Finally, dynamic libraries
give you the power


284
00:15:40,874 --> 00:15:44,111 line:-2
to expose hooks for your users
to create custom kernels.


285
00:15:44,178 --> 00:15:46,780 line:-1
The Metal API exposes the ability


286
00:15:46,847 --> 00:15:49,950 line:-2
to change which libraries
are loaded at pipeline creation time,


287
00:15:50,017 --> 00:15:53,086 line:-2
allowing you the ability to inject
user-defined behavior


288
00:15:53,153 --> 00:15:56,023 line:-2
into your shaders
without creating the Metal Library


289
00:15:56,089 --> 00:15:58,625 line:-2
and MTLFunctions
containing your entry points.


290
00:16:00,194 --> 00:16:03,897 line:-2
To determine if metal dynamic libraries
are supported for your GPU,


291
00:16:03,964 --> 00:16:07,034 line:-2
check the feature query
"supportsDynamicLibraries."


292
00:16:07,501 --> 00:16:08,836 line:-1
In the next few slides,


293
00:16:08,902 --> 00:16:12,039 line:-2
we'll work through an example
of how to create a dynamic library,


294
00:16:12,105 --> 00:16:15,576 line:-2
how symbols are resolved,
and some more advanced linking scenarios.


295
00:16:17,544 --> 00:16:21,682 line:0
A standard Metal Library is compiled
to AIR through either a makeLibrary


296
00:16:21,748 --> 00:16:23,116 line:0
with source call at runtime,


297
00:16:23,550 --> 00:16:26,420 line:0
or through compiling your library
with the Metal toolchain.


298
00:16:28,422 --> 00:16:32,292 line:-2
To create a Metal Dynamic Library,
we begin with a similar workflow.


299
00:16:32,693 --> 00:16:34,995 line:-1
We start by creating a Metal Library,


300
00:16:35,062 --> 00:16:38,065 line:-2
but when doing so, we specify
that we'd like this library to be used


301
00:16:38,131 --> 00:16:39,733 line:-1
as a dynamic library.


302
00:16:40,534 --> 00:16:43,604 line:0
Next, we call the function
makeDynamicLibrary,


303
00:16:43,670 --> 00:16:47,274 line:0
which will back-end-compile
our metal code to machine code.


304
00:16:47,841 --> 00:16:51,278 line:0
This is the only time you will need
to compile the dynamic library.


305
00:16:52,179 --> 00:16:56,216 line:-2
We need one more bit of information,
a unique install name.


306
00:16:56,783 --> 00:16:58,285 line:-1
At pipeline creation time,


307
00:16:58,352 --> 00:17:01,688 line:-2
these names are used by the linker
to load the dynamic library.


308
00:17:02,022 --> 00:17:06,326 line:-2
The linker supports two relative paths,
@executable_path,


309
00:17:06,393 --> 00:17:09,396 line:-2
which refers to the metallib
containing an executable kernel,


310
00:17:09,463 --> 00:17:13,901 line:-2
and @loader_path, which refers
to the metallib containing a load command.


311
00:17:14,468 --> 00:17:16,770 line:-1
An absolute path can also be used.


312
00:17:18,505 --> 00:17:20,607 line:-1
With an install name and a library type,


313
00:17:20,674 --> 00:17:23,010 line:-1
I'm now ready to create a dynamic library.


314
00:17:23,743 --> 00:17:25,479 line:-1
Once I've set the compile options,


315
00:17:25,878 --> 00:17:30,384 line:-2
I create a Metal Library which will
compile my library from source to AIR.


316
00:17:30,450 --> 00:17:34,988 line:-2
Then, I call the API method
makeDynamicLibrary on the Metal device,


317
00:17:35,522 --> 00:17:38,425 line:-2
which will compile my dynamic library
into machine code.


318
00:17:40,594 --> 00:17:43,697 line:-2
Now that we've covered how to create
a dynamic library,


319
00:17:44,097 --> 00:17:46,033 line:-1
let's take a look at how we can use it.


320
00:17:46,400 --> 00:17:47,801 line:-1
In these next few examples,


321
00:17:47,868 --> 00:17:51,205 line:-2
I'll be discussing how we can link
dynamic libraries at runtime.


322
00:17:51,271 --> 00:17:55,242 line:-2
These operations can also be achieved
when compiling Metal libraries off-line.


323
00:17:55,309 --> 00:17:58,245 line:-2
And we'll discuss our off-line workflow
later in this session.


324
00:17:59,847 --> 00:18:03,116 line:-2
To link a dynamic library
when compiling a metallib from source,


325
00:18:03,450 --> 00:18:06,486 line:-2
add the dynamic library
to the "libraries" property


326
00:18:06,553 --> 00:18:10,290 line:-2
of the MTLCompileOptions
before you compile your library.


327
00:18:11,058 --> 00:18:14,261 line:-2
The specified library will be linked
at pipeline creation time.


328
00:18:14,628 --> 00:18:17,598 line:-2
However, symbol resolution will be checked
at compile time


329
00:18:17,664 --> 00:18:21,201 line:-2
to make sure at least
one implementation of the function exists.


330
00:18:21,935 --> 00:18:23,170 line:-1
To review these steps,


331
00:18:23,670 --> 00:18:25,606 line:-1
when creating a metallib from source,


332
00:18:25,672 --> 00:18:28,509 line:-2
source files should include headers
that define functions available


333
00:18:28,575 --> 00:18:29,877 line:-1
in your dynamic libraries.


334
00:18:31,044 --> 00:18:32,279 line:-1
At compile time,


335
00:18:32,346 --> 00:18:35,215 line:-2
dynamic libraries included
in the "libraries" option


336
00:18:35,282 --> 00:18:38,252 line:-2
are searched for at least one
matching function signature.


337
00:18:38,819 --> 00:18:41,788 line:-2
If no signature is found,
compilation will fail,


338
00:18:41,855 --> 00:18:43,857 line:-1
explaining which symbols are missing.


339
00:18:43,924 --> 00:18:46,560 line:-2
However, unlike when compiling
with static libraries,


340
00:18:46,627 --> 00:18:48,095 line:-1
or header-only libraries,


341
00:18:48,161 --> 00:18:50,330 line:-2
this compilation does not bind
the function call


342
00:18:50,397 --> 00:18:51,999 line:-1
to the function implementation.


343
00:18:52,966 --> 00:18:55,802 line:0
At pipeline creation time,
libraries are linked and loaded,


344
00:18:55,869 --> 00:18:58,305 line:0
and a function implementation is chosen.


345
00:18:58,672 --> 00:18:59,806 line:0
We'll go over the case


346
00:18:59,873 --> 00:19:03,844 line:0
where multiple dynamic libraries export
the same function in just a moment.


347
00:19:05,445 --> 00:19:08,916 line:0
In addition to executable Metal Libraries
linking dynamic libraries,


348
00:19:09,249 --> 00:19:12,286 line:-2
dynamic libraries can also reference
other dynamic libraries.


349
00:19:13,053 --> 00:19:15,956 line:-2
If all these libraries were created
from source at runtime,


350
00:19:16,023 --> 00:19:20,093 line:-2
linking Dylib2 and Dylib3 to Dylib1
is as simple as setting


351
00:19:20,160 --> 00:19:23,864 line:-2
the Metal compiler option
libraries property on creation.


352
00:19:24,631 --> 00:19:29,002 line:-2
And, to reiterate one more time,
dylibs are shared between kernels.


353
00:19:29,069 --> 00:19:31,672 line:-2
And although multiple kernels
link the same dylib,


354
00:19:31,738 --> 00:19:34,741 line:-2
only one instance of the dylib
exists in memory.


355
00:19:35,876 --> 00:19:38,378 line:-2
Because linking is deferred
to pipeline creation time,


356
00:19:38,445 --> 00:19:42,649 line:-2
we can replace functions, or even
full libraries with new implementations


357
00:19:42,716 --> 00:19:46,320 line:-2
by using the insertLibraries property
of the ComputePipelineDescriptor.


358
00:19:47,087 --> 00:19:48,455 line:-1
Setting this option is comparable


359
00:19:48,522 --> 00:19:51,925 line:-2
to setting the DYLD_INSERT_LIBRARIES
environment variable.


360
00:19:53,193 --> 00:19:54,695 line:-1
At pipeline creation time,


361
00:19:54,761 --> 00:19:56,997 line:-2
the linker will first search
through inserted libraries


362
00:19:57,064 --> 00:19:58,599 line:-1
to find imported symbols


363
00:19:58,665 --> 00:20:00,701 line:-2
before looking
through the kernel's linked libraries


364
00:20:00,767 --> 00:20:02,669 line:-1
for any remaining imported symbols.


365
00:20:04,638 --> 00:20:08,408 line:-2
In this example, DylibA
exports the function foo.


366
00:20:08,475 --> 00:20:10,410 line:-2
And when we create
the compute pipeline state,


367
00:20:10,477 --> 00:20:13,347 line:-2
foo will be linked
to the implementation in DylibA.


368
00:20:15,048 --> 00:20:16,850 line:-1
When we use insertLibraries,


369
00:20:16,917 --> 00:20:20,420 line:-2
both DylibA and DylibD
export the function foo.


370
00:20:20,487 --> 00:20:22,222 line:-1
When we create the pipeline state,


371
00:20:22,289 --> 00:20:24,358 line:-2
we walk down the list
of imported libraries


372
00:20:24,424 --> 00:20:25,759 line:-1
to resolve the symbol.


373
00:20:25,826 --> 00:20:29,496 line:-2
And instead of linking
the implementation of foo in DylibA,


374
00:20:29,563 --> 00:20:32,065 line:-1
we will instead link from foo and DylibD.


375
00:20:33,500 --> 00:20:36,570 line:-2
Finally, let's discuss distributing
your dynamic libraries.


376
00:20:37,237 --> 00:20:38,872 line:-1
Much like Binary Archives,


377
00:20:38,939 --> 00:20:42,743 line:-2
compiled dynamic libraries
can be serialized out to URL.


378
00:20:42,809 --> 00:20:44,444 line:-1
Both the precompiled binary


379
00:20:44,511 --> 00:20:47,447 line:-2
and the generic AIR
for the Metal Library are serialized.


380
00:20:48,015 --> 00:20:50,184 line:-2
If you end up distributing
the dynamic library


381
00:20:50,250 --> 00:20:52,186 line:-1
as an asset in your project,


382
00:20:52,252 --> 00:20:55,756 line:-2
the Metal framework will recompile
the AIR slice into machine code


383
00:20:55,822 --> 00:20:58,625 line:-2
if the target device cannot use
the precompiled binary.


384
00:20:59,193 --> 00:21:03,163 line:-2
This would occur when loading your dylib
on a different architecture or OS.


385
00:21:04,298 --> 00:21:06,700 line:-2
This compilation is not added
to the Metal Shader Cache,


386
00:21:06,767 --> 00:21:09,736 line:-2
so make sure to serialize
and load your library next time


387
00:21:09,803 --> 00:21:11,471 line:-1
to save compilation time.


388
00:21:11,538 --> 00:21:15,108 line:-2
To help you adopt this API
and to work through a small example,


389
00:21:15,175 --> 00:21:19,880 line:-2
we've provided a sample Xcode project
available on developer.apple.com.


390
00:21:20,447 --> 00:21:22,149 line:-1
This sample uses a compute shader


391
00:21:22,216 --> 00:21:25,319 line:-2
to apply a full-screen
postprocessing effect.


392
00:21:25,385 --> 00:21:27,421 line:-2
The compute shader
calls in to a dynamic library


393
00:21:27,487 --> 00:21:28,856 line:-1
to determine the pixel color.


394
00:21:29,523 --> 00:21:32,492 line:-2
And at runtime,
we demonstrate how insertLibraries


395
00:21:32,559 --> 00:21:35,128 line:-2
can be used to change
which function it's linked against.


396
00:21:35,863 --> 00:21:38,165 line:-2
If you're interested
in running this code yourself,


397
00:21:38,232 --> 00:21:40,033 line:-1
head to developer.apple.com


398
00:21:40,100 --> 00:21:42,402 line:-2
and download
the Metal Dynamic Library sample.


399
00:21:43,370 --> 00:21:45,939 line:-2
We're really excited
to bring you these features.


400
00:21:46,006 --> 00:21:49,576 line:-2
Dynamic libraries allow you
to write reusable library code


401
00:21:49,643 --> 00:21:53,914 line:-2
without paying the cost in time or memory
of recompiling your utilities.


402
00:21:54,748 --> 00:21:57,017 line:-1
And, like Binary Archives,


403
00:21:57,084 --> 00:22:00,153 line:-2
dynamic libraries
are serializable and shippable.


404
00:22:01,388 --> 00:22:04,725 line:-2
In the sample code, we've demonstrated
how you can use dynamic libraries


405
00:22:04,791 --> 00:22:06,994 line:-1
to allow users to write their own methods


406
00:22:07,060 --> 00:22:09,997 line:-2
without requiring users to write
their own kernel entry points.


407
00:22:12,766 --> 00:22:16,136 line:-2
This feature is supported
this year in iOS and macOS.


408
00:22:16,203 --> 00:22:17,704 line:-1
Check the feature query on your device


409
00:22:17,771 --> 00:22:20,174 line:-2
to see if your GPU
supports dynamic libraries.


410
00:22:21,608 --> 00:22:24,144 line:-2
So far, we've talked about some
of the ways we're updating


411
00:22:24,211 --> 00:22:26,346 line:-1
our shader model in Metal this year.


412
00:22:26,413 --> 00:22:28,248 line:-1
In the final part of our talk,


413
00:22:28,315 --> 00:22:31,952 line:-2
we'll be discussing additional updates
to our off-line toolchains.


414
00:22:32,019 --> 00:22:33,187 line:-1
To help me cover this topic,


415
00:22:33,253 --> 00:22:35,556 line:-2
I'm going to hand you over
to my colleague, Ravi.


416
00:22:36,757 --> 00:22:39,059 line:-1
Thank you, Kyle, and hello everyone.


417
00:22:40,127 --> 00:22:44,131 line:-2
In the previous sections,
we heard about how to create and use


418
00:22:44,198 --> 00:22:48,502 line:-2
Binary Archives and dynamic libraries
using the Metal API.


419
00:22:49,102 --> 00:22:52,739 line:-2
I'm Ravi Ramaseshan
from the Metal Front-End Compiler Team,


420
00:22:53,407 --> 00:22:55,742 line:-2
and in this section
I'm going to talk to you


421
00:22:55,809 --> 00:22:59,079 line:-2
about how to create
and manipulate these objects


422
00:22:59,146 --> 00:23:01,615 line:-1
using the Metal Developer Tools.


423
00:23:03,450 --> 00:23:06,453 line:0
With a small code base,
you can put all your code


424
00:23:06,520 --> 00:23:09,857 line:0
into a couple of Metal files
and build a metallib


425
00:23:09,923 --> 00:23:12,759 line:0
using a command line
like the one shown below.


426
00:23:14,228 --> 00:23:17,564 line:0
As your code base grows,
you keep adding files


427
00:23:17,631 --> 00:23:18,999 line:0
to the same command line.


428
00:23:19,600 --> 00:23:22,302 line:0
But it becomes hard to track dependencies


429
00:23:22,369 --> 00:23:24,404 line:0
between all your shader sources.


430
00:23:26,340 --> 00:23:30,010 line:-2
To address this,
we are bringing libraries to Metal.


431
00:23:31,478 --> 00:23:33,780 line:-1
Libraries come in three flavors.


432
00:23:34,481 --> 00:23:38,252 line:0
The kind of metallibs
that you've been building up until now,


433
00:23:38,318 --> 00:23:41,054 line:0
the ones you use
to create your Metal functions


434
00:23:41,121 --> 00:23:43,724 line:0
are what we call executable metallibs.


435
00:23:45,425 --> 00:23:48,295 line:0
For your non-entry point or utility code,


436
00:23:48,362 --> 00:23:52,032 line:0
you can now create
static or dynamic libraries.


437
00:23:53,600 --> 00:23:55,602 line:-1
Along with Metal libraries,


438
00:23:55,669 --> 00:23:58,338 line:-1
we are also bringing more tools to Metal


439
00:23:58,405 --> 00:24:00,874 line:-1
which mimic the CPU toolchain.


440
00:24:01,642 --> 00:24:05,979 line:-2
All these tools together
form the Metal Developer Tools


441
00:24:06,046 --> 00:24:08,782 line:-2
which can be found
in your Xcode toolchain.


442
00:24:09,516 --> 00:24:11,351 line:-1
We'll see how to use these tools


443
00:24:11,418 --> 00:24:14,121 line:-2
to improve your shader
compilation workflows.


444
00:24:16,423 --> 00:24:19,526 line:0
To get started,
let's use the Metal compiler


445
00:24:19,593 --> 00:24:23,297 line:0
on our Metal sources to get
the corresponding AIR files


446
00:24:23,363 --> 00:24:25,098 line:0
using the command line below.


447
00:24:25,732 --> 00:24:27,167 line:0
With that out of the way...


448
00:24:27,868 --> 00:24:32,439 line:0
let's use a new tool in the toolchain,
metal-libtool,


449
00:24:32,506 --> 00:24:36,610 line:0
which like its CPU counterpart
is used to build libraries.


450
00:24:37,477 --> 00:24:41,048 line:0
The static option archives
all the AIR files together


451
00:24:41,114 --> 00:24:42,816 line:0
to build a static library.


452
00:24:44,818 --> 00:24:48,055 line:0
We'll then run the linker
through the Metal compiler


453
00:24:48,121 --> 00:24:51,225 line:0
to link the AIR files
with the static library


454
00:24:51,291 --> 00:24:53,894 line:0
to create our executable metallibs.


455
00:24:55,095 --> 00:24:58,131 line:0
The lowercase "L" option
followed by a name


456
00:24:58,198 --> 00:25:01,635 line:0
is how you get the linker
to link against your library.


457
00:25:03,670 --> 00:25:06,607 line:0
You can also use the uppercase "L" option


458
00:25:06,673 --> 00:25:11,945 line:0
to get the linker to search directories
in addition to the default system paths.


459
00:25:14,414 --> 00:25:16,683 line:-1
The way to think about static linking


460
00:25:16,750 --> 00:25:19,353 line:-1
is that each of your executable metallibs


461
00:25:19,419 --> 00:25:22,556 line:-1
has a copy of the static library.


462
00:25:22,623 --> 00:25:24,424 line:-1
This has a few implications.


463
00:25:25,859 --> 00:25:31,031 line:-2
On the bright side, your metallibs
are self-contained and easy to deploy


464
00:25:31,098 --> 00:25:33,767 line:-1
since they have no runtime dependencies.


465
00:25:34,468 --> 00:25:36,837 line:-1
Also, the compiler and linker


466
00:25:36,904 --> 00:25:41,074 line:-2
have access to the concrete
implementations of your library,


467
00:25:41,141 --> 00:25:44,011 line:-2
so they can perform
link-time-optimizations,


468
00:25:44,077 --> 00:25:47,714 line:-2
resulting in potentially
smaller and faster code.


469
00:25:49,716 --> 00:25:53,187 line:-2
On the downside,
you may be duplicating the library


470
00:25:53,253 --> 00:25:58,091 line:-2
into each of your metallibs,
resulting in a larger app bundle.


471
00:25:58,158 --> 00:26:01,762 line:-2
Fortunately, dynamic linking
is a powerful mechanism


472
00:26:01,828 --> 00:26:03,363 line:-1
to address this problem.


473
00:26:04,565 --> 00:26:07,935 line:0
To create dynamic libraries,
we'll invoke the linker


474
00:26:08,001 --> 00:26:10,137 line:0
by using the dynamiclib option.


475
00:26:11,438 --> 00:26:13,874 line:0
The install_name option to the linker


476
00:26:13,941 --> 00:26:18,145 line:0
is the toolchain counterpart
of the Metal API you saw earlier.


477
00:26:19,079 --> 00:26:22,216 line:0
The install name is recorded
into the metallib


478
00:26:22,282 --> 00:26:25,052 line:0
for the loader to find
the library at runtime.


479
00:26:27,087 --> 00:26:31,592 line:0
Now, we'll link the utility library
with our AIR files


480
00:26:31,658 --> 00:26:33,794 line:0
to get our executable metallibs.


481
00:26:34,595 --> 00:26:35,963 line:0
With dynamic linking,


482
00:26:36,029 --> 00:26:40,634 line:0
the utility library does not get copied
into the executable metallibs,


483
00:26:40,701 --> 00:26:44,671 line:0
but instead has to be deployed
on the target system separately.


484
00:26:45,739 --> 00:26:49,476 line:-2
Let's see how the loader finds
the dynamic library at runtime.


485
00:26:51,678 --> 00:26:54,181 line:0
It starts when you build the library.


486
00:26:54,848 --> 00:26:58,051 line:0
The linker uses
the install name of the dylib


487
00:26:58,118 --> 00:27:01,989 line:0
to embed a load command
into the resulting metallib.


488
00:27:02,856 --> 00:27:07,327 line:0
Think of it as a reference to the dylib
that this metallib depends on.


489
00:27:08,495 --> 00:27:13,767 line:0
The load command is how the loader locates
and loads the dylib at runtime.


490
00:27:15,269 --> 00:27:17,604 line:0
You can have multiple
of these load commands


491
00:27:17,671 --> 00:27:20,307 line:0
if you link with more than one library.


492
00:27:22,142 --> 00:27:26,113 line:0
Finally, let's revisit
the install_name option we used


493
00:27:26,180 --> 00:27:30,317 line:0
when building our dylib and see
how a couple of special names work.


494
00:27:31,718 --> 00:27:35,722 line:0
Let's assume that libUtility
depends on another dylib


495
00:27:35,789 --> 00:27:39,493 line:0
and focus on how the loader
resolves these special names


496
00:27:39,560 --> 00:27:41,862 line:0
in the load command for libUtility.


497
00:27:43,964 --> 00:27:49,136 line:0
At runtime, the loader finds the library
to be loaded using the install name,


498
00:27:49,203 --> 00:27:51,772 line:0
but replaces @loader_path


499
00:27:51,839 --> 00:27:55,108 line:0
with the path of the metallib
containing the load command.


500
00:27:57,110 --> 00:27:59,947 line:0
Metal also supports @executable_path


501
00:28:00,013 --> 00:28:03,750 line:0
which the loader resolves
to the path of the executable metallib


502
00:28:03,817 --> 00:28:05,853 line:0
containing the entry point function.


503
00:28:06,520 --> 00:28:09,790 line:0
You can probably see
that for executable metallibs


504
00:28:09,857 --> 00:28:13,260 line:0
both these special names
resolve to the same location.


505
00:28:15,662 --> 00:28:18,432 line:-2
Through load commands,
each of your metallibs


506
00:28:18,498 --> 00:28:21,001 line:-1
record only a reference to the dylib.


507
00:28:21,635 --> 00:28:24,972 line:-2
Binding an implementation
of the symbol to its reference


508
00:28:25,038 --> 00:28:27,040 line:-1
is done at runtime by the loader.


509
00:28:27,975 --> 00:28:30,077 line:-1
This, too, has some implications.


510
00:28:31,745 --> 00:28:34,848 line:-2
On the positive side,
using dynamic libraries


511
00:28:34,915 --> 00:28:38,285 line:-2
solves the duplication problem
we saw with static libraries.


512
00:28:39,286 --> 00:28:43,690 line:-2
The downside is that at runtime,
the dylib needs to exist


513
00:28:43,757 --> 00:28:46,293 line:-1
for your executable metallibs to work


514
00:28:46,360 --> 00:28:49,129 line:-1
and the loader must be able to find it.


515
00:28:50,564 --> 00:28:53,567 line:-2
Since libraries can be written
by multiple authors,


516
00:28:53,634 --> 00:28:57,671 line:-2
you run the risk of name collisions
between the libraries.


517
00:28:58,338 --> 00:29:01,975 line:-2
Like in this example,
the two libraries unintentionally export


518
00:29:02,042 --> 00:29:03,911 line:-1
the same symbol calculate.


519
00:29:05,179 --> 00:29:11,084 line:-2
The expected behavior was for each library
to use its own calculate function.


520
00:29:11,618 --> 00:29:13,487 line:-1
In fact, with static linking,


521
00:29:13,554 --> 00:29:16,023 line:-2
you would've gotten
an error at build time.


522
00:29:17,424 --> 00:29:19,760 line:-1
However, with dynamic linking,


523
00:29:19,826 --> 00:29:24,298 line:-2
the loader just picks one definition
and binds all references to it.


524
00:29:26,233 --> 00:29:27,301 line:-1
Because of this,


525
00:29:27,367 --> 00:29:31,505 line:-2
you may only get an incorrect result
observed at runtime


526
00:29:31,572 --> 00:29:33,707 line:-1
and can be quite hard to track down.


527
00:29:34,608 --> 00:29:39,046 line:-2
So, why does the calculate function
participate in dynamic linking?


528
00:29:39,746 --> 00:29:43,617 line:-2
That's because, just like
with the CPU compiler and linker,


529
00:29:43,684 --> 00:29:47,821 line:-2
by default, Metal exports
all the symbols in your library.


530
00:29:49,857 --> 00:29:53,660 line:-2
You can quickly check the symbols
in your library using metal-nm,


531
00:29:54,161 --> 00:29:56,530 line:-1
which, like its CPU counterpart,


532
00:29:56,597 --> 00:30:01,268 line:-2
let's you inspect the names of the symbols
that are exported by your metallib.


533
00:30:02,236 --> 00:30:07,541 line:-2
The question then is, how do we control
what symbols are exported by our library.


534
00:30:08,976 --> 00:30:13,180 line:-2
Just like on the CPU side,
you can use the static keyword,


535
00:30:13,247 --> 00:30:16,717 line:-2
anonymous namespaces
and the visibility attributes


536
00:30:16,783 --> 00:30:20,387 line:-2
to control which symbols
are exported by your library.


537
00:30:22,322 --> 00:30:27,528 line:-2
It's also a good idea to use namespaces
when defining your interfaces.


538
00:30:28,495 --> 00:30:33,200 line:0
And finally, we support
the exported_symbols_list linker option.


539
00:30:34,601 --> 00:30:37,538 line:-2
For more details,
there's some great documentation


540
00:30:37,604 --> 00:30:40,807 line:-2
on our developer website
on dynamic libraries.


541
00:30:43,043 --> 00:30:46,680 line:-2
The other exciting concept
that we introduced to you earlier


542
00:30:46,747 --> 00:30:50,784 line:-2
was harvesting fully compiled binaries
from the device.


543
00:30:51,919 --> 00:30:56,790 line:-2
We have harvested such a metallib
for libUtility on an A13 device


544
00:30:56,857 --> 00:31:00,294 line:-2
using the Metal API that we saw
in the previous section.


545
00:31:01,895 --> 00:31:05,899 line:-2
To work with such objects,
there's a new tool called metal-lipo.


546
00:31:06,500 --> 00:31:09,303 line:-2
Let's use it to peek
into what's in the metallib


547
00:31:09,369 --> 00:31:12,439 line:-2
that we just harvested
using the info option.


548
00:31:13,507 --> 00:31:17,311 line:-2
The tool reports that this metallib
contains two architectures.


549
00:31:18,011 --> 00:31:23,550 line:-2
The way to think about that
is it is a fat binary that really contains


550
00:31:23,617 --> 00:31:26,320 line:-1
two independent metallibs called "slices."


551
00:31:27,020 --> 00:31:32,192 line:-2
The A13 slice, which is back-end compiled
and the generic AIR slice.


552
00:31:33,794 --> 00:31:38,265 line:-2
When the harvested metallib
is deployed on non-A13 devices,


553
00:31:38,332 --> 00:31:42,469 line:-2
Metal will use the AIR slice,
just as it does today.


554
00:31:42,536 --> 00:31:45,506 line:-2
That means spinning up
the Metal Compiler Service


555
00:31:45,572 --> 00:31:47,441 line:-1
and invoking the back-end compiler


556
00:31:47,508 --> 00:31:49,109 line:-1
to build your pipeline.


557
00:31:49,977 --> 00:31:53,947 line:-2
This allows the metallib
to be used on all iOS devices,


558
00:31:54,014 --> 00:31:56,283 line:-1
not just A13-based ones.


559
00:31:57,951 --> 00:31:59,953 line:-1
However, if the same metallib


560
00:32:00,020 --> 00:32:02,523 line:-1
is downloaded on an A13 device,


561
00:32:02,589 --> 00:32:06,960 line:-2
Metal will use the A13 slice,
skip back-end compilation completely


562
00:32:07,027 --> 00:32:10,264 line:-2
and potentially improve
your app-loading performance.


563
00:32:12,266 --> 00:32:16,770 line:-2
Now, let's say you want to improve
the experience of your app users


564
00:32:16,837 --> 00:32:19,239 line:-1
that are also on A12 devices.


565
00:32:20,440 --> 00:32:25,579 line:-2
Besides the A13 device, let's also
harvest a metallib from an A12 device.


566
00:32:26,780 --> 00:32:29,149 line:-1
To simplify your app deployment,


567
00:32:29,216 --> 00:32:33,453 line:-2
you might want to bundle
all the slices into a single metallib.


568
00:32:34,555 --> 00:32:37,257 line:-1
Metal-lipo allows you to do just that


569
00:32:37,324 --> 00:32:40,894 line:-2
and create an even fatter
universal binary.


570
00:32:41,695 --> 00:32:45,699 line:0
This technique can even be used
with Binary Archives.


571
00:32:46,366 --> 00:32:50,037 line:0
Obviously, the more slices
that you pack into your binary,


572
00:32:50,103 --> 00:32:52,506 line:0
the larger your app bundle becomes.


573
00:32:52,573 --> 00:32:56,243 line:0
So keep that in mind when deciding
which slices you want to pack


574
00:32:56,310 --> 00:32:58,045 line:0
into your universal binary.


575
00:32:59,980 --> 00:33:02,349 line:-1
So, let's do a quick recap


576
00:33:02,416 --> 00:33:04,718 line:-2
of the different workflows
we have seen today.


577
00:33:05,485 --> 00:33:07,988 line:-1
We started by using the Metal compiler


578
00:33:08,055 --> 00:33:10,757 line:-1
to turn our Metal sources into AIR files.


579
00:33:11,892 --> 00:33:16,296 line:-2
We then used metal-libtool
to create static libraries,


580
00:33:16,363 --> 00:33:20,801 line:-2
a new workflow to replace
your existing Metal AR-based one.


581
00:33:22,169 --> 00:33:26,240 line:-2
We then built a new kind of metallib,
a dynamic library.


582
00:33:27,274 --> 00:33:32,212 line:-2
We also saw how to combine
AIR, static and dynamic libraries


583
00:33:32,279 --> 00:33:34,715 line:-1
to create executable metallibs.


584
00:33:35,916 --> 00:33:39,119 line:-1
Along the way, we also saw using metal-nm


585
00:33:39,186 --> 00:33:42,556 line:-2
to inspect the symbols
exported by a metallib.


586
00:33:43,524 --> 00:33:46,193 line:-1
And finally, we used metal-lipo


587
00:33:46,260 --> 00:33:49,696 line:-2
to work with slices
in our harvested metallibs.


588
00:33:51,298 --> 00:33:53,300 line:-1
The last thing we want to show you


589
00:33:53,367 --> 00:33:57,204 line:-2
is a use case shared to us
by some of our game developers.


590
00:33:57,871 --> 00:34:00,474 line:-2
Here's a high-level view
of their workflow.


591
00:34:01,975 --> 00:34:05,279 line:-2
As you can see,
they use a variety of tools,


592
00:34:05,345 --> 00:34:10,184 line:-2
including the CPU and GPU toolchains,
to build the app bundle.


593
00:34:11,985 --> 00:34:13,253 line:-1
In some cases,


594
00:34:13,320 --> 00:34:16,089 line:-2
developers have pooled
their machines together


595
00:34:16,156 --> 00:34:19,659 line:-2
into a server farm that they use
to build their assets.


596
00:34:20,527 --> 00:34:26,400 line:-2
This workflow works great
as long as these tools run on macOS.


597
00:34:27,301 --> 00:34:30,103 line:-1
However, some of these developers


598
00:34:30,170 --> 00:34:34,308 line:-2
have established game and graphic
asset creation pipelines


599
00:34:34,373 --> 00:34:37,543 line:-2
that are based
on Microsoft Windows infrastructure.


600
00:34:39,179 --> 00:34:44,051 line:-2
In order to support these developers,
this year we are introducing


601
00:34:44,117 --> 00:34:47,020 line:-1
the Metal Developer Tools on Windows.


602
00:34:48,088 --> 00:34:51,024 line:-2
With this, you will now
have the flexibility


603
00:34:51,091 --> 00:34:54,393 line:-2
to build your metallibs
targeting Apple platforms


604
00:34:54,460 --> 00:34:58,265 line:-2
from macOS, Windows
or even a hybrid setup.


605
00:35:00,200 --> 00:35:02,836 line:-2
The tools are available
as a Windows Installer


606
00:35:02,903 --> 00:35:06,607 line:-2
and can be downloaded
from the Apple developer website today.


607
00:35:07,975 --> 00:35:12,145 line:-2
All the workflows that are supported
by the toolchain we release with Xcode


608
00:35:12,212 --> 00:35:15,315 line:-2
are also supported
by the Windows-hosted tools.


609
00:35:17,251 --> 00:35:19,786 line:-1
That brings us to the end of this session.


610
00:35:19,853 --> 00:35:21,788 line:-1
Let's recap what we covered here.


611
00:35:22,689 --> 00:35:25,392 line:-1
We introduced you to Binary Archives,


612
00:35:25,459 --> 00:35:27,394 line:-1
a mechanism which you can employ


613
00:35:27,461 --> 00:35:30,397 line:-2
to avoid spending time
on back-end compilation


614
00:35:30,464 --> 00:35:32,599 line:-1
for some of your critical pipelines.


615
00:35:34,034 --> 00:35:37,204 line:-2
We then presented
dynamic libraries in Metal


616
00:35:37,271 --> 00:35:39,406 line:-1
as an efficient and flexible way


617
00:35:39,473 --> 00:35:42,543 line:-2
to decouple your library code
from your shaders.


618
00:35:44,244 --> 00:35:49,283 line:-2
And finally, we went over some new
and important compilation workflows


619
00:35:49,349 --> 00:35:52,352 line:-2
by directly using
the Metal Developer Tools.


620
00:35:53,754 --> 00:35:58,458 line:-2
We hope this presentation gets you started
with adopting the new compilation model


621
00:35:58,525 --> 00:36:00,994 line:-1
for your new and existing workflows.


622
00:36:02,763 --> 00:36:07,134 line:-2
Thanks for watching this session,
and enjoy the rest of WWDC.

