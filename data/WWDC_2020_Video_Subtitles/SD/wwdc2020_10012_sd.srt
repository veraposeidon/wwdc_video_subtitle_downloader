1
00:00:03,871 --> 00:00:06,939 line:-1
Hello and welcome to WWDC.


2
00:00:07,774 --> 00:00:11,612 line:0
Hi. My name is Sean James,
and I'm a GPU Software Engineer.


3
00:00:11,678 --> 00:00:13,180 line:0
In this session, we're going to talk about


4
00:00:13,247 --> 00:00:16,783 line:0
the brand new ray tracing API
we've added to Metal this year.


5
00:00:16,850 --> 00:00:19,686 line:-2
This new API allows you
to perform intersection testing


6
00:00:19,753 --> 00:00:22,556 line:-1
directly from within any compute kernel.


7
00:00:22,623 --> 00:00:24,758 line:-2
It also allows you to write
intersection functions


8
00:00:24,825 --> 00:00:27,027 line:-1
to customize the intersection process.


9
00:00:27,995 --> 00:00:31,331 line:-2
Ray tracing applications are based on
tracing the paths that rays take


10
00:00:31,398 --> 00:00:33,200 line:-1
as they interact with a scene.


11
00:00:33,901 --> 00:00:36,136 line:-2
Ray tracing has applications
in a lot of domains


12
00:00:36,203 --> 00:00:38,372 line:-1
such as audio and physics simulation,


13
00:00:38,438 --> 00:00:41,975 line:-2
but one of the most popular applications
is photo-realistic rendering.


14
00:00:42,042 --> 00:00:46,446 line:-2
In rendering, ray tracing is used to model
individual rays of light,


15
00:00:46,513 --> 00:00:49,650 line:-2
so we can simulate effects
such as reflections, soft shadows,


16
00:00:49,716 --> 00:00:51,652 line:-1
indirect lighting, and more.


17
00:00:51,718 --> 00:00:54,021 line:-1
Let's first review how ray tracing works,


18
00:00:54,087 --> 00:00:56,356 line:-2
then we'll look at
the new Metal ray tracing API.


19
00:00:58,492 --> 00:00:59,993 line:-1
We start by generating rays


20
00:01:00,060 --> 00:01:03,130 line:-2
which are emitted from the camera
into the scene.


21
00:01:03,197 --> 00:01:07,334 line:-2
We then test those rays for intersection
with the geometry in the scene.


22
00:01:07,401 --> 00:01:11,071 line:-2
Each intersection point
represents light bouncing off a surface.


23
00:01:11,638 --> 00:01:13,941 line:-2
How much light bounces,
and in what direction,


24
00:01:14,007 --> 00:01:15,843 line:-1
determines what objects look like.


25
00:01:16,376 --> 00:01:20,280 line:-2
So we'll compute a color for each
intersection point and update the image.


26
00:01:20,347 --> 00:01:21,882 line:-1
This process is called shading,


27
00:01:21,949 --> 00:01:25,886 line:-2
and it can also generate additional rays
which bounce further into the scene.


28
00:01:26,486 --> 00:01:28,422 line:-2
We test those rays
for intersection as well


29
00:01:28,488 --> 00:01:30,757 line:-2
and repeat this process
as many times as we'd like


30
00:01:30,824 --> 00:01:33,260 line:-2
to simulate light
bouncing around the scene.


31
00:01:33,327 --> 00:01:36,096 line:-2
For the last two years, we've talked about
how you can do this using


32
00:01:36,163 --> 00:01:38,065 line:-1
the Metal Performance Shaders framework.


33
00:01:38,131 --> 00:01:42,035 line:-2
We start by launching a compute kernel
which generates the initial set of rays


34
00:01:42,102 --> 00:01:43,937 line:-1
and writes them into a Metal buffer.


35
00:01:44,004 --> 00:01:46,607 line:-2
We can then use
the MPSRayIntersector class


36
00:01:46,673 --> 00:01:48,775 line:-1
to intersect those rays with the scene.


37
00:01:49,543 --> 00:01:52,646 line:-2
The intersector writes the intersection
results into another buffer.


38
00:01:53,280 --> 00:01:55,115 line:-1
We can then launch a final compute kernel


39
00:01:55,182 --> 00:01:58,018 line:-2
which reads those intersections
and does the shading.


40
00:01:58,585 --> 00:02:01,288 line:-2
Additional rays can be written
back into the ray buffer,


41
00:02:01,355 --> 00:02:03,624 line:-2
and we can launch
these two compute kernels in a loop


42
00:02:03,690 --> 00:02:04,992 line:-1
to simulate light bouncing.


43
00:02:05,058 --> 00:02:06,226 line:-1
This works great,


44
00:02:06,293 --> 00:02:10,062 line:-2
but it requires us to split up our code
into three separate compute kernels.


45
00:02:10,564 --> 00:02:13,934 line:-2
It also requires us to pass rays
and intersections through memory.


46
00:02:14,001 --> 00:02:17,004 line:-2
In contrast,
in the new Metal ray tracing API,


47
00:02:17,070 --> 00:02:20,641 line:-2
this intersector object is now available
directly from the shading language.


48
00:02:21,975 --> 00:02:23,911 line:-2
This allows us to combine
all three kernels


49
00:02:23,977 --> 00:02:26,079 line:-1
into a single compute kernel.


50
00:02:26,146 --> 00:02:28,916 line:-2
Since we don't need to pass ray data
between kernels anymore,


51
00:02:28,982 --> 00:02:31,785 line:-2
we can also eliminate
the ray and intersection buffers.


52
00:02:33,153 --> 00:02:35,255 line:-2
This removes the need to read
and write memory


53
00:02:35,322 --> 00:02:37,824 line:-1
to pass rays and intersections around.


54
00:02:37,891 --> 00:02:40,561 line:-2
This is also a much more flexible
programming model.


55
00:02:40,627 --> 00:02:43,964 line:-2
For example, instead of launching
compute kernels over and over,


56
00:02:44,031 --> 00:02:47,501 line:-2
the outer loop can be represented
by a simple loop in the shading language.


57
00:02:48,202 --> 00:02:50,604 line:-2
Let's see how
a basic ray tracing kernel works.


58
00:02:51,438 --> 00:02:53,340 line:-2
We'll launch
a two-dimensional compute kernel


59
00:02:53,407 --> 00:02:55,209 line:-1
with one thread per pixel.


60
00:02:55,742 --> 00:02:57,377 line:-1
We start by generating a ray.


61
00:02:57,444 --> 00:03:01,515 line:-2
This is just some math which produces
the initial ray for the given pixel.


62
00:03:01,582 --> 00:03:04,117 line:-1
We then create an intersector object.


63
00:03:04,184 --> 00:03:06,620 line:-2
This object is responsible
for finding intersections


64
00:03:06,687 --> 00:03:09,456 line:-2
between rays
and the geometry in the scene.


65
00:03:09,523 --> 00:03:13,560 line:-2
We can set various properties
on this object to customize its behavior.


66
00:03:13,627 --> 00:03:17,764 line:-2
For example, we can speed up cases
such as shadows and ambient occlusion


67
00:03:17,831 --> 00:03:19,399 line:-1
by accepting the first intersection


68
00:03:19,466 --> 00:03:22,269 line:-2
rather than exhaustively searching
for the closest one.


69
00:03:22,336 --> 00:03:26,006 line:0
We then pass the ray to the intersector
and get back an intersection result.


70
00:03:26,540 --> 00:03:30,377 line:0
Finally, we can use the intersection
result to perform shading.


71
00:03:30,444 --> 00:03:33,747 line:-2
Keep in mind that the intersection step
needs to do a lot of work,


72
00:03:33,814 --> 00:03:35,916 line:-2
so if you combine it
with complex shading code,


73
00:03:35,983 --> 00:03:39,586 line:-2
you may end up with a compute kernel
that runs at lower occupancy.


74
00:03:39,653 --> 00:03:43,090 line:-2
You'll need to profile your application
to find the best way to divide up work


75
00:03:43,156 --> 00:03:45,058 line:-1
between kernels for your application.


76
00:03:45,125 --> 00:03:48,028 line:-2
That's all we need to do
for basic intersection testing.


77
00:03:48,896 --> 00:03:50,631 line:-2
The other argument
to the intersect function


78
00:03:50,697 --> 00:03:52,032 line:-1
is an acceleration structure.


79
00:03:53,000 --> 00:03:54,067 line:-1
Acceleration structures


80
00:03:54,134 --> 00:03:57,638 line:-2
are data structures used to speed up
the ray tracing process.


81
00:03:57,704 --> 00:04:00,507 line:-2
These data structures
recursively partition space


82
00:04:00,574 --> 00:04:02,442 line:-1
so that we can quickly eliminate triangles


83
00:04:02,509 --> 00:04:04,811 line:-2
which could not
possibly intersect a given ray.


84
00:04:05,746 --> 00:04:09,483 line:-2
Like MPS, Metal takes care
of building this data structure for you.


85
00:04:09,550 --> 00:04:11,785 line:-2
All you need to do
is provide your geometry.


86
00:04:11,852 --> 00:04:12,853 line:-1
Here's how that works.


87
00:04:13,287 --> 00:04:15,389 line:-2
First, we need to create
a descriptor object


88
00:04:15,455 --> 00:04:18,591 line:-2
which describes
the acceleration structure to build.


89
00:04:18,659 --> 00:04:22,229 line:-2
Next, we need to allocate memory
to store the acceleration structure.


90
00:04:22,296 --> 00:04:24,898 line:-2
And finally,
we build the acceleration structure.


91
00:04:25,933 --> 00:04:27,401 line:-1
Let's start with the descriptor.


92
00:04:27,835 --> 00:04:30,771 line:-2
Metal supports
two types of acceleration structure:


93
00:04:30,838 --> 00:04:33,974 line:-2
primitive and instance
acceleration structures.


94
00:04:34,041 --> 00:04:37,344 line:-2
For this example, we'll create
a primitive acceleration structure.


95
00:04:37,411 --> 00:04:40,981 line:-2
As the name implies, these contain
primitives such as triangles.


96
00:04:41,048 --> 00:04:42,482 line:-1
Primitive acceleration structures


97
00:04:42,549 --> 00:04:44,751 line:-2
are composed of
individual pieces of geometry.


98
00:04:46,353 --> 00:04:50,858 line:-2
Metal also supports two types of geometry,
but for now, we'll focus on triangles.


99
00:04:50,924 --> 00:04:52,459 line:-1
Each piece of triangle geometry


100
00:04:52,526 --> 00:04:56,597 line:-2
can have its own vertex buffer,
index buffer, triangle count, and so on.


101
00:04:57,064 --> 00:05:00,868 line:-2
We start by creating a primitive
acceleration structure descriptor.


102
00:05:00,934 --> 00:05:03,170 line:-1
Next, we'll create a geometry descriptor.


103
00:05:03,237 --> 00:05:06,773 line:-2
In this example, we'll just create
a single triangle geometry descriptor.


104
00:05:07,674 --> 00:05:11,178 line:-2
Then we'll attach our vertex buffer
and specify the triangle count.


105
00:05:11,245 --> 00:05:14,748 line:-2
The triangle data will be embedded
into the acceleration structure,


106
00:05:14,815 --> 00:05:17,251 line:-2
so it's not necessary
to keep the vertex buffer around


107
00:05:17,317 --> 00:05:19,720 line:-2
once we've built
the acceleration structure.


108
00:05:19,786 --> 00:05:21,688 line:-1
We then simply add the geometry descriptor


109
00:05:21,755 --> 00:05:24,825 line:-2
to an array on
the acceleration structure descriptor.


110
00:05:24,892 --> 00:05:26,460 line:-1
Now that we've created the descriptor,


111
00:05:26,527 --> 00:05:29,229 line:-2
we can allocate memory
for the acceleration structure.


112
00:05:29,296 --> 00:05:32,199 line:-2
These are potentially
large memory allocations.


113
00:05:32,266 --> 00:05:35,802 line:-2
One of the improvements we've made
in the new Metal ray tracing API


114
00:05:35,869 --> 00:05:38,605 line:-2
is that Metal gives you full control
over when and where


115
00:05:38,672 --> 00:05:41,108 line:-1
acceleration structures are allocated.


116
00:05:41,175 --> 00:05:42,643 line:-1
This means you can reuse memory


117
00:05:42,709 --> 00:05:45,779 line:-2
or allocate it at a time
that's convenient for your application.


118
00:05:46,647 --> 00:05:48,782 line:-2
We start by calling a method
on the Metal device


119
00:05:48,849 --> 00:05:51,118 line:-2
which returns a struct
containing the sizes we need


120
00:05:51,185 --> 00:05:53,287 line:-1
to allocate the acceleration structure.


121
00:05:54,054 --> 00:05:56,323 line:-2
Next, we'll actually allocate
the acceleration structure


122
00:05:56,390 --> 00:05:57,791 line:-1
from the Metal device.


123
00:05:58,559 --> 00:06:01,795 line:-2
Finally, we'll also need to allocate
a scratch buffer.


124
00:06:01,862 --> 00:06:04,464 line:-2
This buffer will be used by Metal
as temporary storage


125
00:06:04,531 --> 00:06:06,800 line:-1
while building the acceleration structure,


126
00:06:06,867 --> 00:06:08,936 line:-1
and we can throw it away once we're done.


127
00:06:09,002 --> 00:06:11,338 line:-2
We won't need access to the data
in this buffer,


128
00:06:11,405 --> 00:06:13,407 line:-2
so we'll use
the private resource storage mode


129
00:06:13,473 --> 00:06:15,309 line:-1
to get the best performance.


130
00:06:15,375 --> 00:06:17,945 line:-2
We've now allocated memory
for the acceleration structure,


131
00:06:18,011 --> 00:06:19,947 line:-1
but it hasn't actually been built yet.


132
00:06:20,013 --> 00:06:22,850 line:-2
So, the final step
is to build the acceleration structure.


133
00:06:24,251 --> 00:06:26,086 line:-1
We've also made some improvements here.


134
00:06:26,820 --> 00:06:29,022 line:-2
Building acceleration structures
can take some time,


135
00:06:29,089 --> 00:06:31,925 line:-2
so Metal now gives you full control
over when they are built,


136
00:06:31,992 --> 00:06:35,662 line:-2
including which GPU command queue
and command buffer they're built on.


137
00:06:36,396 --> 00:06:38,031 line:-1
First, we'll create a command buffer


138
00:06:38,098 --> 00:06:42,202 line:-2
and, from it, one of the new
AccelerationStructureCommandEncoders.


139
00:06:42,269 --> 00:06:43,837 line:-1
Like the other Metal encoders,


140
00:06:43,904 --> 00:06:46,673 line:-2
this object is used
to schedule work on the GPU.


141
00:06:46,740 --> 00:06:49,710 line:-2
In this case, we'll encode
the actual build command,


142
00:06:49,776 --> 00:06:53,247 line:-2
providing the descriptor,
acceleration structure and scratch buffer.


143
00:06:54,715 --> 00:06:57,951 line:0
Finally, we end encoding
and commit the command buffer.


144
00:06:58,018 --> 00:07:01,788 line:0
This allows the GPU to get started
building the acceleration structure.


145
00:07:02,289 --> 00:07:06,226 line:-2
Acceleration structure builds
now run entirely on the GPU timeline


146
00:07:06,293 --> 00:07:08,428 line:-1
with no CPU synchronization,


147
00:07:08,495 --> 00:07:12,699 line:-2
so it's safe to schedule intersection work
on the GPU after this command buffer.


148
00:07:13,467 --> 00:07:16,470 line:0
We've actually already seen
how to use an acceleration structure.


149
00:07:16,537 --> 00:07:19,006 line:0
We simply pass it to the intersector.


150
00:07:19,072 --> 00:07:21,141 line:0
As you can see,
acceleration structures bind


151
00:07:21,208 --> 00:07:23,844 line:0
to normal Metal buffer binding points.


152
00:07:23,911 --> 00:07:25,112 line:0
And there's a corresponding method


153
00:07:25,179 --> 00:07:27,614 line:0
on the compute command encoder
and argument encoder


154
00:07:27,681 --> 00:07:30,751 line:0
to bind acceleration structures
to these binding points.


155
00:07:30,817 --> 00:07:34,655 line:-2
So that's it for the basic building blocks
of the new Metal ray tracing API.


156
00:07:35,422 --> 00:07:38,759 line:-2
There are a few more advanced topics
we didn't have time to cover today,


157
00:07:38,825 --> 00:07:41,962 line:-2
so I'd encourage you to check out
our documentation and sample code.


158
00:07:42,596 --> 00:07:45,999 line:-2
I'd also like to encourage you to review
the previous two ray tracing talks


159
00:07:46,066 --> 00:07:47,634 line:-1
since many of the concepts are the same.


160
00:07:48,235 --> 00:07:51,672 line:-2
For example, like MPS,
Metal acceleration structures


161
00:07:51,738 --> 00:07:55,475 line:-2
support two-level instancing
of primitive acceleration structures,


162
00:07:55,542 --> 00:07:57,878 line:-1
which can be used to reduce memory usage.


163
00:07:57,945 --> 00:08:01,114 line:-2
Metal also supports refitting
existing acceleration structures,


164
00:08:01,181 --> 00:08:04,952 line:-2
which can be combined with instancing
to support dynamic geometry.


165
00:08:05,018 --> 00:08:08,922 line:-2
Finally, Metal acceleration structures
also support compaction,


166
00:08:08,989 --> 00:08:11,658 line:-2
which can be used to reclaim
significant amounts of memory


167
00:08:11,725 --> 00:08:14,394 line:-2
once an acceleration structure
has been built.


168
00:08:14,461 --> 00:08:15,829 line:-1
Next, we're going to talk about how


169
00:08:15,896 --> 00:08:19,499 line:-2
you can customize the intersection process
using intersection functions.


170
00:08:19,566 --> 00:08:22,503 line:-2
But first, let's see a demo
of everything we've covered so far.


171
00:08:28,108 --> 00:08:30,944 line:-2
This is an application
built by our Advanced Content Team


172
00:08:31,011 --> 00:08:33,480 line:-2
which demonstrates
the new Metal ray tracing API


173
00:08:33,547 --> 00:08:35,414 line:-1
applied to a complex scene.


174
00:08:36,082 --> 00:08:38,751 line:-2
What we're looking at now
is an interactive preview of the scene


175
00:08:38,818 --> 00:08:44,658 line:-2
recorded on a Mac Pro
with the new AMD Radeon Pro W5700X GPU.


176
00:08:45,492 --> 00:08:47,127 line:-1
The interactive preview is noisy


177
00:08:47,194 --> 00:08:49,663 line:-2
because we're only using
a single sample per pixel,


178
00:08:49,730 --> 00:08:52,399 line:-2
but it starts to converge
when the camera stops moving.


179
00:08:54,201 --> 00:08:57,271 line:-2
This is the way an artist
would see the scene while editing it.


180
00:08:57,337 --> 00:08:59,139 line:-1
For high-quality off-line rendering,


181
00:08:59,206 --> 00:09:03,243 line:-2
we would give each frame plenty of time
to converge to a noise-free image.


182
00:09:03,310 --> 00:09:05,512 line:-2
To give you a sense of
what the final result would look like,


183
00:09:05,579 --> 00:09:07,848 line:-2
we've rendered out
a fly-through of the scene


184
00:09:07,915 --> 00:09:09,950 line:-1
using 400 samples per pixel.


185
00:09:12,419 --> 00:09:15,889 line:-2
Special thanks to Quixel
for the use of their Megascans library.


186
00:09:15,956 --> 00:09:18,292 line:-2
This scene was assembled
from Megascans assets


187
00:09:18,358 --> 00:09:20,627 line:-1
and has over 32 million triangles.


188
00:09:23,130 --> 00:09:27,167 line:-2
The application works very similarly
to the outline I described earlier.


189
00:09:27,234 --> 00:09:30,971 line:-2
Using a rendering algorithm called
path tracing to simulate advanced effects


190
00:09:31,038 --> 00:09:34,641 line:-2
such as soft shadows, depth of field,
and indirect lighting.


191
00:09:40,447 --> 00:09:42,950 line:-2
We've now seen
the new Metal ray tracing API


192
00:09:43,016 --> 00:09:46,486 line:-2
in both an interactive application
and a full off-line renderer.


193
00:09:46,553 --> 00:09:49,890 line:-2
Next, let's move on
to one of the most exciting new features


194
00:09:49,957 --> 00:09:52,693 line:-2
of the new Metal API:
intersection functions.


195
00:09:52,759 --> 00:09:54,962 line:-1
So far, our programming model has been


196
00:09:55,028 --> 00:09:58,165 line:-2
that rays go in to the intersector
and intersections come out.


197
00:09:58,232 --> 00:10:01,001 line:-2
But the intersector
has always been a black box.


198
00:10:01,068 --> 00:10:03,604 line:-2
But there are actually a few cases
where you would want to customize


199
00:10:03,670 --> 00:10:05,138 line:-1
how the intersector works.


200
00:10:06,640 --> 00:10:08,709 line:-1
One example is alpha testing.


201
00:10:08,775 --> 00:10:11,478 line:-2
This is a common technique
with rasterization,


202
00:10:11,545 --> 00:10:13,213 line:-1
where we use a texture to mask off


203
00:10:13,280 --> 00:10:15,883 line:-2
parts of a triangle
that should be transparent.


204
00:10:15,949 --> 00:10:18,285 line:-2
This can be used to add
a lot of geometric detail


205
00:10:18,352 --> 00:10:20,821 line:-2
without increasing
the actual triangle count.


206
00:10:21,488 --> 00:10:23,857 line:-2
In this example,
the leaves get a lot more detailed


207
00:10:23,924 --> 00:10:25,526 line:-1
when we turn on alpha testing.


208
00:10:27,127 --> 00:10:29,463 line:-2
It's pretty easy to implement this
with rasterization,


209
00:10:29,530 --> 00:10:32,599 line:-2
where we can simply discard
the fragment from a fragment shader.


210
00:10:32,666 --> 00:10:33,700 line:-1
But with ray tracing,


211
00:10:33,767 --> 00:10:36,270 line:-2
it's a little more tricky
to implement this efficiently.


212
00:10:36,937 --> 00:10:40,874 line:-2
Each time we cast a ray, the intersector
will return the closest intersection.


213
00:10:41,642 --> 00:10:42,743 line:-1
However, in this case,


214
00:10:42,809 --> 00:10:44,778 line:-2
the intersection point
is actually transparent,


215
00:10:44,845 --> 00:10:46,046 line:-1
so we should ignore it.


216
00:10:47,381 --> 00:10:51,785 line:-2
So, we now have to cast a whole new ray
starting at the first intersection point.


217
00:10:51,852 --> 00:10:56,023 line:-2
Finally, we hit an opaque surface
and we can stop and move on to shading.


218
00:10:56,623 --> 00:10:59,860 line:-2
But each of these rays requires
a whole new trip to the intersector.


219
00:10:59,927 --> 00:11:02,796 line:-2
This is very inefficient
because we are constantly restarting


220
00:11:02,863 --> 00:11:06,133 line:-2
acceleration structure traversal
from the root of the tree structure.


221
00:11:06,200 --> 00:11:09,870 line:-2
A more efficient way to implement this
is with a triangle intersection function.


222
00:11:11,238 --> 00:11:12,639 line:-1
To understand how this works,


223
00:11:12,706 --> 00:11:15,475 line:-2
we'll need to look at
how the intersector works internally.


224
00:11:17,644 --> 00:11:20,013 line:-2
We start by traversing
the acceleration structure


225
00:11:20,080 --> 00:11:24,318 line:-2
until we find an intersection
between the ray and a piece of geometry.


226
00:11:24,384 --> 00:11:25,686 line:-1
We then check if the intersection


227
00:11:25,752 --> 00:11:28,555 line:-2
is closer than
the previous closest intersection.


228
00:11:28,622 --> 00:11:31,825 line:-2
If it is,
we make it the new closest intersection.


229
00:11:31,892 --> 00:11:34,695 line:-2
Then, we go back to traversing
the acceleration structure


230
00:11:36,463 --> 00:11:39,533 line:-2
Eventually, we will finish
and return the closest intersection.


231
00:11:39,600 --> 00:11:42,803 line:-2
Intersection functions
plug directly into this process.


232
00:11:42,870 --> 00:11:46,874 line:-2
These functions are called
each time we find an intersection.


233
00:11:46,940 --> 00:11:51,445 line:-2
The intersection function can then choose
to accept or reject the intersection.


234
00:11:51,512 --> 00:11:55,516 line:-2
If it accepts, then this becomes
the new closest intersection as usual.


235
00:11:55,582 --> 00:11:57,384 line:-1
But it can also reject the intersection,


236
00:11:57,451 --> 00:12:00,120 line:-2
in which case we go back
to traversing the acceleration structure,


237
00:12:00,187 --> 00:12:01,855 line:-1
discarding the intersection.


238
00:12:02,422 --> 00:12:04,024 line:-1
So, for our alpha testing example,


239
00:12:04,091 --> 00:12:08,128 line:-2
we can move the alpha testing logic
into an intersection function.


240
00:12:08,195 --> 00:12:11,131 line:-2
We will then only need to traverse
the acceleration structure once,


241
00:12:11,198 --> 00:12:12,533 line:-1
which is much more efficient.


242
00:12:12,599 --> 00:12:14,868 line:-2
Here's what a basic intersection function
looks like.


243
00:12:14,935 --> 00:12:17,137 line:-1
First we declare the function.


244
00:12:17,204 --> 00:12:20,240 line:-2
"Triangle" means
this is a triangle intersection function


245
00:12:20,307 --> 00:12:22,176 line:-1
and "triangle_data" means we want access


246
00:12:22,242 --> 00:12:25,345 line:-2
to the barycentric coordinates
of the intersection point.


247
00:12:25,412 --> 00:12:26,780 line:-1
The function returns a Boolean


248
00:12:26,847 --> 00:12:29,750 line:-2
indicating whether to accept
or reject the intersection.


249
00:12:30,184 --> 00:12:32,152 line:-2
We receive information
from the intersector


250
00:12:32,219 --> 00:12:34,655 line:-2
such as the primitive index,
geometry index,


251
00:12:34,721 --> 00:12:37,457 line:-2
and barycentric coordinates
of the intersection point,


252
00:12:37,524 --> 00:12:39,693 line:-2
along with other data
that isn't used here.


253
00:12:40,160 --> 00:12:41,895 line:-1
We can also bind our own resources


254
00:12:41,962 --> 00:12:44,364 line:-2
which we'll use
to access the alpha textures.


255
00:12:44,865 --> 00:12:47,835 line:-2
First, we'll look up
the alpha texture for this primitive.


256
00:12:47,901 --> 00:12:49,803 line:-2
Next, we'll use
the barycentric coordinates


257
00:12:49,870 --> 00:12:52,339 line:-1
to interpolate the texture coordinates.


258
00:12:52,406 --> 00:12:55,509 line:-2
This is exactly the same as
what you would do for the shading step.


259
00:12:55,576 --> 00:12:59,379 line:-2
Then we'll do the actual texture lookup,
and finally, we'll return true or false


260
00:12:59,446 --> 00:13:01,248 line:-2
depending on whether
the intersection point


261
00:13:01,315 --> 00:13:02,616 line:-1
is transparent or not.


262
00:13:02,683 --> 00:13:06,153 line:-2
But intersection functions
are not just limited to triangle geometry.


263
00:13:06,220 --> 00:13:10,090 line:-2
Metal also allows you to write
bounding box intersection functions.


264
00:13:10,490 --> 00:13:11,758 line:-1
These functions are invoked


265
00:13:11,825 --> 00:13:14,528 line:-2
when a ray intersects
a bounding box that you provide,


266
00:13:14,595 --> 00:13:17,130 line:-2
which can be used
to model custom primitives.


267
00:13:17,197 --> 00:13:19,032 line:-1
In this scene, the sphere is implemented


268
00:13:19,099 --> 00:13:22,035 line:-2
using a bounding box
intersection function.


269
00:13:22,102 --> 00:13:24,204 line:-2
Rays are tested
against the sphere mathematically


270
00:13:24,271 --> 00:13:26,006 line:-1
rather than modeling it with triangles.


271
00:13:26,073 --> 00:13:29,543 line:-2
This is a very simple example,
but bounding box intersection functions


272
00:13:29,610 --> 00:13:33,313 line:-2
can also be used to model
more complex surfaces such as curves.


273
00:13:33,380 --> 00:13:36,683 line:-2
In this example, we used
bounding box intersection functions


274
00:13:36,750 --> 00:13:38,218 line:-1
to render hair.


275
00:13:38,285 --> 00:13:41,989 line:-2
Each hair strand
is a custom cubic Bézier curve primitive,


276
00:13:42,055 --> 00:13:45,325 line:-2
and we used 10,000 of them
to give the hair its overall shape.


277
00:13:46,527 --> 00:13:49,730 line:-2
Although intersecting each curve primitive
is more expensive,


278
00:13:49,796 --> 00:13:52,332 line:-2
using curves instead of triangles
allows us to render


279
00:13:52,399 --> 00:13:55,936 line:-2
perfectly smooth hair strands
with no triangulation artifacts.


280
00:13:56,003 --> 00:13:58,172 line:-2
We can also use less memory
since each curve


281
00:13:58,238 --> 00:14:01,408 line:-2
needs just a few control points
instead of numerous triangles.


282
00:14:01,475 --> 00:14:05,812 line:-2
This efficient use of memory is important
for characters with a lot of hair.


283
00:14:05,879 --> 00:14:08,382 line:-2
Let's say we had a scene
made of sphere primitives.


284
00:14:09,883 --> 00:14:13,987 line:-2
We start by providing axis-aligned
bounding boxes enclosing each sphere.


285
00:14:14,054 --> 00:14:15,556 line:-1
Then, just like with triangles,


286
00:14:15,622 --> 00:14:18,492 line:-2
Metal builds an acceleration structure
over the boxes.


287
00:14:19,826 --> 00:14:21,328 line:-1
Later, when we provide a ray,


288
00:14:21,395 --> 00:14:25,399 line:-2
Metal searches for intersections
between bounding boxes and the ray.


289
00:14:25,465 --> 00:14:29,102 line:-2
Just like with triangles, Metal invokes
the bounding box intersection function


290
00:14:29,169 --> 00:14:31,471 line:-2
each time it finds
a potential intersection.


291
00:14:32,439 --> 00:14:34,208 line:-2
We only need to make
a couple of small changes


292
00:14:34,274 --> 00:14:36,210 line:-1
to build this acceleration structure.


293
00:14:37,544 --> 00:14:39,947 line:-2
We will create a primitive acceleration
structure descriptor


294
00:14:40,013 --> 00:14:41,315 line:-1
just like before.


295
00:14:41,381 --> 00:14:44,351 line:-2
However, this time, instead of
creating a triangle geometry descriptor,


296
00:14:44,418 --> 00:14:46,887 line:-2
we'll create
a bounding box geometry descriptor.


297
00:14:48,222 --> 00:14:51,024 line:-2
This descriptor simply provides
a place to attach a buffer


298
00:14:51,091 --> 00:14:54,228 line:-2
containing our bounding boxes
as well as the bounding box count.


299
00:14:55,829 --> 00:14:59,166 line:-2
Like triangle intersection functions,
bounding box intersection functions


300
00:14:59,233 --> 00:15:03,303 line:-2
return true or false to indicate whether
to accept or reject the intersection.


301
00:15:03,704 --> 00:15:04,972 line:-1
But they're also responsible


302
00:15:05,038 --> 00:15:07,574 line:-2
for computing the closest distance
from the ray origin


303
00:15:07,641 --> 00:15:10,477 line:-2
to any intersection points
on the custom primitive.


304
00:15:10,544 --> 00:15:14,014 line:-2
Metal will use this distance to
compute the overall closest intersection


305
00:15:14,081 --> 00:15:17,985 line:-2
across all the different triangle
and bounding box primitives in the scene.


306
00:15:18,051 --> 00:15:19,520 line:-1
The declaration changes slightly


307
00:15:19,586 --> 00:15:22,890 line:-2
to show that we're now writing
a bounding box intersection function.


308
00:15:23,423 --> 00:15:27,427 line:-2
Since we need to return multiple values,
we'll return a user-defined struct.


309
00:15:27,494 --> 00:15:30,497 line:-2
In this example, we've created a struct
which contains a Boolean


310
00:15:30,564 --> 00:15:33,500 line:-2
indicating whether to accept
or reject the intersection


311
00:15:33,567 --> 00:15:36,436 line:-2
as well as a float which contains
the intersection distance.


312
00:15:37,304 --> 00:15:38,839 line:-1
Like triangle intersection functions,


313
00:15:38,906 --> 00:15:42,209 line:-2
we receive ray data
such as the ray origin and direction


314
00:15:42,276 --> 00:15:44,211 line:-2
as well as information
about the intersection


315
00:15:44,278 --> 00:15:46,280 line:-1
such as the primitive index.


316
00:15:46,346 --> 00:15:48,448 line:-1
Again, we can also bind our own resources,


317
00:15:48,515 --> 00:15:50,951 line:-2
which we'll use to pass
an array of spheres.


318
00:15:51,018 --> 00:15:52,486 line:-1
We start by checking mathematically


319
00:15:52,553 --> 00:15:56,123 line:-2
whether the ray intersected the sphere
enclosed in the bounding box.


320
00:15:56,190 --> 00:15:58,325 line:-1
If not, we can return false right away.


321
00:15:59,159 --> 00:16:01,228 line:0
Next,
unlike triangle intersection functions,


322
00:16:01,295 --> 00:16:04,031 line:0
we have one more responsibility,
which is to check


323
00:16:04,097 --> 00:16:07,034 line:0
if the intersection function
is within the acceptable range.


324
00:16:07,935 --> 00:16:10,404 line:0
If it is,
then we can accept the intersection


325
00:16:10,470 --> 00:16:12,906 line:0
and return the intersection distance.


326
00:16:12,973 --> 00:16:14,942 line:0
But what if we want to return
additional data?


327
00:16:15,008 --> 00:16:16,643 line:-1
For example, we may want to return


328
00:16:16,710 --> 00:16:19,146 line:-2
the surface normal
at the intersection point for shading.


329
00:16:19,980 --> 00:16:22,216 line:-1
We can do this using the ray payload.


330
00:16:22,282 --> 00:16:25,819 line:-2
This is a small piece of data which can be
passed from an intersection function


331
00:16:25,886 --> 00:16:29,656 line:-2
all the way back to the compute kernel
that started the intersection process.


332
00:16:29,723 --> 00:16:31,925 line:-2
We simply declare a reference
to our payload type


333
00:16:31,992 --> 00:16:34,461 line:-2
as an argument
to the intersection function.


334
00:16:34,528 --> 00:16:36,997 line:-2
Then, we can write to it
to modify the payload.


335
00:16:37,064 --> 00:16:39,566 line:-2
Keep in mind that changes to the payload
will be visible


336
00:16:39,633 --> 00:16:41,835 line:-2
whether you accept the intersection
or not,


337
00:16:41,902 --> 00:16:44,571 line:-2
so in most cases,
you will only want to modify the payload


338
00:16:44,638 --> 00:16:46,273 line:-2
if you're going to
accept the intersection.


339
00:16:47,241 --> 00:16:51,011 line:-2
To retrieve the payload value, we simply
modify our call to the intersector


340
00:16:51,078 --> 00:16:53,347 line:-1
to pass the payload by reference.


341
00:16:53,413 --> 00:16:55,916 line:-2
Any changes to the payload
from an intersection function


342
00:16:55,983 --> 00:16:58,552 line:-2
will be visible
once the intersector returns.


343
00:16:58,619 --> 00:17:03,023 line:-2
So far, we've talked about how to use
a ray intersector from a compute kernel.


344
00:17:03,090 --> 00:17:06,093 line:-2
We've also talked about
how to write intersection functions.


345
00:17:06,159 --> 00:17:08,395 line:-2
Next, we'll talk about
how to combine the two.


346
00:17:08,896 --> 00:17:11,298 line:-2
In order for the intersector
to actually be able to call


347
00:17:11,365 --> 00:17:12,733 line:-1
our intersection functions,


348
00:17:12,799 --> 00:17:15,569 line:-2
we need to link them together
in a compute pipeline state.


349
00:17:17,237 --> 00:17:19,272 line:-2
We'll start by loading
the intersection functions


350
00:17:19,339 --> 00:17:20,507 line:-1
out of a Metal library.


351
00:17:20,574 --> 00:17:22,976 line:-2
This is done
just like any other Metal function.


352
00:17:24,178 --> 00:17:27,314 line:-2
Next, we attach the intersection functions
to the pipeline descriptor


353
00:17:27,381 --> 00:17:29,883 line:-1
using an MTLLinkedFunctions object.


354
00:17:31,218 --> 00:17:34,121 line:-2
Finally, we'll compile
the pipeline state as usual.


355
00:17:34,188 --> 00:17:36,623 line:-2
The compiler will link the code
for the compute kernel


356
00:17:36,690 --> 00:17:39,726 line:-2
and intersection functions together
so that the intersection functions


357
00:17:39,793 --> 00:17:43,363 line:-2
can be called from a ray intersector
inside the compute kernel.


358
00:17:43,897 --> 00:17:45,799 line:-2
Now that we've linked
all the intersection functions


359
00:17:45,866 --> 00:17:47,568 line:-1
into our compute pipeline state,


360
00:17:47,634 --> 00:17:49,436 line:-2
we need to map
these intersection functions


361
00:17:49,503 --> 00:17:51,305 line:-1
to individual pieces of geometry.


362
00:17:53,006 --> 00:17:56,276 line:-2
We do this using what's called
an intersection function table.


363
00:17:56,343 --> 00:18:00,714 line:-2
This table contains pointers to the actual
executable code in the pipeline state.


364
00:18:01,748 --> 00:18:04,218 line:-2
Just like each piece
of acceleration structure geometry


365
00:18:04,284 --> 00:18:06,019 line:-1
can have its own vertex buffer,


366
00:18:06,086 --> 00:18:09,389 line:-2
they can also each have
their own intersection function.


367
00:18:09,456 --> 00:18:12,025 line:-2
And if you're using
an instance acceleration structure,


368
00:18:12,092 --> 00:18:15,429 line:-2
each instance can have its own
set of intersection functions as well.


369
00:18:16,597 --> 00:18:19,566 line:-2
Both acceleration structure geometry
and instance descriptors


370
00:18:19,633 --> 00:18:23,103 line:-2
have individual
Intersection function table offsets.


371
00:18:23,170 --> 00:18:26,607 line:-2
When a ray hits a piece of geometry,
these two values are added together


372
00:18:26,673 --> 00:18:30,043 line:-2
to determine which
intersection function table entry to call.


373
00:18:30,110 --> 00:18:33,714 line:-2
To create an intersection function table,
we start by creating a descriptor.


374
00:18:33,780 --> 00:18:36,183 line:-2
In this example,
we create one with enough space


375
00:18:36,250 --> 00:18:38,151 line:-1
for all of our intersection functions.


376
00:18:38,886 --> 00:18:41,822 line:-2
Next, we allocate
the intersection function table.


377
00:18:41,889 --> 00:18:44,224 line:-2
This table points to
actual executable code


378
00:18:44,291 --> 00:18:46,360 line:-1
in a specific compute pipeline state,


379
00:18:46,426 --> 00:18:49,129 line:-2
so it's also created
from that pipeline state.


380
00:18:49,196 --> 00:18:52,299 line:-2
Furthermore, it can only be used
with this pipeline state


381
00:18:52,366 --> 00:18:54,368 line:-1
or a pipeline state derived from it.


382
00:18:55,169 --> 00:18:57,604 line:-2
Next, we'll get a handle
for each intersection function


383
00:18:57,671 --> 00:18:59,373 line:-1
from the compute pipeline state.


384
00:18:59,439 --> 00:19:02,709 line:-2
This handle represents the address
of the function's executable code


385
00:19:02,776 --> 00:19:04,945 line:-2
which has been linked
into the pipeline state.


386
00:19:06,013 --> 00:19:09,516 line:-2
We then insert this handle
into the intersection function table.


387
00:19:09,583 --> 00:19:11,418 line:-1
This is also where we bind the resources


388
00:19:11,485 --> 00:19:13,987 line:-2
used by the intersection functions
in the table.


389
00:19:15,155 --> 00:19:19,226 line:0
For example, we'll bind our sphere buffer
to buffer index 0.


390
00:19:19,293 --> 00:19:21,061 line:-1
Using an intersection function table


391
00:19:21,128 --> 00:19:23,597 line:-2
is very similar to how we use
an acceleration structure.


392
00:19:24,998 --> 00:19:27,467 line:-2
We again simply pass it
to the intersector.


393
00:19:27,534 --> 00:19:31,805 line:0
Intersection function tables also bind
to normal Metal buffer binding points.


394
00:19:31,872 --> 00:19:33,774 line:0
And again,
there's a corresponding API method


395
00:19:33,841 --> 00:19:35,576 line:0
to bind an intersection function table


396
00:19:35,642 --> 00:19:38,445 line:0
on the compute command encoder
and argument encoder.


397
00:19:38,512 --> 00:19:42,249 line:-2
And that's everything we need to do
to set up intersection functions.


398
00:19:42,316 --> 00:19:44,284 line:-1
intersection functions are a powerful tool


399
00:19:44,351 --> 00:19:47,221 line:-2
which gives you much more control
over the intersection process.


400
00:19:47,955 --> 00:19:51,959 line:-2
To summarize, we first talked about
the new Metal ray tracing API,


401
00:19:52,025 --> 00:19:53,527 line:-1
and the ray intersector object


402
00:19:53,594 --> 00:19:56,830 line:-2
which is now available
directly from within any compute kernel.


403
00:19:57,664 --> 00:19:59,733 line:-2
This is a much more flexible
programming model


404
00:19:59,800 --> 00:20:03,403 line:-2
which allows you to divide up work
in the best way for your application.


405
00:20:05,138 --> 00:20:07,975 line:-2
We also talked about how the new API
gives you more control


406
00:20:08,041 --> 00:20:10,010 line:-2
over when and where
acceleration structures


407
00:20:10,077 --> 00:20:11,812 line:-1
are allocated and built.


408
00:20:13,514 --> 00:20:16,350 line:-2
Finally, we talked about
how you can write intersection functions


409
00:20:16,416 --> 00:20:18,685 line:-1
to customize the intersection process.


410
00:20:19,186 --> 00:20:22,256 line:-2
There's actually a lot more we could say
about intersection functions.


411
00:20:22,322 --> 00:20:24,691 line:-2
In fact, we've also made
the underlying mechanism


412
00:20:24,758 --> 00:20:27,094 line:-1
available for use in other applications.


413
00:20:28,195 --> 00:20:31,865 line:-2
For example, since a ray
could hit any surface at any time,


414
00:20:31,932 --> 00:20:34,468 line:-2
the shading step needs to be able
to execute code


415
00:20:34,535 --> 00:20:36,770 line:-1
for arbitrary materials on demand.


416
00:20:37,404 --> 00:20:39,773 line:0
So, I would encourage you
to watch the function pointers talk,


417
00:20:39,840 --> 00:20:41,141 line:0
which accompanies this session,


418
00:20:41,208 --> 00:20:44,511 line:0
to learn about another powerful tool
which will allow you to do this.


419
00:20:44,578 --> 00:20:48,482 line:-2
We only had time to cover the basics
of the new ray tracing API today,


420
00:20:48,549 --> 00:20:51,552 line:-2
so I'd also recommend that you check out
the sample code and documentation


421
00:20:51,618 --> 00:20:53,353 line:-1
attached to this session.


422
00:20:53,420 --> 00:20:56,223 line:-2
Thanks for watching,
and enjoy the rest of WWDC.

