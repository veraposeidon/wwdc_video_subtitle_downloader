1
00:00:03,737 --> 00:00:06,939 line:-1
Hello and welcome to WWDC.


2
00:00:08,475 --> 00:00:13,914 line:0
Hi. I'm Ted. And welcome to
"What's New in Swift."


3
00:00:14,381 --> 00:00:20,454 line:-2
Today, the ecosystem around Swift
is blossoming in many directions.


4
00:00:20,521 --> 00:00:25,092 line:-2
The introduction of API stability
in Swift 5


5
00:00:25,158 --> 00:00:27,961 line:-1
brought binary frameworks to Swift.


6
00:00:28,028 --> 00:00:32,633 line:-2
This led to the advent
of powerful new APIs, such as SwiftUI,


7
00:00:32,698 --> 00:00:37,604 line:-2
that are front and center
to the Apple developer experience.


8
00:00:37,671 --> 00:00:41,241 line:-2
Over the last year,
many investments have been made in Swift,


9
00:00:41,308 --> 00:00:44,077 line:-1
both on the surface and under the hood,


10
00:00:44,144 --> 00:00:47,981 line:-2
that will amplify Swift impact
on Apple's APIs,


11
00:00:48,048 --> 00:00:53,487 line:-2
the core of its operating systems
and the Apple developer ecosystem.


12
00:00:55,088 --> 00:00:59,059 line:-2
There's also a growing set
of powerful open-source APIs


13
00:00:59,126 --> 00:01:01,895 line:-1
that take full advantage of Swift,


14
00:01:01,962 --> 00:01:05,265 line:-2
which are conveniently accessible
to app developers in Xcode


15
00:01:05,331 --> 00:01:07,901 line:-1
using the Swift Package Manager.


16
00:01:08,902 --> 00:01:12,773 line:-2
Finally, Swift's reach
as a cross-platform language


17
00:01:12,840 --> 00:01:16,844 line:-2
for tackling problems in many domains
continues to grow


18
00:01:16,910 --> 00:01:21,114 line:-2
with support for more platforms
than ever before.


19
00:01:21,982 --> 00:01:26,053 line:-2
Across both releases,
there has been a continuum of investments


20
00:01:26,119 --> 00:01:31,692 line:-2
in performance, language refinements,
and the developer experience.


21
00:01:33,293 --> 00:01:34,394 line:-1
Let us start things off


22
00:01:34,461 --> 00:01:39,333 line:-2
by looking at some significant advances
in Swift's runtime performance.


23
00:01:40,334 --> 00:01:42,903 line:-1
The first piece to look at is code size.


24
00:01:42,970 --> 00:01:46,006 line:-2
Code size is the part of the app
that represents


25
00:01:46,073 --> 00:01:49,776 line:-2
the machine code representation
of the app's logic.


26
00:01:49,843 --> 00:01:53,881 line:-2
This has been a focus of optimization
for several releases now.


27
00:01:55,148 --> 00:01:58,552 line:-2
To track progress,
we have been using a Swift rewrite


28
00:01:58,619 --> 00:02:01,555 line:-1
of one of the apps that ships with iOS.


29
00:02:01,622 --> 00:02:04,691 line:-2
We've been tracking the code size
of the Swift version of the app


30
00:02:04,758 --> 00:02:08,495 line:-2
versus the Objective-C version
since Swift 4.


31
00:02:09,763 --> 00:02:11,398 line:-1
We started out with the Swift version


32
00:02:11,465 --> 00:02:15,536 line:-2
at about 2.3 times the code size
of the Objective-C version.


33
00:02:16,904 --> 00:02:19,973 line:-1
Swift 4.1 took a big chunk out


34
00:02:20,040 --> 00:02:23,844 line:-2
with the optimize for code size
optimization setting.


35
00:02:25,445 --> 00:02:29,716 line:-2
At each subsequent release,
we narrowed the difference.


36
00:02:29,783 --> 00:02:31,718 line:-1
With Swift 5.3, we're down to


37
00:02:31,785 --> 00:02:36,023 line:-2
below one-and-a-half times
the code size of the Objective-C version.


38
00:02:36,089 --> 00:02:39,059 line:-2
Note that some amount of difference
is inevitable


39
00:02:39,126 --> 00:02:42,029 line:-1
because Swift comes with safety features


40
00:02:42,095 --> 00:02:46,633 line:-2
that take some amount of code size
to implement in an app.


41
00:02:46,700 --> 00:02:51,705 line:-2
Different styles of applications, however,
produce different binary sizes.


42
00:02:51,772 --> 00:02:57,177 line:-2
This application was a UIKit app.
But what about a SwiftUI app?


43
00:02:57,244 --> 00:02:59,446 line:-1
In Swift 5.3,


44
00:02:59,513 --> 00:03:03,851 line:-2
there are significant improvements
to the code size of SwiftUI apps.


45
00:03:03,917 --> 00:03:05,252 line:-1
Here's MovieSwiftUI,


46
00:03:05,319 --> 00:03:09,523 line:-2
which is an excellent open-source app
by Thomas Ricouard.


47
00:03:09,590 --> 00:03:14,561 line:-2
We see that its application logic
code size is reduced by over 40%.


48
00:03:14,628 --> 00:03:19,132 line:-2
Now, binary size is essential
for things like download times,


49
00:03:19,199 --> 00:03:23,003 line:-2
but when you're running the app,
it's part of what we call clean memory.


50
00:03:23,070 --> 00:03:28,108 line:-2
That's memory that can be purged
because it can be reloaded when needed.


51
00:03:28,175 --> 00:03:30,444 line:-1
So it's less critical than dirty memory,


52
00:03:30,511 --> 00:03:35,082 line:-2
the memory the application allocates
and manipulates at runtime.


53
00:03:35,148 --> 00:03:39,186 line:-2
Let's next look at how dirty memory usage
has significantly improved.


54
00:03:40,654 --> 00:03:44,157 line:-2
Swift's use of value types
has some fundamental advantages


55
00:03:44,224 --> 00:03:47,361 line:-1
over reference type based languages.


56
00:03:47,427 --> 00:03:51,498 line:-2
To understand why, here's an example
in Objective-C of a simple model type


57
00:03:51,565 --> 00:03:55,269 line:-1
with a UUID, a string, and a number.


58
00:03:55,335 --> 00:03:59,673 line:-2
Let's look at how this model is held
in memory when we store it in an array.


59
00:04:00,674 --> 00:04:04,244 line:-2
In Objective-C,
object variables are just pointers.


60
00:04:04,311 --> 00:04:07,447 line:-2
So the array holds pointers
to the model objects.


61
00:04:09,016 --> 00:04:13,320 line:-2
Those objects, in turn,
hold pointers to their properties.


62
00:04:13,387 --> 00:04:18,926 line:-2
Every object you allocate has some
overhead and performance and memory use.


63
00:04:18,992 --> 00:04:23,897 line:-2
This is so important that Objective-C
has a special small string representation


64
00:04:23,964 --> 00:04:29,403 line:-2
for tiny ASCII strings that allow them
to be stored within the pointer,


65
00:04:29,469 --> 00:04:31,939 line:-2
which saves on allocating
the extra object.


66
00:04:33,707 --> 00:04:36,443 line:-2
Now, we'll look at the same model
in Swift.


67
00:04:37,377 --> 00:04:39,213 line:-1
Swift's use of value types


68
00:04:39,279 --> 00:04:43,617 line:-2
avoids the need for many of these values
to be accessed via a pointer.


69
00:04:43,684 --> 00:04:47,287 line:-2
Thus the UUIDs can be held
within the Mountain objects.


70
00:04:48,121 --> 00:04:51,992 line:-2
And Swift's small string could hold
many more characters,


71
00:04:52,059 --> 00:04:56,129 line:-2
up to 15 code units,
including non-ASCII characters.


72
00:04:57,431 --> 00:04:59,466 line:-1
Finally, all the Mountain objects


73
00:04:59,533 --> 00:05:02,736 line:-2
can be allocated
directly within the array storage.


74
00:05:02,803 --> 00:05:04,605 line:-1
So, with the exception of a few strings,


75
00:05:04,671 --> 00:05:08,208 line:-2
everything is held
within a contiguous block of memory.


76
00:05:08,275 --> 00:05:11,278 line:-2
Swift programs can get
a significant memory benefit


77
00:05:11,345 --> 00:05:14,181 line:-1
from using value types like this.


78
00:05:15,616 --> 00:05:20,454 line:-2
So if we examine the heap memory used
by an array of 400 of these model objects,


79
00:05:20,521 --> 00:05:23,390 line:-2
we can see
the Swift model data is more compact.


80
00:05:23,457 --> 00:05:26,860 line:-2
About
20 kilobytes instead of 35 kilobytes.


81
00:05:26,927 --> 00:05:29,396 line:-2
Note these measurements
are from Swift 5.1.


82
00:05:31,298 --> 00:05:35,969 line:0
Despite this advantage,
some Swift programs previously still used


83
00:05:36,036 --> 00:05:40,040 line:0
more heap memory
because of runtime overhead.


84
00:05:40,107 --> 00:05:44,344 line:-2
Previously, Swift created
a number of caches and memory on start-up.


85
00:05:44,411 --> 00:05:47,414 line:-2
These caches stored things
like protocol conformances


86
00:05:47,481 --> 00:05:49,249 line:-1
and other type information,


87
00:05:49,316 --> 00:05:53,153 line:-2
as well as data used to bridge types
over to Objective-C.


88
00:05:54,721 --> 00:06:00,494 line:-2
All language runtimes have some overhead,
but in Swift's case, it was too large.


89
00:06:00,561 --> 00:06:03,597 line:-1
This was a big focus for us to optimize.


90
00:06:04,965 --> 00:06:10,637 line:0
I'm happy to say that in Swift 5.3,
we've cut that overhead way down


91
00:06:10,704 --> 00:06:13,006 line:0
to the point where the Swift version
of the app now uses


92
00:06:13,073 --> 00:06:17,811 line:0
less than a third of the heap memory
it did in last year's release.


93
00:06:17,878 --> 00:06:19,847 line:-2
To get full advantage
of these improvements,


94
00:06:19,913 --> 00:06:24,585 line:-2
an app's minimum deployment target
needs to be set to iOS 14.


95
00:06:24,651 --> 00:06:26,720 line:-2
But many of these improvements
will benefit apps


96
00:06:26,787 --> 00:06:29,823 line:-1
that back deploy to earlier OS releases.


97
00:06:31,491 --> 00:06:33,026 line:-1
In most applications,


98
00:06:33,093 --> 00:06:36,797 line:-2
these differences
are not often noticeable,


99
00:06:36,864 --> 00:06:38,832 line:-1
but optimizing Swift's memory like this


100
00:06:38,899 --> 00:06:44,104 line:-2
was critical to allow us to push Swift
further throughout Apple system


101
00:06:44,171 --> 00:06:47,808 line:-2
to be able to use it in daemons
and low-level frameworks


102
00:06:47,875 --> 00:06:50,911 line:-1
where every byte of memory used counts.


103
00:06:52,145 --> 00:06:56,116 line:-2
To that end,
we've also made another important change.


104
00:06:56,183 --> 00:06:58,452 line:-1
We have moved Swift's Standard Library


105
00:06:58,519 --> 00:07:01,788 line:-2
so that it sits
below Foundation in the stack.


106
00:07:01,855 --> 00:07:05,425 line:-2
That means it can actually be used
to implement frameworks


107
00:07:05,492 --> 00:07:10,797 line:-2
that float below the level of Objective-C,
where previously C had to be used.


108
00:07:11,732 --> 00:07:13,667 line:-1
Next, let's turn our attention


109
00:07:13,734 --> 00:07:16,937 line:-2
to how we continue to refine
the developer experience.


110
00:07:18,038 --> 00:07:22,843 line:-2
Starting with looking at how diagnostics,
errors and warnings from the compiler,


111
00:07:22,910 --> 00:07:25,812 line:-2
have vastly improved
in this release cycle.


112
00:07:27,181 --> 00:07:30,184 line:-2
The Swift compiler
has a new diagnostic strategy


113
00:07:30,250 --> 00:07:32,386 line:-1
that results in more precise errors


114
00:07:32,452 --> 00:07:36,757 line:-2
that point to the exact location
in source code where the problem occurs.


115
00:07:37,457 --> 00:07:40,761 line:-2
There are new heuristics
for diagnosing the cause of issues


116
00:07:40,827 --> 00:07:45,666 line:-2
that lead to actionable errors
with guidance on how to fix issues.


117
00:07:46,867 --> 00:07:50,137 line:-2
Here's an example
of an incomprehensible diagnostic


118
00:07:50,204 --> 00:07:54,875 line:-2
the Swift 5.1 compiler would have produced
on SwiftUI code a year ago.


119
00:07:56,076 --> 00:08:00,147 line:-2
Fast forward today,
the diagnostic is significantly better


120
00:08:00,214 --> 00:08:03,483 line:-2
with an error that tells you
exactly what is the problem.


121
00:08:04,251 --> 00:08:05,652 line:-1
When diagnosing issues,


122
00:08:05,719 --> 00:08:11,158 line:-2
the compiler internally also records
more information about problems.


123
00:08:11,225 --> 00:08:14,061 line:-1
So it now produces additional notes.


124
00:08:14,127 --> 00:08:17,064 line:-2
These notes can help the developer
in a variety of circumstances


125
00:08:17,130 --> 00:08:20,467 line:-1
to better understand and resolve an issue.


126
00:08:21,268 --> 00:08:25,939 line:-2
In this case, applying the fix-it
naturally guides the developer


127
00:08:26,006 --> 00:08:27,574 line:-1
to provide the missing pieces


128
00:08:27,641 --> 00:08:30,511 line:-2
to an incomplete initialization
of a Text-Field.


129
00:08:32,044 --> 00:08:34,581 line:-1
If you're interested in finding out more


130
00:08:34,648 --> 00:08:37,618 line:-2
about the new diagnostic architecture
in the compiler,


131
00:08:37,683 --> 00:08:39,953 line:-1
you can navigate over to Swift.org


132
00:08:40,020 --> 00:08:43,123 line:-1
and find a great write-up in a blog post.


133
00:08:44,391 --> 00:08:48,328 line:-2
Code completion for Swift has also
dramatically improved in this release.


134
00:08:48,395 --> 00:08:50,831 line:-2
All the way
from the code completion inference


135
00:08:50,898 --> 00:08:53,000 line:-1
provided by the compiler and SourceKit,


136
00:08:53,066 --> 00:08:57,004 line:-2
and through the experience
in the Xcode code editor.


137
00:08:57,070 --> 00:08:58,305 line:-1
Let's turn our attention


138
00:08:58,372 --> 00:09:02,142 line:-2
to how completion results
have fundamentally gotten much better.


139
00:09:03,143 --> 00:09:06,280 line:-2
First, the inference
of candidate completions


140
00:09:06,346 --> 00:09:08,515 line:-1
has significantly improved.


141
00:09:08,582 --> 00:09:11,618 line:-2
Here the compiler is inferring the value
in a ternary expression


142
00:09:11,685 --> 00:09:15,522 line:-2
when used within
an incomplete dictionary literal.


143
00:09:15,589 --> 00:09:17,758 line:-1
This simply would not have worked before.


144
00:09:18,859 --> 00:09:22,095 line:-2
Code completion also provides
the values you would expect


145
00:09:22,162 --> 00:09:25,232 line:-2
for some of the more dynamic features
of the language,


146
00:09:25,299 --> 00:09:27,634 line:-1
such as using KeyPath as functions.


147
00:09:28,969 --> 00:09:31,371 line:0
Besides the quality of completion results,


148
00:09:31,438 --> 00:09:34,508 line:0
code completion performance
has drastically improved.


149
00:09:34,575 --> 00:09:39,913 line:0
In some cases, up to 15 times
speed improvement compared to Xcode 11.5.


150
00:09:41,381 --> 00:09:45,752 line:-2
This is particularly beneficial
for editing SwiftUI code.


151
00:09:45,819 --> 00:09:47,521 line:-1
These bar charts show the performance


152
00:09:47,588 --> 00:09:52,526 line:-2
for common uses of code completion
in SwiftUI code measured in seconds.


153
00:09:52,593 --> 00:09:57,297 line:-2
In Xcode 11.5, these actions would take
around half a second to complete,


154
00:09:57,364 --> 00:09:59,132 line:-1
which is quite noticeable.


155
00:09:59,199 --> 00:10:01,902 line:-1
Now, these are under a tenth of a second.


156
00:10:03,470 --> 00:10:05,239 line:-1
Code indentation in Xcode,


157
00:10:05,305 --> 00:10:07,608 line:-2
also powered
by the open-source SourceKit engine,


158
00:10:07,674 --> 00:10:10,143 line:-1
has significantly improved.


159
00:10:10,210 --> 00:10:13,080 line:-2
You will see improved handling
of chained method calls


160
00:10:13,146 --> 00:10:16,817 line:-2
and property accesses,
a major component of Swift UI code.


161
00:10:16,884 --> 00:10:20,320 line:-2
You'll also find improvements
for alignment of call arguments,


162
00:10:20,387 --> 00:10:24,224 line:-2
tuple elements, collection elements
that span multiple lines,


163
00:10:24,291 --> 00:10:26,960 line:-1
and multi-line control flow.


164
00:10:28,462 --> 00:10:30,464 line:-2
Here you can see
one of the improvements at work


165
00:10:30,531 --> 00:10:34,368 line:-2
in SwiftUI code taken from
the open-source MovieSwiftUI project.


166
00:10:34,434 --> 00:10:37,971 line:-2
Before, you would get sometimes
a natural indentation


167
00:10:38,038 --> 00:10:39,940 line:-1
for some of the chained accesses.


168
00:10:42,276 --> 00:10:45,679 line:-2
But now,
they are cleanly visually aligned.


169
00:10:45,746 --> 00:10:48,315 line:-2
These, and the other improvements
I mentioned,


170
00:10:48,382 --> 00:10:52,085 line:-2
will have a noticeable effect
on your editing experience.


171
00:10:52,152 --> 00:10:54,321 line:-1
Next, let's talk about improvements


172
00:10:54,388 --> 00:10:57,257 line:-2
to the core experience
of debugging Swift code.


173
00:10:58,625 --> 00:11:02,429 line:-2
When debug information is available,
the debugger will now display


174
00:11:02,496 --> 00:11:06,366 line:-2
the reason for common Swift
runtime failure traps


175
00:11:06,433 --> 00:11:10,037 line:-2
instead of just showing
an opaque "invalid instruction" crash.


176
00:11:11,171 --> 00:11:16,143 line:-2
Further, Swift debugging support
is now more robust in general.


177
00:11:16,210 --> 00:11:18,445 line:-1
To understand why, let's look at a key way


178
00:11:18,512 --> 00:11:21,982 line:-2
Swift interoperates with Objective-C
at compile time.


179
00:11:23,317 --> 00:11:28,722 line:-2
Swift imports APIs from Objective-C
using Clang modules.


180
00:11:28,789 --> 00:11:31,792 line:-2
To resolve information
about types and variables,


181
00:11:31,859 --> 00:11:34,828 line:-2
LLDB needs to import
all Swift and Clang modules


182
00:11:34,895 --> 00:11:38,866 line:-2
that are visible
in the current debugging context.


183
00:11:39,867 --> 00:11:43,971 line:-2
While these module files
have a wealth of information about types,


184
00:11:44,037 --> 00:11:46,240 line:-1
since LLDB has a global view


185
00:11:46,306 --> 00:11:50,277 line:-2
of the entire program
and all of its dynamic libraries,


186
00:11:50,344 --> 00:11:55,949 line:-2
importing Clang modules can sometimes fail
in ways they would not at compile time.


187
00:11:56,016 --> 00:11:57,951 line:-1
One common failure scenario


188
00:11:58,018 --> 00:12:00,787 line:-2
is when the search pass
from different dynamic libraries


189
00:12:00,854 --> 00:12:02,122 line:-1
are in conflict.


190
00:12:03,257 --> 00:12:04,892 line:-1
As a fallback, when this occurs,


191
00:12:04,958 --> 00:12:07,961 line:-2
LLDB can now also import
C and Objective-C types


192
00:12:08,028 --> 00:12:12,065 line:-2
for Swift debugging purposes
from DWARF debug information.


193
00:12:12,132 --> 00:12:14,801 line:-2
This vastly increases
the reliability of features


194
00:12:14,868 --> 00:12:18,872 line:-2
such as the Xcode variable view
and expression evaluator.


195
00:12:19,907 --> 00:12:23,210 line:-2
Swift is an excellent
general-purpose language.


196
00:12:23,277 --> 00:12:25,746 line:-2
Swift is great for building apps
on Apple's platforms,


197
00:12:25,812 --> 00:12:27,848 line:-1
but also great for many other tasks.


198
00:12:28,482 --> 00:12:33,053 line:-2
For this reason, we think cross-platform
support in Swift is so important.


199
00:12:34,454 --> 00:12:37,824 line:-2
Swift's official support
for more platforms continues to grow.


200
00:12:38,692 --> 00:12:41,461 line:-2
This year, Swift updated its support
for Ubuntu,


201
00:12:41,528 --> 00:12:45,465 line:-2
as well as picked up official support
for more variants of Linux


202
00:12:45,532 --> 00:12:48,969 line:-1
with CentOS and Amazon Linux 2.


203
00:12:49,036 --> 00:12:53,106 line:-2
And coming for Swift 5.3
will be the initial support for Windows.


204
00:12:53,173 --> 00:12:56,710 line:-2
Follow along on Swift.org
to find out more as it becomes available.


205
00:12:56,777 --> 00:13:01,615 line:-2
With these ports comes increased
opportunity to use Swift in more places.


206
00:13:02,649 --> 00:13:05,352 line:-1
One of those places is AWS Lambda.


207
00:13:05,419 --> 00:13:09,189 line:-2
Serverless functions are an easy way
for client application developers


208
00:13:09,256 --> 00:13:12,626 line:-2
to extend their applications
into the cloud.


209
00:13:12,693 --> 00:13:17,464 line:-2
It is now easy to do this in Swift
using the open-source Swift AWS runtime.


210
00:13:18,265 --> 00:13:22,269 line:-2
The runtime is 100% open-source
and available on GitHub,


211
00:13:22,336 --> 00:13:24,371 line:-1
and is the result of a group effort


212
00:13:24,438 --> 00:13:27,508 line:-2
that included engineers
across the Swift community.


213
00:13:27,574 --> 00:13:31,678 line:-2
It includes instructions, how to build
and deploy to AWS Lambda


214
00:13:31,745 --> 00:13:33,847 line:-1
and programming to AWS Lambda.


215
00:13:33,914 --> 00:13:35,782 line:-1
As this example shows in Xcode,


216
00:13:35,849 --> 00:13:40,087 line:-2
the amount of code needed
is as simple as writing "Hello, world".


217
00:13:40,153 --> 00:13:43,223 line:-2
Those are just
some of the exciting updates


218
00:13:43,290 --> 00:13:45,125 line:-1
in the Swift ecosystem.


219
00:13:45,192 --> 00:13:50,764 line:-2
Next, Kyle will talk about changes
to the Swift language and libraries.


220
00:13:51,331 --> 00:13:53,734 line:-1
Thanks, Ted. Hi, I'm Kyle,


221
00:13:53,800 --> 00:13:55,903 line:-2
a member
of the Swift Standard Library Team.


222
00:13:56,470 --> 00:14:01,041 line:0
It's been a big year for the Swift
language and the Swift Library ecosystem.


223
00:14:01,108 --> 00:14:03,277 line:-1
Let's start by talking about the language.


224
00:14:03,343 --> 00:14:06,246 line:-2
In addition to the improvements
Ted just discussed,


225
00:14:06,313 --> 00:14:08,649 line:-2
we've added over a dozen
new language features


226
00:14:08,715 --> 00:14:12,219 line:-1
across Swift 5.2 and Swift 5.3.


227
00:14:12,286 --> 00:14:15,088 line:-2
Because we don't have time
to cover all of them today,


228
00:14:15,155 --> 00:14:18,025 line:-2
I want to draw your attention
to these SE numbers.


229
00:14:19,293 --> 00:14:20,427 line:-1
As many of you know,


230
00:14:20,494 --> 00:14:23,397 line:-2
the Swift language goes through
an open evolution process.


231
00:14:23,463 --> 00:14:26,834 line:-2
Each one of these numbers
corresponds to a feature document


232
00:14:26,900 --> 00:14:30,304 line:-2
that you can look up
on the Swift Evolution website.


233
00:14:30,370 --> 00:14:32,906 line:-2
This website
is also a great jumping-off point


234
00:14:32,973 --> 00:14:37,110 line:-2
if you're curious about how you can help
shape the future of Swift.


235
00:14:37,177 --> 00:14:39,746 line:-1
All right, let's dive in.


236
00:14:39,813 --> 00:14:42,216 line:-2
Some of the most exciting additions
this year


237
00:14:42,282 --> 00:14:45,853 line:-2
are the powerful new tools
available to API designers,


238
00:14:45,919 --> 00:14:46,920 line:-1
which is all of you,


239
00:14:46,987 --> 00:14:49,923 line:-2
whether you maintain
a popular open-source package,


240
00:14:49,990 --> 00:14:52,226 line:-1
work on a team with other developers,


241
00:14:52,292 --> 00:14:55,329 line:-2
or just use Swift
for your own personal projects.


242
00:14:55,395 --> 00:14:58,165 line:-1
If you code, you design APIs.


243
00:14:58,232 --> 00:15:02,102 line:-2
Let's begin
with multiple trailing closure syntax.


244
00:15:02,169 --> 00:15:06,673 line:-2
Since its inception, Swift has supported
something called trailing closure syntax,


245
00:15:06,740 --> 00:15:11,545 line:-2
a bit of syntactic sugar that lets you pop
the final argument to a method


246
00:15:11,612 --> 00:15:14,281 line:-2
out of the parenthesis
when it's a closure.


247
00:15:14,348 --> 00:15:17,584 line:-2
Trailing closure syntax
has proven to be very popular.


248
00:15:17,651 --> 00:15:19,353 line:-1
And it's not hard to guess why.


249
00:15:19,419 --> 00:15:23,824 line:-2
It can be more concise
and less nested without loss of clarity,


250
00:15:23,891 --> 00:15:26,426 line:-1
making the call site much easier to read.


251
00:15:26,493 --> 00:15:30,063 line:-2
However, the restriction
of trailing closure syntax


252
00:15:30,130 --> 00:15:33,500 line:-2
to only the final closure
has limited its applicability.


253
00:15:34,835 --> 00:15:38,739 line:-2
In this case, the trailing closure
makes the code harder to read


254
00:15:38,805 --> 00:15:40,607 line:-1
because its role is unclear.


255
00:15:40,674 --> 00:15:45,512 line:-2
Worse, it changes meaning
from the completion block at one call site


256
00:15:45,579 --> 00:15:48,015 line:-1
to the animation block at another.


257
00:15:48,081 --> 00:15:52,052 line:-2
Concerns about call site confusion
have led Swift style guides


258
00:15:52,119 --> 00:15:54,555 line:-2
to prohibit
the use of trailing closure syntax


259
00:15:54,621 --> 00:15:59,493 line:-2
when a method call, like this one,
has multiple closure arguments.


260
00:16:00,894 --> 00:16:05,299 line:-2
As a result, if we ever need to append
an additional closure argument,


261
00:16:05,365 --> 00:16:08,135 line:-2
many of us find ourselves
having to rejigger our code


262
00:16:08,202 --> 00:16:09,803 line:-1
more than may seem necessary.


263
00:16:12,072 --> 00:16:15,943 line:-2
New to Swift 5.3
is multiple trailing closure syntax.


264
00:16:17,244 --> 00:16:20,280 line:-2
This extends the benefits
of trailing closure syntax


265
00:16:20,347 --> 00:16:22,583 line:-1
to calls with multiple closure arguments,


266
00:16:22,649 --> 00:16:26,520 line:-2
and there's no rejiggering required
to append an additional one.


267
00:16:26,954 --> 00:16:30,924 line:-2
Multiple trailing closure syntax
is also a great fit for DSLs.


268
00:16:31,458 --> 00:16:35,462 line:-2
SwiftUI's new Gauge View
is used to indicate the level of a value


269
00:16:35,529 --> 00:16:37,831 line:-1
relative to some overall capacity.


270
00:16:38,999 --> 00:16:41,869 line:-1
Here I have a circular watchOS gauge


271
00:16:41,935 --> 00:16:45,272 line:-2
for tracking the acidity level
of my garden soil.


272
00:16:45,339 --> 00:16:47,307 line:-1
But tomatoes are finicky enough to where


273
00:16:47,374 --> 00:16:49,943 line:-2
I'd really like to see
the exact value at a glance.


274
00:16:50,911 --> 00:16:54,448 line:-2
Fortunately,
I can add a currentValueLabel


275
00:16:54,515 --> 00:16:58,552 line:-1
and minimum and maximumValueLabels.


276
00:16:58,886 --> 00:17:01,955 line:-2
By taking advantage
of multiple trailing closure syntax,


277
00:17:02,022 --> 00:17:07,160 line:-2
Gauge is able to elegantly, progressively
disclose its customization points.


278
00:17:07,528 --> 00:17:09,963 line:-2
Let's take a moment
to explore the implications


279
00:17:10,030 --> 00:17:13,901 line:-2
of trailing closure syntax
on Swift API design.


280
00:17:13,967 --> 00:17:16,069 line:-1
Imagine you encounter this line of code


281
00:17:16,136 --> 00:17:18,539 line:-2
in, say, a messaging app
you're working on,


282
00:17:18,605 --> 00:17:23,676 line:-2
where summary is used to show a snippet
of the last message in each chat.


283
00:17:23,743 --> 00:17:25,779 line:-1
What's the value of summary?


284
00:17:25,846 --> 00:17:29,016 line:-1
What's the call to the take method doing?


285
00:17:29,082 --> 00:17:32,953 line:-2
The closure is probably determining
which characters to take,


286
00:17:33,020 --> 00:17:35,455 line:-1
but how's it being applied?


287
00:17:35,522 --> 00:17:37,090 line:-1
Pause and think about it for a second.


288
00:17:39,493 --> 00:17:42,095 line:-2
Is it taking characters
that match the predicate


289
00:17:42,162 --> 00:17:43,897 line:-1
and dropping those that don't?


290
00:17:45,599 --> 00:17:48,602 line:-2
Is it taking characters
while they match the predicate


291
00:17:48,669 --> 00:17:50,437 line:-1
and dropping everything that follows?


292
00:17:51,872 --> 00:17:54,741 line:-1
In this case, the call site is only clear


293
00:17:54,808 --> 00:17:58,045 line:-2
if we use the longhand spelling
that includes the argument label.


294
00:18:00,013 --> 00:18:01,515 line:-1
We can do better.


295
00:18:01,582 --> 00:18:04,084 line:-1
Because folks can drop the argument label,


296
00:18:04,151 --> 00:18:06,587 line:-2
it's best to name methods
assuming that they will.


297
00:18:07,387 --> 00:18:11,158 line:-2
A better name for "take"
might be something like "prefix,"


298
00:18:11,225 --> 00:18:15,162 line:-2
which suggests the result is anchored
to the start of the collection.


299
00:18:15,229 --> 00:18:19,800 line:-2
In fact, prefix(while is the name
that was ultimately chosen for this method


300
00:18:19,867 --> 00:18:23,937 line:-2
when it was added to the Standard Library
way back in Swift 3.1.


301
00:18:24,671 --> 00:18:27,574 line:-2
The same guidance applies
to more complex APIs,


302
00:18:27,641 --> 00:18:30,310 line:-2
including those
with multiple trailing closures.


303
00:18:31,011 --> 00:18:32,713 line:-1
It's important the base name of the method


304
00:18:32,779 --> 00:18:35,616 line:-2
clarify the role
of the first trailing closure.


305
00:18:35,682 --> 00:18:37,251 line:-1
Because its label will be dropped


306
00:18:37,317 --> 00:18:39,653 line:-2
even if it isn't the first argument
to the method.


307
00:18:40,587 --> 00:18:45,325 line:-2
Next, let's discuss KeyPath expressions
as functions.


308
00:18:45,759 --> 00:18:49,196 line:-2
Back in Swift 4.1,
we introduced smart KeyPaths,


309
00:18:49,263 --> 00:18:52,799 line:-2
types that represent
uninvoked references to properties


310
00:18:52,866 --> 00:18:56,136 line:-2
which can be used to get
and set their underlying values.


311
00:18:57,838 --> 00:18:59,573 line:-1
When you're designing an API,


312
00:18:59,640 --> 00:19:02,676 line:-2
KeyPaths are a tempting alternative
to function parameters


313
00:19:02,743 --> 00:19:05,913 line:-2
if you expect the call site
to be a simple property access,


314
00:19:05,979 --> 00:19:09,149 line:-2
because they're more concise
and less nested.


315
00:19:09,216 --> 00:19:12,653 line:-2
For this example,
I've borrowed an algorithm from Ruby.


316
00:19:12,719 --> 00:19:17,457 line:-2
Chunked. It's an adapter over a collection
that groups adjacent elements


317
00:19:17,524 --> 00:19:19,760 line:-1
while their keys are equal.


318
00:19:19,826 --> 00:19:23,597 line:-2
I happen to keep a list handy
of my friends' and family's shoe sizes.


319
00:19:23,664 --> 00:19:25,632 line:-2
A new pair of shoes
always makes a good present.


320
00:19:26,333 --> 00:19:28,936 line:-1
I can get a quick overview by sorting,


321
00:19:29,002 --> 00:19:31,371 line:-2
and then chunking my contacts
by shoe size.


322
00:19:31,972 --> 00:19:36,944 line:-2
Hmm. If I ever need to re-gift a pair,
it looks like I should try Charles.


323
00:19:37,010 --> 00:19:38,946 line:-1
Of course, every once in a while,


324
00:19:39,012 --> 00:19:42,883 line:-2
you're going to encounter a use case
that isn't a simple property access.


325
00:19:43,350 --> 00:19:46,286 line:-2
Say you're shopping for sandals
which don't come in half sizes.


326
00:19:47,321 --> 00:19:51,692 line:-2
To support both of these call sites,
you'd have to duplicate the declaration.


327
00:19:51,758 --> 00:19:56,230 line:-2
New to Swift 5.2, you can use
a KeyPath expression as a function.


328
00:19:57,764 --> 00:20:00,033 line:-1
This means you can pass a KeyPath argument


329
00:20:00,100 --> 00:20:02,769 line:-2
to any function parameter
with a matching signature.


330
00:20:02,836 --> 00:20:05,506 line:-2
And you can delete
any duplicate declarations


331
00:20:05,572 --> 00:20:08,475 line:-2
you may have added in the past,
in order to accept KeyPaths.


332
00:20:09,843 --> 00:20:12,446 line:-1
Next, I'll introduce you to @main,


333
00:20:12,513 --> 00:20:15,716 line:-2
a tool for type-based
program entry points.


334
00:20:15,782 --> 00:20:19,520 line:-2
Every program
needs to start execution somehow.


335
00:20:19,586 --> 00:20:22,623 line:-2
Here, I'm using
the new ArgumentParser package


336
00:20:22,689 --> 00:20:24,992 line:-2
to declare a simple tool
that prints "hello"


337
00:20:25,058 --> 00:20:27,060 line:-1
to a name drawn from the command line.


338
00:20:28,562 --> 00:20:31,064 line:-2
But the boilerplate
required to start execution


339
00:20:31,131 --> 00:20:33,200 line:-1
is as long as the program itself,


340
00:20:33,267 --> 00:20:35,469 line:-2
and it seriously kills
the declarative vibe.


341
00:20:37,070 --> 00:20:39,273 line:-1
Since Swift 1.0, you've been able to use


342
00:20:39,339 --> 00:20:42,409 line:-2
the UIApplicationMain attribute
on your AppDelegate


343
00:20:42,476 --> 00:20:46,880 line:-2
to tell the compiler to generate
an implicit main.swift that runs your app.


344
00:20:46,947 --> 00:20:51,151 line:-2
In Swift 5.3, we've generalized
and democratized this feature.


345
00:20:52,619 --> 00:20:54,021 line:-1
If you're a Library author,


346
00:20:54,087 --> 00:20:58,559 line:-2
just declare a static main method
on the protocol or superclass


347
00:20:58,625 --> 00:21:01,461 line:-2
you expect your users
to derive their entry point from.


348
00:21:03,497 --> 00:21:05,899 line:-2
For ArgumentParser,
that's ParsableCommand.


349
00:21:06,834 --> 00:21:10,871 line:-2
This will enable your users
to tag that type with @main


350
00:21:10,938 --> 00:21:15,576 line:-2
and the compiler to generate
an implicit main.swift on their behalf.


351
00:21:15,642 --> 00:21:19,613 line:-2
This standardized way to delegate
a program's entry point


352
00:21:19,680 --> 00:21:22,015 line:-2
should make it easier
to get up and running,


353
00:21:22,082 --> 00:21:25,052 line:-2
whether you're working
on a command line tool,


354
00:21:25,118 --> 00:21:26,587 line:-1
an existing application,


355
00:21:28,255 --> 00:21:31,758 line:-1
a new one, or something else entirely.


356
00:21:32,726 --> 00:21:37,564 line:-2
We can't wait to see how you put these
powerful new API design tools to use.


357
00:21:38,265 --> 00:21:41,068 line:-2
Next, I want to highlight
some language enhancements


358
00:21:41,134 --> 00:21:44,171 line:-2
that eliminate boilerplate
and increase expressivity.


359
00:21:45,372 --> 00:21:47,708 line:-2
Let's start
with the increased availability


360
00:21:47,774 --> 00:21:50,143 line:-1
of implicit self in closures.


361
00:21:50,711 --> 00:21:53,780 line:-2
In order to draw attention
to potential retain cycles,


362
00:21:53,847 --> 00:21:59,720 line:-2
Swift requires the explicit use of "self"
in escaping closures which capture it.


363
00:21:59,786 --> 00:22:03,090 line:-2
But when you're required to include
many self.s in a row,


364
00:22:03,156 --> 00:22:04,858 line:-1
it can start to feel a bit redundant.


365
00:22:06,093 --> 00:22:10,063 line:-2
New to Swift 5.3,
if you include "self" in the capture list,


366
00:22:10,864 --> 00:22:13,066 line:-2
you can omit it
from the body of the closure.


367
00:22:14,868 --> 00:22:18,772 line:-2
You're still required to be explicit
about your intention to capture self,


368
00:22:18,839 --> 00:22:22,609 line:-2
but now the cost of that explicitness
is only a single declaration.


369
00:22:24,811 --> 00:22:29,516 line:-2
Sometimes, however, even a single use
of self. can feel unnecessary.


370
00:22:29,583 --> 00:22:32,786 line:-2
Like in SwiftUI,
where self tends to be a value type,


371
00:22:32,853 --> 00:22:35,889 line:-1
making reference cycles much less likely.


372
00:22:35,956 --> 00:22:39,059 line:-2
Well, with Swift 5.3,
I'm pleased to tell you


373
00:22:39,126 --> 00:22:43,397 line:-2
that if self is a struct or enum,
you can omit it entirely from the closure.


374
00:22:45,432 --> 00:22:49,036 line:-2
We think these refinements
will increase the signal-to-noise ratio


375
00:22:49,102 --> 00:22:52,906 line:-2
of compiler errors related to
the implicit use of self in closures,


376
00:22:52,973 --> 00:22:57,411 line:-2
mitigating the temptation to slap on self.
without due consideration.


377
00:22:57,945 --> 00:23:00,981 line:-2
Next, let's talk about
multi-pattern catch clauses.


378
00:23:02,216 --> 00:23:04,351 line:-1
Historically, do-catch statements


379
00:23:04,418 --> 00:23:06,820 line:-2
have not been as expressive
as switch statements,


380
00:23:06,887 --> 00:23:09,389 line:-2
leading folks to resort
to nesting switches


381
00:23:09,456 --> 00:23:11,792 line:-1
inside of catch clauses.


382
00:23:11,859 --> 00:23:16,296 line:-2
Well, in Swift 5.3, we've extended
the grammar of catch clauses


383
00:23:16,363 --> 00:23:18,999 line:-1
to have the full power of switch cases.


384
00:23:20,601 --> 00:23:24,371 line:-2
This allows you to flatten
this kind of multi-clause pattern matching


385
00:23:24,438 --> 00:23:28,342 line:-2
directly into the do-catch statement,
making it much easier to read.


386
00:23:29,543 --> 00:23:33,080 line:-2
Next, let's look at a couple enhancements
we've made to enum types.


387
00:23:34,047 --> 00:23:36,984 line:-2
Since Swift 4.1,
the compiler has been able to synthesize


388
00:23:37,050 --> 00:23:40,888 line:-2
equatable and hashable conformance
for a wide variety of types.


389
00:23:42,556 --> 00:23:45,058 line:-1
Sometimes, though, you run into situations


390
00:23:45,125 --> 00:23:48,629 line:-2
where it'd be awfully convenient
to have a comparison operator.


391
00:23:48,695 --> 00:23:51,465 line:-1
I'm pleased to tell you that in Swift 5.3,


392
00:23:51,532 --> 00:23:55,135 line:-2
the compiler has learned
how to synthesize comparable conformance


393
00:23:55,202 --> 00:23:57,337 line:-1
for qualifying enum types.


394
00:23:57,871 --> 00:24:01,642 line:-2
Next, let's discuss enum cases
as protocol witnesses.


395
00:24:02,442 --> 00:24:03,844 line:-1
Consider these two call sites.


396
00:24:04,811 --> 00:24:08,348 line:-2
Is fileCorrupted a static var
or an enum case?


397
00:24:10,217 --> 00:24:13,587 line:-2
Is keyNotFound a static func
or an enum case?


398
00:24:15,455 --> 00:24:16,924 line:-1
Static var and static func:


399
00:24:18,158 --> 00:24:19,326 line:-1
enum cases.


400
00:24:19,893 --> 00:24:23,030 line:-2
The call sites for the two declarations
are identical.


401
00:24:24,531 --> 00:24:26,867 line:-1
In recognition of this, in Swift 5.3,


402
00:24:26,934 --> 00:24:30,537 line:-2
we've enhanced enum cases
so they can now be used to fulfill


403
00:24:30,604 --> 00:24:33,841 line:-2
static var and static func
protocol requirements.


404
00:24:34,575 --> 00:24:37,978 line:-2
Last year, Swift added support
for embedded DSLs


405
00:24:38,045 --> 00:24:40,280 line:-1
to power SwiftUI's declarative syntax.


406
00:24:41,615 --> 00:24:44,751 line:-2
This included builder closures
to collective view's children,


407
00:24:45,719 --> 00:24:48,655 line:-2
and basic control flow statements
like if-else.


408
00:24:50,023 --> 00:24:52,860 line:-1
I'm excited to tell you that in Swift 5.3,


409
00:24:52,926 --> 00:24:54,862 line:-1
we've extended embedded DSLs


410
00:24:54,928 --> 00:24:58,031 line:-2
to support pattern matching
control flow statements


411
00:24:58,098 --> 00:24:59,967 line:-1
like if-let and switch.


412
00:25:01,068 --> 00:25:05,239 line:-2
Here, I'm able to compose a photo gallery
of my favorite animals


413
00:25:05,305 --> 00:25:06,807 line:-1
by using a switch statement


414
00:25:06,874 --> 00:25:09,276 line:-2
to alternate between
the different image layouts


415
00:25:09,343 --> 00:25:12,246 line:-1
within this scrollable vertical stack.


416
00:25:12,312 --> 00:25:15,415 line:-2
Next, I'll introduce you
to builder inference.


417
00:25:16,083 --> 00:25:18,785 line:-2
Here, I've written an app
for keeping track of the books


418
00:25:18,852 --> 00:25:20,754 line:-1
I'm currently reading in my book club.


419
00:25:21,955 --> 00:25:25,592 line:-2
I've got a main window
for my primary user interface


420
00:25:25,659 --> 00:25:28,562 line:-2
and a Preferences window
for my app settings.


421
00:25:28,629 --> 00:25:32,966 line:-2
Previously, to use DSL syntax
at the top level of body like this


422
00:25:33,033 --> 00:25:37,371 line:-2
required tagging it
with the specific builder attribute.


423
00:25:37,437 --> 00:25:40,040 line:-1
With Swift 5.3, I'm excited to tell you


424
00:25:40,107 --> 00:25:42,676 line:-2
that builder attribute
will no longer be required


425
00:25:42,743 --> 00:25:45,045 line:-2
because we're teaching the compiler
how to infer it


426
00:25:45,112 --> 00:25:46,513 line:-1
from the protocol requirement.


427
00:25:48,382 --> 00:25:51,318 line:0
SwiftUI added a ton
of exciting new features this year.


428
00:25:51,385 --> 00:25:52,386 line:0
If you want to know more,


429
00:25:52,452 --> 00:25:55,422 line:0
I recommend you watch
the "What's New in SwiftUI" session.


430
00:25:56,557 --> 00:25:58,292 line:-1
Now I want to change gears and talk about


431
00:25:58,358 --> 00:26:01,461 line:-2
some of the powerful,
new Swift APIs available to you,


432
00:26:01,528 --> 00:26:04,464 line:-1
beginning with those in the SDK.


433
00:26:04,531 --> 00:26:06,667 line:-1
Let's start with Float16.


434
00:26:07,568 --> 00:26:12,439 line:0
Float16 is an IEEE 754
standard floating-point format


435
00:26:12,506 --> 00:26:13,874 line:0
that's new to Swift 5.3.


436
00:26:15,209 --> 00:26:19,179 line:0
As the name suggests,
a Float16 takes just two bytes of memory,


437
00:26:19,246 --> 00:26:22,015 line:0
as opposed to a single-precision float
which takes four.


438
00:26:23,650 --> 00:26:25,052 line:0
Since it's half the size,


439
00:26:25,118 --> 00:26:29,223 line:0
you can fit twice as many of them
in a SIMD register or page of memory


440
00:26:29,289 --> 00:26:31,225 line:0
which, on supported hardware,


441
00:26:31,291 --> 00:26:33,927 line:0
generally results
in a doubling of performance.


442
00:26:35,495 --> 00:26:37,965 line:0
Beware, though. As a smaller data type,


443
00:26:38,031 --> 00:26:40,834 line:0
it also has
a more limited precision and range,


444
00:26:40,901 --> 00:26:44,171 line:0
so be careful translating code
that was originally implemented


445
00:26:44,238 --> 00:26:46,740 line:0
for double or float to work with Float16.


446
00:26:48,408 --> 00:26:50,844 line:0
For more on Float16, I recommend you watch


447
00:26:50,911 --> 00:26:53,914 line:0
the session we've prepared
on "Numerical Computing in Swift."


448
00:26:55,282 --> 00:26:59,753 line:-2
Next, let's talk about Apple Archive,
a new modular archive format


449
00:26:59,820 --> 00:27:04,458 line:-2
based on the battle-tested technology
Apple uses to deliver OS updates.


450
00:27:05,826 --> 00:27:09,229 line:-2
It's optimized
for fast, multithreaded compression


451
00:27:09,296 --> 00:27:12,466 line:-2
and comes with Finder integration,
a command-line tool,


452
00:27:12,533 --> 00:27:18,338 line:-2
and a host of other powerful features,
including an idiomatic Swift API.


453
00:27:18,906 --> 00:27:20,541 line:-1
This is how simple it is


454
00:27:20,607 --> 00:27:25,045 line:-2
to efficiently compress and archive
a source directory using Apple Archive.


455
00:27:27,414 --> 00:27:30,551 line:-2
I want to draw your attention
to the FileStream constructor


456
00:27:30,617 --> 00:27:35,289 line:-2
which leverages another new library
we're introducing this year: Swift System.


457
00:27:36,990 --> 00:27:40,227 line:-2
Swift System provides
modern idiomatic interfaces


458
00:27:40,294 --> 00:27:42,462 line:-1
to system calls and currency types


459
00:27:42,529 --> 00:27:45,399 line:-2
for low-level system APIs
like Apple Archive.


460
00:27:47,201 --> 00:27:51,038 line:-2
The raw weakly-typed interfaces
imported through the Darwin overlay


461
00:27:51,104 --> 00:27:52,906 line:-1
can be finicky and error-prone.


462
00:27:54,541 --> 00:27:56,710 line:-1
Swift System wraps these APIs


463
00:27:56,777 --> 00:28:00,747 line:-2
using techniques such as
strongly-typed RawRepresentable structs,


464
00:28:00,814 --> 00:28:05,619 line:-2
error handling, defaulted arguments,
namespaces, and function overloading,


465
00:28:05,686 --> 00:28:06,854 line:-1
laying the groundwork


466
00:28:06,920 --> 00:28:10,991 line:-2
for a more idiomatically Swift
system layer of the SDK.


467
00:28:11,725 --> 00:28:14,595 line:0
Last, let's look at some enhancements
to OSLog.


468
00:28:15,495 --> 00:28:18,232 line:0
OSLog is a unified logging API


469
00:28:18,298 --> 00:28:20,501 line:0
that's been optimized
to have minimal overhead


470
00:28:20,567 --> 00:28:23,871 line:0
and crafted to prevent
inadvertent logging of sensitive data.


471
00:28:25,405 --> 00:28:29,643 line:0
In Swift 5.3, we've leveraged
sophisticated compiler optimizations


472
00:28:29,710 --> 00:28:33,514 line:0
to make OSLog dramatically faster
and more expressive,


473
00:28:34,381 --> 00:28:38,685 line:0
adding support for string interpolations
and formatting options.


474
00:28:38,752 --> 00:28:41,622 line:-2
If you're still using print
as your logging solution,


475
00:28:41,688 --> 00:28:44,424 line:-1
now is the perfect time to reconsider.


476
00:28:45,125 --> 00:28:46,994 line:0
If you want to learn more about these APIs


477
00:28:47,060 --> 00:28:50,531 line:0
and how to leverage logging
to track down hard-to-reproduce bugs,


478
00:28:50,597 --> 00:28:53,433 line:0
I suggest you watch the session
on "Logging in Swift."


479
00:28:54,201 --> 00:28:57,337 line:-2
Last, let's turn our attention
to the growing number of APIs


480
00:28:57,404 --> 00:29:01,842 line:-2
available to you outside the SDK
via the Swift Package Manager.


481
00:29:02,242 --> 00:29:04,378 line:-1
Let's begin with Swift Numerics,


482
00:29:04,444 --> 00:29:07,514 line:-2
a new open-source package
for numerical computing.


483
00:29:08,849 --> 00:29:11,818 line:-2
Swift Numerics defines
all the basic math functions


484
00:29:11,885 --> 00:29:13,420 line:-1
like sine and logarithm


485
00:29:13,487 --> 00:29:16,557 line:-2
in a way that's much more useful
for generic contexts,


486
00:29:16,623 --> 00:29:20,027 line:-2
as well as support for complex numbers
and arithmetic.


487
00:29:20,093 --> 00:29:21,595 line:-1
Swift Numerics complex numbers


488
00:29:21,662 --> 00:29:24,131 line:-2
are layout compatible
with their C counterparts,


489
00:29:24,198 --> 00:29:26,333 line:-1
but faster and more accurate.


490
00:29:27,801 --> 00:29:31,738 line:-2
There are many other exciting projects
being actively discussed right now


491
00:29:31,805 --> 00:29:33,640 line:-1
on the Swift Numerics GitHub page,


492
00:29:33,707 --> 00:29:36,343 line:-2
including
approximate equality comparisons,


493
00:29:36,410 --> 00:29:39,746 line:-2
arbitrary-precision integers
and decimal floating-point numbers.


494
00:29:41,682 --> 00:29:44,418 line:0
The Swift Numerics package
is discussed in-depth


495
00:29:44,484 --> 00:29:47,120 line:0
in the session we've prepared
on "Numerical Computing."


496
00:29:48,355 --> 00:29:51,758 line:-1
Next, let's look at Swift Argument Parser,


497
00:29:51,825 --> 00:29:56,029 line:-2
a new open-source Swift package
for command-line argument parsing.


498
00:29:56,096 --> 00:29:58,699 line:-1
Earlier, we saw how to use Argument Parser


499
00:29:58,765 --> 00:30:01,768 line:-2
to print "hello" to a name drawn
from the command line.


500
00:30:03,971 --> 00:30:06,840 line:-2
Let's extend this
by adding an integer option,


501
00:30:06,907 --> 00:30:08,976 line:-1
count, with a default of one,


502
00:30:10,344 --> 00:30:13,447 line:-2
and a loop to print the greeting
"count" number of times.


503
00:30:15,649 --> 00:30:18,552 line:-2
Now our tool can be
that much more enthusiastic.


504
00:30:20,420 --> 00:30:23,090 line:-2
It's also smart
about what values it accepts,


505
00:30:24,591 --> 00:30:26,593 line:-1
guides users towards correct usage,


506
00:30:28,695 --> 00:30:31,298 line:-2
and includes
a richly-documented help screen.


507
00:30:32,966 --> 00:30:37,204 line:-2
All this and more from a program
that comfortably fits on a slide.


508
00:30:38,472 --> 00:30:40,374 line:-1
Last, I'll introduce you


509
00:30:40,440 --> 00:30:43,043 line:-2
to the Swift StandardLibraryPreview
Package.


510
00:30:43,110 --> 00:30:46,213 line:-2
The Preview Package provides access
to functionality


511
00:30:46,280 --> 00:30:48,982 line:-2
that's been accepted
through the Swift Evolution process,


512
00:30:49,049 --> 00:30:52,519 line:-2
but hasn't yet shipped
as a part of an official Swift release.


513
00:30:52,586 --> 00:30:55,255 line:-2
By getting new features
into your hands sooner,


514
00:30:55,322 --> 00:30:57,925 line:-1
we think we can make Swift even better.


515
00:30:58,625 --> 00:31:01,061 line:-2
As part of this effort,
we've also made it easier


516
00:31:01,128 --> 00:31:04,431 line:-2
for Swift Evolution proposals
to proceed to review.


517
00:31:04,498 --> 00:31:08,569 line:-2
In the past, that would have meant
building the entire compiler stack.


518
00:31:08,635 --> 00:31:13,073 line:-2
Now, you can provide the implementation
for a StandardLibrary feature proposal


519
00:31:13,140 --> 00:31:15,776 line:-1
as a stand-alone Swift PM package.


520
00:31:17,177 --> 00:31:21,114 line:-2
We've seeded the preview package
with the functionality from SE-0270,


521
00:31:21,181 --> 00:31:24,117 line:-2
which includes operations
on sub-ranges of collections


522
00:31:24,184 --> 00:31:26,053 line:-1
and the supporting range set type.


523
00:31:26,119 --> 00:31:27,921 line:-1
I encourage you to try it out.


524
00:31:28,422 --> 00:31:33,126 line:-2
The future of the Swift Library ecosystem
is being molded right now


525
00:31:33,193 --> 00:31:36,997 line:-2
as we push onto new platforms
and into new domains,


526
00:31:37,064 --> 00:31:39,366 line:-1
and it's being done in plain sight


527
00:31:39,433 --> 00:31:42,870 line:-2
as we increasingly leverage
open-source packages.


528
00:31:43,270 --> 00:31:46,039 line:-2
We're deliberately
releasing these packages early


529
00:31:46,106 --> 00:31:47,841 line:-1
while they're still malleable


530
00:31:47,908 --> 00:31:50,911 line:-2
and developing them
as community efforts on GitHub.


531
00:31:52,346 --> 00:31:56,083 line:-2
So try them out. File an issue.
Open a pull request.


532
00:31:57,451 --> 00:31:59,152 line:-1
It's never been a better time,


533
00:31:59,219 --> 00:32:03,724 line:-2
and it's never been easier
to get involved and make an impact.


534
00:32:03,790 --> 00:32:07,294 line:-2
I hope you're as excited
about these new Swift releases as we are.


535
00:32:07,361 --> 00:32:09,630 line:-1
We can't wait to see what you build.


536
00:32:10,163 --> 00:32:14,067 line:-2
Enjoy the rest of WWDC.
Thank you for watching.

