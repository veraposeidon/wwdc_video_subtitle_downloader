1
00:00:03,836 --> 00:00:06,974 line:-1
Hello, and welcome to WWDC.


2
00:00:09,409 --> 00:00:10,611 line:0
Hey. My name's Matthew,


3
00:00:10,677 --> 00:00:12,946 line:0
and I'm on the Security Engineering
and Architecture team.


4
00:00:13,013 --> 00:00:16,283 line:-2
Today, we're going to talk
about the Endpoint Security Framework.


5
00:00:16,350 --> 00:00:20,854 line:-2
The Endpoint Security Framework was first
introduced last year in macOS Catalina.


6
00:00:21,255 --> 00:00:24,558 line:-2
It is intended to be used as a replacement
for the Kauth KPI,


7
00:00:24,625 --> 00:00:27,995 line:-2
the unsupported Mac kernel framework,
and the OpenBSM audit trail.


8
00:00:29,530 --> 00:00:32,799 line:-2
Kernel extensions, or KEXTS,
can be difficult to develop


9
00:00:32,866 --> 00:00:34,668 line:-1
and even more difficult to debug.


10
00:00:35,402 --> 00:00:37,371 line:-2
Further, KEXTS pose
a maintenance nightmare,


11
00:00:37,437 --> 00:00:39,406 line:-1
as kernel interfaces frequently change.


12
00:00:40,474 --> 00:00:43,744 line:-2
They can also degrade
overall system security and stability


13
00:00:43,810 --> 00:00:46,246 line:-2
as even minor bugs
often lead to kernel panics.


14
00:00:47,981 --> 00:00:49,483 line:-1
With the EndpointSecurity Framework,


15
00:00:49,550 --> 00:00:51,985 line:-2
you no longer need to develop
a kernel extension,


16
00:00:52,052 --> 00:00:54,988 line:-2
and you can instead focus on
the real goals of your products.


17
00:00:56,657 --> 00:00:58,992 line:-1
Products that use EndpointSecurity, or ES,


18
00:00:59,059 --> 00:01:02,796 line:-2
are able to tap into a rich event stream
from a normal application.


19
00:01:03,564 --> 00:01:07,568 line:-2
Right now, ES supports roughly 100 event
types, and we're constantly adding more.


20
00:01:08,802 --> 00:01:10,938 line:-1
There are two categories of event types.


21
00:01:11,004 --> 00:01:14,474 line:-2
We have NOTIFY events, which inform you
of an operation taking place,


22
00:01:14,541 --> 00:01:16,510 line:-2
and AUTH events,
which allow you to control


23
00:01:16,577 --> 00:01:19,379 line:-2
whether or not an operation
should be allowed to continue.


24
00:01:20,013 --> 00:01:23,050 line:-2
We'll be discussing how
the EndpointSecurity subsystem works,


25
00:01:23,116 --> 00:01:25,819 line:-2
how your products
can best utilize the event stream,


26
00:01:25,886 --> 00:01:28,589 line:-2
as well as some more advanced features
available to you.


27
00:01:29,923 --> 00:01:33,894 line:-2
While it's possible to distribute your
ES application as a stand-alone product,


28
00:01:33,961 --> 00:01:36,663 line:-2
we believe there are a lot of benefits
to delivering your product


29
00:01:36,730 --> 00:01:38,932 line:-2
as an EndpointSecurity based
system extension.


30
00:01:39,733 --> 00:01:43,203 line:-2
System extensions were also introduced
last year in macOS Catalina.


31
00:01:44,071 --> 00:01:47,508 line:-2
Several types of extensions are supported,
including Network Extensions


32
00:01:47,574 --> 00:01:50,644 line:-2
for writing applications
such as VPNs and content filters,


33
00:01:50,711 --> 00:01:52,813 line:-1
DriverKit for controlling hardware,


34
00:01:52,880 --> 00:01:56,717 line:-2
and EndpointSecurity targeted at products
like endpoint detection and response.


35
00:01:57,384 --> 00:02:00,187 line:-2
We're not going to cover system extensions
in detail here,


36
00:02:00,254 --> 00:02:03,857 line:-2
but you should check out last year's
WWDC 2019 session


37
00:02:03,924 --> 00:02:07,027 line:-2
titled "System Extensions and DriverKit"
for more information.


38
00:02:08,262 --> 00:02:10,464 line:-1
First, when the extension is installed,


39
00:02:10,531 --> 00:02:13,166 line:-2
it becomes protected
by System Integrity Protection,


40
00:02:13,233 --> 00:02:16,803 line:-2
preventing accidental or malicious
tampering of you extension and assets.


41
00:02:17,804 --> 00:02:21,108 line:-2
We're also able to provide a greater
level of protection for you daemon


42
00:02:21,175 --> 00:02:22,743 line:-1
similar to that of system daemons.


43
00:02:23,343 --> 00:02:25,612 line:-1
This means that we prevent even root users


44
00:02:25,679 --> 00:02:28,348 line:-2
from being able to unload
your launchd job.


45
00:02:29,716 --> 00:02:33,787 line:-2
Also, there are some EndpointSecurity
features that products can only use


46
00:02:33,854 --> 00:02:35,455 line:-1
if they are a system extension,


47
00:02:35,856 --> 00:02:37,257 line:-1
such as during system start-up,


48
00:02:37,324 --> 00:02:39,760 line:-2
the ability to execute
and set up an event stream


49
00:02:39,826 --> 00:02:43,463 line:-2
before other third party applications
are able to execute.


50
00:02:44,164 --> 00:02:45,799 line:-1
I always like starting with an example,


51
00:02:45,866 --> 00:02:48,235 line:-2
so let's take a quick look
at the key components needed


52
00:02:48,302 --> 00:02:50,070 line:-1
to get started with EndpointSecurity.


53
00:02:50,904 --> 00:02:53,907 line:-2
One thing to note,
this framework is provided as a C library,


54
00:02:53,974 --> 00:02:55,142 line:-1
which is a little different


55
00:02:55,209 --> 00:02:57,778 line:-2
than many other Apple frameworks
you might encounter.


56
00:02:58,345 --> 00:03:00,180 line:-1
Using C allowed us greater control


57
00:03:00,247 --> 00:03:02,616 line:-2
over some memory
and performance characteristics.


58
00:03:03,183 --> 00:03:05,986 line:-2
Also, our goal was to be able
to provide a library


59
00:03:06,053 --> 00:03:08,622 line:-2
that would be quickly adoptable
by existing products.


60
00:03:09,156 --> 00:03:12,025 line:-2
By using C, this library is callable
from many languages


61
00:03:12,092 --> 00:03:14,394 line:-1
including Swift, Objective-C and Rust.


62
00:03:15,829 --> 00:03:19,733 line:-2
First off, in this example, you can see we
start by initializing a new event stream


63
00:03:19,800 --> 00:03:22,035 line:-1
using the ES new client API.


64
00:03:23,003 --> 00:03:26,573 line:-2
This function returns
an ES client T handle as an out parameter,


65
00:03:26,640 --> 00:03:29,610 line:-2
but, importantly, is also defines
the event handler block.


66
00:03:30,377 --> 00:03:31,378 line:-1
The block passed here


67
00:03:31,445 --> 00:03:34,581 line:-2
will be invoked whenever there is
an event ready to be processed.


68
00:03:36,183 --> 00:03:39,419 line:-2
In this example, you can see the block
simply prints out the event type.


69
00:03:40,187 --> 00:03:42,756 line:-2
Next, we set up the subscriptions
for the event stream


70
00:03:42,823 --> 00:03:44,791 line:-1
using the es_subscribe API.


71
00:03:44,858 --> 00:03:48,295 line:-2
In this example, we have a single event
in the array, the NOTIFY_EXEC event.


72
00:03:50,097 --> 00:03:53,667 line:-2
Also in this example, we see
the es_delete client API being used,


73
00:03:53,734 --> 00:03:56,036 line:-2
when something went wrong
setting up the subscriptions,


74
00:03:56,103 --> 00:03:58,338 line:-2
and this API can be used
to clean up resources


75
00:03:58,405 --> 00:04:01,041 line:-2
previously obtained
from a call to es_new_client.


76
00:04:03,076 --> 00:04:04,978 line:-1
Finally, we call dispatch main


77
00:04:05,045 --> 00:04:07,147 line:-2
which will allow the program
to continue executing


78
00:04:07,214 --> 00:04:10,184 line:-2
and process events via
the event handler block submitted above.


79
00:04:11,485 --> 00:04:14,421 line:-2
To help you all get an understanding
of how EndpointSecurity works,


80
00:04:14,488 --> 00:04:16,790 line:-2
let's take a look
at a high-level architecture design.


81
00:04:17,724 --> 00:04:20,394 line:-2
When your process connects
to the EndpointSecurity subsystem


82
00:04:20,459 --> 00:04:22,629 line:-1
using the es_new_client API,


83
00:04:22,696 --> 00:04:25,899 line:-2
a channel is set up through which messages
will be enqueued for processing.


84
00:04:26,500 --> 00:04:30,103 line:-2
In this diagram here, there are
two different ES-based applications.


85
00:04:31,205 --> 00:04:35,042 line:-2
One has set up two event streams
using multiple calls to es_new_client,


86
00:04:35,509 --> 00:04:37,644 line:-1
and the second one has a single channel.


87
00:04:37,711 --> 00:04:40,314 line:-2
We typically refer to these channels
as ES clients.


88
00:04:41,248 --> 00:04:44,017 line:-2
Each ES client is able to have
its own set of subscriptions


89
00:04:44,084 --> 00:04:45,853 line:-1
to control which events it receives.


90
00:04:47,354 --> 00:04:48,989 line:-1
When an event is triggered in the kernel,


91
00:04:49,056 --> 00:04:51,391 line:-2
and assuming our client
is subscribed to that event,


92
00:04:51,458 --> 00:04:53,927 line:-2
EndpointSecurity intercepts
and enriches this event


93
00:04:53,994 --> 00:04:57,764 line:-2
with information that is typically helpful
for ES clients performing analysis.


94
00:04:58,699 --> 00:05:01,835 line:-2
We'll discuss the information collected
in more detail in a second,


95
00:05:01,902 --> 00:05:04,638 line:-2
but once collected, this data
is then wrapped in a message envelope.


96
00:05:05,439 --> 00:05:08,775 line:-2
Next, that message is then sent
to all appropriate ES clients,


97
00:05:08,842 --> 00:05:11,879 line:-2
enqueueing the message
for the event handler blocks to process.


98
00:05:12,846 --> 00:05:15,949 line:-2
The message is enqueued
for all clients simultaneously.


99
00:05:16,016 --> 00:05:18,752 line:-2
So for those of you
already familiar with EndpointSecurity,


100
00:05:18,819 --> 00:05:20,521 line:-1
this is a slight change in behavior,


101
00:05:20,587 --> 00:05:23,090 line:-2
where before,
events were delivered to clients serially.


102
00:05:24,424 --> 00:05:27,794 line:-2
Some events require a response,
which we'll talk about shortly,


103
00:05:27,861 --> 00:05:30,230 line:-2
in which case the original operation
is held up in the kernel


104
00:05:30,297 --> 00:05:31,732 line:-1
until a response is received.


105
00:05:32,633 --> 00:05:36,904 line:-2
For normal notification events, or after
receiving a response for AUTH events,


106
00:05:36,970 --> 00:05:40,340 line:-2
the operation is immediately unblocked
in the kernel and allowed to continue.


107
00:05:41,608 --> 00:05:42,943 line:-1
Last thing to note in this diagram,


108
00:05:43,010 --> 00:05:46,046 line:-2
is that EndpointSecurity
attempts to cache as much as possible


109
00:05:46,113 --> 00:05:47,748 line:-1
in order to reduce the number of messages


110
00:05:47,814 --> 00:05:50,217 line:-2
that are required to be delivered
for AUTH events.


111
00:05:50,751 --> 00:05:53,086 line:-2
We have a lot more information
about the cache later on.


112
00:05:54,521 --> 00:05:58,358 line:-2
The message envelope I just mentioned
refers to the es_message_t structure,


113
00:05:58,425 --> 00:06:01,328 line:-2
which is the wrapper for all ES events
delivered to ES clients


114
00:06:01,395 --> 00:06:02,763 line:-1
via the event handler block.


115
00:06:03,830 --> 00:06:06,834 line:-2
Each message contains three
primary categories of information.


116
00:06:07,668 --> 00:06:09,636 line:-1
First, message metadata.


117
00:06:09,703 --> 00:06:13,106 line:-2
This includes things like the event type,
message generation time,


118
00:06:13,173 --> 00:06:15,309 line:-1
whether it's an AUTH or a NOTIFY event,


119
00:06:15,375 --> 00:06:18,846 line:-2
and a message version number used for
compatibility, which we'll touch on later.


120
00:06:19,880 --> 00:06:22,316 line:-1
Next, all messages include information


121
00:06:22,382 --> 00:06:25,619 line:-2
about the process that caused the event
to be triggered in the first place.


122
00:06:26,353 --> 00:06:29,523 line:-2
Process information includes information
about the executable file,


123
00:06:29,590 --> 00:06:31,091 line:-1
including full stat info,


124
00:06:31,158 --> 00:06:35,229 line:-2
code signing information, process ID and
user ID information, and a whole lot more.


125
00:06:36,496 --> 00:06:40,968 line:-2
Last, each message contains information
specific to the event that occurred.


126
00:06:41,635 --> 00:06:44,037 line:-2
For example,
the SIGNAL event includes information


127
00:06:44,104 --> 00:06:47,107 line:-2
about the process being signaled
and the signal number.


128
00:06:47,174 --> 00:06:50,377 line:-2
The exec event includes information
such as the file that will be executed


129
00:06:50,444 --> 00:06:51,979 line:-1
and the executable arguments,


130
00:06:52,746 --> 00:06:55,716 line:-2
and the OPEN event includes information
about the file being opened


131
00:06:55,782 --> 00:06:56,783 line:-1
and the open flags.


132
00:06:58,819 --> 00:07:01,321 line:-2
Time-of-check time-of-use issues
are extremely important


133
00:07:01,388 --> 00:07:04,191 line:-2
for you to be aware of
when developing your ES products.


134
00:07:04,892 --> 00:07:07,327 line:-2
Quickly, for those
who may not be familiar,


135
00:07:07,394 --> 00:07:10,664 line:-2
this refers to a class of bugs that occur
when a program makes assumptions


136
00:07:10,731 --> 00:07:14,568 line:-2
about some state that were previously true
but may no longer be true.


137
00:07:15,035 --> 00:07:17,704 line:-2
Classic example here
is first checking if a file exists


138
00:07:17,771 --> 00:07:20,240 line:-2
and then opening the file
as a two-step process.


139
00:07:21,074 --> 00:07:22,943 line:-2
If someone on the system
maybe deleted the file


140
00:07:23,010 --> 00:07:26,914 line:-2
after your program checked its existence,
but before your program opened it,


141
00:07:26,980 --> 00:07:29,516 line:-2
and your program
didn't handle open failures correctly,


142
00:07:29,583 --> 00:07:31,451 line:-1
it could lead to unexpected behavior.


143
00:07:32,519 --> 00:07:36,290 line:-2
The information provided in ES messages
reflects a snapshot in time.


144
00:07:37,324 --> 00:07:40,494 line:-2
The system continues to process
multiple threads simultaneously,


145
00:07:40,561 --> 00:07:43,463 line:-2
and those threads may do things
that can change system state


146
00:07:43,530 --> 00:07:46,633 line:-2
before your application has an opportunity
to inspect a message.


147
00:07:47,534 --> 00:07:50,971 line:-2
This means, in some cases, parts
of the message may have different values


148
00:07:51,038 --> 00:07:53,574 line:-2
than if you were to query that information
on your own.


149
00:07:55,008 --> 00:07:58,478 line:-2
Products need to be cautious of things
like time-of-check time-of-use issues.


150
00:07:58,545 --> 00:08:00,514 line:-2
This is no different
than those issues faced


151
00:08:00,581 --> 00:08:02,549 line:-1
by kernel extension-based products today.


152
00:08:03,383 --> 00:08:06,253 line:-2
One last thing to note
before diving in to a demo,


153
00:08:06,320 --> 00:08:08,889 line:-2
EndpointSecurity
has a handful of runtime requirements


154
00:08:08,956 --> 00:08:13,894 line:-2
that programs must satisfy in order to
successfully establish an ES event stream.


155
00:08:15,362 --> 00:08:19,333 line:-2
First, an application must have
the proper EndpointSecurity entitlement.


156
00:08:19,399 --> 00:08:20,734 line:-1
This is a restricted entitlement,


157
00:08:20,801 --> 00:08:24,137 line:-2
and you can request a provisioning profile
via the link shown here.


158
00:08:25,772 --> 00:08:28,041 line:-2
If your application is bundled
as a system extension,


159
00:08:28,108 --> 00:08:31,512 line:-2
there is an additional entitlement
required for the containing app bundle


160
00:08:31,578 --> 00:08:33,447 line:-1
in order to install the extension.


161
00:08:34,147 --> 00:08:37,618 line:-2
This information can be found
within the system extension documentation.


162
00:08:38,519 --> 00:08:43,190 line:-2
Also, system extensions require approval
from the user to complete installation.


163
00:08:44,124 --> 00:08:46,527 line:-2
Once an extension
begins the installation process


164
00:08:46,593 --> 00:08:48,729 line:-1
by using the system extension API,


165
00:08:48,795 --> 00:08:50,230 line:-1
the user must approve the installation


166
00:08:50,297 --> 00:08:53,901 line:-2
from the Security and Privacy Preferences
dialogue on the General pane.


167
00:08:55,335 --> 00:08:58,005 line:-1
Next, in order to increase user privacy,


168
00:08:58,071 --> 00:09:00,841 line:-2
we require that your applications
obtain user consent


169
00:09:00,908 --> 00:09:03,610 line:-2
in the form
of Full Disk Access permissions,


170
00:09:03,677 --> 00:09:07,748 line:-2
which is found on the Privacy pane of the
Security and Privacy Preferences dialogue.


171
00:09:08,749 --> 00:09:10,317 line:-1
If you deploy as a system extension,


172
00:09:10,384 --> 00:09:13,620 line:-2
on installation, we pre-populate
your extension in this dialogue


173
00:09:13,687 --> 00:09:16,323 line:-2
to make it easier on users
to enable these permissions.


174
00:09:18,025 --> 00:09:20,394 line:-2
If your product is being deployed
on managed devices,


175
00:09:20,460 --> 00:09:23,630 line:-2
there are two MDM payloads available
to aid distribution.


176
00:09:24,498 --> 00:09:26,667 line:-2
First, there's payload
to define extensions


177
00:09:26,733 --> 00:09:30,070 line:-2
that will be automatically
allowed to install without user approval.


178
00:09:30,938 --> 00:09:33,373 line:-2
And second,
there is a privacy preferences payload


179
00:09:33,440 --> 00:09:36,610 line:-2
that can automatically enable
Full Disk Access permissions.


180
00:09:37,444 --> 00:09:39,580 line:-2
All right.
Now, let's just into our first demo


181
00:09:39,646 --> 00:09:41,782 line:-2
where we're going to look at
notification messages


182
00:09:41,849 --> 00:09:44,117 line:-1
and expand upon an existing ES extension.


183
00:09:45,752 --> 00:09:49,189 line:-2
So over here we're looking at
our main function for a NOTIFY demo,


184
00:09:49,256 --> 00:09:51,458 line:-2
and we can see right away
this code looks very similar


185
00:09:51,525 --> 00:09:54,127 line:-2
to the example code
that we saw a few slides back.


186
00:09:54,761 --> 00:09:58,465 line:-2
We start by setting up our new client
event stream with es_new_client,


187
00:09:59,099 --> 00:10:01,602 line:-2
and our handler block here just calls
our handle_event function,


188
00:10:01,668 --> 00:10:03,237 line:-1
which we'll look at in a second.


189
00:10:04,037 --> 00:10:07,341 line:-2
Next, we set up our subscriptions here
and call es_subscribe.


190
00:10:07,407 --> 00:10:10,444 line:-2
Right now we have the NOTIFY_EXEC
and NOTIFY_FORK event types.


191
00:10:11,778 --> 00:10:14,615 line:-2
Then, once the subscriptions are in place,
we call dispatch_main


192
00:10:14,681 --> 00:10:17,885 line:-2
to allow our program to continue
executing and processing these events.


193
00:10:18,519 --> 00:10:20,220 line:-1
So let's jump up in the handle_event.


194
00:10:21,121 --> 00:10:25,592 line:-2
Up here, you can see we use a switch
statement on the message event_type,


195
00:10:25,659 --> 00:10:29,096 line:-2
and then we have a case for each one
to just log message to the screen.


196
00:10:29,863 --> 00:10:35,035 line:-2
So this extension is already installed
and running and approved on the system,


197
00:10:35,102 --> 00:10:37,204 line:-2
so let's go take a look
at what's happening.


198
00:10:38,005 --> 00:10:40,374 line:-2
So we're going to
set up our log stream here first,


199
00:10:40,440 --> 00:10:42,009 line:-1
and there's a predicate involved


200
00:10:42,075 --> 00:10:45,546 line:-2
that allows us to just focus on
the executions that I'm doing right now.


201
00:10:46,280 --> 00:10:49,049 line:-2
Next, I'm gonna use the ps utility
as an example.


202
00:10:50,150 --> 00:10:53,453 line:-2
So now, when we execute ps,
we see two messages come through.


203
00:10:54,254 --> 00:10:58,192 line:-2
We first see that our Z shell
is forking a new child process,


204
00:10:58,258 --> 00:11:00,194 line:-1
and then from that forked process,


205
00:11:00,260 --> 00:11:04,097 line:-2
it wants to execute the new 
executable /bin/ps.


206
00:11:04,698 --> 00:11:06,834 line:-1
All right. Now let's expand upon this demo


207
00:11:06,900 --> 00:11:09,970 line:-2
and add the EXIT event to get
full process life cycle information.


208
00:11:10,704 --> 00:11:15,475 line:-2
So here in our event array, we're going to
add the ES_EVENT_TYPE_NOTIFY_EXIT


209
00:11:15,542 --> 00:11:17,177 line:-1
to our list of subscriptions.


210
00:11:19,012 --> 00:11:21,982 line:-2
In our handle_event function,
we need to add this new case.


211
00:11:24,418 --> 00:11:26,019 line:-2
So I'm gonna go ahead
and add the break statement


212
00:11:26,086 --> 00:11:28,088 line:-1
so I don't forget to do that later,


213
00:11:28,155 --> 00:11:30,123 line:-1
and now we want to log this information.


214
00:11:30,858 --> 00:11:34,294 line:-2
So I'll set up some of the boiler plate
code for the OS log function here,


215
00:11:34,995 --> 00:11:36,396 line:-1
and for the format string,


216
00:11:37,331 --> 00:11:40,934 line:-2
let's go ahead and add 
the instigating process information


217
00:11:41,001 --> 00:11:43,003 line:-1
like we did above, along with the pid.


218
00:11:44,404 --> 00:11:49,409 line:-2
And then next, I know that the EXIT event
includes some event specific information


219
00:11:49,476 --> 00:11:51,111 line:-1
related to the exit status.


220
00:11:51,178 --> 00:11:52,479 line:-1
So let's get that as well.


221
00:11:57,117 --> 00:11:58,118 line:-1
All right.


222
00:11:58,185 --> 00:12:01,255 line:-2
So now, to fill in the data
for this format string,


223
00:12:01,321 --> 00:12:03,857 line:-2
we need to first look for
the instigating process,


224
00:12:03,924 --> 00:12:07,194 line:-2
and we can do that looking at the process
member of the message structure.


225
00:12:08,862 --> 00:12:12,866 line:-2
From there, we can look at the executable,
and then finally grab the path.


226
00:12:14,835 --> 00:12:19,907 line:-2
Next, we need that pid
for that process, and for processes,


227
00:12:19,973 --> 00:12:23,243 line:-2
EndpointSecurity provides audit tokens
for that information,


228
00:12:23,310 --> 00:12:26,180 line:-2
which includes things like the user ID
and the process ID.


229
00:12:26,246 --> 00:12:30,083 line:-2
So you can use the lib BSM function,
audit_token_to_pid, to extract that.


230
00:12:31,018 --> 00:12:34,388 line:-2
So, once again,
we'll dive into the-- the process field


231
00:12:35,189 --> 00:12:36,623 line:-1
and pull out the audit token.


232
00:12:38,458 --> 00:12:42,062 line:-2
And finally, we want the event specific
information free at the EXIT event,


233
00:12:42,129 --> 00:12:43,597 line:-1
which is the exit status code.


234
00:12:44,531 --> 00:12:47,267 line:-2
So to do that, we'll look at
the event member of the message.


235
00:12:47,768 --> 00:12:50,370 line:-1
From there we can pull out the EXIT event


236
00:12:50,437 --> 00:12:53,240 line:-2
and then, finally, the stat field
for that status code.


237
00:12:54,908 --> 00:12:57,044 line:-2
All right. So we're going
to build this extension,


238
00:12:57,110 --> 00:12:58,645 line:-1
and now we need to install it.


239
00:12:58,712 --> 00:13:03,984 line:-2
A quick note that I've set up a system
extension developer mode on this system,


240
00:13:04,051 --> 00:13:07,221 line:-2
and that just allows us
to more quickly deploy test extensions.


241
00:13:10,824 --> 00:13:13,427 line:-2
The other thing to note here
is that system extension requires


242
00:13:13,493 --> 00:13:16,129 line:-2
that the containing app bundle
live in /Applications


243
00:13:16,196 --> 00:13:18,165 line:-1
to be able to install the extension.


244
00:13:18,498 --> 00:13:22,870 line:-2
So we're gonna drag this containing app
we just built over to /Applications.


245
00:13:23,937 --> 00:13:28,375 line:-2
And then, once there, we can run that
app and finally install the extension.


246
00:13:28,675 --> 00:13:30,811 line:-2
So this is now
just performing the upgrade,


247
00:13:30,878 --> 00:13:33,780 line:-2
and the new extension is now running
and live on the system.


248
00:13:34,381 --> 00:13:38,051 line:-2
So, once again,
let's use the ps utility as an example.


249
00:13:38,719 --> 00:13:41,088 line:-2
Now you can see
we get a third exit message,


250
00:13:41,154 --> 00:13:43,090 line:-1
that includes the status code of zero,


251
00:13:43,156 --> 00:13:45,592 line:-2
indicating the process
exited successfully.


252
00:13:46,126 --> 00:13:49,162 line:-2
As a quick example,
we could pass an invalid flag to ps


253
00:13:49,229 --> 00:13:52,132 line:-1
and we can see now the status code is 256


254
00:13:52,199 --> 00:13:54,735 line:-2
indicating there might have been an issue
with the process.


255
00:13:56,637 --> 00:13:59,039 line:-2
Now that we've seen notification events
in action,


256
00:13:59,106 --> 00:14:01,074 line:-1
it's time to talk about AUTH events.


257
00:14:01,542 --> 00:14:03,410 line:-1
A major feature of EndpointSecurity


258
00:14:03,477 --> 00:14:06,747 line:-2
is the ability to authorize operations
on the system.


259
00:14:07,247 --> 00:14:08,615 line:-1
AUTH events are synchronous,


260
00:14:08,682 --> 00:14:11,618 line:-2
which means after we enqueue
the message for the ES clients,


261
00:14:11,685 --> 00:14:14,655 line:-2
the operation is held up in the kernel
and unable to resume


262
00:14:14,721 --> 00:14:17,925 line:-2
until a response is received
or a deadline expires.


263
00:14:19,459 --> 00:14:22,496 line:-2
Each AUTH message received
has its own deadline field


264
00:14:22,563 --> 00:14:24,798 line:-1
contained inside the message structure.


265
00:14:25,299 --> 00:14:28,335 line:-2
Your ES clients must inspect this value
for each message


266
00:14:28,402 --> 00:14:32,573 line:-2
and ensure that the work it performs
is completed before the deadline expires.


267
00:14:32,806 --> 00:14:35,008 line:-2
If a client fails to respond
before the deadline,


268
00:14:35,075 --> 00:14:36,877 line:-1
the application will be terminated.


269
00:14:38,212 --> 00:14:40,113 line:-1
If your application is a system extension,


270
00:14:40,180 --> 00:14:43,684 line:-2
the launchd job we submit for you
will be automatically restarted.


271
00:14:44,184 --> 00:14:48,121 line:-2
It's important to emphasize that each
individual message has its own deadline,


272
00:14:48,789 --> 00:14:51,291 line:-2
and there is no guarantee
that each message


273
00:14:51,358 --> 00:14:53,760 line:-2
allows for the same amount
of response time.


274
00:14:54,328 --> 00:14:56,897 line:-2
These values can
and will change over time.


275
00:14:58,298 --> 00:15:01,969 line:-2
When a deadline is missed, an implicit
ALLOW is applied as the response,


276
00:15:02,035 --> 00:15:03,504 line:-1
but the result will not be cached,


277
00:15:03,570 --> 00:15:05,973 line:-2
allowing future operations
to be reevaluated.


278
00:15:07,574 --> 00:15:10,511 line:-2
There are two APIs available
for responding to AUTH events.


279
00:15:10,978 --> 00:15:14,515 line:-2
Most event types require a simple
ALLOW or DENY response


280
00:15:14,581 --> 00:15:17,284 line:-1
using the es_respond_auth_result API.


281
00:15:18,519 --> 00:15:21,955 line:-2
The second response API,
es_respond_flags_result


282
00:15:22,022 --> 00:15:26,593 line:-2
is used when an event has a range of
options that may be permitted or denied,


283
00:15:26,660 --> 00:15:29,329 line:-2
such as being able
to allow a file to be opened


284
00:15:29,396 --> 00:15:31,999 line:-2
with read-only permissions
instead of read/write.


285
00:15:33,534 --> 00:15:37,838 line:-2
You should look at documentation to know
which API to use for each event type,


286
00:15:37,905 --> 00:15:42,509 line:-2
however as of today, only the AUTH OPEN
event uses the flags result API.


287
00:15:44,578 --> 00:15:48,482 line:-2
If there are multiple clients on a system
that subscribe to the same AUTH event,


288
00:15:48,549 --> 00:15:50,851 line:-2
the responses
from all the clients are combined


289
00:15:50,918 --> 00:15:53,287 line:-1
by applying the most restrictive response,


290
00:15:53,587 --> 00:15:56,290 line:-2
so if you have four clients respond
to an event with ALLOW


291
00:15:56,356 --> 00:16:00,561 line:-2
but one wants to DENY, the overall result
is to deny the operation.


292
00:16:01,929 --> 00:16:04,298 line:-1
Similarly for flags responses,


293
00:16:04,364 --> 00:16:07,868 line:-2
only the subset of flags
set by all clients will be allowed.


294
00:16:09,236 --> 00:16:12,773 line:-2
You should also be aware that ES
does not send introspective AUTH events


295
00:16:12,840 --> 00:16:14,842 line:-1
as this would lead to trivial deadlocks.


296
00:16:15,342 --> 00:16:17,511 line:-1
The events will be implicitly allowed.


297
00:16:18,111 --> 00:16:22,549 line:-2
We will, however, send NOTIFY messages
for events instigated by your process.


298
00:16:23,650 --> 00:16:26,353 line:-2
One quick caveat to call out
with the flags result API


299
00:16:26,420 --> 00:16:28,088 line:-1
is that your ES client process


300
00:16:28,155 --> 00:16:30,757 line:-2
should respond with
all the flags it will ever permit,


301
00:16:30,824 --> 00:16:35,295 line:-2
not necessarily only the flags requested
for an individual event.


302
00:16:35,362 --> 00:16:38,632 line:-2
This has to do with caching, and we'll
discuss this in more detail soon.


303
00:16:39,166 --> 00:16:43,070 line:-2
With muting, ES clients are able to
prevent receiving messages


304
00:16:43,136 --> 00:16:46,373 line:-2
from processes that may not be
of interest to the application.


305
00:16:46,573 --> 00:16:48,308 line:-1
There are two main ways to do this.


306
00:16:50,143 --> 00:16:52,012 line:-1
First, with es_mute_process,


307
00:16:52,079 --> 00:16:56,617 line:-2
the ES application provides an audit token
that uniquely identifies a process.


308
00:16:57,284 --> 00:17:01,221 line:-2
Typically, the client will obtain
the audit token from a previous message.


309
00:17:01,688 --> 00:17:05,224 line:-2
The EndpointSecurity subsystem
will automatically track process exits


310
00:17:05,291 --> 00:17:08,529 line:-2
and remove them from your client's set
of muted processes.


311
00:17:08,595 --> 00:17:12,965 line:-2
There is no need to manually use
the corresponding es_unmute_process API


312
00:17:13,032 --> 00:17:16,270 line:-2
unless your client
wants to start receiving messages again


313
00:17:16,336 --> 00:17:18,539 line:-1
from a process that it previously muted.


314
00:17:20,174 --> 00:17:23,844 line:-2
ES also supports muting by path literals,
that is complete paths,


315
00:17:23,911 --> 00:17:29,416 line:-2
with es_mute_path_literal as well as
path prefixes with es_mute_path_prefix.


316
00:17:30,417 --> 00:17:33,353 line:-2
As the names suggest,
this mechanism will prevent messages


317
00:17:33,420 --> 00:17:36,723 line:-2
from instigating processes
which match the provided paths.


318
00:17:37,424 --> 00:17:41,328 line:-2
We recommend that ES clients use caution
with these last two APIs here.


319
00:17:42,095 --> 00:17:45,399 line:-2
While we employ data structures
with fast lookup operations,


320
00:17:45,465 --> 00:17:47,067 line:-1
adding a large number of paths


321
00:17:47,134 --> 00:17:50,003 line:-2
can potentially have
an adverse affect on performance.


322
00:17:50,470 --> 00:17:54,641 line:-2
Muting by process audit token
is generally a better way to mute events


323
00:17:54,708 --> 00:17:56,276 line:-1
without as much overhead.


324
00:17:58,378 --> 00:17:59,913 line:-1
Many of the AUTH events can cache


325
00:17:59,980 --> 00:18:02,716 line:-2
the combined result
from the ES client responses,


326
00:18:02,783 --> 00:18:06,987 line:-2
and this is stored in a single global
cache shared across all ES clients.


327
00:18:08,388 --> 00:18:11,358 line:-2
The cache strategy used
by EndpointSecurity is best effort,


328
00:18:11,425 --> 00:18:13,527 line:-1
and entries may expire at any time.


329
00:18:14,061 --> 00:18:16,096 line:-2
EndpointSecurity tracks
several operations,


330
00:18:16,163 --> 00:18:18,665 line:-2
and will automatically
invalidate cached entries,


331
00:18:18,732 --> 00:18:22,269 line:-2
for example, if a file is written,
truncated, deleted and many more.


332
00:18:23,770 --> 00:18:26,073 line:-2
While we don't guarantee responses
will be cached,


333
00:18:26,139 --> 00:18:29,843 line:-2
if an ES client sets the cache flag
in the response APIs to false,


334
00:18:29,910 --> 00:18:32,513 line:-2
ES will guarantee
not to cache that result,


335
00:18:32,579 --> 00:18:35,549 line:-2
even if another client
does request that it be cached.


336
00:18:36,450 --> 00:18:39,419 line:-2
Some reasons that an ES client
may want to deny caching


337
00:18:39,486 --> 00:18:40,821 line:-1
might be for the EXEC events


338
00:18:40,888 --> 00:18:44,525 line:-2
when the executable is very dependent
upon the executable arguments


339
00:18:44,591 --> 00:18:46,894 line:-2
or environment variables,
such as interpreters


340
00:18:46,960 --> 00:18:50,731 line:-2
where you may want to inspect the script
that the interpreter will execute.


341
00:18:52,165 --> 00:18:56,803 line:-2
ES applications are able to clear the
entire cache with the es_clear_cache API,


342
00:18:56,870 --> 00:19:00,941 line:-2
however we do not support
invalidating individual cache entries.


343
00:19:01,975 --> 00:19:04,478 line:-2
Also note that ES
will automatically clear the cache


344
00:19:04,545 --> 00:19:07,814 line:-2
when a new client connects
or an existing client disconnects.


345
00:19:08,582 --> 00:19:11,218 line:-2
This allows for various scenarios
where the remaining clients


346
00:19:11,285 --> 00:19:15,322 line:-2
might respond with a different result
than the previously combined cache result.


347
00:19:16,924 --> 00:19:18,959 line:-2
A few slides back I mentioned
an important caveat


348
00:19:19,026 --> 00:19:22,930 line:-2
that you need to be aware of when using
the es_respond_flags_result API.


349
00:19:24,431 --> 00:19:28,435 line:-2
While at first it might sound unintuitive,
the response must contain all flags


350
00:19:28,502 --> 00:19:30,938 line:-2
an ES client might ever allow
for an operation.


351
00:19:31,638 --> 00:19:33,841 line:-2
This is because the cache
for flags responses


352
00:19:33,907 --> 00:19:35,876 line:-1
operates the same way as AUTH responses.


353
00:19:37,477 --> 00:19:40,247 line:-2
When a future event occurs,
the cache is first consulted.


354
00:19:41,014 --> 00:19:43,650 line:-2
If a cached entry exists,
the flags from that entry


355
00:19:43,717 --> 00:19:46,987 line:-2
are compared against the requested flags
for the new operation,


356
00:19:47,054 --> 00:19:50,157 line:-2
and the result is applied
without generating an AUTH message.


357
00:19:51,358 --> 00:19:55,128 line:-2
So consider the case where a process
opens a file with read-only flags set,


358
00:19:56,063 --> 00:19:59,166 line:-2
and suppose the file being opened
isn't a concern to your application.


359
00:19:59,233 --> 00:20:01,668 line:-2
That is, your application wants
to allow that process


360
00:20:01,735 --> 00:20:03,971 line:-1
to manipulate the file however it needs.


361
00:20:04,037 --> 00:20:07,074 line:-2
When your ES client process
responds with the flags result,


362
00:20:07,140 --> 00:20:09,843 line:-2
it should set all appropriate flags,
including the WRITE flag,


363
00:20:09,910 --> 00:20:13,113 line:-2
even though it wasn't requested
for this particular event.


364
00:20:13,180 --> 00:20:15,916 line:-2
Because what would happen
if you did not set the WRITE flag?


365
00:20:16,650 --> 00:20:19,987 line:-2
Well, if the process opened
the same file for writing in the future,


366
00:20:20,053 --> 00:20:21,989 line:-1
and the cached result still existed,


367
00:20:22,055 --> 00:20:23,924 line:-2
the operation would be
automatically denied


368
00:20:23,991 --> 00:20:25,659 line:-1
without generating an AUTH message,


369
00:20:25,726 --> 00:20:28,228 line:-2
even though that wasn't
what your product intended.


370
00:20:29,062 --> 00:20:32,165 line:-2
Now that we've gone over the two,
let's look at a quick comparison


371
00:20:32,232 --> 00:20:34,434 line:-1
between AUTH and NOTIFY event types.


372
00:20:35,569 --> 00:20:37,704 line:-1
NOTIFY events are always asynchronous.


373
00:20:37,771 --> 00:20:41,141 line:-2
We enqueue the message for the client,
but the operation immediately continues


374
00:20:41,208 --> 00:20:43,243 line:-2
and could be completed
before the ES client


375
00:20:43,310 --> 00:20:45,445 line:-1
has an opportunity to see the message.


376
00:20:46,813 --> 00:20:49,283 line:-2
AUTH events, as previously stated,
are synchronous


377
00:20:49,349 --> 00:20:52,452 line:-2
and the operation is held up
until a response is received.


378
00:20:54,288 --> 00:20:57,758 line:-2
Regarding delivery, NOTIFY messages
are always delivered.


379
00:20:57,824 --> 00:21:01,862 line:-2
However, AUTH messages are only delivered
if there is no cached result


380
00:21:01,929 --> 00:21:03,497 line:-1
and the message isn't being delivered


381
00:21:03,564 --> 00:21:05,832 line:-2
to the same process
that instigated the event.


382
00:21:07,034 --> 00:21:09,436 line:-2
Neither AUTH
nor NOTIFY messages are delivered


383
00:21:09,503 --> 00:21:11,939 line:-1
if the instigating process is muted.


384
00:21:13,307 --> 00:21:16,777 line:0
Finally, there is a slight difference
in message structure between the two.


385
00:21:17,277 --> 00:21:20,781 line:0
NOTIFY messages contain the result
as applied by EndpointSecurity.


386
00:21:21,081 --> 00:21:24,685 line:0
That is, the ALLOW or DENY result
from the corresponding AUTH message.


387
00:21:25,385 --> 00:21:27,955 line:0
If there were no ES clients
subscribed to the AUTH variant,


388
00:21:28,021 --> 00:21:32,125 line:0
or no AUTH variant exists for the event,
the result is implicitly allowed.


389
00:21:33,227 --> 00:21:36,597 line:0
For AUTH messages, no result information
exists yet, obviously.


390
00:21:36,663 --> 00:21:38,866 line:0
However, a message will have
a deadline value


391
00:21:38,932 --> 00:21:41,935 line:0
and also requires a response
from the ES client process.


392
00:21:42,736 --> 00:21:45,839 line:-2
Now, let's do another demo,
this time looking at AUTH event types


393
00:21:45,906 --> 00:21:50,310 line:-2
and seeing how we can write a client
to handle and respond to these messages.


394
00:21:51,178 --> 00:21:54,481 line:-2
So, once again, we're looking
at our main function here.


395
00:21:54,548 --> 00:21:59,152 line:-2
You'll notice right away it looks very similar
to the previous demo setup that we had.


396
00:21:59,753 --> 00:22:01,021 line:-1
One slight difference here,


397
00:22:01,088 --> 00:22:03,290 line:-2
we're going to be performing
some asynchronous work


398
00:22:03,357 --> 00:22:05,225 line:-1
on an asynchronous dispatch queue.


399
00:22:05,292 --> 00:22:07,794 line:-2
So, we're going to go ahead
and set up that queue first.


400
00:22:08,161 --> 00:22:11,798 line:-2
But afterwards, we'll go ahead and
initialize our new client event stream


401
00:22:11,865 --> 00:22:13,634 line:-1
with the es_new_client.


402
00:22:13,700 --> 00:22:17,237 line:-2
And our handler block will once again
call our handle_event function.


403
00:22:18,438 --> 00:22:22,809 line:-2
For this demo, we're going to be looking
at AUTH_EXEC and AUTH_OPEN event types.


404
00:22:22,876 --> 00:22:26,246 line:-2
And after subscribing,
we once again call into dispatch_main


405
00:22:26,313 --> 00:22:30,050 line:-2
to allow our program to continue
executing and processing these events.


406
00:22:31,285 --> 00:22:33,487 line:-2
So, let's look at
the handle_event function.


407
00:22:34,454 --> 00:22:36,924 line:-1
Once again, we see a switch statement here


408
00:22:36,990 --> 00:22:38,859 line:-2
where we call
an appropriate handle function


409
00:22:38,926 --> 00:22:40,594 line:-1
for each individual event type.


410
00:22:41,428 --> 00:22:42,729 line:-1
Let's start with EXEC.


411
00:22:44,665 --> 00:22:49,102 line:-2
First thing to note here is that we call
the es_respond_auth_result


412
00:22:49,169 --> 00:22:52,506 line:-1
with ES_AUTH_RESULT_ALLOW for all EXECS.


413
00:22:52,773 --> 00:22:56,810 line:-2
But we've left a TODO for ourselves
to deny new EXECs matching the signing ID.


414
00:22:57,644 --> 00:23:01,215 line:-2
Now, we typically expect most products
will want more restricted polices,


415
00:23:01,281 --> 00:23:02,950 line:-1
such as matching on CD hashes,


416
00:23:03,016 --> 00:23:04,418 line:-1
but for demonstration purposes,


417
00:23:04,484 --> 00:23:07,254 line:-2
this is a little more clear
to see what we're trying to block.


418
00:23:08,021 --> 00:23:09,389 line:-1
So, how can we do this?


419
00:23:09,456 --> 00:23:13,360 line:-2
Well, one way, we could just use
a simple string comparison


420
00:23:13,427 --> 00:23:15,195 line:-1
on the new process that we'll be executing


421
00:23:15,262 --> 00:23:18,999 line:-2
then compare that signing ID
to the one that we want to block.


422
00:23:20,567 --> 00:23:23,070 line:-2
So, because we're looking at
the event-specific data,


423
00:23:23,136 --> 00:23:26,173 line:-1
we'll dive into the event union.


424
00:23:26,974 --> 00:23:29,776 line:-2
And then from here,
we can look at the target process


425
00:23:29,843 --> 00:23:31,745 line:-1
and pull out the signing_id data.


426
00:23:33,113 --> 00:23:35,649 line:-2
So, now we'll compare that
to the signing_id_to_block,


427
00:23:35,716 --> 00:23:38,452 line:-2
and if they're equal,
we want to deny that.


428
00:23:39,052 --> 00:23:42,189 line:-2
So, we can do that
with the es_respond_auth_result API.


429
00:23:42,689 --> 00:23:45,626 line:-2
We need to pass our client
and message argument here.


430
00:23:46,460 --> 00:23:49,029 line:-1
And next we need to, define our result


431
00:23:49,096 --> 00:23:51,398 line:-1
which is simply the AUTH_RESULT_DENY.


432
00:23:52,533 --> 00:23:54,535 line:-1
Go ahead and allow this to be cached.


433
00:23:55,169 --> 00:23:56,837 line:-1
And to complete this out,


434
00:23:57,237 --> 00:24:01,275 line:-2
we'll put this previous existing response
here in the else statement.


435
00:24:01,475 --> 00:24:07,080 line:-2
So, now, if our new executable
matches the signing ID we want to block,


436
00:24:07,147 --> 00:24:10,751 line:-2
we will respond with a "deny" result,
and everything else will be allowed.


437
00:24:12,419 --> 00:24:14,254 line:-1
So now let's look at the open case.


438
00:24:15,989 --> 00:24:19,193 line:-2
So in handle_open,
this may look a little less familiar,


439
00:24:19,259 --> 00:24:21,195 line:-2
and there's some concepts
we need to introduce


440
00:24:21,261 --> 00:24:23,297 line:-1
that we haven't quite talked about yet.


441
00:24:23,363 --> 00:24:26,934 line:-2
It is recommended that your ES clients
perform as little work as possible


442
00:24:27,000 --> 00:24:28,669 line:-1
in their event handler block.


443
00:24:28,735 --> 00:24:32,306 line:-2
This typically means
that you shouldn't perform a lot of I/O


444
00:24:32,372 --> 00:24:34,775 line:-1
or large CPU-intensive tasks.


445
00:24:34,842 --> 00:24:37,010 line:-2
And the goal here
is that your event handler block


446
00:24:37,077 --> 00:24:38,846 line:-1
should be as quick as possible


447
00:24:38,912 --> 00:24:42,082 line:-2
so that they can return
and continue dequeuing messages


448
00:24:42,149 --> 00:24:45,052 line:-2
in order to keep
that message queue size small,


449
00:24:45,586 --> 00:24:48,155 line:-2
and that will help prevent
with dropping messages.


450
00:24:49,323 --> 00:24:52,359 line:-2
So in this function,
you see we copy our message


451
00:24:52,426 --> 00:24:55,762 line:-2
with the es_copy_message API,
and we'll discuss that more later on.


452
00:24:57,130 --> 00:24:59,066 line:-1
After we've copied our message,


453
00:24:59,132 --> 00:25:02,736 line:-2
we asynchronously call
our handle_open_worker function,


454
00:25:02,803 --> 00:25:06,940 line:-2
and then once that's complete, we then
go ahead and free that copied message.


455
00:25:08,141 --> 00:25:09,977 line:-1
So, what does our worker function do?


456
00:25:10,344 --> 00:25:12,713 line:-2
We have three cases
that we're concerned about.


457
00:25:13,380 --> 00:25:16,216 line:-2
Our first case
is a test for an EICAR file,


458
00:25:16,283 --> 00:25:19,586 line:-2
and for those not familiar,
an EICAR file is a test file


459
00:25:19,653 --> 00:25:23,123 line:-2
that antivirus products typically use
to test their operation


460
00:25:23,190 --> 00:25:26,059 line:-2
without needing to introduce
real malicious code on the system.


461
00:25:27,027 --> 00:25:30,998 line:-2
So, it's not important what this function
does for this demo purposes.


462
00:25:31,064 --> 00:25:33,767 line:-2
Just know that it needs to open
and inspect the file contents,


463
00:25:33,834 --> 00:25:36,837 line:-2
and it was a big driver for why
we're doing this work asynchronously.


464
00:25:38,071 --> 00:25:40,073 line:-1
So, assuming this is an EICAR file,


465
00:25:40,140 --> 00:25:42,709 line:-2
we will use
the es_respond_flags_result API.


466
00:25:42,976 --> 00:25:45,245 line:-2
And you can see we've defined
a mask of zero.


467
00:25:45,312 --> 00:25:47,481 line:-1
And this essentially clears all bits


468
00:25:47,548 --> 00:25:50,517 line:-2
and will deny all open operations
for that file.


469
00:25:52,419 --> 00:25:55,422 line:-2
Next, you can see
we left a TODO for ourselves.


470
00:25:56,957 --> 00:25:59,393 line:-2
So, what's going on here?
In this if statement,


471
00:25:59,459 --> 00:26:03,363 line:-2
you can see we're inspecting
the open event specific data


472
00:26:03,430 --> 00:26:05,132 line:-1
for the file that is being opened,


473
00:26:05,199 --> 00:26:07,701 line:-2
and we compare that against
the read only prefix


474
00:26:07,768 --> 00:26:10,571 line:-1
here defined as /usr/local/bin.


475
00:26:11,438 --> 00:26:15,609 line:-2
So we want to prevent anybody from
manipulating files on these directories.


476
00:26:17,611 --> 00:26:21,982 line:-2
So, to do that, we can once again use
the es_respond_flags_result API.


477
00:26:22,950 --> 00:26:26,253 line:-2
We'll also pass
our client and message arguments.


478
00:26:26,320 --> 00:26:28,288 line:-1
Now we need to define the flags.


479
00:26:28,355 --> 00:26:31,191 line:-2
We know that the only operation
that we want to deny here


480
00:26:31,258 --> 00:26:32,826 line:-1
is the write operation.


481
00:26:33,360 --> 00:26:38,665 line:-2
So we can define the mask
that is first with all bits set


482
00:26:39,032 --> 00:26:42,135 line:-2
and then use some bitwise operations
to clear the right flag.


483
00:26:44,037 --> 00:26:45,672 line:-1
One thing to note here you might notice


484
00:26:45,739 --> 00:26:48,876 line:-2
is that EndpointSecurity
provides flags for the open event


485
00:26:48,942 --> 00:26:50,811 line:-1
that are the kernel versions of flags,


486
00:26:50,878 --> 00:26:54,581 line:-2
not the oflags that you might be
familiar with from the open system call.


487
00:26:54,648 --> 00:26:57,918 line:-2
This is documented in the open event,
and you should check that out.


488
00:26:59,386 --> 00:27:01,421 line:-1
Last, we'll allow this to be cached.


489
00:27:02,189 --> 00:27:04,057 line:-2
And then the final case here
already written,


490
00:27:04,124 --> 00:27:09,162 line:-2
is that for all other open operations, we
have our mask set here with all bits set


491
00:27:09,229 --> 00:27:12,699 line:-2
and will allow all those open operations
to continue successfully.


492
00:27:14,034 --> 00:27:16,170 line:-1
So, let's recap what we've done.


493
00:27:17,437 --> 00:27:21,308 line:-2
So, the three things that our program
was intending to do


494
00:27:21,375 --> 00:27:25,779 line:-2
was first to deny
the text edit application to open.


495
00:27:25,846 --> 00:27:29,783 line:-2
We haven't installed the extension yet,
so we can see all this working now.


496
00:27:30,050 --> 00:27:32,519 line:-1
So text edit can successfully open.


497
00:27:33,420 --> 00:27:38,292 line:-2
We also wanted to deny writing to files
in /usr/local/bin.


498
00:27:39,193 --> 00:27:43,630 line:-2
So, as an example here,
we have set up a script called hi.sh


499
00:27:43,697 --> 00:27:45,566 line:-1
that simply prints "hi" to the screen.


500
00:27:46,967 --> 00:27:49,436 line:-2
And just to see that running,
we can execute it.


501
00:27:49,503 --> 00:27:52,005 line:-2
It does
exactly what you'd expect it to do.


502
00:27:52,372 --> 00:27:55,742 line:-2
Finally, in our home directory,
I have an EICAR file.


503
00:27:55,809 --> 00:27:57,244 line:-1
So, we'll print that out here,


504
00:27:57,311 --> 00:28:00,447 line:-2
and we can see
the standard EICAR test file definition.


505
00:28:01,882 --> 00:28:06,153 line:-2
All right, so, now let's go over,
build our extension.


506
00:28:07,321 --> 00:28:12,292 line:-2
We once again need to install
the system extension,


507
00:28:12,359 --> 00:28:14,761 line:-2
so we're gonna drag it over
to /Applications.


508
00:28:17,865 --> 00:28:22,836 line:-2
Now we'll launch the containing app bundle
and install that new extension,


509
00:28:22,903 --> 00:28:26,006 line:-2
and now our AUTH demo
is now live and running.


510
00:28:26,473 --> 00:28:29,576 line:-2
So, we can first try now to open
the text edit application.


511
00:28:30,444 --> 00:28:33,514 line:-2
We can see the icon bounces,
but nothing's able to launch anymore.


512
00:28:34,982 --> 00:28:38,519 line:-2
Next we want to try and modify a file
in usr/local/bin.


513
00:28:39,086 --> 00:28:43,657 line:-2
So, here we can see I'm trying to modify
the contents of the hi script


514
00:28:43,724 --> 00:28:45,259 line:-1
to say "Bye" instead.


515
00:28:45,859 --> 00:28:48,195 line:-1
However, this is now no longer allowed.


516
00:28:48,996 --> 00:28:53,867 line:-2
But you can see this file is still allowed
to be opened for read-only purposes,


517
00:28:53,934 --> 00:28:55,903 line:-1
and the script is able to still execute.


518
00:28:57,137 --> 00:29:01,775 line:-2
And finally we have the EICAR file
that we want to prevent all operations on.


519
00:29:02,476 --> 00:29:05,546 line:-2
So we can see even trying
to read that file is no longer permitted.


520
00:29:06,046 --> 00:29:10,017 line:-2
After seeing how easy it is to write
in ES client to handle AUTH events,


521
00:29:10,083 --> 00:29:12,452 line:-1
let's dive into some more advanced topics.


522
00:29:12,519 --> 00:29:15,189 line:-2
The message structure contains
a version field


523
00:29:15,255 --> 00:29:18,859 line:-2
that will allow your ES-based applications
to maintain compatibility


524
00:29:18,926 --> 00:29:21,962 line:-2
when deployed across
different operating system releases.


525
00:29:23,163 --> 00:29:26,934 line:-2
New fields can be added to the various
EndpointSecurity structures over time,


526
00:29:27,000 --> 00:29:30,037 line:-2
allowing us to provide
additional information to your ES clients.


527
00:29:30,103 --> 00:29:33,473 line:-2
The version number
is a single integer value,


528
00:29:33,540 --> 00:29:37,411 line:-2
and all messages in an OS release
will share the same version number.


529
00:29:38,445 --> 00:29:42,216 line:-2
If an OS release modified structures
in a way that could affect compatibility,


530
00:29:42,282 --> 00:29:44,051 line:-1
the version number will be increased.


531
00:29:44,785 --> 00:29:47,754 line:-2
Clients using newer fields
must first check the message version


532
00:29:47,821 --> 00:29:49,590 line:-1
to ensure the field is available.


533
00:29:49,890 --> 00:29:52,526 line:-2
Failing to do so
will result in undefined behavior.


534
00:29:53,360 --> 00:29:56,797 line:-2
Please pay close attention
to the header docs for the ES structures


535
00:29:56,864 --> 00:29:59,967 line:-2
as they indicate in which version
new fields were added.


536
00:30:01,802 --> 00:30:05,439 line:0
As a quick example, let's take a look
at the acl field for the create event.


537
00:30:05,906 --> 00:30:08,041 line:0
This field didn't exist
in the initial release,


538
00:30:08,108 --> 00:30:11,144 line:0
and, when it was added,
we bumped the message version to 2.


539
00:30:11,411 --> 00:30:14,781 line:0
In the small example here,
we have the handle_notify_create function


540
00:30:14,848 --> 00:30:16,884 line:0
that operates on NOTIFY_CREATE events.


541
00:30:17,818 --> 00:30:19,887 line:0
We see that before accessing
the acl member,


542
00:30:19,953 --> 00:30:21,955 line:0
the function first checks
that the message version


543
00:30:22,022 --> 00:30:23,790 line:0
is greater than or equal to two.


544
00:30:24,992 --> 00:30:28,996 line:-2
The so-called early boot feature is
a powerful mechanism of EndpointSecurity.


545
00:30:29,062 --> 00:30:31,365 line:-2
And, as a reminder,
this feature is only available


546
00:30:31,431 --> 00:30:33,734 line:-2
to ES-based products
that are system extensions,


547
00:30:33,800 --> 00:30:36,069 line:-1
not to stand-alone ES applications.


548
00:30:36,537 --> 00:30:38,438 line:-1
An extension opts into this feature


549
00:30:38,505 --> 00:30:41,675 line:-2
by setting
the NSEndpointSecurityEarlyBoot key


550
00:30:41,742 --> 00:30:43,977 line:-1
in the extensions input/out plist.


551
00:30:44,778 --> 00:30:47,681 line:-2
When there are registered
early boot clients on system start-up,


552
00:30:47,748 --> 00:30:49,650 line:-1
the system still comes up normally.


553
00:30:49,716 --> 00:30:53,453 line:-2
However, no additional third-party
applications will be allowed to execute


554
00:30:53,520 --> 00:30:56,390 line:-2
until all of the early boot extensions
are ready.


555
00:30:57,024 --> 00:31:00,661 line:-2
To signal readiness, your extension
needs to make at least one call


556
00:31:00,727 --> 00:31:02,563 line:-1
to the es_subscribe API.


557
00:31:03,897 --> 00:31:07,601 line:-2
Once all early boot clients
have made their first subscriptions,


558
00:31:07,668 --> 00:31:10,671 line:-2
the third-party applications
are finally allowed to execute.


559
00:31:11,305 --> 00:31:13,841 line:-2
This means that your client
should be prepared to subscribe


560
00:31:13,907 --> 00:31:17,277 line:-2
to all necessary events
in a single call to es_subscribe.


561
00:31:18,178 --> 00:31:20,747 line:-2
If you split your events
across multiple calls,


562
00:31:20,814 --> 00:31:23,150 line:-2
third-party applications
may begin executing


563
00:31:23,217 --> 00:31:25,552 line:-2
before the additional subscriptions
are in place


564
00:31:25,619 --> 00:31:27,187 line:-1
and your client can miss events.


565
00:31:28,255 --> 00:31:30,824 line:-2
It's also important to note
that there is a deadline enforced


566
00:31:30,891 --> 00:31:32,593 line:-1
by EndpointSecurity subsystem


567
00:31:32,659 --> 00:31:35,796 line:-2
by which all early boot clients
must signal readiness.


568
00:31:36,263 --> 00:31:37,664 line:-1
Once the deadline expires,


569
00:31:37,731 --> 00:31:41,001 line:-2
all third-party executions
are automatically allowed to continue.


570
00:31:42,236 --> 00:31:45,506 line:-2
Your extensions should be careful
not to perform long initialization steps


571
00:31:45,572 --> 00:31:48,675 line:-2
before making a subscription
to prevent missing events.


572
00:31:50,210 --> 00:31:52,713 line:-2
We do not consider the deadline value
to be API


573
00:31:52,779 --> 00:31:55,015 line:-1
and is subject to change over time,


574
00:31:55,082 --> 00:31:58,719 line:-2
but we believe the value is suitable for
your products to come up and become ready


575
00:31:58,785 --> 00:32:01,188 line:-2
without having a large impact
on end users.


576
00:32:02,289 --> 00:32:05,425 line:-2
Those of you who have already worked
with the EndpointSecurity framework


577
00:32:05,492 --> 00:32:07,394 line:-2
have likely noticed
that we do not provide events


578
00:32:07,461 --> 00:32:09,530 line:-1
related to networking operations.


579
00:32:09,897 --> 00:32:11,865 line:-2
This is intentional
as these are better covered


580
00:32:11,932 --> 00:32:13,867 line:-1
by the NetworkExtension framework.


581
00:32:14,902 --> 00:32:17,638 line:-2
There's a small exception
related to UNIX domain sockets,


582
00:32:17,704 --> 00:32:19,673 line:-1
and ES does provide events for these.


583
00:32:21,108 --> 00:32:23,177 line:-2
You should also know
that it's possible to use


584
00:32:23,243 --> 00:32:25,979 line:-2
both the EndpointSecurity
and NetworkExtension frameworks


585
00:32:26,046 --> 00:32:28,515 line:-1
from a single combined system extension.


586
00:32:29,283 --> 00:32:32,085 line:-2
For these products,
you should use the system extension APIs


587
00:32:32,152 --> 00:32:34,054 line:-1
and install flow as you normally would


588
00:32:34,121 --> 00:32:36,790 line:-2
for extensions
that are of a single extension type.


589
00:32:37,791 --> 00:32:41,762 line:-2
Additionally, it is safe to combine keys
in your extension's info.plist


590
00:32:41,828 --> 00:32:45,766 line:-2
that are specific to either network
extensions or EndpointSecurity extensions


591
00:32:45,832 --> 00:32:48,869 line:-2
and the system will take care
of applying those values as appropriate.


592
00:32:50,003 --> 00:32:54,641 line:-2
ES provides messages to clients in the
same order as they occurred on the system.


593
00:32:54,708 --> 00:32:58,278 line:-2
For example, if a client subscribes
to FORK and EXEC events,


594
00:32:58,345 --> 00:33:01,281 line:-2
in the common scenario,
when a new process is spawned,


595
00:33:01,348 --> 00:33:04,418 line:-2
the client's handler block
will always receive the fork event


596
00:33:04,484 --> 00:33:06,553 line:-1
before the corresponding exec.


597
00:33:07,487 --> 00:33:12,392 line:-2
Also note that message ordering applies to
subscriptions on an individual ES client.


598
00:33:12,726 --> 00:33:15,529 line:-2
If your application
creates multiple ES clients


599
00:33:15,596 --> 00:33:19,867 line:-2
and splits subscriptions across them,
the order of the events are only sequenced


600
00:33:19,933 --> 00:33:22,870 line:-2
relative to the subscriptions
for each ES client.


601
00:33:23,837 --> 00:33:26,673 line:-2
If desired,
you can reconstruct global ordering


602
00:33:26,740 --> 00:33:30,244 line:-2
by using the message generation time
contained in the message struct.


603
00:33:32,012 --> 00:33:34,781 line:-2
Messages are delivered to ES clients
one at a time,


604
00:33:34,848 --> 00:33:38,385 line:-2
and messages are delivered only when
the ES client's event handler block


605
00:33:38,452 --> 00:33:40,654 line:-2
returns from processing
the previous message.


606
00:33:41,388 --> 00:33:44,558 line:-2
The message structure received
by the handler block has a lifetime


607
00:33:44,625 --> 00:33:46,527 line:-1
that is only guaranteed to be valid


608
00:33:46,593 --> 00:33:50,264 line:-2
as long as the invocation
of the handler block for that message.


609
00:33:51,231 --> 00:33:54,935 line:-2
Once you return from the block, you
should not continue to access the message


610
00:33:55,002 --> 00:33:57,604 line:-2
as doing so will result
in undefined behavior.


611
00:33:58,805 --> 00:34:00,974 line:-2
If you need to extend
the lifetime of the message,


612
00:34:01,041 --> 00:34:02,943 line:-1
as we needed to do in the demo,


613
00:34:03,010 --> 00:34:05,879 line:-2
you can do so using
the es_copy_message API.


614
00:34:06,413 --> 00:34:08,282 line:-1
This will return a handle to the message


615
00:34:08,348 --> 00:34:11,918 line:-2
that will live until the corresponding
es_free_message API is called.


616
00:34:13,687 --> 00:34:15,422 line:-1
An important feature this implies


617
00:34:15,489 --> 00:34:18,525 line:-2
is that AUTH events
do not necessarily need to be replied to


618
00:34:18,592 --> 00:34:20,893 line:-1
before the handler block returns.


619
00:34:21,161 --> 00:34:24,697 line:-2
It also means that AUTH events
need not necessarily be responded to


620
00:34:24,764 --> 00:34:27,301 line:-2
in the same order
as presented to the ES client.


621
00:34:28,902 --> 00:34:32,539 line:-2
It might be important for your application
to first inspect future messages


622
00:34:32,606 --> 00:34:35,375 line:-2
in order to make a decision
on a previous message.


623
00:34:35,943 --> 00:34:39,045 line:-2
In this case, the ES application
can first copy the message


624
00:34:39,112 --> 00:34:43,283 line:-2
and return from the handler block
to begin inspecting additional messages,


625
00:34:43,350 --> 00:34:47,855 line:-2
and then later reply to that copied
message with the appropriate response.


626
00:34:48,822 --> 00:34:52,259 line:-2
Don't forget to finally free the message
when it's no longer needed.


627
00:34:52,326 --> 00:34:55,362 line:-2
If you need to do some sort
of asynchronous message processing,


628
00:34:55,429 --> 00:34:58,031 line:-2
such as using
an asynchronous dispatch queue,


629
00:34:58,098 --> 00:35:00,167 line:-1
be sure you initialize the dispatch queue


630
00:35:00,234 --> 00:35:03,737 line:-2
with a quality-of-service class
appropriate for your application.


631
00:35:04,638 --> 00:35:07,207 line:-2
This will likely be dependent
on many factors,


632
00:35:07,274 --> 00:35:10,944 line:-2
such as whether or not you subscribe
to AUTH events, expected event volume


633
00:35:11,011 --> 00:35:14,281 line:-2
or how much CPU or system resources
you wish to consume.


634
00:35:15,215 --> 00:35:17,150 line:-1
Next, we wanted to share some various tips


635
00:35:17,217 --> 00:35:20,354 line:-2
that we think will help you develop
great EndpointSecurity-based products.


636
00:35:21,455 --> 00:35:23,590 line:-2
One field you might've noticed
in the message structure


637
00:35:23,657 --> 00:35:26,493 line:-1
is the is_es_client Boolean member.


638
00:35:26,560 --> 00:35:29,563 line:-2
ES applications are not able
to authorize their own actions


639
00:35:29,630 --> 00:35:32,499 line:-2
as these introspective events
are automatically allowed.


640
00:35:33,033 --> 00:35:36,236 line:-2
However, there might be
multiple ES clients on a system,


641
00:35:36,303 --> 00:35:41,008 line:-2
and ES clients do have the ability to
authorize the actions of other ES clients.


642
00:35:41,575 --> 00:35:43,510 line:-1
For both AUTH and NOTIFY messages,


643
00:35:43,577 --> 00:35:46,180 line:-2
the is_es_client field
will be set to "true"


644
00:35:46,246 --> 00:35:50,284 line:-2
if the instigating process contain
the EndpointSecurity client entitlement.


645
00:35:51,652 --> 00:35:54,521 line:-2
ES client should inspect this field
and take appropriate action


646
00:35:54,588 --> 00:35:58,625 line:-2
to ensure they don't inappropriately
interfere with those clients' actions


647
00:35:58,692 --> 00:36:01,094 line:-2
or perform actions
that could create feedback loops.


648
00:36:02,729 --> 00:36:04,398 line:-1
Path muting is a fantastic way


649
00:36:04,464 --> 00:36:07,935 line:-2
to prevent your client
from being inundated with messages.


650
00:36:08,001 --> 00:36:10,437 line:-2
It also helps keep
the overall system more performant


651
00:36:10,504 --> 00:36:14,341 line:-2
by reducing the number of messages
that need to be processed or authorized.


652
00:36:15,175 --> 00:36:17,110 line:-2
For instance,
if your client isn't concerned


653
00:36:17,177 --> 00:36:20,514 line:-2
about the Spotlight service
on Mac OS indexing files,


654
00:36:20,581 --> 00:36:22,783 line:-1
muting the appropriate indexing processes


655
00:36:22,850 --> 00:36:26,286 line:-2
can greatly reduce the number
of messages received for some event types.


656
00:36:27,855 --> 00:36:29,990 line:-2
Applications
that take advantage of the cache


657
00:36:30,057 --> 00:36:33,460 line:-2
should be aware that caching should
be used for performance purposes only,


658
00:36:33,527 --> 00:36:35,762 line:-2
and caching should never be used
for policy.


659
00:36:36,864 --> 00:36:40,834 line:-2
This is because, as stated earlier,
cache entries may expire at any time.


660
00:36:41,568 --> 00:36:46,240 line:-2
For example, if your application decides
to deny a process from opening any files


661
00:36:46,306 --> 00:36:50,677 line:-2
and allows the response to be cached,
you should then not mute the process.


662
00:36:51,178 --> 00:36:55,282 line:-2
Consider what happens if the cache entry
is later invalidated or otherwise removed.


663
00:36:56,116 --> 00:37:00,387 line:-2
If that process attempts to reopen files,
no AUTH events will be generated


664
00:37:00,454 --> 00:37:02,823 line:-2
because your ES client
has muted the process


665
00:37:02,890 --> 00:37:05,726 line:-2
and those open operations
would be automatically allowed.


666
00:37:07,194 --> 00:37:10,130 line:-2
The next tip is to be careful
when debugging your ES application


667
00:37:10,197 --> 00:37:12,032 line:-1
when subscribed to AUTH events.


668
00:37:12,099 --> 00:37:16,003 line:-2
There is no way to disable
or otherwise extend the response deadline.


669
00:37:16,637 --> 00:37:19,873 line:-2
If an AUTH event is enqueued
while your application hits a break point,


670
00:37:19,940 --> 00:37:22,743 line:-2
you're still required to respond
before the deadline,


671
00:37:22,809 --> 00:37:26,213 line:-2
or your process will be terminated
as per the normal rules.


672
00:37:27,281 --> 00:37:30,417 line:-2
Finally, it is possible
for EndpointSecurity to drop messages


673
00:37:30,484 --> 00:37:34,121 line:-2
without delivering them to clients
if the message queue is full.


674
00:37:34,688 --> 00:37:36,523 line:-1
Client can determine if this has happened


675
00:37:36,590 --> 00:37:39,626 line:-2
by inspecting the sequence number field
in the message structure.


676
00:37:40,194 --> 00:37:43,163 line:-2
This is a per-client
and per-event-type sequence number


677
00:37:43,230 --> 00:37:47,201 line:-2
so you can determine exactly how many
of each event type may have been missed.


678
00:37:47,267 --> 00:37:50,370 line:-2
Clients that see higher drop rates
are encouraged to take advantage


679
00:37:50,437 --> 00:37:53,440 line:-2
of more advanced
EndpointSecurity API usage patterns


680
00:37:53,507 --> 00:37:55,876 line:-1
such as muting, asynchronous processing


681
00:37:55,943 --> 00:37:59,012 line:-2
and splitting subscriptions
across multiple ES clients.


682
00:38:00,714 --> 00:38:04,318 line:0
This year we're announcing that
the audit subsystem is being deprecated.


683
00:38:04,384 --> 00:38:07,487 line:0
This mainly refers to functionality
related to audit events


684
00:38:07,554 --> 00:38:09,890 line:0
such as events written
to audit trail files,


685
00:38:09,957 --> 00:38:12,793 line:0
typically those found
in the /var/audit directory,


686
00:38:13,093 --> 00:38:15,796 line:0
as well as events
sent to the Auditpipe pseudo-device


687
00:38:15,863 --> 00:38:18,098 line:0
for applications that wanted
a live event stream.


688
00:38:18,866 --> 00:38:22,002 line:0
This does not apply to things
like audit tokens and audit sessions,


689
00:38:22,069 --> 00:38:24,638 line:0
which will continue to be
a core part of the system.


690
00:38:25,272 --> 00:38:26,974 line:-1
Products that rely on audit events


691
00:38:27,040 --> 00:38:29,610 line:-2
should migrate
to using the EndpointSecurity framework.


692
00:38:29,910 --> 00:38:31,879 line:-1
So what's new in macOS Big Sur?


693
00:38:32,980 --> 00:38:36,483 line:-2
First up, there is some new
event-specific API for the EXEC event.


694
00:38:37,150 --> 00:38:40,454 line:-2
ES now provides the list of
file descriptors and file descriptor types


695
00:38:40,521 --> 00:38:43,023 line:-2
that a newly executing process
will begin with.


696
00:38:43,757 --> 00:38:47,794 line:-2
We also provide unique identifiers
specifically for Pipe file descriptors


697
00:38:47,861 --> 00:38:51,665 line:-2
that will allow you to track how multiple
processes might be communicating


698
00:38:51,732 --> 00:38:54,668 line:-2
via the Pipe interprocess
communication mechanism.


699
00:38:55,402 --> 00:38:59,439 line:-2
Due to performance limitations,
not all file descriptors may be provided.


700
00:38:59,506 --> 00:39:03,177 line:-2
The main focus was for standard in,
standard out and standard err descriptors,


701
00:39:03,243 --> 00:39:05,412 line:-2
but we also provide several more
if they exist,


702
00:39:05,479 --> 00:39:08,015 line:-2
and we expose to clients
if there are additional descriptors


703
00:39:08,081 --> 00:39:10,050 line:-1
we may not have enumerated.


704
00:39:11,418 --> 00:39:15,122 line:-2
Regarding performance, we think early
adopters of EndpointSecurity framework


705
00:39:15,189 --> 00:39:18,025 line:-2
will have a lot to look forward to
in macOS Big Sur.


706
00:39:18,392 --> 00:39:21,929 line:-2
We've rewritten many of our data
structures to reduce memory allocations


707
00:39:21,995 --> 00:39:23,630 line:-1
and increase event throughput.


708
00:39:23,697 --> 00:39:26,700 line:-2
We've tuned the caches
to eliminate invalidation bottlenecks


709
00:39:26,767 --> 00:39:29,203 line:-2
and improved
our overall memory performance.


710
00:39:29,736 --> 00:39:32,739 line:-2
Combined, these enhancements have led
to better system performance


711
00:39:32,806 --> 00:39:34,308 line:-1
and fewer drops.


712
00:39:34,374 --> 00:39:36,977 line:-2
We think this will provide
much better performance characteristics


713
00:39:37,044 --> 00:39:39,112 line:-2
for your EndpointSecurity products
as well.


714
00:39:40,647 --> 00:39:43,984 line:0
There were also several new event types
that were added in macOS Big Sur.


715
00:39:44,585 --> 00:39:48,655 line:0
Some of these are additional AUTH variants
for previously existing NOTIFY events


716
00:39:48,722 --> 00:39:50,023 line:0
and some are brand new.


717
00:39:50,824 --> 00:39:52,559 line:0
I wanted to call out a couple here.


718
00:39:52,626 --> 00:39:55,829 line:0
First, we added the trace event
that was widely requested.


719
00:39:55,896 --> 00:39:58,799 line:0
This will notify your client
when a process is being debugged.


720
00:40:00,000 --> 00:40:03,203 line:0
Second, we're excited to introduce
the CS_INVALIDATED event.


721
00:40:03,737 --> 00:40:06,139 line:0
As many of you know,
as a signed process executes,


722
00:40:06,206 --> 00:40:09,142 line:0
the kernel is constantly validating
that the code it pages in


723
00:40:09,209 --> 00:40:12,012 line:0
matches the individual page hashes
of that binary.


724
00:40:12,846 --> 00:40:16,450 line:0
If a mismatch is found, the process has
its code signing flags updated


725
00:40:16,517 --> 00:40:18,485 line:0
to clear the CS_VALID bit.


726
00:40:19,186 --> 00:40:21,922 line:0
Previously, ES clients
had to wait for future messages


727
00:40:21,989 --> 00:40:24,858 line:0
and inspect the code signing flags
of the instigating process


728
00:40:24,925 --> 00:40:27,027 line:0
to determine if it went invalid.


729
00:40:27,661 --> 00:40:31,598 line:0
However, with this event,
clients can get an immediate notification.


730
00:40:32,533 --> 00:40:35,669 line:0
One thing to note, binaries that use
hardened run-time features,


731
00:40:35,736 --> 00:40:38,906 line:0
such as those that have
the CS_KILL code signing flag set,


732
00:40:39,339 --> 00:40:41,942 line:0
will still automatically be terminated
by the system


733
00:40:42,009 --> 00:40:44,378 line:0
if a hash mismatch is encountered.


734
00:40:45,412 --> 00:40:47,347 line:-1
So, where do you go from here?


735
00:40:47,414 --> 00:40:49,216 line:-1
First, you can use the top link shown


736
00:40:49,283 --> 00:40:53,086 line:-2
to begin the process of requesting the
restricted EndpointSecurity entitlement.


737
00:40:53,453 --> 00:40:56,590 line:-2
Next, you can begin reviewing
the official EndpointSecurity


738
00:40:56,657 --> 00:41:00,727 line:-2
and System Extension API documentation
on the Apple developer website.


739
00:41:01,361 --> 00:41:05,465 line:-2
I want to also encourage you to carefully read the
EndpointSecurity header docs in the SDK.


740
00:41:05,532 --> 00:41:08,535 line:-2
We've added a lot of comments and detail
that may not be on the websites


741
00:41:08,602 --> 00:41:12,105 line:-2
that we think answers common questions
and will help you build great products.


742
00:41:12,406 --> 00:41:16,109 line:-2
Lastly, we'll be making sample code
available largely based on today's demos


743
00:41:16,176 --> 00:41:18,912 line:-2
to help you get started working
with the EndpointSecurity framework.


744
00:41:19,680 --> 00:41:23,116 line:-2
With that, thanks for joining us, and we
look forward to seeing what you build.


745
00:41:23,183 --> 00:41:25,319 line:-1
And enjoy WWDC 2020.

